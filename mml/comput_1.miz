:: The set of primitive recursive functions
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received July 27, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, RELAT_1, FUNCT_1, FINSEQ_1, FUNCT_4,
      FINSEQ_3, XXREAL_0, NAT_1, ARYTM_3, CARD_1, FINSEQ_2, PARTFUN1, SETFAM_1,
      FUNCT_6, TARSKI, MSUALG_6, RFUNCT_3, VALUED_0, UNIALG_1, CARD_3,
      FUNCOP_1, FUNCT_2, PRALG_3, ORDINAL1, ORDINAL4, ZFMISC_1, FINSET_1,
      BINTREE1, VALUED_2, REALSET1, NEWTON, ARYTM_1, COMPUT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0,
      RELAT_1, RELSET_1, FUNCT_1, FINSEQ_1, FINSEQ_2, SETFAM_1, FUNCT_2,
      FUNCOP_1, XXREAL_2, VALUED_0, FUNCT_4, CARD_3, PROB_1, FINSEQ_3,
      FINSEQ_4, PARTFUN1, RFUNCT_3, UNIALG_1, FUNCT_6, FUNCT_7, MIDSP_3,
      FINSET_1, NEWTON, NAT_D, NAT_1, RECDEF_1, BINARITH;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, REAL_1, NAT_1, PROB_1, FINSEQ_3,
      FINSEQ_4, NEWTON, RFUNCT_3, NAT_D, FUNCT_7, SEQ_1, RECDEF_1, XXREAL_2,
      BINARITH, MIDSP_3, RELSET_1, UNIALG_1, FUNCT_6;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, PARTFUN1,
      FUNCOP_1, FINSET_1, XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1,
      FINSEQ_2, FUNCT_7, FUNCT_2, VALUED_0, XXREAL_2, CARD_1, RELSET_1, CARD_3,
      FINSEQ_3, UNIALG_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_2, PARTFUN1, RFUNCT_3, UNIALG_1, FUNCT_1, RELAT_1, TARSKI,
      FINSEQ_2, FUNCOP_1, CARD_3, MARGREL1;
 theorems TARSKI, NAT_1, ZFMISC_1, RELAT_1, RELSET_1, FINSEQ_1, FUNCOP_1,
      PARTFUN1, FINSEQ_2, FINSEQ_4, FUNCT_6, FUNCT_1, RFUNCT_3, FUNCT_2,
      GRFUNC_1, FUNCT_7, FUNCT_4, FINSEQ_3, SUBSET_1, SETFAM_1, CARD_5,
      UNIALG_1, FUNCT_5, CARD_1, CARD_3, NEWTON, WSIERP_1, XBOOLE_0, XBOOLE_1,
      ORDINAL1, XXREAL_0, VALUED_0, XXREAL_2, XREAL_0, NAT_D, XREAL_1,
      MARGREL1;
 schemes NAT_1, FUNCT_2, RECDEF_1, MONOID_1, PARTFUN2;

begin :: Preliminaries

reserve i, j, k, c, m, n for Element of NAT,
  a, x, y, z, X, Y for set,
  D, E
  for non empty set,
  R for Relation,
  f, g for Function,
  p, q for FinSequence;

canceled 2;

theorem Th3:
  <*x,y*>+*(1,z) = <*z,y*> & <*x,y*>+*(2,z) = <*x,z*>
proof
  set a = <*x,y*>+*(1,z), b = <*x,y*>+*(2,z);
  <*x,y*>.1 = x by FINSEQ_1:61;
  then
A1: b.1 = x by FUNCT_7:34;
  <*x,y*>.2 = y by FINSEQ_1:61;
  then
A2: a.2 = y by FUNCT_7:34;
A3: len <*x,y*> = 2 by FINSEQ_1:61;
  then 1 in dom <*x,y*> by FINSEQ_3:27;
  then
A4: a.1 = z by FUNCT_7:33;
  len a = 2 by A3,FUNCT_7:99;
  hence <*x,y*>+*(1,z) = <*z,y*> by A4,A2,FINSEQ_1:61;
  2 in dom <*x,y*> by A3,FINSEQ_3:27;
  then
A5: b.2 = z by FUNCT_7:33;
  len b = 2 by A3,FUNCT_7:99;
  hence thesis by A1,A5,FINSEQ_1:61;
end;

canceled;

theorem Th5:
  f+*(a,x) = g+*(a,y) implies f+*(a,z) = g+*(a,z)
proof
  set i = a;
  assume
A1: f+*(i,x) = g+*(i,y);
A2: dom (g+*(i,z)) = dom g by FUNCT_7:32;
A3: dom (g+*(i,y)) = dom g by FUNCT_7:32;
A4: dom (f+*(i,x)) = dom f by FUNCT_7:32;
  now
    thus dom (f+*(i,z)) = dom f by FUNCT_7:32;
    thus dom (g+*(i,z)) = dom f by A1,A3,A2,FUNCT_7:32;
    let a be set;
    assume
A5: a in dom f;
    per cases;
    suppose
A6:   a = i;
      hence (f+*(i,z)).a = z by A5,FUNCT_7:33
        .= (g+*(i,z)).a by A1,A4,A3,A5,A6,FUNCT_7:33;
    end;
    suppose
A7:   a <> i;
      hence (f+*(i,z)).a = f.a by FUNCT_7:34
        .= (g+*(i,y)).a by A1,A7,FUNCT_7:34
        .= g.a by A7,FUNCT_7:34
        .= (g+*(i,z)).a by A7,FUNCT_7:34;
    end;
  end;
  hence thesis by FUNCT_1:9;
end;

theorem Th6:
  Del(p+*(i,x),i) = Del(p,i)
proof
  set f = p;
  per cases;
  suppose
A1: i in dom f;
    then
A2: i <= len f by FINSEQ_3:27;
    1 <= i by A1,FINSEQ_3:27;
    then consider j being Nat such that
A3: len f = j+1 by A2,NAT_1:6;
    reconsider j as Element of NAT by ORDINAL1:def 13;
A4: len f = j+1 by A3;
A5: dom (f+*(i,x)) = dom f by FUNCT_7:32;
    then
A6: len (f+*(i,x)) = len f by FINSEQ_3:31;
    then len Del(f+*(i,x),i) = j by A1,A3,A5,FINSEQ_3:118;
    then
A7: dom Del(f+*(i,x),i) = Seg j by FINSEQ_1:def 3;
    now
      thus len Del(f+*(i,x),i) = j by A1,A3,A5,A6,FINSEQ_3:118;
      thus len Del(f,i) = j by A1,A3,FINSEQ_3:118;
      let a be Nat;
A8:   a in NAT by ORDINAL1:def 13;
      assume
      a in dom Del(f+*(i,x),i);
      then
A9:   a <= j by A7,FINSEQ_1:3;
      per cases;
      suppose
A10:    a < i;
        hence Del(f+*(i,x),i).a = (f+*(i,x)).a by A4,A6,A8,FINSEQ_3:119
          .= f.a by A10,FUNCT_7:34
          .= Del(f,i).a by A4,A8,A10,FINSEQ_3:119;
      end;
      suppose
A11:    i <= a;
        then
A12:    i < a+1 by NAT_1:13;
        thus Del(f+*(i,x),i).a = (f+*(i,x)).(a+1) by A1,A3,A5,A6,A9,A8,A11,
FINSEQ_3:120
          .= f.(a+1) by A12,FUNCT_7:34
          .= Del(f,i).a by A1,A3,A9,A8,A11,FINSEQ_3:120;
      end;
    end;
    hence thesis by FINSEQ_2:10;
  end;
  suppose
    not i in dom f;
    hence thesis by FUNCT_7:def 3;
  end;
end;

theorem Th7:
  p+*(i,a) = q+*(i,a) implies Del(p,i) = Del(q,i)
proof
  set x = p, y = q;
  assume
A1: x+*(i,a) = y+*(i,a);
  set xi = x+*(i,a), yi = y+*(i,a);
  set dx = Del(x,i), dy = Del(y,i);
A2: dom xi = dom x by FUNCT_7:32;
A3: dom yi = dom y by FUNCT_7:32;
A4: Seg len y = dom y by FINSEQ_1:def 3;
A5: Seg len x = dom x by FINSEQ_1:def 3;
  per cases;
  suppose
A6: i in dom x;
A7: dom Del(x,i) = Seg len dx by FINSEQ_1:def 3;
    now
      thus len dx = len dx;
      x <> {} by A6;
      then consider m being Nat such that
A8:   len x = m+1 by NAT_1:6;
      reconsider m as Element of NAT by ORDINAL1:def 13;
A9:   len x = m+1 by A8;
A10:  len dx = m by A6,A8,FINSEQ_3:118;
      hence len dy = len dx by A1,A2,A3,A5,A4,A6,A8,FINSEQ_1:8,FINSEQ_3:118;
      let j be Nat;
      assume
      j in dom Del(x,i);
      then
A11:  j <= m by A7,A10,FINSEQ_1:3;
A12:  j in NAT by ORDINAL1:def 13;
      per cases;
      suppose
A13:    j < i;
        hence dx.j = x.j by A9,A12,FINSEQ_3:119
          .= yi.j by A1,A13,FUNCT_7:34
          .= y.j by A13,FUNCT_7:34
          .= dy.j by A1,A2,A3,A5,A4,A9,A12,A13,FINSEQ_1:8,FINSEQ_3:119;
      end;
      suppose
A14:    i <= j;
        then
A15:    j+1 > i by NAT_1:13;
        thus dx.j = x.(j+1) by A6,A8,A11,A12,A14,FINSEQ_3:120
          .= yi.(j+1) by A1,A15,FUNCT_7:34
          .= y.(j+1) by A15,FUNCT_7:34
          .= dy.j by A1,A2,A3,A5,A4,A6,A8,A11,A12,A14,FINSEQ_1:8,FINSEQ_3:120;
      end;
    end;
    hence thesis by FINSEQ_2:10;
  end;
  suppose
A16: not i in dom x;
    then xi = x by FUNCT_7:def 3;
    hence thesis by A1,A3,A16,FUNCT_7:def 3;
  end;
end;

theorem Th8:
  0-tuples_on X = {{}}
proof
  set S = {s where s is Element of X*: len s = 0};
  now
    let x be set;
    hereby
      assume
      x in S;
      then consider s being Element of X* such that
A1:   x = s and
A2:   len s = 0;
      s = {} by A2;
      hence x in {{}} by A1,TARSKI:def 1;
    end;
    assume
    x in {{}};
    then
A3: x = {} by TARSKI:def 1;
    <*>(X*) is Element of X* by FINSEQ_1:66;
    hence x in S by A3,CARD_1:47;
  end;
  hence thesis by TARSKI:2;
end;

theorem
  n <> 0 implies n-tuples_on {} = {}
proof
  assume that
A1: n <> 0 and
A2: n-tuples_on {} <> {};
  consider x such that
A3: x in n-tuples_on {} by A2,XBOOLE_0:def 1;
  ex s being Element of {}* st s = x & len s = n by A3;
  hence contradiction by A1;
end;

theorem Th10:
  {} in rng f implies <:f:> = {}
proof
A1: dom <:f:> = meet doms f by FUNCT_6:49
    .= meet rng doms f by FUNCT_6:def 4;
  assume
  {} in rng f;
  then consider x being set such that
A2: x in dom f and
A3: f.x = {} by FUNCT_1:def 5;
A4: dom doms f = f"SubFuncs rng f by FUNCT_6:def 2;
  then
A5: x in dom doms f by A2,A3,FUNCT_6:28;
  then (doms f).x = {} by A3,A4,FUNCT_5:10,FUNCT_6:def 2;
  hence thesis by A1,A5,FUNCT_1:12,SETFAM_1:5;
end;

theorem Th11:
  rng f = D implies rng <:<*f*>:> = 1-tuples_on D
proof
  set X = D;
A1: dom <:<*f*>:> = dom f by FUNCT_6:61;
  assume
A2: rng f = X;
  now
    let x be set;
    hereby
      assume
      x in rng <:<*f*>:>;
      then consider y being set such that
A3:   y in dom <:<*f*>:> and
A4:   <:<*f*>:>.y = x by FUNCT_1:def 5;
      reconsider fy = f.y as Element of X by A2,A1,A3,FUNCT_1:12;
A5:   <*fy*> is Element of 1-tuples_on X by FINSEQ_2:151;
      <:<*f*>:>.y = <*f.y*> by A1,A3,FUNCT_6:61;
      hence x in 1-tuples_on X by A4,A5;
    end;
    assume x in 1-tuples_on X;
    then x is Tuple of 1,X by FINSEQ_2:151;
    then consider d being Element of X such that
A6: x = <*d*> by FINSEQ_2:117;
    consider y being set such that
A7: y in dom f and
A8: f.y = d by A2,FUNCT_1:def 5;
    <:<*f*>:>.y = <*d*> by A7,A8,FUNCT_6:61;
    hence x in rng <:<*f*>:> by A1,A6,A7,FUNCT_1:12;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th12:
  1 <= i & i <= n+1 implies for p being Element of (n+1)-tuples_on
  D holds Del(p,i) in n-tuples_on D
proof
  set X = D;
  assume that
A1: 1 <= i and
A2: i <= n+1;
  let p be Element of (n+1)-tuples_on X;
A3: len p = n+1 by FINSEQ_1:def 18;
  then i in dom p by A1,A2,FINSEQ_3:27;
  then
A4: len Del(p,i) = n by A3,FINSEQ_3:118;
  Del(p,i) is FinSequence of X by FINSEQ_3:114;
  then Del(p,i) is Element of n-tuples_on X by A4,FINSEQ_2:110;
  hence thesis;
end;

theorem Th13:
  for X being set, Y being FinSequenceSet of X holds Y c= X*
proof
  let X be set, Y be FinSequenceSet of X;
  let x be set;
  assume
  x in Y;
  then x is FinSequence of X by FINSEQ_2:def 3;
  hence thesis by FINSEQ_1:def 11;
end;

begin :: Sets of compatible functions

definition
  let X be set;
  attr X is compatible means
  :Def1:
  for f,g being Function st f in X & g in X
  holds f tolerates g;
end;

registration
  cluster non empty functional compatible set;
  existence
  proof
    set A = {{}};
    take A;
    A is compatible
    proof
      let f, g be Function;
      assume that
A1:   f in A and
      g in A;
      f={} by A1,TARSKI:def 1;
      hence thesis by PARTFUN1:135,XBOOLE_1:2;
    end;
    hence thesis;
  end;
end;

registration
  let X be functional compatible set;
  cluster union X -> Function-like Relation-like;
  coherence
  proof
    thus union X is Function-like
    proof
      let x,y1,y2 be set;
      assume that
A1:   [x,y1] in union X and
A2:   [x,y2] in union X;
      consider f being set such that
A3:   [x,y1] in f and
A4:   f in X by A1,TARSKI:def 4;
      consider g being set such that
A5:   [x,y2] in g and
A6:   g in X by A2,TARSKI:def 4;
      reconsider f, g as Function by A4,A6;
A7:   x in dom f by A3,RELAT_1:def 4;
      then
A8:   f.x = y1 by A3,FUNCT_1:def 4;
A9:   x in dom g by A5,RELAT_1:def 4;
      then
A10:  g.x = y2 by A5,FUNCT_1:def 4;
A11:  x in dom f /\ dom g by A7,A9,XBOOLE_0:def 4;
      f tolerates g by A4,A6,Def1;
      hence thesis by A8,A10,A11,PARTFUN1:def 6;
    end;
    thus union X is Relation-like
    proof
      let x be set;
      assume
      x in union X;
      then ex f being set st x in f & f in X by TARSKI:def 4;
      hence thesis by RELAT_1:def 1;
    end;
  end;
end;

theorem Th14:
  X is functional compatible iff union X is Function
proof
  now
    assume
A1: union X is Function;
    thus X is functional
    proof
      let f be set;
      assume
A2:   f in X;
A3:   f is Function-like
      proof
        let x, y1, y2 be set;
        assume that
A4:     [x,y1] in f and
A5:     [x, y2] in f;
A6:     [x,y2] in union X by A2,A5,TARSKI:def 4;
        [x,y1] in union X by A2,A4,TARSKI:def 4;
        hence thesis by A1,A6,FUNCT_1:def 1;
      end;
      f is Relation-like
      proof
        let x be set;
        assume
        x in f;
        then x in union X by A2,TARSKI:def 4;
        hence thesis by A1,RELAT_1:def 1;
      end;
      hence thesis by A3;
    end;
    thus X is compatible
    proof
      let f,g be Function such that
A7:   f in X and
A8:   g in X;
      let x be set;
      assume
A9:   x in dom f /\ dom g;
      then
A10:  x in dom g by XBOOLE_0:def 4;
      then consider y2 being set such that
A11:  [x,y2] in g by RELAT_1:def 4;
A12:  [x,y2] in union X by A8,A11,TARSKI:def 4;
A13:  x in dom f by A9,XBOOLE_0:def 4;
      then consider y1 being set such that
A14:  [x,y1] in f by RELAT_1:def 4;
      [x,y1] in union X by A7,A14,TARSKI:def 4;
      then
A15:  y1 = y2 by A1,A12,FUNCT_1:def 1;
      thus f.x = y1 by A13,A14,FUNCT_1:def 4
        .= g.x by A10,A11,A15,FUNCT_1:def 4;
    end;
  end;
  hence thesis;
end;

registration
  let X,Y be set;
  cluster non empty compatible PFUNC_DOMAIN of X,Y;
  existence
  proof
    set A = {{}};
A1: A is compatible
    proof
      let f, g be Function;
      assume that
A2:   f in A and
      g in A;
      f = {} by A2,TARSKI:def 1;
      hence thesis by PARTFUN1:135,XBOOLE_1:2;
    end;
    now
      let x be Element of A;
      x = {} by TARSKI:def 1;
      hence x is PartFunc of X, Y by XBOOLE_1:2;
    end;
    then A is PFUNC_DOMAIN of X,Y by RFUNCT_3:def 3;
    hence thesis by A1;
  end;
end;

theorem Th15:
  for X being non empty functional compatible set holds dom union
  X = union {dom f where f is Element of X: not contradiction}
proof
  let X be non empty functional compatible set;
  set F = {dom f where f is Element of X: not contradiction};
  now
    let x be set;
    hereby
      assume
      x in dom union X;
      then consider y being set such that
A1:   [x,y] in union X by RELAT_1:def 4;
      consider Z being set such that
A2:   [x,y] in Z and
A3:   Z in X by A1,TARSKI:def 4;
      reconsider Z as Element of X by A3;
A4:   dom Z in F;
      x in dom Z by A2,RELAT_1:20;
      hence x in union F by A4,TARSKI:def 4;
    end;
    assume
    x in union F;
    then consider Z being set such that
A5: x in Z and
A6: Z in F by TARSKI:def 4;
    consider f being Element of X such that
A7: Z = dom f and
    not contradiction by A6;
    consider y being set such that
A8: [x, y] in f by A5,A7,RELAT_1:def 4;
    [x, y] in union X by A8,TARSKI:def 4;
    hence x in dom union X by RELAT_1:20;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th16:
  for X being functional compatible set, f being Function st f in
X holds dom f c= dom union X & for x being set st x in dom f holds (union X).x
  = f.x
proof
  let X be functional compatible set, f be Function such that
A1: f in X;
  thus dom f c= dom union X
  proof
    let x be set;
    assume
    x in dom f;
    then consider y being set such that
A2: [x,y] in f by RELAT_1:def 4;
    [x, y] in union X by A1,A2,TARSKI:def 4;
    hence thesis by RELAT_1:20;
  end;
  let x being set;
  assume
  x in dom f;
  then consider y being set such that
A3: [x,y] in f by RELAT_1:def 4;
  [x, y] in union X by A1,A3,TARSKI:def 4;
  hence (union X).x = y by FUNCT_1:8
    .= f.x by A3,FUNCT_1:8;
end;

theorem Th17:
  for X being non empty functional compatible set holds rng union
  X = union {rng f where f is Element of X: not contradiction}
proof
  let X be non empty functional compatible set;
  set F = {rng f where f is Element of X: not contradiction};
  now
    let y be set;
    hereby
      assume
      y in rng union X;
      then consider x being set such that
A1:   [x,y] in union X by RELAT_1:def 5;
      consider Z being set such that
A2:   [x,y] in Z and
A3:   Z in X by A1,TARSKI:def 4;
      reconsider Z as Element of X by A3;
A4:   rng Z in F;
      y in rng Z by A2,RELAT_1:20;
      hence y in union F by A4,TARSKI:def 4;
    end;
    assume
    y in union F;
    then consider Z being set such that
A5: y in Z and
A6: Z in F by TARSKI:def 4;
    consider f being Element of X such that
A7: Z = rng f and
    not contradiction by A6;
    consider x being set such that
A8: [x, y] in f by A5,A7,RELAT_1:def 5;
    [x, y] in union X by A8,TARSKI:def 4;
    hence y in rng union X by RELAT_1:20;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let X,Y;
  cluster -> functional PFUNC_DOMAIN of X,Y;
  coherence
  proof
    let P be PFUNC_DOMAIN of X,Y;
    let x be set;
    assume
    x in P;
    hence thesis by RFUNCT_3:def 3;
  end;
end;

theorem Th18:
  for P being compatible PFUNC_DOMAIN of X,Y holds union P is
  PartFunc of X,Y
proof
  let D be compatible PFUNC_DOMAIN of X,Y;
  set E = {dom f where f is Element of D: not contradiction};
  set F = {rng f where f is Element of D: not contradiction};
  reconsider u = union D as Function;
A1: rng u c= Y
  proof
    let y be set;
    assume
    y in rng u;
    then y in union F by Th17;
    then consider Z being set such that
A2: y in Z and
A3: Z in F by TARSKI:def 4;
    consider f being Element of D such that
A4: Z = rng f and
    not contradiction by A3;
    rng f c= Y by RELAT_1:def 19;
    hence thesis by A2,A4;
  end;
  dom u c= X
  proof
    let x be set;
    assume
    x in dom u;
    then x in union E by Th15;
    then consider Z being set such that
A5: x in Z and
A6: Z in E by TARSKI:def 4;
    ex f being Element of D st Z = dom f & not contradiction by A6;
    hence thesis by A5;
  end;
  hence thesis by A1,RELSET_1:11;
end;

begin :: Homogeneous relations

notation
  let f be Relation;
  synonym f is to-naturals for f is natural-valued;
end;

registration
  cluster NAT*-defined to-naturals Function;
  existence
  proof
    take f={};
    thus dom f c= NAT* by XBOOLE_1:2;
    thus thesis;
  end;
end;

definition
  canceled;
  let f be NAT*-defined Relation;
  attr f is len-total means
  :Def3:
  for x,y being FinSequence of NAT st len x =
  len y & x in dom f holds y in dom f;
end;

theorem Th19:
  dom R c= n-tuples_on D implies R is homogeneous
proof
  assume dom R c= n-tuples_on D;
  hence dom R is with_common_domain;
end;

registration
  cluster empty -> homogeneous Relation;
  coherence
  proof
    let R be Relation such that
A1: R is empty;
    thus dom R is with_common_domain
    proof let x,y be Function;
    assume
    x in dom R;
    thus thesis by A1;
    end;
  end;
end;

registration
  let p be FinSequence, x be set;
  cluster p .--> x -> non empty homogeneous;
  coherence
  proof
    set f = p .--> x;
    thus f is non empty;
    thus dom(p .--> x) is with_common_domain
    proof
    let x,y be Function;
    assume that
A1: x in dom f and
A2: y in dom f;
A3: dom f = {p} by FUNCOP_1:19;
    then x = p by A1,TARSKI:def 1;
    hence thesis by A3,A2,TARSKI:def 1;
   end;
  end;
end;

registration
  cluster non empty homogeneous Function;
  existence
  proof
    consider p being FinSequence;
    take p.-->0;
    thus thesis;
  end;
end;

registration
  let f be homogeneous Function, g be Function;
  cluster g*f -> homogeneous;
  coherence
  proof
    dom(g*f) c= dom f by RELAT_1:44;
    hence dom(g*f) is with_common_domain;
  end;
end;

registration
  let X,Y be set;
  cluster homogeneous PartFunc of X*, Y;
  existence
  proof
    set f = {};
    reconsider f as PartFunc of X*, Y by XBOOLE_1:2;
    take f;
    thus dom f is with_common_domain;
  end;
end;

registration
  let X,Y be non empty set;
  cluster non empty homogeneous PartFunc of X*, Y;
  existence
  proof
    consider y being Element of Y;
    reconsider Z = 0-tuples_on X as non empty Subset of X* by Th13;
    reconsider f = Z --> y as PartFunc of X*, Y;
    take f;
    thus f is non empty;
    thus dom f is with_common_domain by FUNCOP_1:19;
  end;
end;

registration
  let X be non empty set;
  cluster non empty homogeneous quasi_total PartFunc of X*, X;
  existence
  proof
    consider n being Element of NAT, y being Element of X;
    reconsider Z = n-tuples_on X as non empty Subset of X* by Th13;
    reconsider f = Z --> y as PartFunc of X*, X;
    take f;
    thus f is non empty;
A1: dom f = Z by FUNCOP_1:19;
    thus f is homogeneous
    proof
      thus dom f is with_common_domain by A1;
    end;
    let p,q be FinSequence of X;
    assume that
A4: len p = len q and
A5: p in dom f;
    len q = n by A1,A4,A5,FINSEQ_1:def 18;
    then q is Element of Z by FINSEQ_2:110;
    hence thesis by A1;
  end;
end;

registration
  cluster non empty homogeneous to-naturals len-total (NAT*-defined Function);
  existence
  proof
    reconsider Z = 0-tuples_on NAT as non empty Subset of NAT* by Th13;
    set f = Z --> 0;
A1: dom f = Z by FUNCOP_1:19;
    reconsider f as NAT*-defined Function;
A2: f is len-total
    proof
      let x,y be FinSequence of NAT such that
A3:   len x = len y and
A4:   x in dom f;
A5:   y is Element of (len y)-tuples_on NAT by FINSEQ_2:110;
      len x = 0 by A1,A4;
      hence thesis by A1,A3,A5;
    end;
    take f;
    f is homogeneous
    proof
      thus dom f is with_common_domain by FUNCOP_1:19;
    end;
    hence thesis by A2;
  end;
end;

registration
  cluster -> to-naturals NAT*-defined PartFunc of NAT*, NAT;
  coherence;
end;

registration
  cluster quasi_total -> len-total PartFunc of NAT*,NAT;
  coherence
  proof
    let f be PartFunc of NAT*,NAT;
    assume
A1: f is quasi_total;
    let x,y be FinSequence of NAT such that
A2: len x = len y and
A3: x in dom f;
    thus y in dom f by A1,A2,A3,UNIALG_1:def 2;
  end;
end;

theorem Th20:
  for g being len-total to-naturals (NAT*-defined Function) holds
  g is quasi_total PartFunc of NAT*, NAT
proof
  let g be len-total to-naturals (NAT*-defined Function);
A1: rng g c= NAT by VALUED_0:def 6;
  dom g c= NAT* by RELAT_1:def 18;
  then reconsider g9 = g as PartFunc of NAT*, NAT by A1,RELSET_1:11;
  for x,y being FinSequence of NAT st len x = len y & x in dom g holds y
  in dom g by Def3;
  then g9 is quasi_total by UNIALG_1:def 2;
  hence thesis;
end;

theorem Th21:
  arity {} = 0
proof
  not ex x being FinSequence st x in dom {};
  hence thesis by UNIALG_1:def 10;
end;

theorem Th22:
  for f being homogeneous Relation st dom f = {{}} holds arity f =
  0
proof
  let f be homogeneous Relation;
  assume
  dom f = {{}};
  then {} in dom f by TARSKI:def 1;
  hence thesis by CARD_1:47,UNIALG_1:def 10;
end;

theorem Th23:
  for f being homogeneous PartFunc of X*, Y holds dom f c= (arity
  f)-tuples_on X
proof
  let f be homogeneous PartFunc of X*, Y;
  let x be set;
  assume
A1: x in dom f;
  per cases;
  suppose
A2: X is empty;
    then x = <*>(X*) by A1,FUNCT_7:19,TARSKI:def 1;
    then
A3: arity f = len <*>(X*) by A1,UNIALG_1:def 10;
    0-tuples_on X = {{}} by Th8;
    hence thesis by A1,A2,A3,FUNCT_7:19;
  end;
  suppose
    X is non empty;
    then reconsider X9 = X as non empty set;
    reconsider x9 = x as FinSequence of X9 by A1,FINSEQ_1:def 11;
    len x9 = arity f by A1,UNIALG_1:def 10;
    then x9 is Element of (arity f)-tuples_on X9 by FINSEQ_2:110;
    hence thesis;
  end;
end;

theorem Th24:
  for f being homogeneous NAT*-defined Function holds dom f c= (
  arity f)-tuples_on NAT
proof
  let f be homogeneous NAT*-defined Function;
  let x be set;
  assume
A1: x in dom f;
  dom f c= NAT* by RELAT_1:def 18;
  then reconsider x9 = x as FinSequence of NAT by A1,FINSEQ_1:def 11;
  len x9 = arity f by A1,UNIALG_1:def 10;
  then x9 is Element of (arity f)-tuples_on NAT by FINSEQ_2:110;
  hence thesis;
end;

Lm1: for f being homogeneous PartFunc of D*, D holds f is quasi_total non
empty iff dom f = (arity f)-tuples_on D

proof
  set X = D;
  let f being homogeneous PartFunc of X*, X;
A1: dom f c= (arity f)-tuples_on X by Th23;
  hereby
    assume
    f is quasi_total non empty;

    then reconsider
    f9 = f as quasi_total non empty homogeneous PartFunc of X*, X;

    consider x being set such that
A2: x in dom f9 by XBOOLE_0:def 1;
    reconsider x9 = x as FinSequence of X by A2,FINSEQ_1:def 11;
A3: len x9 = arity f by A2,UNIALG_1:def 10;
    now
      let z be set;
      thus z in dom f implies z in (arity f)-tuples_on X by A1;
      assume
      z in (arity f)-tuples_on X;
      then reconsider z9 = z as Element of (arity f)-tuples_on X;
      len z9=arity f by FINSEQ_1:def 18;
      hence z in dom f by A2,A3,UNIALG_1:def 2;
    end;
    hence dom f = (arity f)-tuples_on X by TARSKI:2;
  end;
  assume
A4: dom f = (arity f)-tuples_on X;
  thus f is quasi_total
  proof
    let x, y be FinSequence of X;
    assume that
A5: len x = len y and
A6: x in dom f;
    len x = arity f by A4,A6,FINSEQ_1:def 18;
    then y is Element of (arity f)-tuples_on X by A5,FINSEQ_2:110;
    hence y in dom f by A4;
  end;
  thus thesis by A4;
end;

theorem Th25:
  for f being homogeneous PartFunc of X*, X holds f is quasi_total
  non empty iff dom f = (arity f)-tuples_on X
proof
  let f be homogeneous PartFunc of X*, X;
  per cases;
  suppose
    X is empty;
    then f = {};
    hence thesis by Th8,Th21;
  end;
  suppose
    X is non empty;
    hence thesis by Lm1;
  end;
end;

theorem Th26:
  for f being homogeneous to-naturals NAT*-defined Function holds
  f is len-total non empty iff dom f = (arity f)-tuples_on NAT
proof
  let f being homogeneous to-naturals NAT*-defined Function;
A1: dom f c= (arity f)-tuples_on NAT by Th24;
  hereby
    assume
    f is len-total non empty;
    then reconsider
    f9 = f as quasi_total non empty homogeneous PartFunc of NAT*,
    NAT by Th20;
    consider x being set such that
A2: x in dom f9 by XBOOLE_0:def 1;
    reconsider x9 = x as FinSequence of NAT by A2,FINSEQ_1:def 11;
A3: len x9 = arity f by A2,UNIALG_1:def 10;
    now
      let z be set;
      thus z in dom f implies z in (arity f)-tuples_on NAT by A1;
      assume
      z in (arity f)-tuples_on NAT;
      then reconsider z9 = z as Element of (arity f)-tuples_on NAT;
      len z9 = arity f by FINSEQ_1:def 18;
      hence z in dom f by A2,A3,UNIALG_1:def 2;
    end;
    hence dom f = (arity f)-tuples_on NAT by TARSKI:2;
  end;
  assume
A4: dom f = (arity f)-tuples_on NAT;
  thus f is len-total
  proof
    let x, y be FinSequence of NAT;
    assume that
A5: len x = len y and
A6: x in dom f;
    len x = arity f by A4,A6,FINSEQ_1:def 18;
    then y is Element of (arity f)-tuples_on NAT by A5,FINSEQ_2:110;
    hence thesis by A4;
  end;
  thus thesis by A4;
end;

theorem
  for f being non empty homogeneous PartFunc of D*, D, n st dom f c= n
  -tuples_on D holds arity f = n
proof
  let f be non empty homogeneous PartFunc of D*, D, n;
  consider x being set such that
A1: x in dom f by XBOOLE_0:def 1;
  assume
A2: dom f c= n-tuples_on D;
  then
A3: for x being FinSequence st x in dom f holds n = len x by FINSEQ_1:def 18;
  reconsider x as Element of n-tuples_on D by A2,A1;
  x in dom f by A1;
  hence thesis by A3,UNIALG_1:def 10;
end;

theorem Th28:
  for f being homogeneous PartFunc of D*, D, n st dom f = n
  -tuples_on D holds arity f = n
proof
  let f be homogeneous PartFunc of D*, D, n;
  consider x being set such that
A1: x in n-tuples_on D by XBOOLE_0:def 1;
  reconsider x as Element of n-tuples_on D by A1;
  assume
A2: dom f = n-tuples_on D;
  then
A3: for x be FinSequence st x in dom f holds len x = n by FINSEQ_1:def 18;
  x in dom f by A2;
  hence thesis by A3,UNIALG_1:def 10;
end;

definition
  let R be Relation;
  canceled 2;
  attr R is with_the_same_arity means
  :Def6:
  for f,g being Function st f in
  rng R & g in rng R holds (f is empty implies g is empty or dom g = {{}}) & (f
  is non empty & g is non empty implies ex n being Element of NAT, X being non
  empty set st dom f c= n-tuples_on X & dom g c= n-tuples_on X);
end;

registration
  cluster empty -> with_the_same_arity Relation;
  coherence
  proof
    let R be Relation such that
A1: R is empty;
    let f, g be Function;
    thus thesis by A1;
  end;
end;

registration
  let X be set;
  cluster with_the_same_arity FinSequence of X;
  existence
  proof
    take <*>X;
    thus thesis;
  end;
  cluster with_the_same_arity Element of X*;
  existence
  proof
    reconsider p = <*>X as Element of X* by FINSEQ_1:def 11;
    take p;
    thus thesis;
  end;
end;

definition
  let F be with_the_same_arity Relation;
  func arity F -> Element of NAT means
  :Def7:
  for f being homogeneous Function
st f in rng F holds it = arity f if ex f being homogeneous Function st f in rng
  F otherwise it = 0;
  existence
  proof
    hereby
      given f being homogeneous Function such that
A1:   f in rng F;
      take i = arity f;
      let g be homogeneous Function;
      assume
A2:   g in rng F;
      per cases;
      suppose
A3:     f is empty;
        thus i = arity g
        proof
          per cases by A1,A2,A3,Def6;
          suppose
            g is empty;
            hence thesis by A3;
          end;
          suppose
            dom g = {{}};
            hence thesis by A3,Th21,Th22;
          end;
        end;
      end;
      suppose
A4:     g is empty;
        thus i = arity g
        proof
          per cases by A1,A2,A4,Def6;
          suppose
            f is empty;
            hence thesis by A4;
          end;
          suppose
            dom f = {{}};
            hence thesis by A4,Th21,Th22;
          end;
        end;
      end;
      suppose
A5:     f is non empty & g is non empty;
        consider a being Element of dom f;
        dom f <> {} by A5;
        then
A6:     a in dom f;
        consider n being Element of NAT, X being non empty set such that
A7:     dom f c= n-tuples_on X and
A8:     dom g c= n-tuples_on X by A1,A2,A5,Def6;
        reconsider a as Element of n-tuples_on X by A7,A6;
A9:     arity f = len a by A5,UNIALG_1:def 10
          .= n by FINSEQ_1:def 18;
        consider a being Element of dom g;
        dom g <> {} by A5;
        then a in dom g;
        then reconsider a as Element of n-tuples_on X by A8;
        arity g = len a by A5,UNIALG_1:def 10;
        hence i = arity g by A9,FINSEQ_1:def 18;
      end;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let i1, i2 be Element of NAT;
    hereby
      given f being homogeneous Function such that
A10:  f in rng F;
      assume
      for f being homogeneous Function st f in rng F holds i1 = arity
      f;
      then i1 = arity f by A10;
      hence
      (for f being homogeneous Function st f in rng F holds i2 = arity f)
      implies i1 = i2 by A10;
    end;
    thus thesis;
  end;
  correctness;
end;

theorem
  for F be with_the_same_arity FinSequence st len F = 0 holds arity F =
  0
proof
  let F be with_the_same_arity FinSequence;
  assume
  len F = 0;
  then F = {};
  then for f being homogeneous Function holds not f in rng F;
  hence thesis by Def7;
end;

definition
  let X be set;
  func HFuncs X -> PFUNC_DOMAIN of X*, X equals
  {f where f is Element of
  PFuncs(X*, X): f is homogeneous};
  coherence
  proof
    set H = {f where f is Element of PFuncs(X*, X): f is homogeneous};
    H is non empty functional
    proof
      {} is PartFunc of X* ,X by RELSET_1:25;
      then {} in PFuncs(X*, X) by PARTFUN1:119;
      then {} in H;
      hence H is non empty;
      let x be set;
      assume
      x in H;
      then ex g being Element of PFuncs(X*, X) st x = g & g is homogeneous;
      hence thesis;
    end;
    then reconsider H as non empty functional set;
    now
      let f be Element of H;
      f in H;
      then ex g being Element of PFuncs(X*, X) st f = g & g is homogeneous;
      hence f is PartFunc of X*, X;
    end;
    hence thesis by RFUNCT_3:def 3;
  end;
end;

theorem Th30:
  {} in HFuncs X
proof
  set f = {};
  reconsider f as PartFunc of X*, X by XBOOLE_1:2;
  reconsider f as Element of PFuncs(X*, X) by PARTFUN1:119;
  f in {g where g is Element of PFuncs(X*, X): g is homogeneous};
  hence thesis;
end;

registration
  let X be non empty set;
  cluster non empty homogeneous quasi_total Element of HFuncs X;
  existence
  proof
    set p = <*>X;
    consider x being Element of X;
    p in X* by FINSEQ_1:def 11;
    then reconsider Y = {p} as Subset of X* by ZFMISC_1:37;
A1: Y --> x in PFuncs(X*, X);
    p .--> x is homogeneous;
    then
    {p} --> x in {f where f is Element of PFuncs(X* , X): f is homogeneous
    } by A1;
    then reconsider f = p .--> x as Element of HFuncs X;
    take f;
A2: dom f = {p} by FUNCOP_1:19;
    thus f is non empty homogeneous;
    let a,b be FinSequence of X such that
A3: len a = len b;
    assume
    a in dom f;
    then a = p by A2,TARSKI:def 1;
    then b = {} by A3;
    hence thesis by A2,TARSKI:def 1;
  end;
end;

registration
  let X be set;
  cluster -> homogeneous Element of HFuncs X;
  coherence
  proof
    let f be Element of HFuncs X;
    f in HFuncs X;
    then ex g being Element of PFuncs(X*, X) st f = g & g is homogeneous;
    hence thesis;
  end;
end;

registration
  let X be non empty set, S be non empty Subset of HFuncs X;
  cluster -> homogeneous Element of S;
  coherence;
end;

theorem Th31:
  for f being to-naturals homogeneous NAT*-defined Function holds
  f is Element of HFuncs NAT
proof
  let f be to-naturals homogeneous NAT*-defined Function;
A1: rng f c= NAT by VALUED_0:def 6;
  dom f c= NAT* by RELAT_1:def 18;
  then f is PartFunc of NAT*,NAT by A1,RELSET_1:11;
  then reconsider f9=f as Element of PFuncs(NAT*,NAT) by PARTFUN1:119;
  f9 in {f1 where f1 is Element of PFuncs(NAT*,NAT): f1 is homogeneous};
  hence thesis;
end;

theorem Th32:
  for f being len-total to-naturals (homogeneous NAT*-defined
  Function) holds f is quasi_total Element of HFuncs NAT
proof
  let f be len-total to-naturals (homogeneous NAT*-defined Function);
  reconsider f9=f as Element of HFuncs NAT by Th31;
  f9 is quasi_total
  proof
    let x,y be FinSequence of NAT;
    assume that
A1: len x = len y and
A2: x in dom f9;
    thus y in dom f9 by A1,A2,Def3;
  end;
  hence thesis;
end;

theorem Th33:
  for X being non empty set, F being Relation st rng F c= HFuncs X
& for f,g being homogeneous Function st f in rng F & g in rng F holds arity f =
  arity g holds F is with_the_same_arity
proof
  let X be non empty set, R be Relation such that
A1: rng R c= HFuncs X and
A2: for f,g being homogeneous Function st f in rng R & g in rng R holds
  arity f = arity g;
  let f,g be Function;
  assume that
A3: f in rng R and
A4: g in rng R;
  reconsider f9 = f, g9 = g as Element of HFuncs X by A1,A3,A4;
A5: arity f9 = arity g9 by A2,A3,A4;
  hereby
    assume
    f is empty;
    then dom g9 c= 0-tuples_on X by A5,Th21,Th23;
    then dom g9 c= {<*>X} by FINSEQ_2:112;
    hence g is empty or dom g = {{}} by ZFMISC_1:39;
  end;
  assume that
A6: f is non empty and
  g is non empty;
  reconsider f9 as non empty Element of HFuncs X by A6;
  take n = arity f9, X;
  thus thesis by A5,Th23;
end;

definition
  let n, m be Element of NAT;
  func n const m -> homogeneous to-naturals NAT*-defined Function equals
  (n-tuples_on NAT) --> m;
  coherence
  proof
    set X=NAT;
    set f = (n-tuples_on X)-->m;
A1: n-tuples_on X c= X* by FINSEQ_2:162;
X:  dom f = n-tuples_on X by FUNCOP_1:19;
A2: f is homogeneous
    proof
      thus dom f is with_common_domain;
    end;
    thus thesis by A1,A2,X,RELAT_1:def 18;
  end;
end;

theorem Th34:
  n const m in HFuncs NAT
proof
  set X=NAT;
  set f=n const m;
A1: rng f c= NAT by VALUED_0:def 6;
  dom f c= NAT* by RELAT_1:def 18;
  then f is PartFunc of X*, X by A1,RELSET_1:11;
  then f is Element of PFuncs(X*, X) by PARTFUN1:119;
  hence thesis;
end;

registration
  let n,m be Element of NAT;
  cluster n const m -> len-total non empty;
  coherence
  proof
    set X = NAT;
A1: dom (n const m) = n-tuples_on X by FUNCOP_1:19;
    n const m is len-total
    proof
      let x, y be FinSequence of X;
      assume that
A2:   len x = len y and
A3:   x in dom (n const m);
      len x = n by A1,A3,FINSEQ_1:def 18;
      then y is Element of n-tuples_on X by A2,FINSEQ_2:110;
      hence thesis by A1;
    end;
    hence thesis;
  end;
end;

theorem Th35:
  arity (n const m) = n
proof
  set X = NAT;
  consider d being Element of n-tuples_on X;
A1: dom (n const m) = n-tuples_on X by FUNCOP_1:19;
  then
A2: for x be FinSequence st x in dom (n const m) holds n=len x by
FINSEQ_1:def 18;
  d in dom (n const m) by A1;
  hence thesis by A2,UNIALG_1:def 10;
end;

registration
  cluster -> homogeneous to-naturals NAT*-defined Element of HFuncs NAT;
  coherence;
end;

definition
  let n,i be Element of NAT;
  func n succ i -> homogeneous to-naturals NAT*-defined Function means
: Def10:
  dom it = n-tuples_on NAT & for p being Element of n-tuples_on NAT holds it.p
  = (p/.i)+1;
  existence
  proof
    deffunc f(Element of NAT*) = ($1/.i)+1;
    defpred p[set] means $1 in n-tuples_on NAT;
    consider f being PartFunc of NAT*, NAT such that
A1: for d being Element of NAT* holds d in dom f iff p[d] and
A2: for d being Element of NAT* st d in dom f holds f/.d = f(d) from
    PARTFUN2:sch 2;
A3: n-tuples_on NAT c= NAT* by FINSEQ_2:162;
    then
A4: for x be set holds x in dom f iff x in n-tuples_on NAT by A1;
    then
A5: dom f = n-tuples_on NAT by TARSKI:2;
    reconsider f as Element of PFuncs(NAT*, NAT) by PARTFUN1:119;
    f is homogeneous
    proof
      thus dom f is with_common_domain by A5;
    end;
    then f in {g where g is Element of PFuncs(NAT*,NAT):g is homogeneous};
    then reconsider f as Element of HFuncs NAT;
    take f;
    thus dom f = n-tuples_on NAT by A4,TARSKI:2;
    let p be Element of n-tuples_on NAT;
    p in n-tuples_on NAT;
    then reconsider p9 = p as Element of NAT* by A3;
    thus f.p = f/.p9 by A5,PARTFUN1:def 8
      .= (p/.i)+1 by A2,A5;
  end;
  uniqueness
  proof
    let it1, it2 be homogeneous to-naturals NAT*-defined Function such that
A8: dom it1 = n-tuples_on NAT and
A9: for p being Element of n-tuples_on NAT holds it1.p = (p/.i)+1 and
A10: dom it2 = n-tuples_on NAT and
A11: for p being Element of n-tuples_on NAT holds it2.p = (p/.i)+1;
    now
      let x be set;
      assume
      x in n-tuples_on NAT;
      then reconsider x9 = x as Element of n-tuples_on NAT;
      thus it1.x = (x9/.i)+1 by A9
        .= it2.x by A11;
    end;
    hence thesis by A8,A10,FUNCT_1:9;
  end;
end;

canceled;

theorem Th37:
  n succ i in HFuncs NAT
proof
  set X=NAT;
  set f=n succ i;
A1: rng f c= NAT by VALUED_0:def 6;
  dom f c= NAT* by RELAT_1:def 18;
  then f is PartFunc of X*, X by A1,RELSET_1:11;
  then f is Element of PFuncs(X*, X) by PARTFUN1:119;
  hence thesis;
end;

registration
  let n,i be Element of NAT;
  cluster n succ i -> len-total non empty;
  coherence
  proof
A1: dom (n succ i) = n-tuples_on NAT by Def10;
    (n succ i) is len-total
    proof
      let x, y be FinSequence of NAT;
      assume that
A2:   len x = len y and
A3:   x in dom (n succ i);
      len x = n by A1,A3,FINSEQ_1:def 18;
      then y is Element of n-tuples_on NAT by A2,FINSEQ_2:110;
      hence thesis by A1;
    end;
    hence thesis by A1;
  end;
end;

theorem Th38:
  arity (n succ i) = n
proof
  consider d being set such that
A1: d in dom (n succ i) by XBOOLE_0:def 1;
  reconsider d as Element of n-tuples_on NAT by A1,Def10;
  dom (n succ i) = n-tuples_on NAT by Def10;
  then
A2: for y be FinSequence st y in dom (n succ i) holds n= len y by
FINSEQ_1:def 18;
  d in dom (n succ i) by A1;
  hence thesis by A2,UNIALG_1:def 10;
end;

definition
  let n,i be Element of NAT;
  func n proj i -> homogeneous to-naturals NAT*-defined Function equals
  proj(n
  |->NAT, i);
  correctness
  proof
A1: dom proj(n|->NAT, i) = product(n|->NAT) by CARD_3:def 17
      .= n-tuples_on NAT by FUNCT_6:9;
    now
      set P = proj(n|->NAT, i);
A2:   rng P c= NAT
      proof
        let x be set;
        assume
        x in rng P;
        then consider d being set such that
A3:     d in dom P and
A4:     x = P.d by FUNCT_1:def 5;
        reconsider d as Element of n-tuples_on NAT by A1,A3;
        reconsider d as FinSequence of NAT;
        P.d = d.i by A3,CARD_3:def 17;
        hence thesis by A4;
      end;
A5:   P is homogeneous
      proof
        thus dom P is with_common_domain by A1;
      end;
      reconsider P as PartFunc of NAT*, NAT by A1,A2,FINSEQ_2:162,RELSET_1:11;
      P is Element of PFuncs(NAT*, NAT) by PARTFUN1:119;
      then P in HFuncs NAT by A5;
      hence proj(n|->NAT, i) is Element of HFuncs NAT;
    end;
    hence thesis;
  end;
end;

theorem Th39:
  n proj i in HFuncs NAT
proof
  set X=NAT;
  set f=n proj i;
A1: rng f c= NAT by VALUED_0:def 6;
  dom f c= NAT* by RELAT_1:def 18;
  then f is PartFunc of X*, X by A1,RELSET_1:11;
  then f is Element of PFuncs(X*, X) by PARTFUN1:119;
  hence thesis;
end;

theorem Th40:
  dom (n proj i) = n-tuples_on NAT & (1 <= i & i <= n implies rng
  (n proj i) = NAT)
proof
  thus
A1: dom (n proj i)= product(n|->NAT) by CARD_3:def 17
    .= n-tuples_on NAT by FUNCT_6:9;
  assume that
A2: 1 <= i and
A3: i <= n;
  now
    let x be set;
    hereby
      assume
      x in rng (n proj i);
      then consider d being set such that
A4:   d in dom (n proj i) and
A5:   x = (n proj i).d by FUNCT_1:def 5;
      thus x in NAT by A5;
      reconsider d as Element of n-tuples_on NAT by A1,A4;
      reconsider d as FinSequence of NAT;
    end;
    assume
    x in NAT;
    then reconsider x9 = x as Element of NAT;
    reconsider d = n |-> x9 as FinSequence of NAT by FINSEQ_2:77;
    i in Seg n by A2,A3,FINSEQ_1:3;
    then
A6: d.i = x9 by FUNCOP_1:13;
A7: d is Element of n-tuples_on NAT by FINSEQ_2:132;
    then (n proj i).d = d.i by A1,CARD_3:def 17;
    hence x in rng (n proj i) by A1,A7,A6,FUNCT_1:def 5;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let n,i be Element of NAT;
  cluster n proj i -> len-total non empty;
  coherence
  proof
A1: dom (n proj i) = n-tuples_on NAT by Th40;
    n proj i is len-total
    proof
      let x, y be FinSequence of NAT;
      assume that
A2:   len x=len y and
A3:   x in dom (n proj i);
      len x=n by A1,A3,FINSEQ_1:def 18;
      then y is Element of n-tuples_on NAT by A2,FINSEQ_2:110;
      hence thesis by A1;
    end;
    hence thesis by A1;
  end;
end;

theorem Th41:
  arity (n proj i) = n
proof
  consider d being set such that
A1: d in n-tuples_on NAT by XBOOLE_0:def 1;
  reconsider d as Element of n-tuples_on NAT by A1;
A2: dom (n proj i) = n-tuples_on NAT by Th40;
  then
A3: for x be FinSequence st x in dom (n proj i) holds n= len x by
FINSEQ_1:def 18;
  d in dom (n proj i) by A2;
  hence thesis by A3,UNIALG_1:def 10;
end;

theorem Th42:
  for t being Element of n-tuples_on NAT holds (n proj i).t = t.i
proof
  let t be Element of n-tuples_on NAT;
  dom (n proj i) = n-tuples_on NAT by Th40;
  hence thesis by CARD_3:def 17;
end;

registration
  let X be set;
  cluster HFuncs X -> functional;
  coherence;
end;

theorem Th43:
  for F being Function of D, HFuncs E st rng F is compatible & for
  x being Element of D holds dom (F.x) c= n-tuples_on E ex f being Element of
  HFuncs E st f = Union F & dom f c= n-tuples_on E
proof
  set X = D, Y = E;
  let F be Function of X, HFuncs Y;
  assume
A1: rng F is compatible;
  assume
A2: for x being Element of X holds dom (F.x) c= n-tuples_on Y;
A4: rng F is functional
    proof
      let x be set;
A5:   rng F c= HFuncs Y by RELAT_1:def 19;
      assume
      x in rng F;
      hence thesis by A5;
    end;
    then reconsider rngF = rng F as non empty functional compatible set by A1;
    set D = {dom g where g is Element of rngF: not contradiction};
    reconsider f = Union F as Function by A1,A4;
A7: rng f c= Y
    proof
      let y be set;
      assume
      y in rng f;
      then consider x being set such that
A8:   x in dom f and
A9:   f.x = y by FUNCT_1:def 5;
      x in union D by A8,Th15;
      then consider d being set such that
A10:  x in d and
A11:  d in D by TARSKI:def 4;
      consider g being Element of rngF such that
A12:  d = dom g and
      not contradiction by A11;
A13:  g in rngF;
      rng F c= HFuncs Y by RELAT_1:def 19;
      then reconsider g as Element of HFuncs Y by A13;
A14:  g.x in rng g by A10,A12,FUNCT_1:12;
A15:  rng g c= Y by RELAT_1:def 19;
      f.x = g.x by A10,A12,Th16;
      hence thesis by A9,A15,A14;
    end;
A16: dom f c= n-tuples_on Y
    proof
      let x be set;
      assume
      x in dom f;
      then x in union D by Th15;
      then consider d being set such that
A17:  x in d and
A18:  d in D by TARSKI:def 4;
      consider g being Element of rngF such that
A19:  d = dom g and
      not contradiction by A18;
      consider e being set such that
A20:  e in dom F and
A21:  F.e = g by FUNCT_1:def 5;
      reconsider e as Element of X by A20;
      dom (F.e) c= n-tuples_on Y by A2;
      hence thesis by A17,A19,A21;
    end;
    n-tuples_on Y c= Y* by FINSEQ_2:162;
    then dom f c= Y* by A16,XBOOLE_1:1;
    then reconsider f as PartFunc of Y*, Y by A7,RELSET_1:11;
    reconsider f as Element of PFuncs(Y*, Y) by PARTFUN1:119;
    f is homogeneous
    proof
      thus dom f is with_common_domain by A16;
    end;
    then f in {g where g is Element of PFuncs(Y*, Y): g is homogeneous};
    then reconsider f = Union F as Element of HFuncs Y;
    take f;
    thus f = Union F;
    thus thesis by A16;
end;

theorem
  for F being Function of NAT, HFuncs D st for i holds F.i c= F.(i+1)
  holds Union F in HFuncs D
proof
  set X = D;
  let F be Function of NAT, HFuncs X such that
A1: for i being Element of NAT holds F.i c= F.(i+1);
A2: now
    let n be Element of NAT;
    defpred p[Element of NAT] means F.n c= F.(n+$1);
    let m be Element of NAT;
A3: now
      let i be Element of NAT such that
A4:   p[i];
      F.(n+i) c= F.(n+i+1) by A1;
      hence p[i+1] by A4,XBOOLE_1:1;
    end;
A5: p[0];
A6: for i being Element of NAT holds p[i] from NAT_1:sch 1(A5,A3);
    assume
    n <= m;
    then consider i being Nat such that
A7: m = n+i by NAT_1:10;
    i in NAT by ORDINAL1:def 13;
    hence F.n c= F.m by A6,A7;
  end;
  reconsider Y = rng F as non empty Subset of HFuncs X by RELAT_1:def 19;
A8: Y is compatible
  proof
    let f,g be Function;
    assume
    f in Y;
    then consider i being set such that
A9: i in dom F and
A10: f = F.i by FUNCT_1:def 5;
    assume
    g in Y;
    then consider j being set such that
A11: j in dom F and
A12: g = F.j by FUNCT_1:def 5;
    reconsider i,j as Element of NAT by A9,A11;
    i <= j or j <= i;
    hence thesis by A2,A10,A12,PARTFUN1:135;
  end;
  Y is PartFunc-set of X*, X
  proof
    let f be Element of Y;
    f is Element of HFuncs X;
    hence thesis;
  end;
  then Union F is PartFunc of X*, X by A8,Th18;
  then reconsider f = Union F as Element of PFuncs(X*, X) by PARTFUN1:119;
A14: dom f=union {dom g where g is Element of Y: not contradiction} by A8,Th15;
  f is homogeneous
  proof
    thus dom f is with_common_domain
    proof
    let x,y be FinSequence;
    assume
    x in dom f;
    then consider A1 being set such that
A15: x in A1 and
A16: A1 in {dom g where g is Element of Y: not contradiction} by A14,
TARSKI:def 4;
    consider g1 being Element of Y such that
A17: A1 = dom g1 by A16;
    assume
    y in dom f;
    then consider A2 being set such that
A18: y in A2 and
A19: A2 in {dom g where g is Element of Y: not contradiction} by A14,
TARSKI:def 4;
    consider g2 being Element of Y such that
A20: A2 = dom g2 by A19;
    consider i1 being set such that
A21: i1 in dom F and
A22: g1 = F.i1 by FUNCT_1:def 5;
    consider i2 being set such that
A23: i2 in dom F and
A24: g2 = F.i2 by FUNCT_1:def 5;
    reconsider i1, i2 as Element of NAT by A21,A23;
    i1 <= i2 or i2 <= i1;
    then g1 c= g2 or g2 c= g1 by A2,A22,A24;
    then dom g1 c= dom g2 or dom g2 c= dom g1 by GRFUNC_1:8;
    then dom x = dom y by A15,A17,A18,A20,CARD_3:def 10;
    hence len x = len y by FINSEQ_3:31;
    end;
  end;
  hence thesis;
end;

theorem Th45:
  for F being with_the_same_arity FinSequence of HFuncs D holds
  dom <:F:> c= (arity F)-tuples_on D
proof
  set X = D;
  let F be with_the_same_arity FinSequence of HFuncs X;
  thus dom <:F:> c= (arity F)-tuples_on X
  proof
A1: dom <:F:> = meet doms F by FUNCT_6:49
      .= meet rng doms F by FUNCT_6:def 4;
    let x be set such that
A2: x in dom <:F:>;
    consider y being set such that
A3: y in rng doms F by A2,A1,SETFAM_1:2,XBOOLE_0:def 1;
A4: x in y by A2,A1,A3,SETFAM_1:def 1;
    consider z being set such that
A5: z in dom doms F and
A6: (doms F).z = y by A3,FUNCT_1:def 5;
A7: dom doms F=F"SubFuncs rng F by FUNCT_6:def 2;
    then z in dom F by A5,FUNCT_6:28;
    then
A8: F.z in rng F by FUNCT_1:12;
    rng F c= HFuncs X by RELAT_1:def 19;
    then reconsider Fz = F.z as Element of HFuncs X by A8;
A9: dom Fz c= (arity Fz)-tuples_on X by Th23;
    (doms F).z = dom Fz by A7,A5,FUNCT_6:def 2;
    then x in (arity Fz)-tuples_on X by A6,A4,A9;
    hence thesis by A8,Def7;
  end;
end;

registration
  let X be non empty set;
  let F be with_the_same_arity FinSequence of HFuncs X;
  cluster <:F:> -> homogeneous;
  coherence
  proof
    dom <:F:> c= (arity F)-tuples_on X by Th45;
    hence dom<:F:> is with_common_domain;
  end;
end;

theorem Th46:
  for f being Element of HFuncs D, F being with_the_same_arity
FinSequence of HFuncs D holds dom (f*<:F:>) c= (arity F)-tuples_on D & rng (f*
  <:F:>) c= D & f*<:F:> in HFuncs D
proof
  set X = D;
  let f be Element of HFuncs X;
  let F be with_the_same_arity FinSequence of HFuncs X;
A1: dom (f*<:F:>) c=dom <:F:> by RELAT_1:44;
A2: (arity F)-tuples_on X c= X* by FINSEQ_2:162;
  dom <:F:> c=(arity F)-tuples_on X by Th45;
  hence dom (f*<:F:>) c= (arity F)-tuples_on X by A1,XBOOLE_1:1;
  then
A3: dom (f*<:F:>) c= X* by A2,XBOOLE_1:1;
  thus rng (f*<:F:>) c= X by RELAT_1:def 19;
  then f*<:F:> is PartFunc of X*, X by A3,RELSET_1:11;
  then f*<:F:> in PFuncs(X*, X) by PARTFUN1:119;
  hence thesis;
end;

definition
  let X,Y be non empty set, P be PFUNC_DOMAIN of X,Y;
  let S be non empty Subset of P;
  redefine mode Element of S -> Element of P;
  coherence
  proof
    let f be Element of S;
    thus thesis;
  end;
end;

registration
  let f be homogeneous NAT*-defined Function;
  cluster <*f*> -> with_the_same_arity;
  coherence
  proof
    let h,g be Function such that
A1: h in rng <*f*> and
A2: g in rng <*f*>;
A3: rng <*f*> = {f} by FINSEQ_1:56;
    then
A4: h = f by A1,TARSKI:def 1;
    hence h is empty implies g is empty or dom g = {{}} by A2,A3,TARSKI:def 1;
    assume that
    h is non empty and
    g is non empty;
    take i = arity f,NAT;
    g = f by A2,A3,TARSKI:def 1;
    hence thesis by A4,Th24;
  end;
end;

theorem
  for f being homogeneous to-naturals NAT*-defined Function holds arity
  <*f*> = arity f
proof
  let f be homogeneous to-naturals NAT*-defined Function;
  rng <*f*> = {f} by FINSEQ_1:55;
  then f in rng <*f*> by TARSKI:def 1;
  hence thesis by Def7;
end;

theorem Th48:
  for f,g being non empty Element of HFuncs NAT, F being
  with_the_same_arity FinSequence of HFuncs NAT st g = f*<:F:> holds arity g =
  arity F
proof
  let f, g be non empty Element of HFuncs NAT, F be with_the_same_arity
  FinSequence of HFuncs NAT;
  assume
  g = f*<:F:>;
  then
A1: dom g c= (arity F)-tuples_on NAT by Th46;
  consider x being set such that
A2: x in dom g by XBOOLE_0:def 1;
  reconsider x as Element of (arity F)-tuples_on NAT by A1,A2;
  len x = arity F by FINSEQ_1:def 18;
  hence thesis by A2,UNIALG_1:def 10;
end;

theorem Th49:
  for f being non empty quasi_total Element of HFuncs D, F being
with_the_same_arity FinSequence of HFuncs D st arity f = len F & F is non empty
  & (for h being Element of HFuncs D st h in rng F holds h is quasi_total non
empty) holds f*<:F:> is non empty quasi_total Element of HFuncs D & dom (f*<:F
  :>) = (arity F)-tuples_on D
proof
  set X = D;
  let f being non empty quasi_total Element of HFuncs X, F being
  with_the_same_arity FinSequence of HFuncs X such that
A1: arity f = len F and
A2: F is non empty and
A3: for h being Element of HFuncs X st h in rng F holds h is quasi_total
  non empty;
  set n = arity F;
  set fF = f*<:F:>;
A4: dom fF c= n-tuples_on X by Th46;
A5: n-tuples_on X c= dom fF
  proof
    let x be set;
A6: product rngs F c= (len F)-tuples_on X
    proof
      let p be set;
A7:   dom rngs F = F"SubFuncs rng F by FUNCT_6:def 3;
      assume
      p in product rngs F;
      then consider g being Function such that
A8:   p = g and
A9:   dom g = dom rngs F and
A10:  for x being set st x in dom rngs F holds g.x in (rngs F).x by
CARD_3:def 5;
      now
        let x be set;
        hereby
          assume
          x in F"SubFuncs rng F;
          then x in dom F by FUNCT_6:28;
          hence x in Seg len F by FINSEQ_1:def 3;
        end;
        assume
        x in Seg len F;
        then
A12:    x in dom F by FINSEQ_1:def 3;
        then F.x in rng F by FUNCT_1:12;
        hence x in F"SubFuncs rng F by A12,FUNCT_6:28;
      end;
      then
A13:  F"SubFuncs rng F = Seg len F by TARSKI:2;
      then reconsider g as FinSequence by A9,A7,FINSEQ_1:def 2;
      rng g c= X
      proof
        let x be set;
        assume
        x in rng g;
        then consider d being set such that
A14:    d in dom g and
A15:    g.d = x by FUNCT_1:def 5;
A16:    g.d in (rngs F).d by A9,A10,A14;
        reconsider d as Element of NAT by A14;
        dom F = Seg len F by FINSEQ_1:def 3;
        then reconsider Fd = F.d as Element of HFuncs X by A9,A7,A13,A14,
FINSEQ_2:13;
A17:    rng Fd c= X by RELAT_1:def 19;
        (rngs F).d = rng Fd by A9,A7,A14,FUNCT_6:def 3;
        hence thesis by A15,A16,A17;
      end;
      then reconsider g as FinSequence of X by FINSEQ_1:def 4;
      len g = len F by A9,A7,A13,FINSEQ_1:def 3;
      then p is Element of (len F)-tuples_on X by A8,FINSEQ_2:110;
      hence thesis;
    end;
    rng <:F:> c= product rngs F by FUNCT_6:49;
    then
A18: rng <:F:> c= (len F)-tuples_on X by A6,XBOOLE_1:1;
A19: dom f = (arity f)-tuples_on X by Th25;
A20: n-tuples_on X c= dom <:F:>
    proof
      let x be set;
A22:  dom doms F = F"SubFuncs rng F by FUNCT_6:def 2;
      assume
A23:  x in n-tuples_on X;
A24:  now
        let y be set;
        assume
        y in rng doms F;
        then consider w being set such that
A25:    w in dom doms F and
A26:    (doms F).w = y by FUNCT_1:def 5;
A27:    w in dom F by A22,A25,FUNCT_6:28;
        then reconsider w as Element of NAT;
        reconsider Fw = F.w as Element of HFuncs X by A27,FINSEQ_2:13;
A28:    (doms F).w = dom (Fw) by A22,A25,FUNCT_6:def 2;
A29:    Fw in rng F by A27,FUNCT_1:12;
        then Fw is non empty quasi_total by A3;
        then dom (Fw) = (arity Fw)-tuples_on X by Th25;
        hence x in y by A23,A26,A28,A29,Def7;
      end;
      consider z being set such that
A30:  z in dom F by A2,XBOOLE_0:def 1;
      F.z in rng F by A30,FUNCT_1:12;
      then z in dom doms F by A30,A22,FUNCT_6:28;
      then
A31:  rng doms F <> {} by RELAT_1:65;
      dom <:F:> = meet doms F by FUNCT_6:49
        .= meet rng doms F by FUNCT_6:def 4;
      hence thesis by A31,A24,SETFAM_1:def 1;
    end;
    assume
A32: x in n-tuples_on X;
    then <:F:>.x in rng <:F:> by A20,FUNCT_1:12;
    hence thesis by A1,A32,A20,A19,A18,FUNCT_1:21;
  end;
  then
A33: dom fF = n-tuples_on X by A4,XBOOLE_0:def 10;
A34: rng fF c= X by Th46;
  (arity F)-tuples_on X c= X* by FINSEQ_2:162;
  then dom fF c= X* by A4,XBOOLE_1:1;
  then fF is Relation of X*, X by A34,RELSET_1:11;
  then fF is Element of PFuncs(X*, X) by PARTFUN1:119;
  then fF in HFuncs X;
  then reconsider fF as Element of HFuncs X;
  fF is quasi_total
  proof
    let x, y be FinSequence of X such that
A35: len x = len y and
A36: x in dom fF;
    len x = n by A4,A36,FINSEQ_1:def 18;
    then y is Element of n-tuples_on X by A35,FINSEQ_2:110;
    hence y in dom fF by A33;
  end;
  hence f*<:F:> is non empty quasi_total Element of HFuncs X by A5;
  thus thesis by A4,A5,XBOOLE_0:def 10;
end;

theorem Th50:
  for f being quasi_total Element of HFuncs D, F being
  with_the_same_arity FinSequence of HFuncs D st arity f = len F & for h being
  Element of HFuncs D st h in rng F holds h is quasi_total holds f*<:F:> is
  quasi_total Element of HFuncs D
proof
  set X = D;
  let f being quasi_total Element of HFuncs X, F being with_the_same_arity
  FinSequence of HFuncs X such that
A1: arity f = len F and
A2: for h being Element of HFuncs X st h in rng F holds h is quasi_total;
  reconsider g = {} as PartFunc of X*, X by RELSET_1:25;
  set fF = f*<:F:>;
A3: g is quasi_total
  proof
    let x, y be FinSequence of X;
    assume that
    len x = len y and
A4: x in dom g;
    thus y in dom g by A4;
  end;
  g in PFuncs(X*, X) by PARTFUN1:119;
  then
A5: g in {h where h is Element of PFuncs(X*, X): h is homogeneous};
  per cases;
  suppose
    f = {};
    hence thesis;
  end;
  suppose
    F = {};
    hence thesis by A5,A3,FUNCT_6:60;
  end;
  suppose
    ex h being set st h in rng F & h = {};
    then <:F:> = {} by Th10;
    hence thesis by A5,A3;
  end;
  suppose
A6: F <> {} & f <> {} & for h being set st h in rng F holds h <> {};
    then
    for h be Element of HFuncs X st h in rng F holds h is quasi_total non
    empty by A2;
    hence thesis by A1,A6,Th49;
  end;
end;

theorem Th51:
  for f,g being non empty quasi_total Element of HFuncs D st arity
  f = 0 & arity g = 0 & f.{} = g.{} holds f = g
proof
  set X = D;
  let f,g be non empty quasi_total Element of HFuncs X;
  assume that
A1: arity f = 0 and
A2: arity g = 0 and
A3: f.{} = g.{};
  now
    thus dom f = 0-tuples_on X by A1,Th25
      .= {<*>X} by FINSEQ_2:112;
    thus dom g = 0-tuples_on X by A2,Th25
      .= {<*>X} by FINSEQ_2:112;
    let x be set;
    assume
    x in {<*>X};
    then x = {} by TARSKI:def 1;
    hence f.x = g.x by A3;
  end;
  hence thesis by FUNCT_1:9;
end;

theorem Th52:
  for f,g being non empty len-total homogeneous to-naturals (NAT*
  -defined Function) st arity f = 0 & arity g = 0 & f.{} = g.{} holds f = g
proof
  let f,g be non empty len-total homogeneous to-naturals (NAT*-defined
  Function);
  assume that
A1: arity f = 0 and
A2: arity g = 0 and
A3: f.{} = g.{};
A4: g is non empty quasi_total Element of HFuncs NAT by Th32;
  f is non empty quasi_total Element of HFuncs NAT by Th32;
  hence thesis by A1,A2,A3,A4,Th51;
end;

begin :: Primitive recursiveness

reserve f1, f2 for non empty homogeneous to-naturals NAT*-defined Function,
  e1
  , e2 for homogeneous to-naturals NAT*-defined Function,
  p for Element of (arity
  f1+1)-tuples_on NAT;

definition
  let g, f1, f2 be homogeneous to-naturals NAT*-defined Function, i be Element
  of NAT;
  pred g is_primitive-recursively_expressed_by f1,f2,i means
  :Def12:
  ex n
being Element of NAT st dom g c= n-tuples_on NAT & i >= 1 & i <= n & (arity f1)
+1 = n & n+1 = arity f2 & for p being FinSequence of NAT st len p = n holds (p
+*(i,0) in dom g iff Del(p,i) in dom f1) & (p+*(i,0) in dom g implies g.(p+*(i,
0)) = f1.Del(p,i)) & for n being Element of NAT holds (p+*(i,n+1) in dom g iff
p+*(i,n) in dom g & (p+*(i,n))^<*g.(p+*(i,n))*> in dom f2) & (p+*(i,n+1) in dom
  g implies g.(p+*(i,n+1)) = f2.((p+*(i,n))^<*g.(p+*(i,n))*>));
end;

defpred Q[Element of NAT,Element of HFuncs NAT, Element of HFuncs NAT,
FinSequence of NAT, Element of NAT, homogeneous Function] means ($5 in dom $4 &
$4+*($5,$1) in dom $2 & ($4+*($5,$1))^<*$2.($4+*($5,$1))*> in dom $6 implies $3
= $2+*($4+*($5,$1+1) .--> $6.(($4+*($5,$1))^<*$2.($4+*($5,$1))*>))) & (not $5
in dom $4 or not $4+*($5,$1) in dom $2 or not ($4+*($5,$1))^<*$2.($4+*($5,$1))
*> in dom $6 implies $3 = $2);

definition
  let f1,f2 be homogeneous to-naturals NAT*-defined Function;
  let i be Element of NAT;
  let p be FinSequence of NAT;
  func primrec(f1,f2,i,p) -> Element of HFuncs NAT means
  :Def13:
  ex F being
Function of NAT, HFuncs NAT st it = F.(p/.i) & (i in dom p & Del(p,i) in dom f1
implies F.0 = p+*(i,0) .--> (f1.Del(p,i))) & (not i in dom p or not Del(p,i) in
dom f1 implies F.0 = {}) & for m being Element of NAT holds (i in dom p & p+*(i
,m) in dom (F.m) & (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2 implies F.(m+1) =
(F.m)+*(p+*(i,m+1) .--> f2.((p+*(i,m))^<*(F.m).(p+*(i,m))*>))) & (not i in dom
p or not p+*(i,m) in dom (F.m) or not (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2
  implies F.(m+1) = F.m);
  existence
  proof
    reconsider ff1 = f1, ff2 = f2 as Element of HFuncs NAT by Th31;
    set n = len p;
    reconsider z = ff1.Del(p,i) as Element of NAT;
    defpred A[Element of NAT,Element of HFuncs NAT, Element of HFuncs NAT]
    means Q[$1, $2, $3, p, i, ff2];
    p+*(i,0) in NAT* by FINSEQ_1:def 11;
    then reconsider Ap = {p+*(i,0)} as non empty Subset of NAT* by ZFMISC_1:37;
    {} is PartFunc of NAT*, NAT by RELSET_1:25;
    then {} in PFuncs(NAT*, NAT) by PARTFUN1:119;
    then
A1: {} in HFuncs NAT;
    Ap --> z = p+*(i,0) .--> z;
    then Ap --> z in HFuncs NAT;
    then reconsider t = Ap --> z, e = {} as Element of HFuncs NAT by A1;
    i in dom p & Del(p,i) in dom f1 or not i in dom p or not Del(p,i) in
    dom f1;
    then consider A being Element of HFuncs NAT such that
A2: i in dom p & Del(p,i) in dom f1 implies A = t and
A3: not i in dom p or not Del(p,i) in dom f1 implies A = e;
A4: for m being Element of NAT for x being Element of HFuncs NAT ex y
    being Element of HFuncs NAT st A[m,x,y]
    proof
      let m be Element of NAT, x be Element of HFuncs NAT;
      set f= x+*({p+*(i,m+1)} --> f2.((p+*(i,m))^<*x.(p+*(i,m))*>));
      reconsider z = ff2.((p+*(i,m))^<*x.(p+*(i,m))*>) as Element of NAT;
      i in dom p & p+*(i,m) in dom x & (p+*(i,m))^<*x.(p+*(i,m))*> in dom
f2 or not i in dom p or not p+*(i,m) in dom x or not (p+*(i,m))^<*x.(p+*(i,m))
      *> in dom f2;
      then consider y being Function such that
A5:   i in dom p & p+*(i,m) in dom x & (p+*(i,m))^<*x.(p+*(i,m))*> in
dom f2 & y = x+*({p+*(i,m+1)}--> f2.((p+*(i,m))^<*x.(p+*(i,m))*>)) or (not i in
dom p or not p+*(i,m) in dom x or not (p+*(i,m))^<*x.(p+*(i,m))*> in dom f2) &
      y = x;
      p+*(i,m+1) in NAT* by FINSEQ_1:def 11;
      then reconsider B = {p+*(i,m+1)} as Subset of NAT* by ZFMISC_1:37;
      dom (B --> z) = B by FUNCOP_1:19;
      then
A6:   dom f = dom x \/ B by FUNCT_4:def 1;
      dom p = dom (p+*(i,m+1)) by FUNCT_7:32;
      then len (p+*(i,m+1)) = n by FINSEQ_3:31;
      then p+*(i,m+1) is Element of n-tuples_on NAT by FINSEQ_2:110;
      then
A7:   B c= n-tuples_on NAT by ZFMISC_1:37;
A8:   f = x+*(B --> z);
      now
        assume
A9:     p+*(i,m) in dom x;
        dom x c= n-tuples_on NAT
        proof
          let a be set;
A10:      dom p = dom (p+*(i,m)) by FUNCT_7:32;
          assume
A11:      a in dom x;
          then reconsider q = a as Element of NAT*;
          len q = len (p+*(i,m)) by A9,A11,MARGREL1:def 1;
          then len q = n by A10,FINSEQ_3:31;
          hence thesis;
        end;
        then
A12:    f is homogeneous by A7,A6,Th19,XBOOLE_1:8;
        f in PFuncs(NAT*, NAT) by A8,PARTFUN1:119;
        hence f in HFuncs NAT by A12;
      end;
      then reconsider y as Element of HFuncs NAT by A5;
      take y;
      thus i in dom p & p+*(i,m) in dom x & (p+*(i,m))^<*x.(p+*(i,m))*> in dom
ff2 implies y = x+*( p+*(i,m+1).-->ff2.((p+*(i,m))^<*x.(p+*(i,m))*>)) by A5;
      thus not i in dom p or not p+*(i,m) in dom x or not (p+*(i,m))^<*x.(p+*(
      i,m))*> in dom ff2 implies y = x by A5;
    end;
    consider FF being Function of NAT, HFuncs NAT such that
A13: FF.0 = A and
A14: for m being Element of NAT holds A[m,FF.m qua Element of HFuncs
    NAT,FF.(m+1)qua Element of HFuncs NAT] from RECDEF_1:sch 2(A4);
    take FF.(p/.i), FF;
    thus thesis by A2,A3,A13,A14;
  end;
  uniqueness
  proof
    reconsider ff2 = f2 as Element of HFuncs NAT by Th31;
    let g1,g2 be Element of HFuncs NAT;
    given F1 being Function of NAT, HFuncs NAT such that
A15: g1 = F1.(p/.i) and
A16: i in dom p & Del(p,i) in dom f1 implies F1.0 = p+*(i,0) .--> (f1.
    Del(p,i)) and
A17: not i in dom p or not Del(p,i) in dom f1 implies F1.0 = {} and
A18: for m being Element of NAT holds Q[m, F1.m qua Element of HFuncs
    NAT, F1.(m+1) qua Element of HFuncs NAT, p, i, f2];
    given F2 being Function of NAT, HFuncs NAT such that
A19: g2 = F2.(p/.i) and
A20: i in dom p & Del(p,i) in dom f1 implies F2.0 = p+*(i,0) .--> (f1.
    Del(p,i)) and
A21: not i in dom p or not Del(p,i) in dom f1 implies F2.0 = {} and
A22: for m being Element of NAT holds Q[m, F2.m qua Element of HFuncs
    NAT, F2.(m+1) qua Element of HFuncs NAT, p, i, f2];
    defpred p[Element of NAT] means F1.$1 = F2.$1;
A23: now
      let m be Element of NAT;
      assume
      p[m];
      then
A24:  Q[m, F1.m qua Element of HFuncs NAT, F2.(m+1)qua Element of HFuncs
      NAT, p, i, ff2] by A22;
      Q[m,F1.m qua Element of HFuncs NAT, F1.(m+1)qua Element of HFuncs
      NAT,p,i,f2] by A18;
      hence p[m+1] by A24;
    end;
A25: p[0] by A16,A17,A20,A21;
    for m being Element of NAT holds p[m] from NAT_1:sch 1(A25,A23);
    hence thesis by A15,A19;
  end;
end;

theorem Th53:
  for p, q being FinSequence of NAT st q in dom primrec(e1,e2,i,p)
  ex k st q = p+*(i,k)
proof
  set f1 = e1, f2 = e2;
  let p, q being FinSequence of NAT such that
A1: q in dom primrec(f1,f2,i,p);
  consider F being Function of NAT, HFuncs NAT such that
A2: primrec(f1,f2,i,p) = F.(p/.i) and
A3: i in dom p & Del(p,i) in dom f1 implies F.0 = p+*(i,0) .--> (f1.Del(
  p,i)) and
A4: not i in dom p or not Del(p,i) in dom f1 implies F.0 = {} and
A5: for m being Element of NAT holds Q[m, F.m qua Element of HFuncs NAT,
  F.(m+1)qua Element of HFuncs NAT, p, i, f2] by Def13;
  defpred p[Element of NAT] means q in dom (F.$1) implies ex k being Element
  of NAT st q = p+*(i,k);
A6: for m be Element of NAT st p[m] holds p[m+1]
  proof
    let m be Element of NAT such that
A7: p[m] and
A8: q in dom (F.(m+1));
    per cases;
    suppose
      i in dom p & p+*(i,m) in dom (F.m) & (p+*(i,m))^<*(F.m).(p+*(i,
      m))*> in dom f2;
      then F.(m+1) = (F.m)+*(p+*(i,m+1).--> f2.((p+*(i,m))^<*(F.m).(p+*(i,m))
      *>)) by A5;
      then
      dom (F.(m+1)) = dom (F.m) \/ dom (p+*(i,m+1).--> f2.((p+*(i,m))^<*(
      F.m).(p+*(i,m))*>)) by FUNCT_4:def 1;
      then
A9:   dom (F.(m+1)) = dom (F.m) \/ {p+*(i,m+1)} by FUNCOP_1:19;
      thus ex k being Element of NAT st q = p+*(i,k)
      proof
        per cases by A8,A9,XBOOLE_0:def 3;
        suppose
          q in dom (F.m);
          hence thesis by A7;
        end;
        suppose
          q in {p+*(i,m+1)};
          then q = p+*(i,m+1) by TARSKI:def 1;
          hence thesis;
        end;
      end;
    end;
    suppose
      not i in dom p or not p+*(i,m) in dom (F.m) or not (p+*(i,m))^
      <*(F.m).(p+*(i,m))*> in dom f2;
      hence thesis by A5,A7,A8;
    end;
  end;
A10: p[0]
  proof
    assume
A11: q in dom (F.0);
    per cases;
    suppose
      i in dom p & Del(p,i) in dom f1;
      then dom (F.0) = {p+*(i,0)} by A3,FUNCOP_1:19;
      then p+*(i,0) = q by A11,TARSKI:def 1;
      hence thesis;
    end;
    suppose
      not i in dom p or not Del(p,i) in dom f1;
      hence thesis by A4,A11;
    end;
  end;
  for n being Element of NAT holds p[n] from NAT_1:sch 1(A10,A6);
  hence thesis by A1,A2;
end;

theorem Th54:
  for p being FinSequence of NAT st not i in dom p holds primrec(
  e1,e2,i,p) = {}
proof
  set f1 = e1, f2 = e2;
  let p be FinSequence of NAT;
  consider F being Function of NAT, HFuncs NAT such that
A1: primrec(f1,f2,i,p) = F.(p/.i) and
  i in dom p & Del(p,i) in dom f1 implies F.0 = p+*(i,0) .--> (f1.Del(p,i)
  ) and
A2: not i in dom p or not Del(p,i) in dom f1 implies F.0 = {} and
A3: for m being Element of NAT holds Q[m, F.m qua Element of HFuncs NAT,
  F.(m+1)qua Element of HFuncs NAT, p, i, f2] by Def13;
  defpred p[Element of NAT] means F.$1 = {};
  assume
A4: not i in dom p;
  then
A5: for m be Element of NAT st p[m] holds p[m+1] by A3;
A6: p[0] by A4,A2;
  for m being Element of NAT holds p[m] from NAT_1:sch 1(A6, A5);
  hence thesis by A1;
end;

theorem Th55:
  for p, q being FinSequence of NAT holds primrec(e1,e2,i,p)
  tolerates primrec(e1,e2,i,q)
proof
  set f1 = e1, f2 = e2;
  let p1,p2 be FinSequence of NAT;
  per cases;
  suppose
    not i in dom p1 or not i in dom p2;
    then primrec(f1,f2,i, p1) = {} or primrec(f1,f2,i, p2) = {} by Th54;
    hence thesis by PARTFUN1:141;
  end;
  suppose
A1: i in dom p1 & i in dom p2;
    reconsider m = p1/.i, n = p2/.i as Element of NAT;
    consider F2 being Function of NAT, HFuncs NAT such that
A2: primrec(f1,f2,i,p2) = F2.(p2/.i) and
A3: i in dom p2 & Del(p2,i) in dom f1 implies F2.0 = p2+*(i,0) .--> (
    f1.Del(p2,i)) and
A4: not i in dom p2 or not Del(p2,i) in dom f1 implies F2.0 = {} and
A5: for m being Element of NAT holds Q[m, F2.m qua Element of HFuncs
    NAT, F2.(m+1)qua Element of HFuncs NAT, p2, i, f2] by Def13;
    consider F1 being Function of NAT, HFuncs NAT such that
A6: primrec(f1,f2,i,p1) = F1.(p1/.i) and
A7: i in dom p1 & Del(p1,i) in dom f1 implies F1.0 = p1+*(i,0) .--> (
    f1.Del(p1,i)) and
A8: not i in dom p1 or not Del(p1,i) in dom f1 implies F1.0 = {} and
A9: for m being Element of NAT holds Q[m, F1.m qua Element of HFuncs
    NAT, F1.(m+1)qua Element of HFuncs NAT, p1, i, f2] by Def13;
    defpred p[Element of NAT] means for x being set st x in dom (F1.$1) ex n
    being Element of NAT st x = p1+*(i,n) & n <= $1;
A10: now
      let m be Element of NAT such that
A11:  p[m];
      thus p[m+1]
      proof
        set p1c = (p1+*(i,m))^<*(F1.m).(p1+*(i,m))*>;
        let x be set such that
A12:    x in dom (F1.(m+1));
A13:    m <= m+1 by NAT_1:11;
        per cases;
        suppose
          i in dom p1 & p1+*(i,m) in dom (F1.m) & p1c in dom f2;
          then F1.(m+1) = (F1.m)+*(p1+*(i,m+1).--> f2.(p1c)) by A9;
          then dom (F1.(m+1)) = dom (F1.m) \/ dom (p1+*(i,m+1).--> f2.(p1c))
          by FUNCT_4:def 1
            .= dom (F1.m) \/ {p1+*(i,m+1)} by FUNCOP_1:19;
          then
A14:      x in dom (F1.m) or x in {p1+*(i,m+1)} by A12,XBOOLE_0:def 3;
          thus ex n being Element of NAT st x = p1+*(i,n) & n <= m+1
          proof
            per cases by A14,TARSKI:def 1;
            suppose
              x in dom (F1.m);
              then ex n being Element of NAT st x = p1+*(i,n) & n <= m by A11;
              hence thesis by A13,XXREAL_0:2;
            end;
            suppose
              x = p1+*(i,m+1);
              hence thesis;
            end;
          end;
        end;
        suppose
          not i in dom p1 or not p1+*(i,m) in dom (F1.m) or not p1c
          in dom f2;
          then F1.(m+1) = F1.m by A9;
          then ex n being Element of NAT st x = p1+*(i,n) & n <= m by A11,A12;
          hence thesis by A13,XXREAL_0:2;
        end;
      end;
    end;
A15: now
      defpred r[Element of NAT] means F1.$1 = F2.$1;
      assume
A16:  p1+*(i,0) = p2+*(i,0);
A17:  r[0]
      proof
        per cases;
        suppose
          i in dom p1 & Del(p1,i) in dom f1;
          hence thesis by A1,A7,A3,A16,Th7;
        end;
        suppose
          not i in dom p1 or not Del(p1, i) in dom f1;
          hence thesis by A1,A8,A4,A16,Th7;
        end;
      end;
A18:  now
        let m be Element of NAT such that
A19:    r[m];
A20:    Q[m, F1.m qua Element of HFuncs NAT, F1.(m+1)qua Element of
        HFuncs NAT, p1, i, f2] by A9;
A21:    Q[m, F2.m qua Element of HFuncs NAT, F2.(m+1)qua Element of
        HFuncs NAT, p2, i, f2] by A5;
        p1+*(i,m) = p2+*(i,m) by A16,Th5;
        hence r[m+1] by A1,A19,A20,A21,Th5;
      end;
      thus for m being Element of NAT holds r[m] from NAT_1:sch 1(A17, A18);
    end;
A22: p[0]
    proof
      let x be set such that
A23:  x in dom (F1.0);
      dom (F1.0) = {p1+*(i,0)} by A7,A8,A23,FUNCOP_1:19;
      then x = p1+*(i,0) by A23,TARSKI:def 1;
      hence thesis;
    end;
A24: for m being Element of NAT holds p[m] from NAT_1:sch 1(A22, A10);
A25: for m, n being Element of NAT holds F1.m c= F1.(m+n)
    proof
      let m be Element of NAT;
      defpred r[Element of NAT] means F1.m c= F1.(m+$1);
A26:  now
        let n be Element of NAT such that
A27:    r[n];
        set k = m+n;
        F1.k qua set c= F1.(k+1) qua set
        proof
          set p1c = (p1+*(i,k))^<*(F1.k).(p1+*(i,k))*>;
          let x be set such that
A28:      x in F1.k;
          per cases;
          suppose
A29:        i in dom p1 & p1+*(i,k) in dom (F1.k) & p1c in dom f2;
A30:        dom (F1.k) misses dom (p1+*(i,k+1).--> f2.(p1c))
            proof
              assume
              not thesis;
              then consider x being set such that
A31:          x in dom (F1.k) /\ dom({p1+*(i,k+1)}--> f2.(p1c)) by XBOOLE_0:4;
              x in dom (F1.k) by A31,XBOOLE_0:def 4;
              then consider n1 being Element of NAT such that
A32:          x = p1+*(i,n1) and
A33:          n1 <= k by A24;
A34:          k+1 = (p1+*(i,k+1)).i by A1,FUNCT_7:33;
A35:          x = p1+*(i,k+1) by A31,TARSKI:def 1;
              n1 = (p1+*(i,n1)).i by A1,FUNCT_7:33;
              hence contradiction by A35,A32,A33,A34,NAT_1:13;
            end;
            F1.(k+1) = (F1.k)+*(p1+*(i,k+1).--> f2.(p1c)) by A9,A29;
            then F1.k c= F1.(k+1) by A30,FUNCT_4:33;
            hence thesis by A28;
          end;
          suppose
            not i in dom p1 or not p1+*(i,k) in dom (F1.k) or not p1c
            in dom f2;
            hence thesis by A9,A28;
          end;
        end;
        hence r[n+1] by A27,XBOOLE_1:1;
      end;
A36:  r[0];
      thus for n being Element of NAT holds r[n] from NAT_1:sch 1(A36, A26);
    end;
    defpred p[Element of NAT] means for x being set st x in dom (F2.$1) ex n
    being Element of NAT st x = p2+*(i,n) & n <= $1;
A37: now
      let m be Element of NAT such that
A38:  p[m];
      thus p[m+1]
      proof
        set p2c = (p2+*(i,m))^<*(F2.m).(p2+*(i,m))*>;
        let x be set such that
A39:    x in dom (F2.(m+1));
A40:    m <= m+1 by NAT_1:11;
        per cases;
        suppose
          i in dom p2 & p2+*(i,m) in dom (F2.m) & p2c in dom f2;
          then F2.(m+1) = (F2.m)+*(p2+*(i,m+1).--> f2.(p2c)) by A5;
          then dom (F2.(m+1)) = dom (F2.m) \/ dom (p2+*(i,m+1).--> f2.(p2c))
          by FUNCT_4:def 1
            .= dom (F2.m) \/ {p2+*(i,m+1)} by FUNCOP_1:19;
          then
A41:      x in dom (F2.m) or x in {p2+*(i,m+1)} by A39,XBOOLE_0:def 3;
          thus ex n being Element of NAT st x = p2+*(i,n) & n <= m+1
          proof
            per cases by A41,TARSKI:def 1;
            suppose
              x in dom (F2.m);
              then ex n being Element of NAT st x = p2+*(i,n) & n <= m by A38;
              hence thesis by A40,XXREAL_0:2;
            end;
            suppose
              x = p2+*(i,m+1);
              hence thesis;
            end;
          end;
        end;
        suppose
          not i in dom p2 or not p2+*(i,m) in dom (F2.m) or not p2c
          in dom f2;
          then F2.(m+1) = F2.m by A5;
          then ex n being Element of NAT st x = p2+*(i,n) & n <= m by A38,A39;
          hence thesis by A40,XXREAL_0:2;
        end;
      end;
    end;
A42: p[0]
    proof
      let x be set such that
A43:  x in dom (F2.0);
      dom (F2.0) = {p2+*(i,0)} by A3,A4,A43,FUNCOP_1:19;
      then x = p2+*(i,0) by A43,TARSKI:def 1;
      hence thesis;
    end;
A44: for m being Element of NAT holds p[m] from NAT_1:sch 1(A42, A37);
A45: for m, n being Element of NAT holds F2.m c= F2.(m+n)
    proof
      let m be Element of NAT;
      defpred r[Element of NAT] means F2.m c= F2.(m+$1);
A46:  now
        let n be Element of NAT such that
A47:    r[n];
        set k = m+n;
        F2.k c= F2.(k+1)
        proof
          set p2c = (p2+*(i,k))^<*(F2.k).(p2+*(i,k))*>;
          let x be set such that
A48:      x in F2.k;
          per cases;
          suppose
A49:        i in dom p2 & p2+*(i,k) in dom (F2.k) & p2c in dom f2;
A50:        dom (F2.k) misses dom (p2+*(i,k+1).--> f2.(p2c))
            proof
              assume
              not thesis;
              then consider x being set such that
A51:          x in dom (F2.k) /\ dom({p2+*(i,k+1)}--> f2.(p2c)) by XBOOLE_0:4;
              x in dom (F2.k) by A51,XBOOLE_0:def 4;
              then consider n2 being Element of NAT such that
A52:          x = p2+*(i,n2) and
A53:          n2 <= k by A44;
A54:          k+1 = (p2+*(i,k+1)).i by A1,FUNCT_7:33;
A55:          x = p2+*(i,k+1) by A51,TARSKI:def 1;
              n2 = (p2+*(i,n2)).i by A1,FUNCT_7:33;
              hence contradiction by A55,A52,A53,A54,NAT_1:13;
            end;
            F2.(k+1) = (F2.k)+*(p2+*(i,k+1).--> f2.(p2c)) by A5,A49;
            then F2.k c= F2.(k+1) by A50,FUNCT_4:33;
            hence thesis by A48;
          end;
          suppose
            not i in dom p2 or not p2+*(i,k) in dom (F2.k) or not
            p2c in dom f2;
            hence thesis by A5,A48;
          end;
        end;
        hence r[n+1] by A47,XBOOLE_1:1;
      end;
A56:  r[0];
      thus for n being Element of NAT holds r[n] from NAT_1:sch 1(A56, A46);
    end;
    reconsider F1m = F1.m, F1n = F1.n, F2m = F2.m, F2n = F2.n as Element of
    HFuncs NAT;
A57: now
      assume
A58:  p1+*(i,0) <> p2+*(i,0);
      let m be Element of NAT;
      assume
      dom (F1.m) /\ dom (F2.m) <> {};
      then consider x being set such that
A59:  x in dom(F1.m) /\ dom(F2.m) by XBOOLE_0:def 1;
      x in dom(F2.m) by A59,XBOOLE_0:def 4;
      then
A60:  ex n2 being Element of NAT st x = p2+*(i,n2) & n2 <= m by A44;
      x in dom(F1.m) by A59,XBOOLE_0:def 4;
      then ex n1 being Element of NAT st x = p1+*(i,n1) & n1 <= m by A24;
      hence contradiction by A58,A60,Th5;
    end;
    thus thesis
    proof
      per cases;
      suppose
        m <= n;
        then consider k being Nat such that
A61:    n = m+k by NAT_1:10;
        reconsider k as Element of NAT by ORDINAL1:def 13;
A62:    n = m+k by A61;
        thus primrec(f1,f2,i,p1) tolerates primrec(f1,f2,i,p2)
        proof
          per cases by A15,A57;
          suppose
            F1n = F2n;
            hence thesis by A6,A2,A25,A62,PARTFUN1:140;
          end;
          suppose
            dom (F1n) /\ dom (F2n) = {};
            then dom (F1n) misses dom (F2n) by XBOOLE_0:def 7;
            then F1n tolerates F2n by PARTFUN1:138;
            hence thesis by A6,A2,A25,A62,PARTFUN1:140;
          end;
        end;
      end;
      suppose
        m >= n;
        then consider k being Nat such that
A63:    m = n+k by NAT_1:10;
        reconsider k as Element of NAT by ORDINAL1:def 13;
A64:    m = n+k by A63;
        thus primrec(f1,f2,i,p1) tolerates primrec(f1,f2,i,p2)
        proof
          per cases by A15,A57;
          suppose
            F1m = F2m;
            hence thesis by A6,A2,A45,A64,PARTFUN1:140;
          end;
          suppose
            dom (F1m) /\ dom (F2m) = {};
            then dom (F1m) misses dom (F2m) by XBOOLE_0:def 7;
            then F1m tolerates F2m by PARTFUN1:138;
            hence thesis by A6,A2,A45,A64,PARTFUN1:140;
          end;
        end;
      end;
    end;
  end;
end;

theorem Th56:
  for p being FinSequence of NAT holds dom primrec(e1,e2,i,p) c= (
  1+arity e1)-tuples_on NAT
proof
  set f1 = e1, f2 = e2;
  let p be FinSequence of NAT;
  per cases;
  suppose
A1: i in dom p;
    consider F being Function of NAT, HFuncs NAT such that
A2: primrec(f1,f2,i,p) = F.(p/.i) and
A3: i in dom p & Del(p,i) in dom f1 implies F.0 = p+*(i,0) .--> (f1.
    Del(p,i)) and
A4: not i in dom p or not Del(p,i) in dom f1 implies F.0 = {} and
A5: for m being Element of NAT holds Q[m, F.m qua Element of HFuncs
    NAT, F.(m+1)qua Element of HFuncs NAT, p, i, f2] by Def13;
    defpred p[Element of NAT] means dom (F.$1) c= (1+arity f1)-tuples_on NAT;
A6: now
      let m be Element of NAT such that
A7:   p[m];
      set pc = (p+*(i,m))^<*(F.m).(p+*(i,m))*>;
      per cases;
      suppose
A8:     p+*(i,m) in dom (F.m) & pc in dom f2;
        dom (p+*(i,m)) = dom p by FUNCT_7:32
          .= dom (p+*(i,m+1)) by FUNCT_7:32;
        then
A9:     len (p+*(i,m)) = len (p+*(i,m+1)) by FINSEQ_3:31;
        len (p+*(i,m)) = 1+arity f1 by A7,A8,FINSEQ_1:def 18;
        then p+*(i,m+1)is Element of (1+arity f1)-tuples_on NAT by A9,
FINSEQ_2:110;
        then
A10:    {p+*(i,m+1)} c= (1+arity f1)-tuples_on NAT by ZFMISC_1:37;
        F.(m+1) = (F.m)+*(p+*(i,m+1).--> f2.(pc)) by A1,A5,A8;
        then dom (F.(m+1)) = dom (F.m) \/ dom (p+*(i,m+1).--> f2.(pc)) by
FUNCT_4:def 1;
        then dom (F.(m+1)) = dom (F.m) \/ {p+*(i,m+1)} by FUNCOP_1:19;
        hence p[m+1] by A7,A10,XBOOLE_1:8;
      end;
      suppose
        not p+*(i,m) in dom (F.m) or not pc in dom f2;
        hence p[m+1] by A5,A7;
      end;
    end;
A11: p[0]
    proof
      per cases;
      suppose
A12:    Del(p,i) in dom f1;
        dom f1 c= (arity f1)-tuples_on NAT by Th24;
        then
A13:    len Del(p,i) = arity f1 by A12,FINSEQ_1:def 18;
A14:    dom p = dom (p+*(i,0)) by FUNCT_7:32;
        p <> <*>NAT by A1;
        then consider n being Nat such that
A15:    len p = n+1 by NAT_1:6;
        len Del(p,i) = n by A1,A15,FINSEQ_3:118;
        then len (p+*(i,0)) = 1+arity f1 by A13,A15,A14,FINSEQ_3:31;
        then
A16:    (p+*(i,0)) is Element of (1+arity f1)-tuples_on NAT by FINSEQ_2:110;
        dom (F.0) = {p+*(i,0)} by A1,A3,A12,FUNCOP_1:19;
        hence thesis by A16,ZFMISC_1:37;
      end;
      suppose
        not Del(p,i) in dom f1;
        hence thesis by A4,RELAT_1:60,XBOOLE_1:2;
      end;
    end;
    for m being Element of NAT holds p[m] from NAT_1:sch 1(A11,A6);
    hence thesis by A2;
  end;
  suppose
    not i in dom p;
    then primrec(f1,f2,i,p) = {} by Th54;
    hence thesis by RELAT_1:60,XBOOLE_1:2;
  end;
end;

theorem Th57:
  for p being FinSequence of NAT st e1 is empty holds primrec(e1,
  e2,i,p) is empty
proof
  set f1 = e1, f2 = e2;
  let p be FinSequence of NAT;
  consider F be Function of NAT, HFuncs NAT such that
A1: primrec(f1,f2,i,p) = F.(p/.i) and
  i in dom p & Del(p,i) in dom f1 implies F.0 = p+*(i,0) .--> (f1.Del(p,i
  )) and
A2: not i in dom p or not Del(p,i) in dom f1 implies F.0 = {} and
A3: for m being Element of NAT holds (i in dom p & p+*(i,m) in dom (F.m)
& (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2 implies F.(m+1) = (F.m)+*(p+*(i,m+1
).--> f2.((p+*(i,m))^<*(F.m).(p+*(i,m))*>))) & (not i in dom p or not p+*(i,m)
in dom (F.m) or not (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2 implies F.(m+1) =
  F.m) by Def13;
  defpred p[Element of NAT] means F.$1 = {};
A4: for k be Element of NAT st p[k] holds p[k+1] by A3,RELAT_1:60;
  assume
  f1 is empty;
  then
A5: p[0] by A2;
  for k being Element of NAT holds p[k] from NAT_1:sch 1(A5,A4);
  hence thesis by A1;
end;

theorem Th58:
  f1 is len-total & f2 is len-total & arity f1 +2 = arity f2 & 1
  <= i & i <= 1+arity f1 implies p in dom primrec(f1,f2,i,p)
proof
  assume that
A1: f1 is len-total and
A2: f2 is len-total and
A3: arity f1 +2 = arity f2 and
A4: 1 <= i and
A5: i <= 1+arity f1;
A6: len p = 1+arity f1 by FINSEQ_1:def 18;
  then
A7: i in dom p by A4,A5,FINSEQ_3:27;
  then
A8: p/.i = p.i by PARTFUN1:def 8;
  consider F being Function of NAT, HFuncs NAT such that
A9: primrec(f1,f2,i,p) = F.(p/.i) and
A10: i in dom p & Del(p,i) in dom f1 implies F.0 = p+*(i,0) .--> (f1.Del
  (p,i)) and
  not i in dom p or not Del(p,i) in dom f1 implies F.0 = {} and
A11: for m being Element of NAT holds (i in dom p & p+*(i,m) in dom (F.m
) & (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2 implies F.(m+1) = (F.m)+*(p+*(i,m
+1).--> f2.((p+*(i,m))^<*(F.m).(p+*(i,m))*>))) & (not i in dom p or not p+*(i,m
) in dom (F.m) or not (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2 implies F.(m+1)
  = F.m) by Def13;
  defpred p[Element of NAT] means (p+*(i,$1)) in dom (F.$1);
A12: (p+*(i,p.i)) = p by FUNCT_7:37;
A13: now
    let m be Element of NAT such that
A14: p[m];
    reconsider aa = (F.m).(p+*(i,m)) as Element of NAT;
    set pc = (p+*(i,m))^<*(F.m).(p+*(i,m))*>;
    reconsider p2 = <*aa*> as FinSequence of NAT;
    reconsider p1 = (p+*(i,m))^p2 as FinSequence of NAT;
A15: len p2 = 1 by FINSEQ_1:def 18;
    len (p+*(i,m))=1+arity f1 by FINSEQ_1:def 18;
    then len p1 = arity f1+1+1 by A15,FINSEQ_1:35
      .= arity f2 by A3;
    then
A16: p1 is Element of (arity f2)-tuples_on NAT by FINSEQ_2:110;
    p+*(i,m+1) in {p+*(i,m+1)} by TARSKI:def 1;
    then
A17: p+*(i,m+1) in dom ({p+*(i,m+1)}--> f2.(pc)) by FUNCOP_1:19;
    dom f2 = (arity f2)-tuples_on NAT by A2,Th26;
    then F.(m+1) = (F.m)+*(p+*(i,m+1).--> f2.(pc)) by A7,A11,A14,A16;
    then dom(F.(m+1))=dom (F.m) \/ dom ({p+*(i,m+1)}--> f2.(pc))by
FUNCT_4:def 1;
    hence p[m+1] by A17,XBOOLE_0:def 3;
  end;
A18: now
    reconsider Dpi = Del(p,i) as FinSequence of NAT by FINSEQ_3:114;
    reconsider Dpi9 = Dpi as Element of (len Dpi)-tuples_on NAT by FINSEQ_2:110
;
A19: dom f1 = (arity f1)-tuples_on NAT by A1,Th26;
    len Del(p,i) = arity f1 by A6,A7,FINSEQ_3:118;
    then Dpi9 in dom f1 by A19;
    then dom (F.0) = {p+*(i,0)} by A4,A5,A6,A10,FINSEQ_3:27,FUNCOP_1:19;
    hence p[0] by TARSKI:def 1;
  end;
  for m being Element of NAT holds p[m] from NAT_1:sch 1(A18, A13);
  hence thesis by A8,A9,A12;
end;

definition
  let f1,f2 be homogeneous to-naturals NAT*-defined Function;
  let i be Element of NAT;
  func primrec(f1,f2,i) -> Element of HFuncs NAT means
  :Def14:
  ex G being
  Function of (arity f1+1)-tuples_on NAT, HFuncs NAT st it = Union G & for p
  being Element of (arity f1+1)-tuples_on NAT holds G.p = primrec(f1,f2,i,p);
  existence
  proof
    deffunc f(FinSequence of NAT) = primrec(f1,f2,i,$1);
    reconsider ff1 = f1, ff2 = f2 as Element of HFuncs NAT by Th31;
    set n = arity f1+1;
    consider G being Function of n-tuples_on NAT, HFuncs NAT such that
A1: for p being Element of n-tuples_on NAT holds G.p = f(p) from
    FUNCT_2:sch 4;
    reconsider Y = rng G as non empty Subset of HFuncs NAT by RELAT_1:def 19;
    Y is PartFunc-set of NAT*, NAT
    proof
      let f be Element of Y;
      thus thesis;
    end;
    then reconsider Y as PFUNC_DOMAIN of NAT*, NAT;
A2: Y is compatible
    proof
      let f,g be Function;
      assume
      f in Y;
      then consider x being set such that
A3:   x in dom G and
A4:   f = G.x by FUNCT_1:def 5;
      assume
      g in Y;
      then consider y being set such that
A5:   y in dom G and
A6:   g = G.y by FUNCT_1:def 5;
      reconsider x,y as Element of n-tuples_on NAT by A3,A5;
A7:   g = primrec(ff1,ff2,i,y) by A1,A6;
      f = primrec(ff1,ff2,i,x) by A1,A4;
      hence thesis by A7,Th55;
    end;
    now
      let x be Element of n-tuples_on NAT;
      G.x = primrec(ff1,ff2,i,x) by A1;
      hence dom (G.x) c= n-tuples_on NAT by Th56;
    end;
    then consider g being Element of HFuncs NAT such that
A8: g = Union G and
    dom g c= n-tuples_on NAT by A2,Th43;
    take g, G;
    thus thesis by A1,A8;
    consider np being Element of n-tuples_on NAT;
  end;
  uniqueness
  proof
    let g1,g2 be Element of HFuncs NAT;
    given G1 being Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such
    that
A9: g1 = Union G1 and
A10: for p being Element of (arity f1+1)-tuples_on NAT holds G1.p =
    primrec(f1,f2,i,p);
    given G2 being Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such
    that
A11: g2 = Union G2 and
A12: for p being Element of (arity f1+1)-tuples_on NAT holds G2.p =
    primrec(f1,f2,i,p);
    now
      let p be Element of (arity f1+1)-tuples_on NAT;
      thus G1.p = primrec(f1,f2,i,p) by A10
        .= G2.p by A12;
    end;
    hence thesis by A9,A11,FUNCT_2:113;
  end;
end;

theorem Th59:
  e1 is empty implies primrec(e1,e2,i) is empty
proof
  set f1 = e1, f2 = e2;
  assume
A1: f1 is empty;
  consider G being Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such
  that
A2: primrec(f1,f2,i) = Union G and
A3: for p being Element of (arity f1+1)-tuples_on NAT holds G.p =
  primrec(f1,f2,i,p) by Def14;
A4: dom G = (arity f1+1)-tuples_on NAT by FUNCT_2:def 1;
  now
    consider p being Element of (arity f1+1)-tuples_on NAT;
    let y be set;
    hereby
      assume
      y in rng G;
      then consider x being set such that
A5:   x in dom G and
A6:   G.x = y by FUNCT_1:def 5;
      reconsider p = x as Element of (arity f1+1)-tuples_on NAT by A5;
      G.p = primrec(f1,f2,i,p) by A3
        .= {} by A1,Th57;
      hence y in {{}} by A6,TARSKI:def 1;
    end;
    assume
    y in {{}};
    then
A7: y = {} by TARSKI:def 1;
    G.p = primrec ( f1,f2,i,p) by A3
      .= {} by A1,Th57;
    hence y in rng G by A4,A7,FUNCT_1:12;
  end;
  then
A8: rng G = {{}} by TARSKI:2;
  Union G = union rng G
    .= {} by A8,ZFMISC_1:31;
  hence thesis by A2;
end;

theorem Th60:
  dom primrec(f1,f2,i) c= (arity f1+1)-tuples_on NAT
proof
  let x be set such that
A1: x in dom primrec(f1,f2,i);
  consider G being Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such
  that
A2: primrec(f1,f2,i) = Union G and
A3: for p being Element of (arity f1+1)-tuples_on NAT holds G.p =
  primrec(f1,f2,i,p) by Def14;
A4: rng G is compatible
  proof
    let f,g being Function such that
A5: f in rng G and
A6: g in rng G;
    consider fx being set such that
A7: fx in dom G and
A8: f = G.fx by A5,FUNCT_1:def 5;
    reconsider fx as Element of (arity f1+1)-tuples_on NAT by A7;
    consider gx being set such that
A9: gx in dom G and
A10: g = G.gx by A6,FUNCT_1:def 5;
    reconsider gx as Element of (arity f1+1)-tuples_on NAT by A9;
A11: G.gx = primrec(f1,f2,i,gx) by A3;
    G.fx = primrec(f1,f2,i,fx) by A3;
    hence thesis by A8,A10,A11,Th55;
  end;
  now
    let x be Element of (arity f1+1)-tuples_on NAT;
    G.x = primrec(f1,f2,i,x) by A3;
    hence dom (G.x) c= (arity f1+1)-tuples_on NAT by Th56;
  end;
  then
  ex F being Element of HFuncs NAT st F = Union G & dom F c= (arity f1+
  1)-tuples_on NAT by A4,Th43;
  hence thesis by A1,A2;
end;

theorem Th61:
  f1 is len-total & f2 is len-total & arity f1 +2 = arity f2 & 1
  <= i & i <= 1+arity f1 implies dom primrec(f1,f2,i) = (arity f1+1)-tuples_on
  NAT & arity primrec(f1,f2,i) = arity f1+1
proof
  assume that
A1: f1 is len-total and
A2: f2 is len-total and
A3: arity f1 +2 = arity f2 and
A4: 1 <= i and
A5: i <= 1+arity f1;
  set n = arity f1+1;
A6: n-tuples_on NAT c= dom primrec(f1,f2,i)
  proof
    let x be set;
    assume
    x in n-tuples_on NAT;
    then reconsider x9 = x as Element of n-tuples_on NAT;
    consider G being Function of n-tuples_on NAT, HFuncs NAT such that
A7: primrec(f1,f2,i) = Union G and
A8: for p being Element of n-tuples_on NAT holds G.p = primrec(f1,f2,
    i,p) by Def14;
    reconsider rngG = rng G as non empty functional compatible set by A7,Th14;
A9: dom union rngG = union {dom f where f is Element of rngG: not
    contradiction} by Th15;
    dom G = n-tuples_on NAT by FUNCT_2:def 1;
    then G.x9 in rng G by FUNCT_1:12;
    then
A10: dom (G.x9) in {dom f where f is Element of rngG:not contradiction};
A11: x9 in dom primrec(f1,f2,i,x9) by A1,A2,A3,A4,A5,Th58;
    G.x9 = primrec(f1,f2,i,x9) by A8;
    hence thesis by A7,A11,A9,A10,TARSKI:def 4;
  end;
  dom primrec(f1,f2,i) c= (arity f1+1)-tuples_on NAT by Th60;
  hence dom primrec(f1,f2,i) = (arity f1+1)-tuples_on NAT by A6,XBOOLE_0:def 10
;
  hence thesis by Th28;
end;

Lm2: now
  let f1,f2 be non empty homogeneous to-naturals NAT*-defined Function;
  let p be Element of (arity f1+1)-tuples_on NAT;
  let i, m be Element of NAT;
  set pm1 = p+*(i,m+1), pm = p+*(i,m);
  let F1, F be Function of NAT, HFuncs NAT such that

A1: i in dom pm1 & Del(pm1,i) in dom f1 implies F1.0 = {pm1+*(i,0)} -->
  (f1 .Del(pm1,i)) and
A2: not i in dom pm1 or not Del(pm1,i) in dom f1 implies F1.0 = {} and

A3: for M being Element of NAT holds Q[M, F1.M qua Element of HFuncs NAT
  , F1.(M+1)qua Element of HFuncs NAT, pm1, i, f2] and

A4: i in dom pm & Del(pm,i) in dom f1 implies F.0 = {pm+*(i,0)} --> (f1
  .Del(pm,i)) and
A5: not i in dom pm or not Del(pm,i) in dom f1 implies F.0 = {} and

A6: for M being Element of NAT holds Q[M, F.M qua Element of HFuncs NAT,
  F.(M+1) qua Element of HFuncs NAT, pm, i, f2];

A7: dom p = dom pm by FUNCT_7:32;
A8: pm+*(i,0) = p+*(i,0) by FUNCT_7:36
    .= pm1+*(i,0) by FUNCT_7:36;
A9: dom p = dom pm1 by FUNCT_7:32;
A10: Del(pm,i) = Del(p,i) by Th6
    .= Del(pm1,i) by Th6;
  for x being set st x in NAT holds F.x = F1.x
  proof
    let x be set;
    defpred p[Element of NAT] means F.$1 = F1.$1;
A11: for k be Element of NAT st p[k] holds p[k+1]
    proof
      let k be Element of NAT such that
A12:  p[k];
A13:  pm+*(i,(k+1))=p+*(i,(k+1)) by FUNCT_7:36
        .=pm1+*(i,(k+1)) by FUNCT_7:36;
A14:  pm+*(i,k) = p+*(i,k) by FUNCT_7:36
        .= pm1+*(i,k) by FUNCT_7:36;
      per cases;
      suppose

A15:    i in dom pm & pm+*(i,k) in dom (F.k) & (pm+*(i,k))^<*(F.k).(
        pm+*(i,k))*> in dom f2;

        hence
        F.(k+1) = (F.k)+*(pm+*(i,k+1).--> f2.((pm+*(i,k))^<*(F.k).(pm+*(i
        ,k))*>)) by A6

          .= F1.(k+1) by A3,A7,A9,A12,A14,A13,A15;
      end;
      suppose

A16:    not i in dom pm or not pm+*(i,k) in dom (F.k) or not (pm+*(i,
        k))^<*(F.k).(pm+*(i,k))*> in dom f2;

        hence F.(k+1) = F.k by A6
          .= F1.(k+1) by A3,A7,A9,A12,A14,A16;
      end;
    end;
A17: p[0] by A1,A2,A4,A5,A7,A8,A10,FUNCT_7:32;
A18: for k being Element of NAT holds p[k] from NAT_1:sch 1(A17, A11);
    assume
    x in NAT;
    hence thesis by A18;
  end;
  hence F1 = F by FUNCT_2:18;
end;

Lm3: now
  let f1,f2 be non empty homogeneous to-naturals NAT*-defined Function;
  let p be Element of (arity f1+1)-tuples_on NAT;
  let i, m be Element of NAT such that
A1: i in dom p;
  set pm = p+*(i,m), pm1 = p+*(i,(m+1));
  let F be Function of NAT, HFuncs NAT such that

A2: i in dom pm1 & Del(pm1,i) in dom f1 implies F.0 = {pm1+*(i,0)} --> (
  f1. Del(pm1,i)) and
A3: not i in dom pm1 or not Del(pm1,i) in dom f1 implies F.0 = {} and

A4: for M being Element of NAT holds Q[M, F.M qua Element of HFuncs NAT,
  F.(M+1)qua Element of HFuncs NAT, pm1, i, f2];

  thus F.(m+1).pm = F.m.pm
  proof
    per cases;
    suppose

A5:   i in dom pm1 & pm1+*(i,m) in dom (F.m) & (pm1+*(i,m))^<*(F.m).(
      pm1+*(i,m))*> in dom f2;

A6:   pm1 = pm1+*(i,m+1) by FUNCT_7:36;
A7:   pm1.i = m+1 by A1,FUNCT_7:33;
      pm.i = m by A1,FUNCT_7:33;
      then pm <> pm1 by A7;

      then
A8:   not pm in dom ({pm1+*(i,m+1)}--> f2.((pm1+*(i,m))^<*(F.m).(pm1+*(i,
      m))*>)) by A6,TARSKI:def 1;

      F.(m+1) = (F.m)+*(pm1+*(i,m+1).--> f2.((pm1+*(i,m))^<*(F.m).(pm1+*(i
      ,m))*>)) by A4,A5;

      hence thesis by A8,FUNCT_4:12;
    end;
    suppose

      not i in dom pm1 or not pm1+*(i,m) in dom (F.m) or not (pm1+*(i
      ,m))^<*(F.m).(pm1+*(i,m))*> in dom f2;

      hence thesis by A4;
    end;
  end;
A9: for m, k being Element of NAT st p+*(i,k) in dom (F.m) holds k <= m
  proof

    defpred p[Element of NAT] means for k being Element of NAT st p+*(i,k) in
    dom (F.$1) holds k <= $1;

A10: for m be Element of NAT st p[m] holds p[m+1]
    proof
      let m be Element of NAT such that
A11:  p[m];
      let k be Element of NAT such that
A12:  p+*(i,k) in dom (F.(m+1));
      per cases;
      suppose

        i in dom pm1 & pm1+*(i,m) in dom (F.m) & (pm1+*(i,m))^<*(F.m)
        .(pm1+*(i,m))*> in dom f2;

        then F.(m+1) = (F.m)+*(pm1+*(i,m+1).--> f2.((pm1+*(i,m))^<*(F.m).(pm1
        +*(i,m))*>))by A4;

        then
        dom (F.(m+1)) = dom (F.m) \/ dom ({pm1+*(i,m+1)}--> f2.((pm1+*(i,
        m))^<*(F.m).(pm1+*(i,m))*>)) by FUNCT_4:def 1;

        then
A13:    dom (F.(m+1)) = dom (F.m) \/ {pm1+*(i,m+1)} by FUNCOP_1:19;
        thus k <= (m+1)
        proof
          per cases by A12,A13,XBOOLE_0:def 3;
          suppose
A14:        p+*(i,k) in dom (F.m);
A15:        m <= m+1 by NAT_1:11;
            k <= m by A11,A14;
            hence thesis by A15,XXREAL_0:2;
          end;
          suppose
            p+*(i,k) in {pm1+*(i,m+1)};
            then
A16:        p+*(i,k)= pm1+*(i,m+1) by TARSKI:def 1
              .=p+*(i,m+1) by FUNCT_7:36;
            k = (p+*(i,k)).i by A1,FUNCT_7:33
              .= m+1 by A1,A16,FUNCT_7:33;
            hence thesis;
          end;
        end;
      end;
      suppose

        not i in dom pm1 or not pm1+*(i,m) in dom (F.m) or not (pm1+*
        (i,m))^<*(F.m).(pm1+*(i,m))*> in dom f2;

        then F.(m+1) = F.m by A4;
        then
A17:    k <= m by A11,A12;
        m <= m+1 by NAT_1:11;
        hence thesis by A17,XXREAL_0:2;
      end;
    end;
A18: p[0]
    proof
      let k be Element of NAT such that
A19:  p+*(i,k) in dom (F.0);
      per cases;
      suppose
        i in dom pm1 & Del(pm1,i) in dom f1;
        then dom (F.0) = {pm1+*(i,0)} by A2,FUNCOP_1:19;
        then
A20:    (p+*(i,k)) = (pm1+*(i,0)) by A19,TARSKI:def 1
          .= p+*(i,0) by FUNCT_7:36;
        k = (p+*(i,k)).i by A1,FUNCT_7:33
          .= 0 by A1,A20,FUNCT_7:33;
        hence thesis;
      end;
      suppose
        not i in dom pm1 or not Del(pm1,i) in dom f1;
        hence thesis by A3,A19;
      end;
    end;
    thus for n be Element of NAT holds p[n] from NAT_1:sch 1(A18, A10);
  end;
  thus not pm1 in dom (F.m)
  proof
    assume
    not thesis;
    then m+1 <= m by A9;
    hence contradiction by NAT_1:13;
  end;
end;

definition let n be Nat, p be Element of n-tuples_on NAT;
 let i,k be Element of NAT;
 redefine func p+*(i,k) -> Element of n-tuples_on NAT;
 coherence
  proof
    dom(p+*(i,k)) = dom p by FUNCT_7:32;
    then len(p+*(i,k)) = len p by FINSEQ_3:31
      .= n by FINSEQ_1:def 18;
    hence p+*(i,k) is Element of n-tuples_on NAT by FINSEQ_2:110;
  end;
end;

Lm4: now
  let f1,f2 be non empty homogeneous to-naturals NAT*-defined Function;
  let p be Element of (arity f1+1)-tuples_on NAT;
  let i, m be Element of NAT such that
A1: i in dom p;
  let G be Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such that

A2: for p being Element of (arity f1+1)-tuples_on NAT holds G.p =
  primrec(f1,f2,i,p);

  thus for k, n being Element of NAT holds dom (G.(p+*(i,k))) c= dom (G.(p+*(i
  ,(k+n))))

  proof
    let k be Element of NAT;
    set pk = p+*(i,k);
    defpred p[Element of NAT] means dom (G.pk) c= dom(G.(p+*(i,(k+$1))));
A3: now
      let n be Element of NAT such that
A4:   p[n];
      set m = k+n;
      set pkn1 = p+*(i,((k+n)+1));
      set pkn = p+*(i,(k+n));
      consider F being Function of NAT, HFuncs NAT such that
A5:   primrec(f1,f2,i,pkn)= F.(pkn/.i) and

A6:   i in dom pkn & Del(pkn,i) in dom f1 implies F.0 = pkn+*(i,0)
      .--> (f1. Del(pkn,i)) and
A7:   not i in dom pkn or not Del(pkn,i) in dom f1 implies F.0 = {} and

A8:   for M being Element of NAT holds Q[M, F.M qua Element of HFuncs
      NAT, F.(M+1)qua Element of HFuncs NAT, pkn, i, f2] by Def13;

      dom p = dom pkn1 by FUNCT_7:32;
      then
A9:   pkn1/.i = pkn1.i by A1,PARTFUN1:def 8
        .= m+1 by A1,FUNCT_7:33;
      consider F1 being Function of NAT, HFuncs NAT such that
A10:  primrec(f1,f2,i,pkn1)= F1.(pkn1/.i) and

A11:  i in dom pkn1 & Del(pkn1,i) in dom f1 implies F1.0 = pkn1+*(i,0
      ) .--> (f1.Del(pkn1,i)) and

A12:  not i in dom pkn1 or not Del(pkn1,i) in dom f1 implies F1.0 =
      {} and

A13:  for M being Element of NAT holds Q[M, F1.M qua Element of
      HFuncs NAT, F1.(M+1)qua Element of HFuncs NAT, pkn1, i, f2] by Def13;

      F1 = F by A6,A7,A8,A11,A12,A13,Lm2;
      then
A14:  G.(p+*(i,(k+(n+1)))) = F.(m+1) by A2,A10,A9;
      dom p = dom pkn by FUNCT_7:32;
      then pkn/.i = pkn.i by A1,PARTFUN1:def 8
        .= m by A1,FUNCT_7:33;
      then
A15:  G.(p+*(i,(k+n))) = F.m by A2,A5;
      per cases;
      suppose

        i in dom pkn & pkn+*(i,m) in dom (F.m) & (pkn+*(i,m))^<*(F.m)
        .(pkn+*(i,m))*> in dom f2;

        then F.(m+1) = (F.m)+*(pkn+*(i,m+1).--> f2.((pkn+*(i,m))^<*(F.m).(pkn
        +*(i,m))*>)) by A8;

        then
        dom (F.(m+1)) = dom (F.m) \/ dom ({pkn+*(i,m+1)}--> f2.((pkn+*(i,
        m))^<*(F.m).(pkn+*(i,m))*>)) by FUNCT_4:def 1;

        then dom (F.m) c= dom (F.(m+1)) by XBOOLE_1:7;
        hence p[n+1] by A4,A14,A15,XBOOLE_1:1;
      end;
      suppose

        not i in dom pkn or not pkn+*(i,m) in dom (F.m) or not (pkn+*
        (i,m))^<*(F.m).(pkn+*(i,m))*> in dom f2;

        hence p[n+1] by A4,A8,A14,A15;
      end;
    end;
A16: p[0];
    thus for n being Element of NAT holds p[n] from NAT_1:sch 1(A16, A3);
  end;
end;

Lm5: now
  let f1,f2 be non empty homogeneous to-naturals NAT*-defined Function;
  let p be Element of (arity f1+1)-tuples_on NAT;
  let i, m be Element of NAT such that
A1: i in dom p;
  let G be Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such that

A2: for p being Element of (arity f1+1)-tuples_on NAT holds G.p =
  primrec(f1,f2,i,p);

  thus for k, n being Element of NAT st not p+*(i,k) in dom (G.(p+*(i,k)))
  holds not p+*(i,k) in dom (G.(p+*(i,(k+n))))

  proof
    let k be Element of NAT;
    set pk = p+*(i,k);

    defpred p[Element of NAT] means not pk in dom (G.pk) implies not pk in dom
    (G.(p+*(i,(k+$1))));

A3: for n be Element of NAT st p[n] holds p[n+1]
    proof
      let n be Element of NAT such that
A4:   p[n] and
A5:   not pk in dom (G.pk);
      set m = k+n;
      set pkn = p+*(i,(k+n));
      consider F being Function of NAT, HFuncs NAT such that
A6:   primrec(f1,f2,i,pkn)= F.(pkn/.i) and

A7:   i in dom pkn & Del(pkn,i) in dom f1 implies F.0 = pkn+*(i,0)
      .--> (f1. Del(pkn,i)) and
A8:   not i in dom pkn or not Del(pkn,i) in dom f1 implies F.0 = {} and

A9:   for M being Element of NAT holds Q[M, F.M qua Element of HFuncs
      NAT, F.(M+1)qua Element of HFuncs NAT, pkn, i, f2] by Def13;

A10:  dom p = dom pkn by FUNCT_7:32;
      then pkn/.i = pkn.i by A1,PARTFUN1:def 8
        .= m by A1,FUNCT_7:33;
      then
A11:  not pk in dom (F.m) by A2,A4,A5,A6;
      set pkn1 = p+*(i,((k+n)+1));
      consider F1 being Function of NAT, HFuncs NAT such that
A12:  primrec(f1,f2,i,pkn1)= F1.(pkn1/.i) and

A13:  i in dom pkn1 & Del(pkn1,i) in dom f1 implies F1.0 = pkn1+*(i,0
      ) .--> (f1.Del(pkn1,i)) and

A14:  not i in dom pkn1 or not Del(pkn1,i) in dom f1 implies F1.0 =
      {} and

A15:  for M being Element of NAT holds Q[M, F1.M qua Element of
      HFuncs NAT, F1.(M+1)qua Element of HFuncs NAT, pkn1, i, f2] by Def13;

      dom p = dom pkn1 by FUNCT_7:32;
      then
A16:  pkn1/.i = pkn1.i by A1,PARTFUN1:def 8
        .= m+1 by A1,FUNCT_7:33;
      F1 = F by A7,A8,A9,A13,A14,A15,Lm2;
      then
A17:  G.(p+*(i,(k+(n+1)))) = F.(m+1) by A2,A12,A16;
      per cases;
      suppose

        i in dom pkn & pkn+*(i,m) in dom (F.m) & (pkn+*(i,m))^<*(F.m)
        .(pkn+*(i,m))*> in dom f2;

        then F.(m+1) = (F.m)+*(pkn+*(i,m+1).--> f2.((pkn+*(i,m))^<*(F.m).(pkn
        +*(i,m))*>)) by A9;

        then
        dom (F.(m+1)) = dom (F.m) \/ dom ({pkn+*(i,m+1)}--> f2.((pkn+*(i,
        m))^<*(F.m).(pkn+*(i,m))*>)) by FUNCT_4:def 1;

        then
A18:    dom (F.(m+1)) = dom (F.m) \/ {pkn+*(i,m+1)} by FUNCOP_1:19;
        k <= k+n by NAT_1:11;
        then
A19:    k <> m+1 by NAT_1:13;
A20:    pk.i = k by A1,FUNCT_7:33;
        (pkn+*(i,m+1)).i = m+1 by A1,A10,FUNCT_7:33;
        then not pk in {pkn+*(i,m+1)} by A19,A20,TARSKI:def 1;
        hence thesis by A11,A17,A18,XBOOLE_0:def 3;
      end;
      suppose

        not i in dom pkn or not pkn+*(i,m) in dom (F.m) or not (pkn+*
        (i,m))^<*(F.m).(pkn+*(i,m))*> in dom f2;

        hence thesis by A9,A11,A17;
      end;
    end;
A21: p[0];
    thus for n being Element of NAT holds p[n] from NAT_1:sch 1(A21, A3);
  end;
end;

Lm6: i in dom p implies (p+*(i,0) in dom primrec(f1,f2,i) iff Del(p,i) in dom
f1) & (p+*(i,0) in dom primrec(f1,f2,i) implies primrec(f1,f2,i).(p+*(i,0)) =
f1.Del(p,i)) & (p+*(i,m+1) in dom primrec(f1,f2,i) iff p+*(i,m) in dom primrec(
f1,f2,i) & (p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*> in dom f2) & (p+*(i,m+1)
in dom primrec(f1,f2,i) implies primrec(f1,f2,i).(p+*(i,m+1)) = f2.((p+*(i,m))^
<*primrec(f1,f2,i).(p+*(i,m))*>))

proof
  set p0 = p+*(i,0);

  consider G being Function of (arity f1+1)-tuples_on NAT, HFuncs NAT such
  that

A1: primrec(f1,f2,i) = Union G and

A2: for p being Element of (arity f1+1)-tuples_on NAT holds G.p =
  primrec(f1,f2,i,p) by Def14;
  reconsider rngG = rng G as functional compatible set by A1,Th14;
  assume
A4: i in dom p;
A5: now
    let k be Element of NAT such that
A6: p+*(i,k) in dom primrec(f1,f2,i) and
A7: not p+*(i,k) in dom (G.((p+*(i,k))));
    union rngG <> {} by A1,A6;
    then reconsider rngG = rng G as non empty functional compatible set;
    set pk = p+*(i,k);

    dom union rngG = union {dom f where f is Element of rngG : not
    contradiction} by Th15;

    then consider X being set such that
A8: pk in X and

A9: X in {dom f where f is Element of rngG: not contradiction} by A1,A6,
TARSKI:def 4;

    consider f being Element of rngG such that
A10: X = dom f and
    not contradiction by A9;
    consider pp being set such that
A11: pp in dom G and
A12: f = G.pp by FUNCT_1:def 5;
    reconsider pp as Element of (arity f1+1)-tuples_on NAT by A11;
    G.pp = primrec(f1,f2,i,pp) by A2;

    then
A13: ex m being Element of NAT st pk = pp+*(i,m) by A8,A10,A12,Th53;

    set ppi = pp.i;
A14: p+*(i,ppi) = pk+*(i,ppi) by FUNCT_7:36
      .= pp+*(i,ppi) by A13,FUNCT_7:36
      .= pp by FUNCT_7:37;
    per cases by XXREAL_0:1;
    suppose
      k = ppi;
      hence contradiction by A7,A8,A10,A12,A14;
    end;
    suppose
      ppi < k;
      then consider m being Nat such that
A15:  k = ppi+m by NAT_1:10;
      reconsider m as Element of NAT by ORDINAL1:def 13;
      k = ppi+m by A15;
      then dom (G.pp) c= dom (G.pk) by A4,A2,A14,Lm4;
      hence contradiction by A7,A8,A10,A12;
    end;
    suppose
      ppi > k;
      then consider m being Nat such that
A16:  ppi=k+m by NAT_1:10;
      reconsider m as Element of NAT by ORDINAL1:def 13;
      ppi=k+m by A16;
      hence contradiction by A4,A2,A7,A8,A10,A12,A14,Lm5;
    end;
  end;
A17: dom p = dom p0 by FUNCT_7:32;
A18: now
A19: p0 in {p0} by TARSKI:def 1;
A20: p0/.i = p0.i by A4,A17,PARTFUN1:def 8
      .= 0 by A4,FUNCT_7:33;
    consider F being Function of NAT, HFuncs NAT such that
A21: primrec(f1,f2,i,p0)= F.(p0/.i) and

A22: i in dom p0 & Del(p0,i) in dom f1 implies F.0 = p0+*(i,0) .--> (
    f1.Del(p0,i)) and
A23: not i in dom p0 or not Del(p0,i) in dom f1 implies F.0 = {} and

    for m being Element of NAT holds Q[m, F.m qua Element of HFuncs NAT ,
    F.(m+1)qua Element of HFuncs NAT, p0, i, f2] by Def13;

A24: G.p0 = primrec(f1,f2,i,p0) by A2;
    thus p0 in dom (G.p0) iff Del(p,i) in dom f1
    proof

      thus p0 in dom (G.p0) implies Del(p,i) in dom f1 by A2,A21,A23,A20,Th6,
RELAT_1:60;

      assume
      Del(p,i) in dom f1;
      then dom (F.0) = {p0+*(i,0)} by A4,A22,Th6,FUNCOP_1:19,FUNCT_7:32
        .= { p0} by FUNCT_7:36;
      hence thesis by A24,A21,A20,TARSKI:def 1;
    end;
    assume
    p0 in dom (G.p0);

    then F.0 = {p0} --> (f1.Del(p0,i)) by A2,A21,A22,A23,A20,FUNCT_7:36
,RELAT_1:60;

    then F.0 = {p0} --> (f1.Del(p,i)) by Th6;
    hence (G.p0).p0 = f1.Del(p,i) by A24,A21,A20,A19,FUNCOP_1:13;
  end;
  set pm1 = p+*(i,m+1), pm = p+*(i,m), pc = <*(G.pm1).(pm1+*(i,m))*>;
A25: dom G = (arity f1+1)-tuples_on NAT by FUNCT_2:def 1;
  then
A26: G.pm1 in rng G by FUNCT_1:def 5;
  reconsider rngG as non empty functional compatible set;
A27: G.p0 in rng G by A25,FUNCT_1:def 5;
  thus p+*(i,0) in dom primrec(f1,f2,i) iff Del(p,i) in dom f1
  proof

    thus p+*(i,0) in dom primrec(f1,f2,i) implies Del(p,i) in dom f1 by A5,A18;

    assume
A28: Del(p,i) in dom f1;

    dom (G.p0) in {dom f where f is Element of rngG:not contradiction} by A27;

    then p0 in union {dom f where f is Element of rngG: not contradiction} by
A18,A28,TARSKI:def 4;

    hence thesis by A1,Th15;
  end;
  hereby
    assume
A29: p+*(i,0) in dom primrec(f1,f2,i);
    then p0 in dom (G.p0) by A5;
    then (union rngG).p0 = (G.p0).p0 by A27,Th16;

    hence primrec(f1,f2,i).(p+*(i,0)) = f1.Del(p,i) by A1,A5,A18,A29;

  end;
A30: dom p = dom pm1 by FUNCT_7:32;
A31: pm1+*(i,m+1) = pm1 by FUNCT_7:36;
A32: pm1+*(i,m) = pm by FUNCT_7:36;
A33: dom p = dom pm by FUNCT_7:32;
A34: now
A35: pm/.i = pm.i by A4,A33,PARTFUN1:def 8
      .= m by A4,FUNCT_7:33;
    consider F being Function of NAT, HFuncs NAT such that
A36: primrec(f1,f2,i,pm)= F.(pm/.i) and

A37: i in dom pm & Del(pm,i) in dom f1 implies F.0 = pm+*(i,0) .--> (
    f1.Del (pm,i)) and
A38: not i in dom pm or not Del(pm,i) in dom f1 implies F.0 = {} and

A39: for M being Element of NAT holds Q[M, F.M qua Element of HFuncs
    NAT, F.(M+1) qua Element of HFuncs NAT, pm, i, f2] by Def13;

A40: G.pm1 = primrec(f1,f2,i,pm1) by A2;
    consider F1 being Function of NAT, HFuncs NAT such that
A41: primrec(f1,f2,i,pm1)= F1.(pm1/.i) and

A42: i in dom pm1 & Del(pm1,i) in dom f1 implies F1.0 = pm1+*(i,0)
    .--> (f1 .Del(pm1,i)) and
A43: not i in dom pm1 or not Del(pm1,i) in dom f1 implies F1.0 = {} and

A44: for M being Element of NAT holds Q[M, F1.M qua Element of HFuncs
    NAT, F1.(M+1) qua Element of HFuncs NAT, pm1, i, f2] by Def13;

A45: F1.(m+1).pm = F1.m.pm by A4,A42,A43,A44,Lm3;
A46: pm1 in {pm1} by TARSKI:def 1;
    then
A47: pm1 in dom ({pm1}--> f2.((pm)^<*(F1.m).pm*>)) by FUNCOP_1:19;
A48: G.pm = primrec(f1,f2,i,pm) by A2;
A49: pm1/.i = pm1.i by A4,A30,PARTFUN1:def 8
      .= m+1 by A4,FUNCT_7:33;
A50: F1.m = F.m by A42,A43,A44,A37,A38,A39,Lm2;
A51: not pm1 in dom (F1.m) by A4,A42,A43,A44,Lm3;
    thus
A52: pm1 in dom (G.pm1) iff pm in dom (G.pm) & pm^pc in dom f2
    proof
      hereby
        assume
A53:    pm1 in dom (G.pm1);
        then
A54:    pm1 in dom (F1.(m+1)) by A2,A41,A49;
        assume
A55:    not (pm in dom (G.pm) & pm^pc in dom f2);
        per cases by A55;
        suppose
          not pm in dom (G.pm);
          then not pm in dom (F1.m) by A2,A36,A35,A50;
          hence contradiction by A32,A44,A51,A54;
        end;
        suppose
          not pm^pc in dom f2;
          hence contradiction by A32,A40,A41,A44,A49,A45,A51,A53;
        end;
      end;
      assume that
A56:  pm in dom (G.pm) and
A57:  pm^pc in dom f2;
      pm1 in {pm1} by TARSKI:def 1;
      then pm1 in dom ({pm1}--> f2.((pm)^<*(F1.m).pm*>)) by FUNCOP_1:19;

      then
A58:  pm1 in dom (F1.m) \/ dom ({pm1}--> f2.((pm)^<*(F1.m).pm*>)) by
XBOOLE_0:def 3;

      F1.(m+1) = (F1.m)+*(pm1.--> f2.((pm)^<*(F1.m).pm*>)) by A4,A30,A32,A31
,A40,A48,A41,A44,A36,A49,A35,A50,A45,A56,A57;

      hence thesis by A40,A41,A49,A58,FUNCT_4:def 1;
    end;
    assume
A59: pm1 in dom (G.pm1);
    then pm^<*(F1.m).pm*> in dom f2 by A32,A40,A41,A44,A49,A52;

    then F1.(m+1) = (F1.m)+*(pm1.--> f2.((pm)^<*(F1.m).pm*>)) by A4,A30,A32,A31
,A48,A44,A36,A35,A50,A52,A59;

    hence G.(pm1).pm1 = ({pm1}-->f2.((pm)^<*(F1.m).pm*>)).pm1 by A40,A41,A49
,A47,FUNCT_4:14

      .= f2.(pm^pc) by A32,A40,A41,A49,A45,A46,FUNCOP_1:13;
  end;

  thus p+*(i,m+1) in dom primrec(f1,f2,i) iff p+*(i,m) in dom primrec(f1,f2,i
  ) & (p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*> in dom f2

  proof
    hereby
      assume
A60:  p+*(i,m+1) in dom primrec(f1,f2,i);
      G.pm in rng G by A25,FUNCT_1:def 5;

      then dom (G.pm) in {dom f where f is Element of rngG: not contradiction
      };

      then pm in union {dom f where f is Element of rngG: not contradiction}
      by A5,A34,A60,TARSKI:def 4;

      hence p+*(i,m) in dom primrec(f1,f2,i) by A1,Th15;
A61:  G.pm1 in rng G by A25,FUNCT_1:def 5;
      dom (G.pm) c= dom (G.pm1) by A4,A2,Lm4;
      then (union rngG).pm = (G.pm1).pm by A5,A34,A60,A61,Th16;

      hence (p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*> in dom f2
       by A1,A5,A34,A60,FUNCT_7:36;

    end;
    assume that
A62: p+*(i,m) in dom primrec(f1,f2,i) and
A63: (p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*> in dom f2;
A64: G.pm1 in rng G by A25,FUNCT_1:def 5;
    G.pm1 in rng G by A25,FUNCT_1:def 5;

    then
A65: dom (G.pm1)in {dom f where f is Element of rngG: not contradiction };

A66: dom (G.pm) c= dom (G.pm1) by A4,A2,Lm4;
    pm in dom (G.pm) by A5,A62;

    then pm1 in union {dom f where f is Element of rngG: not contradiction}
    by A1,A32,A34,A63,A65,A64,A66,Th16,TARSKI:def 4;

    hence thesis by A1,Th15;
  end;
  assume
A67: p+*(i,m+1) in dom primrec(f1,f2,i);
A68: dom (G.pm) c= dom (G.pm1) by A4,A2,Lm4;
  then
A69: (union rngG).pm1 = (G.pm1).pm1 by A5,A67,A26,Th16;
  (union rngG).pm = (G.pm1).pm by A5,A34,A67,A26,A68,Th16;
  hence thesis by A1,A5,A34,A67,A69,FUNCT_7:36;
end;

theorem
  i in dom p implies (p+*(i,0) in dom primrec(f1,f2,i) iff Del(p,i) in
  dom f1 ) by Lm6;

theorem
  i in dom p & p+*(i,0) in dom primrec(f1,f2,i) implies primrec(f1,f2,i)
  .(p+*(i,0)) = f1.Del(p,i) by Lm6;

theorem Th64:
  i in dom p & f1 is len-total implies primrec(f1,f2,i).(p+*(i,0))
  = f1.Del(p,i)
proof
  assume that
A1: i in dom p and
A2: f1 is len-total;
A3: Del(p,i) is FinSequence of NAT by FINSEQ_3:114;
  len p = arity f1+1 by FINSEQ_1:def 18;
  then len Del(p,i) = arity f1 by A1,FINSEQ_3:118;
  then
A4: Del(p,i) is Element of (arity f1)-tuples_on NAT by A3,FINSEQ_2:110;
  dom f1 = (arity f1)-tuples_on NAT by A2,Th26;
  then p+*(i,0) in dom primrec(f1,f2,i) by A1,A4,Lm6;
  hence thesis by A1,Lm6;
end;

theorem
  i in dom p implies (p+*(i,m+1) in dom primrec(f1,f2,i) iff p+*(i,m) in
dom primrec(f1,f2,i) & (p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*> in dom f2)
by Lm6;

theorem
  i in dom p & p+*(i,m+1) in dom primrec(f1,f2,i) implies primrec(f1,f2,
  i).(p+*(i,m+1)) = f2.((p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*>) by Lm6;

theorem Th67:
  f1 is len-total & f2 is len-total & arity f1 +2 = arity f2 & 1
<= i & i <= 1+arity f1 implies primrec(f1,f2,i).(p+*(i,m+1)) = f2.((p+*(i,m))^
  <*primrec(f1,f2,i).(p+*(i,m))*>)
proof
  assume that
A1: f1 is len-total and
A2: f2 is len-total and
A3: arity f1 +2 = arity f2 and
A4: 1 <= i and
A5: i <= 1+arity f1;
  len p = arity f1 +1 by FINSEQ_1:def 18;
  then
A6: i in dom p by A4,A5,FINSEQ_3:27;
  (p+*(i,m+1)) in (arity f1 +1)-tuples_on NAT;
  then (p+*(i,m+1)) in dom primrec(f1,f2,i) by A1,A2,A3,A4,A5,Th61;
  hence thesis by A6,Lm6;
end;

theorem Th68:
  arity f1+2 = arity f2 & 1 <= i & i <= arity f1+1 implies primrec
  (f1,f2,i) is_primitive-recursively_expressed_by f1,f2,i
proof
  assume that
A1: arity f1+2 = arity f2 and
A2: 1 <= i and
A3: i <= arity f1+1;
  take n = arity f1+1;
  set g = primrec(f1,f2,i);
  thus dom g c= n-tuples_on NAT by Th60;
  thus i >= 1 & i <= n by A2,A3;
  thus arity f1+1 = n;
  thus n+1 = arity f2 by A1;
  let p be FinSequence of NAT;
  assume
A4: len p = n;
  then
A5: i in dom p by A2,A3,FINSEQ_3:27;
A6: p is Element of n-tuples_on NAT by A4,FINSEQ_2:110;
  hence p+*(i,0) in dom g iff Del(p,i) in dom f1 by A5,Lm6;
  thus p+*(i,0) in dom g implies g.(p+*(i,0)) = f1.Del(p,i) by A6,A5,Lm6;
  let m be Element of NAT;
  thus p+*(i,m+1) in dom g iff p+*(i,m) in dom g & (p+*(i,m))^<*g.(p+*(i,m))*>
  in dom f2 by A6,A5,Lm6;
  thus p+*(i,m+1) in dom g implies g.(p+*(i,m+1)) = f2.((p+*(i,m))^<*g.(p+*(i,
  m))*>) by A6,A5,Lm6;
end;

theorem
  1 <= i & i <= arity f1+1 implies for g being Element of HFuncs NAT st
  g is_primitive-recursively_expressed_by f1,f2,i holds g = primrec(f1,f2,i)
proof
  assume that
A1: i >= 1 and
A2: i <= arity f1+1;
  let g be Element of HFuncs NAT;
  set n = arity f1+1, h = primrec(f1,f2,i);
  given n9 being Element of NAT such that
A3: dom g c= n9-tuples_on NAT and
  i >= 1 and
  i <= n9 and
A4: (arity f1)+1 = n9 and
  n9+1 = arity f2 and
A5: for p being FinSequence of NAT st len p = n9 holds (p+*(i,0) in dom
g iff Del(p,i) in dom f1) & (p+*(i,0) in dom g implies g.(p+*(i,0)) = f1.Del(p,
i)) & for n being Element of NAT holds (p+*(i,n+1) in dom g iff p+*(i,n) in dom
g & (p+*(i,n))^<*g.(p+*(i,n))*> in dom f2) & (p+*(i,n+1) in dom g implies g.(p
  +*(i,n+1)) = f2.((p+*(i,n))^<*g.(p+*(i,n))*>));
A6: now
    let p be Element of n-tuples_on NAT;
    defpred p[Element of NAT] means (p+*(i,$1) in dom g iff p+*(i,$1) in dom h
    ) & (p+*(i,$1) in dom g implies g.(p+*(i,$1)) = h.(p+*(i,$1)));
    set k = p/.i;
A7: p = p+*(i,k) by FUNCT_7:40;
A8: len p = n by FINSEQ_1:def 18;
    then
A9: i in dom p by A1,A2,FINSEQ_3:27;
A10: for m be Element of NAT st p[m] holds p[m+1]
    proof
      let m such that
A11:  p+*(i,m) in dom g iff p+*(i,m) in dom h and
A12:  p+*(i,m) in dom g implies g.(p+*(i,m)) = h.(p+*(i,m));
      p+*(i,m+1) in dom g iff p+*(i,m) in dom g & (p+*(i,m))^<*g.(p+*(i,m
      ))*> in dom f2 by A4,A5,A8;
      hence p+*(i,m+1) in dom g iff p+*(i,m+1) in dom h by A9,A11,A12,Lm6;
A13:  p+*(i,m+1) in dom h iff p+*(i,m) in dom h & (p+*(i,m))^<*h.(p+*(i,m
      ))*> in dom f2 by A9,Lm6;
      assume
A14:  p+*(i,m+1) in dom g;
      then g.(p+*(i,m+1)) = f2.((p+*(i,m))^<*g.(p+*(i,m))*>) by A4,A5,A8;
      hence thesis by A4,A5,A8,A9,A11,A12,A13,A14,Lm6;
    end;
A15: p+*(i,0) in dom h iff Del(p,i) in dom f1 by A9,Lm6;
    then
    p+*(i,0) in dom g implies g.(p+*(i,0)) = f1.Del(p,i) & h.(p+*(i,0)) =
    f1.Del(p,i) by A4,A5,A8,A9,Lm6;
    then
A16: p[0] by A4,A5,A8,A15;
    for m holds p[m] from NAT_1:sch 1(A16,A10);
    hence (p in dom g iff p in dom h) & (p in dom g implies g.p = h.p) by A7;
  end;
A17: dom h c= n-tuples_on NAT by Th60;
  then
A18: dom g = dom h by A3,A4,A6,SUBSET_1:8;
  then for x being set st x in dom h holds g.x = h.x by A17,A6;
  hence thesis by A18,FUNCT_1:9;
end;

begin :: The set of primitive recursive functions

definition
  let X be set;
  attr X is composition_closed means
  :Def15:
  for f being Element of HFuncs NAT
  , F being with_the_same_arity FinSequence of HFuncs NAT st f in X & arity f =
  len F & rng F c= X holds f*<:F:> in X;
  attr X is primitive-recursion_closed means
  :Def16:
  for g,f1,f2 being Element
  of HFuncs NAT, i being Element of NAT st g
is_primitive-recursively_expressed_by f1,f2,i & f1 in X & f2 in X holds g in X;
end;

definition
  let X be set;
  attr X is primitive-recursively_closed means
  :Def17:
  0 const 0 in X & 1 succ
1 in X & (for n,i being Element of NAT st 1 <= i & i <= n holds n proj i in X)
  & X is composition_closed & X is primitive-recursion_closed;
end;

theorem Th70:
  HFuncs NAT is primitive-recursively_closed
proof
  set X = HFuncs NAT;
  thus 0 const 0 in X & 1 succ 1 in X & for n,i being Element of NAT st 1<=i &
  i <= n holds n proj i in X by Th34,Th37,Th39;
  thus for f being Element of HFuncs NAT for F being with_the_same_arity
FinSequence of HFuncs NAT st f in X & arity f = len F & rng F c= X holds f*<:F
  :> in X by Th46;
  let g be Element of HFuncs NAT;
  thus thesis;
end;

registration
  cluster primitive-recursively_closed non empty Subset of HFuncs NAT;
  existence
  proof
    HFuncs NAT c= HFuncs NAT;
    then reconsider X = HFuncs NAT as non empty Subset of HFuncs NAT;
    take X;
    thus thesis by Th70;
  end;
end;

reserve P for primitive-recursively_closed non empty Subset of HFuncs NAT;

Lm7: for X being non empty set, n,i be Element of NAT st 1 <= i & i <= n for x
being Element of X for p being Element of n-tuples_on X holds p+*(i,x) in n
-tuples_on X;

theorem Th71:
  for g being Element of HFuncs NAT st e1 = {} & g
  is_primitive-recursively_expressed_by e1, e2, i holds g = {}
proof
  set f1 = e1, f2 = e2;
  let g be Element of HFuncs(NAT);
  assume
A1: f1 = {};
  assume
  g is_primitive-recursively_expressed_by f1, f2, i;
  then consider n being Element of NAT such that
A2: dom g c= n-tuples_on NAT and
  i >= 1 and
  i <= n and
  (arity f1)+1 = n and
  n+1 = arity f2 and
A3: for p being FinSequence of NAT st len p = n holds (p+*(i,0) in dom g
iff Del(p,i) in dom f1) & (p+*(i,0) in dom g implies g.(p+*(i,0)) = f1.Del(p,i)
) & for n being Element of NAT holds (p+*(i,n+1) in dom g iff p+*(i,n) in dom g
& (p+*(i,n))^<*g.(p+*(i,n))*> in dom f2) & (p+*(i,n+1) in dom g implies g.(p+*(
  i,n+1)) = f2.((p+*(i,n))^<*g.(p+*(i,n))*>)) by Def12;
A4: now
    let y be Element of n-tuples_on NAT;
    defpred p[Element of NAT] means not y+*(i,$1) in dom g;
A5: len y = n by FINSEQ_1:def 18;
    then
A6: for k being Element of NAT st p[k] holds p[k+1] by A3;
A7: p[0] by A1,A3,A5;
    thus for k being Element of NAT holds p[k] from NAT_1:sch 1(A7, A6);
  end;
  assume
  g <> {};
  then consider x being set such that
A8: x in dom g by XBOOLE_0:def 1;
  reconsider x as Element of n-tuples_on NAT by A2,A8;
  set xi = x.i;
  x = x+*(i,xi) by FUNCT_7:37;
  hence contradiction by A4,A8;
end;

theorem Th72:
  for g being Element of HFuncs(NAT), f1, f2 being quasi_total
  Element of HFuncs(NAT), i being Element of NAT st g
is_primitive-recursively_expressed_by f1, f2, i holds g is quasi_total & (f1 is
  non empty implies g is non empty)
proof
  let g be Element of HFuncs(NAT), f1, f2 be quasi_total Element of HFuncs(NAT
  ), i be Element of NAT;
  assume
A1: g is_primitive-recursively_expressed_by f1, f2, i;
  then consider n being Element of NAT such that
A2: dom g c= n-tuples_on NAT and
A3: i >= 1 and
A4: i <= n and
A5: (arity f1)+1 = n and
A6: n+1 = arity f2 and
A7: for p being FinSequence of NAT st len p = n holds (p+*(i,0) in dom g
iff Del(p,i) in dom f1) & (p+*(i,0) in dom g implies g.(p+*(i,0)) = f1.Del(p,i)
) & for n being Element of NAT holds (p+*(i,n+1) in dom g iff p+*(i,n) in dom g
& (p+*(i,n))^<*g.(p+*(i,n))*> in dom f2) & (p+*(i,n+1) in dom g implies g.(p+*(
  i,n+1)) = f2.((p+*(i,n))^<*g.(p+*(i,n))*>)) by Def12;
  reconsider f29 = f2 as non empty quasi_total Element of HFuncs(NAT) by A6
,Th21;
  per cases;
  suppose
    f1 is empty;
    hence thesis by A1,Th71;
  end;
  suppose
    f1 is non empty;
    then
A8: dom f1 = (arity f1)-tuples_on NAT by Th25;
A9: g is quasi_total
    proof
      let x, y be FinSequence of NAT such that
A10:  len x = len y and
A11:  x in dom g;
      defpred p[Element of NAT] means y+*(i,$1) in dom g;
A12:  len x = n by A2,A11,FINSEQ_1:def 18;
A13:  now
        let k be Element of NAT such that
A14:    p[k];
        reconsider gyk = g.(y+*(i,k)) as Element of NAT;
        reconsider gyik = <*gyk*> as FinSequence of NAT;
A15:    dom f29 = (arity f2)-tuples_on NAT by Th25;
        len ((y+*(i,k))^<*g.(y+*(i,k))*>) = len (y+*(i,k)) + len <*g.(y+*
        (i,k))*> by FINSEQ_1:35
          .= n+len <*g.(y+*(i,k))*> by A10,A12,FUNCT_7:99
          .= n+1 by FINSEQ_1:56;
        then (y+*(i,k))^<*g.(y+*(i,k))*> is Element of dom f2 by A6,A15,
FINSEQ_2:110;
        then (y+*(i,k))^<*g.(y+*(i,k))*> in dom f29;
        hence p[k+1] by A7,A10,A12,A14;
      end;
      y is Element of (len y)-tuples_on NAT by FINSEQ_2:110;
      then Del(y,i) in (arity f1)-tuples_on NAT by A3,A4,A5,A10,A12,Th12;
      then
A16:  p[0] by A7,A8,A10,A12;
      for k being Element of NAT holds p[k] from NAT_1:sch 1(A16, A13);
      then
A17:  y+*(i,y/.i) in dom g;
      i in dom y by A3,A4,A10,A12,FINSEQ_3:27;
      then y.i = y/.i by PARTFUN1:def 8;
      hence y in dom g by A17,FUNCT_7:37;
    end;
    consider pp being set such that
A18: pp in n-tuples_on NAT by XBOOLE_0:def 1;
    pp is Element of n-tuples_on NAT by A18;
    then reconsider p = pp as FinSequence of NAT;
A19: len p = n by A18,FINSEQ_1:def 18;
    Del(p,i) in (arity f1)-tuples_on NAT by A3,A4,A5,A18,Th12;
    hence thesis by A7,A19,A8,A9;
  end;
end;

theorem Th73:
  n const c in P
proof
  defpred p[Element of NAT] means 0 const $1 in P;
  defpred r[Element of NAT] means for c being Element of NAT holds $1 const c
  in P;
A1: P is composition_closed by Def17;
A2: for i be Element of NAT st p[i] holds p[i+1]
  proof
    reconsider 1succ1 = 1 succ 1 as quasi_total Element of HFuncs NAT by Th32;
    let i be Element of NAT;
A3: (1 succ 1) in P by Def17;
A4: <*>NAT is Element of 0-tuples_on NAT by FINSEQ_2:151;
    then
A5: (0 const i).{} = i by FUNCOP_1:13;
    reconsider 0consti = 0 const i as Element of HFuncs NAT by Th31;
    set F = <*0 const i*>;
    <*0consti*> is FinSequence of HFuncs NAT;
    then reconsider F as with_the_same_arity FinSequence of HFuncs NAT;
    assume
    0 const i in P;
    then
A6: {0 const i} c= P by ZFMISC_1:37;
A7: arity (1 succ 1) = 1 by Th38
      .= len F by FINSEQ_1:56;
A8: rng F = {0 const i} by FINSEQ_1:56;
    now
      let h be Element of HFuncs NAT;
      assume
      h in rng F;
      then h = 0 const i by A8,TARSKI:def 1;
      hence h is quasi_total by Th32;
    end;
    then reconsider
    g = (1succ1)*<:F:> as quasi_total Element of HFuncs NAT by A7,Th50;
A9: arity (0 const (i+1)) = 0 by Th35;
A10: (0 const (i+1)).{} = i+1 by A4,FUNCOP_1:13;
A11: dom (1 succ 1) = 1-tuples_on NAT by Def10;
A12: arity (0 const i) = 0 by Th35;
    then
A13: dom (0 const i) = 0 -tuples_on NAT by Th26;
    then
A14: <:F:>.{} = <*i*> by A4,A5,FUNCT_6:61;
    reconsider ii= <*i*> as Element of 1-tuples_on NAT by FINSEQ_2:151;
A15: dom <:<*0 const i*>:> = dom (0 const i) by FUNCT_6:61;
    then g.{} = (1 succ 1).(<:F:>.{}) by A4,A13,FUNCT_1:23;
    then
A16: g.{} = (ii/.1)+1 by A14,Def10
      .= i+1 by FINSEQ_4:25;
A17: dom (0 const i) = 0-tuples_on NAT by A12,Th26;
    then <:<*0 const i*>:>.{} = ii by A4,A5,FUNCT_6:61;
    then
A18: {} in dom g by A4,A15,A17,A11,FUNCT_1:21;
    0 const i in rng F by A8,TARSKI:def 1;
    then arity F = 0 by A12,Def7;
    then arity g = 0 by A18,Th48,RELAT_1:60;
    then 0 const (i+1) = (1 succ 1)*<:<*0 const i*>:> by A9,A10,A18,A16,Th52,
RELAT_1:60;
    hence thesis by A1,A6,A8,A3,A7,Def15;
  end;
A19: P is primitive-recursion_closed by Def17;
A20: now
    let n be Element of NAT such that
A21: r[n];
    thus r[n+1]
    proof
      let i be Element of NAT;
      set g=(n+1) const i, f1=n const i,j=n+1,f2=(n+2) proj (n+2);
A22:  dom g = (n+1)-tuples_on NAT by FUNCOP_1:19;
A23:  n+(1+1) = j+1;
      then 1 <= n+2 by NAT_1:11;
      then
A24:  f2 in P by Def17;
A25:  arity f2 = n+2 by Th41;
A26:  dom f2 = (n+2)-tuples_on NAT by Th40;
A27:  arity f1 = n by Th35;
A28:  dom f1 = n-tuples_on NAT by FUNCOP_1:19;
A29:  arity g = j by Th35;
A30:  g is_primitive-recursively_expressed_by f1,f2,n+1
      proof
        take m = arity g;
        thus dom g c= m-tuples_on NAT by Th24;
        thus j >= 1 & j <= m by Th35,NAT_1:11;
        thus (arity f1)+1 = m & m+1 = arity f2 by A27,A25,A23,Th35;
        let p be FinSequence of NAT;
        assume
        len p = m;
        then
A31:    p is Element of j-tuples_on NAT by A29,FINSEQ_2:110;
A32:    j >= 1 by NAT_1:11;
        hence p+*(j,0) in dom g implies Del(p,j) in dom f1 by A28,A31,Th12;
        thus Del(p,j) in dom f1 implies p+*(j,0) in dom g by A22,A31,A32,Lm7;
        f1.Del(p,j) = i by A31,A32,Th12,FUNCOP_1:13;
        hence p+*(j,0) in dom g implies g.(p+*(j,0)) = f1.Del(p,j) by A31,A32
,Lm7,FUNCOP_1:13;
        let m being Element of NAT;
A33:    p+*(j,m) in j-tuples_on NAT by A31,A32,Lm7;
        then
B34:    (p+*(j,m))^<*i*> is Tuple of n+2, NAT by A23,FINSEQ_2:127;
then
A34:    (p+*(j,m))^<*i*> is Element of (n+2)-tuples_on NAT by FINSEQ_2:151;
        hereby
          hereby
            assume
            p+*(j,m+1) in dom g;
            thus p+*(j,m) in dom g by A22,A31,A32,Lm7;
            g.(p+*(j,m)) = i by A31,A32,Lm7,FUNCOP_1:13;
            hence (p+*(j,m))^<*g.(p+*(j,m))*> in dom f2
             by A26,B34,FINSEQ_2:151;
          end;
          thus p+*(j,m) in dom g & (p+*(j,m))^<*g.(p+*(j,m))*> in dom f2
          implies p+*(j,m+1) in dom g by A22,A31,A32,Lm7;
        end;
        assume
        p+*(j,m+1) in dom g;
        len (p+*(j,m)) = j by A33,FINSEQ_1:def 18;
        then
A35:    ((p+*(j,m))^<*i*>).(j+1) = i by FINSEQ_1:59;
        thus g.(p+*(j,m+1)) = i by A31,A32,Lm7,FUNCOP_1:13
          .= f2.((p+*(j,m))^<*i*>) by A35,A34,Th42
          .= f2.((p+*(j,m))^<*g.(p+*(j,m))*>) by A31,A32,Lm7,FUNCOP_1:13;
      end;
A36:  f1 in P by A21;
      (n+1) const i is Element of HFuncs NAT by Th31;
      hence thesis by A19,A30,A36,A24,Def16;
    end;
  end;
A37: p[0] by Def17;
  for i being Element of NAT holds p[i] from NAT_1:sch 1(A37,A2);
  then
A38: r[0];
  for n holds r[n] from NAT_1:sch 1(A38,A20);
  hence thesis;
end;

theorem Th74:
  1 <= i & i <= n implies n succ i in P
proof
A1: 1 succ 1 in P by Def17;
A2: arity (1 succ 1) = 1 by Th38
    .= len <*n proj i*> by FINSEQ_1:56;
  reconsider nproji = n proj i as Element of HFuncs NAT by Th31;
  assume that
A3: 1 <= i and
A4: i <= n;
A5: <*nproji*> is with_the_same_arity FinSequence of HFuncs NAT;
  now
    rng (n proj i) = NAT by A3,A4,Th40;
    then
A6: rng <:<*n proj i*>:> = 1-tuples_on NAT by Th11;
    thus dom (n succ i) = n-tuples_on NAT by Def10;
A7: dom (n proj i) = n-tuples_on NAT by Th40;
    then
A8: dom <:<*n proj i*>:> = n-tuples_on NAT by FUNCT_6:61;
    dom (1 succ 1) = 1-tuples_on NAT by Def10;
    hence dom ((1 succ 1)*<:<*n proj i*>:>)=n-tuples_on NAT by A8,A6,RELAT_1:46
;
    let x be set;
    assume
    x in n-tuples_on NAT;
    then reconsider x9 = x as Element of n-tuples_on NAT;
    set xi = x9.i;
    len x9 = n by FINSEQ_1:def 18;
    then
A9: i in dom x9 by A3,A4,FINSEQ_3:27;
A10: (n succ i).x = (x9/.i)+1 by Def10
      .= xi+1 by A9,PARTFUN1:def 8;
    reconsider ii= <*xi*> as Element of 1-tuples_on NAT by FINSEQ_2:151;
    ((1 succ 1)*<:<*n proj i*>:>).x9 = (1 succ 1).(<:<*n proj i*>:>.x9)
    by A8,FUNCT_1:23
      .= (1 succ 1).<*(n proj i).x9*> by A7,FUNCT_6:61
      .= (1 succ 1).<*x9.i*> by Th42
      .= (ii/.1)+1 by Def10
      .= xi+1 by FINSEQ_4:25;
    hence (n succ i).x = ((1 succ 1)*<:<*n proj i*>:>).x by A10;
  end;
  then
A11: n succ i = (1 succ 1)*<:<*n proj i*>:> by FUNCT_1:9;
A12: rng <*n proj i*> c= P
  proof
    let x be set;
    assume
    x in rng <*n proj i*>;
    then x in {n proj i} by FINSEQ_1:56;
    then x = n proj i by TARSKI:def 1;
    hence thesis by A3,A4,Def17;
  end;
  P is composition_closed by Def17;
  hence thesis by A11,A1,A2,A12,A5,Def15;
end;

theorem Th75:
  {} in P
proof
  reconsider F = {} as with_the_same_arity Element of (HFuncs NAT)* by
FINSEQ_1:66;
  set f = 0 const 0;
A1: rng {} c= P by XBOOLE_1:2;
A2: arity f = 0 by Th35;
A3: P is composition_closed by Def17;
  f in P by Th73;
  then f*<:F:> in P by A2,A1,A3,Def15,CARD_1:47;
  hence thesis by FUNCT_6:60;
end;

theorem Th76:
  for f being Element of P, F being with_the_same_arity
  FinSequence of P st arity f = len F holds f*<:F:> in P
proof
  let f be Element of P, F being with_the_same_arity FinSequence of P;
  assume
A1: arity f = len F;
A2: rng F c= P by FINSEQ_1:def 4;
  per cases;
  suppose
    f is empty;
    then f*<:F:> = {};
    hence thesis by Th75;
  end;
  suppose
    f is non empty;
    then reconsider f9 = f as non empty Element of HFuncs NAT;
A3: P* c= (HFuncs NAT)* by FINSEQ_1:83;
    F in P* by FINSEQ_1:def 11;
    then reconsider F9 = F as with_the_same_arity Element of (HFuncs NAT)* by
A3;
    P is composition_closed by Def17;
    then f9*<:F9:> in P by A1,A2,Def15;
    hence thesis;
  end;
end;

theorem Th77:
  for f1,f2 being Element of P st arity f1+2 = arity f2 for i
  being Element of NAT st 1 <= i & i <= arity f1+1 holds primrec(f1,f2,i) in P
proof
  let f1,f2 be Element of P;
  assume
A1: arity f1+2 = arity f2;
  let i be Element of NAT;
  assume that
A2: 1 <= i and
A3: i <= arity f1+1;
A4: P is primitive-recursion_closed by Def17;
  per cases;
  suppose
    f1 is empty;
    then primrec(f1,f2,i) is empty by Th59;
    hence thesis by Th75;
  end;
  suppose
    f1 is non empty;
    then
    primrec(f1,f2,i) is_primitive-recursively_expressed_by f1,f2,i by A1,A2,A3
,Th21,Th68;
    hence thesis by A4,Def16;
  end;
end;

definition
  func PrimRec -> Subset of HFuncs(NAT) equals
  meet { R where R is Subset of
  HFuncs(NAT) : R is primitive-recursively_closed };
  coherence
  proof
    set S = { R where R is Subset of HFuncs(NAT) : R is
    primitive-recursively_closed };
    set T = meet S;
A1: {HFuncs(NAT)} c= bool HFuncs(NAT) by ZFMISC_1:80;
    HFuncs(NAT) in {HFuncs(NAT)} by TARSKI:def 1;
    then
A2: HFuncs(NAT) in S by A1,Th70;
    T c= HFuncs(NAT)
    proof
      let x be set;
      assume
      x in T;
      hence thesis by A2,SETFAM_1:def 1;
    end;
    hence thesis;
  end;
end;

theorem Th78:
  for X being Subset of HFuncs(NAT) st X is
  primitive-recursively_closed holds PrimRec c= X
proof
  let X be Subset of HFuncs(NAT);
  set S = { R where R is Subset of HFuncs(NAT) : R is
  primitive-recursively_closed };
  assume
  X is primitive-recursively_closed;
  then
A1: X in S;
  let x be set;
  assume
  x in PrimRec;
  hence thesis by A1,SETFAM_1:def 1;
end;

registration
  cluster PrimRec -> non empty primitive-recursively_closed;
  coherence
  proof
    set S = { R where R is Subset of HFuncs(NAT) : R is
    primitive-recursively_closed };
A1: {HFuncs(NAT)} c= bool HFuncs(NAT) by ZFMISC_1:80;
    HFuncs(NAT) in {HFuncs(NAT)} by TARSKI:def 1;
    then
A2: HFuncs(NAT) in S by A1,Th70;
A3: now
      let Y be set;
      assume
      Y in S;
      then ex R being Subset of HFuncs(NAT) st R = Y & R is
      primitive-recursively_closed;
      hence 0 const 0 in Y by Def17;
    end;
    hence PrimRec is non empty by A2,SETFAM_1:def 1;
    thus PrimRec is primitive-recursively_closed
    proof
      thus 0 const 0 in PrimRec by A2,A3,SETFAM_1:def 1;
      now
        let Y be set;
        assume
        Y in S;
        then ex R being Subset of HFuncs(NAT) st R = Y & R is
        primitive-recursively_closed;
        hence 1 succ 1 in Y by Def17;
      end;
      hence 1 succ 1 in PrimRec by A2,SETFAM_1:def 1;
      hereby
        let n, i be Element of NAT;
        assume that
A4:     1 <= i and
A5:     i <= n;
        now
          let Y be set;
          assume
          Y in S;
          then ex R being Subset of HFuncs(NAT) st R = Y & R is
          primitive-recursively_closed;
          hence n proj i in Y by A4,A5,Def17;
        end;
        hence n proj i in PrimRec by A2,SETFAM_1:def 1;
      end;
      hereby
        let f be Element of HFuncs NAT, F being with_the_same_arity
        FinSequence of HFuncs NAT such that
A6:     f in PrimRec and
A7:     arity f = len F and
A8:     rng F c= PrimRec;
        now
          let Y be set;
          assume
A9:       Y in S;
          then consider R being Subset of HFuncs(NAT) such that
A10:      R = Y and
A11:      R is primitive-recursively_closed;
A12:      R is composition_closed by A11,Def17;
A13:      PrimRec c= R by A9,A10,SETFAM_1:4;
          then rng F c= R by A8,XBOOLE_1:1;
          hence f*<:F:> in Y by A6,A7,A10,A12,A13,Def15;
        end;
        hence f*<:F:> in PrimRec by A2,SETFAM_1:def 1;
      end;
      hereby
        let g, f1, f2 be Element of HFuncs NAT, i being Element of NAT such
        that
A14:    g is_primitive-recursively_expressed_by f1,f2,i and
A15:    f1 in PrimRec and
A16:    f2 in PrimRec;
        now
          let Y be set;
          assume
A17:      Y in S;
          then consider R being Subset of HFuncs(NAT) such that
A18:      R = Y and
A19:      R is primitive-recursively_closed;
A20:      f2 in R by A16,A17,A18,SETFAM_1:def 1;
A21:      R is primitive-recursion_closed by A19,Def17;
          f1 in R by A15,A17,A18,SETFAM_1:def 1;
          hence g in Y by A14,A18,A21,A20,Def16;
        end;
        hence g in PrimRec by A2,SETFAM_1:def 1;
      end;
    end;
  end;
end;

registration
  cluster -> homogeneous Element of PrimRec;
  coherence;
end;

definition
  let x be set;
  attr x is primitive-recursive means
  :Def19:
  x in PrimRec;
end;

registration
  cluster primitive-recursive -> Relation-like Function-like set;
  coherence
  proof
    let x be set;
    assume
    x in PrimRec;
    hence thesis;
  end;
end;

registration
  cluster primitive-recursive -> homogeneous to-naturals NAT*-defined Relation;
  coherence
  proof
    let x be Relation;
    assume
    x in PrimRec;
    hence thesis;
  end;
end;

registration
  cluster -> primitive-recursive Element of PrimRec;
  coherence by Def19;
end;

registration
  cluster primitive-recursive Function;
  existence
  proof
    consider x being Element of PrimRec;
    take x;
    thus thesis;
  end;
  cluster primitive-recursive Element of HFuncs NAT;
  existence
  proof
    consider x being Element of PrimRec;
    take x;
    thus thesis;
  end;
end;

definition
  func initial-funcs -> Subset of HFuncs NAT equals
  {0 const 0, 1 succ 1} \/ {
  n proj i where n,i is Element of NAT: 1 <= i & i <= n};
  coherence
  proof
    set Q1 = {0 const 0, 1 succ 1}, Q2 = {n proj i where n,i is Element of NAT
    : 1 <= i & i <= n};
A1: Q2 c= HFuncs NAT
    proof
      let x be set;
      assume
      x in Q2;
      then ex n, i being Element of NAT st x = n proj i & 1 <= i & i <= n;
      hence thesis by Th39;
    end;
    Q1 c= HFuncs NAT
    proof
      let x be set;
      assume
      x in Q1;
      then x = 0 const 0 or x = 1 succ 1 by TARSKI:def 2;
      hence thesis by Th34,Th37;
    end;
    hence thesis by A1,XBOOLE_1:8;
  end;
  let Q be Subset of HFuncs NAT;
  func PR-closure Q -> Subset of HFuncs NAT equals
  Q \/ {g where g is Element
of HFuncs NAT: ex f1,f2 being Element of HFuncs NAT, i being Element of NAT st
  f1 in Q & f2 in Q & g is_primitive-recursively_expressed_by f1,f2,i};
  coherence
  proof
    set Q1 = {g where g is Element of HFuncs NAT: ex f1,f2 being Element of
    HFuncs NAT, i being Element of NAT st f1 in Q & f2 in Q & g
    is_primitive-recursively_expressed_by f1,f2,i};
    Q1 c= HFuncs NAT
    proof
      let x be set;
      assume
      x in Q1;
      then
      ex g being Element of HFuncs NAT st x = g & ex f1,f2 being Element
      of HFuncs NAT, i being Element of NAT st f1 in Q & f2 in Q & g
      is_primitive-recursively_expressed_by f1,f2,i;
      hence thesis;
    end;
    hence thesis by XBOOLE_1:8;
  end;
  func composition-closure Q -> Subset of HFuncs NAT equals
  Q \/ {f*<:F:>
  where f is Element of HFuncs NAT, F is with_the_same_arity Element of (HFuncs
  NAT)*: f in Q & arity f = len F & rng F c= Q};
  coherence
  proof
    set Q1 = {f*<:F:> where f is Element of HFuncs NAT, F is
with_the_same_arity Element of (HFuncs NAT)*: f in Q & arity f = len F & rng F
    c= Q};
    Q1 c= HFuncs NAT
    proof
      let x be set;
      assume
      x in Q1;
      then ex f being Element of HFuncs NAT , F being with_the_same_arity
Element of (HFuncs NAT)* st x = f*<:F:> & f in Q & arity f = len F & rng F
      c= Q;
      hence thesis by Th46;
    end;
    hence thesis by XBOOLE_1:8;
  end;
end;

definition
  func PrimRec-Approximation -> Function of NAT, bool HFuncs NAT means
  :Def23:
it.0 = initial-funcs & for m being Nat holds it.(m+1) = (PR-closure (it.m)) \/
  (composition-closure (it.m));
  existence
  proof
    deffunc f(set,Subset of HFuncs(NAT)) = (PR-closure $2) \/ (
    composition-closure $2);
    consider A being Function of NAT, bool HFuncs NAT such that
A1: A.0 = initial-funcs and
A2: for m being Nat holds A.(m+1) = f(m,A.m) from NAT_1:sch 12;
    take A;
    thus A.0 = initial-funcs by A1;
    let m being Nat;
    thus thesis by A2;
  end;
  uniqueness
  proof
    deffunc f(set,Subset of HFuncs(NAT)) = (PR-closure $2) \/ (
    composition-closure $2);
    let it1, it2 be Function of NAT, bool HFuncs NAT such that
A3: it1.0 = initial-funcs and
A4: for m being Nat holds it1.(m+1) = (PR-closure (it1.m)) \/ (
    composition-closure (it1.m)) and
A5: it2.0 = initial-funcs and
A6: for m being Nat holds it2.(m+1) = (PR-closure (it2.m)) \/ (
    composition-closure (it2.m));
A7: for m being Nat holds it1.(m+1) = f(m,it1.m) by A4;
A8: for m being Nat holds it2.(m+1) = f(m,it2.m) by A6;
A9: it2.0 = initial-funcs by A5;
A10: it1.0 = initial-funcs by A3;
    thus it1 = it2 from NAT_1:sch 16(A10,A7, A9,A8);
  end;
end;

theorem Th79:
  m <= n implies PrimRec-Approximation.m c= PrimRec-Approximation.
  n
proof
  set prd = PrimRec-Approximation;
  defpred p[Element of NAT] means m <= $1 implies prd.m c= prd.$1;
A1: for n be Element of NAT st p[n] holds p[n+1]
  proof
    let n be Element of NAT such that
A2: p[n] and
A3: m <= n+1;
    prd.(n+1) = (PR-closure (prd.n)) \/ (composition-closure (prd.n)) by Def23;
    then
A4: PR-closure (prd.n) c= prd.(n+1) by XBOOLE_1:7;
    prd.n c= PR-closure (prd.n) by XBOOLE_1:7;
    then
A5: prd.n c= prd.(n+1) by A4,XBOOLE_1:1;
    per cases by A3,XXREAL_0:1;
    suppose
      m < n+1;
      hence thesis by A2,A5,NAT_1:13,XBOOLE_1:1;
    end;
    suppose
      m = n+1;
      hence thesis;
    end;
  end;
A6: p[0];
  for n being Element of NAT holds p[n] from NAT_1:sch 1(A6,A1);
  hence thesis;
end;

theorem Th80:
  Union PrimRec-Approximation is primitive-recursively_closed
proof
  set PROJ = {n proj i where n,i is Element of NAT: 1 <= i & i <= n};
  set prd = PrimRec-Approximation;
  set UP = Union prd;
A1: dom prd = NAT by FUNCT_2:def 1;
A2: prd.0 = {0 const 0, 1 succ 1} \/ PROJ by Def23;
  0 const 0 in {0 const 0, 1 succ 1} by TARSKI:def 2;
  then 0 const 0 in prd.0 by A2,XBOOLE_0:def 3;
  hence 0 const 0 in UP by A1,CARD_5:10;
  1 succ 1 in {0 const 0, 1 succ 1} by TARSKI:def 2;
  then 1 succ 1 in prd.0 by A2,XBOOLE_0:def 3;
  hence 1 succ 1 in UP by A1,CARD_5:10;
  hereby
    let n,i being Element of NAT;
    assume that
A3: 1 <= i and
A4: i <= n;
    n proj i in PROJ by A3,A4;
    then n proj i in prd.0 by A2,XBOOLE_0:def 3;
    hence n proj i in UP by A1,CARD_5:10;
  end;
  hereby
    deffunc mcocl(Element of NAT) = {f*<:F:> where f is Element of HFuncs NAT,
F is with_the_same_arity Element of (HFuncs NAT)*: f in prd.$1 & arity f = len
    F & rng F c= prd.$1};
    let f be Element of HFuncs NAT, F be with_the_same_arity FinSequence of
    HFuncs NAT such that
A5: f in UP and
A6: arity f = len F and
A7: rng F c= UP;
    consider kf being set such that
A8: kf in dom prd and
A9: f in prd.kf by A5,CARD_5:10;
    reconsider kf as Element of NAT by A8;
    per cases;
    suppose
      arity f = 0;
      then F = {} by A6;
      then
A10:  rng F c= prd.kf by RELAT_1:60,XBOOLE_1:2;
      F is with_the_same_arity Element of (HFuncs NAT)* by FINSEQ_1:def 11;
      then f*<:F:> in mcocl(kf) by A6,A9,A10;
      then f*<:F:> in prd.kf \/ mcocl(kf) by XBOOLE_0:def 3;
      then f*<:F:> in PR-closure (prd.kf) \/ composition-closure(prd.kf) by
XBOOLE_0:def 3;
      then f*<:F:> in prd.(kf+1) by Def23;
      hence f*<:F:> in UP by A1,CARD_5:10;
    end;
    suppose
A11:  arity f <> 0;
      defpred B[set,set] means ex k being Element of NAT st F.$1 in prd.k & $2
      = k;
A12:  for x st x in Seg len F ex y being Element of NAT st B[x,y]
      proof
        let x be set;
        assume
        x in Seg len F;
        then x in dom F by FINSEQ_1:def 3;
        then F.x in rng F by FUNCT_1:def 5;
        then consider k being set such that
A13:    k in dom prd and
A14:    F.x in prd.k by A7,CARD_5:10;
        reconsider k as Element of NAT by A13;
        take k;
        take k1 = k;
        thus F.x in prd.k1 by A14;
        thus thesis;
      end;
      consider fKF being Function of Seg len F, NAT such that
A15:  for x being set st x in Seg len F holds B[x,fKF.x] from
      MONOID_1:sch 1(A12);
      set KF = rng fKF;
      reconsider KF as non empty finite Subset of NAT by A6,A11,RELAT_1:def 19;
      set K = max KF;
      set k = max(kf, K);
      reconsider k as Element of NAT by ORDINAL1:def 13;
A16:  dom fKF = Seg len F by FUNCT_2:def 1;
A17:  rng F c= prd.k
      proof
        let x be set;
A18:    K <= k by XXREAL_0:25;
        assume
        x in rng F;
        then consider d being set such that
A19:    d in dom F and
A20:    x = F.d by FUNCT_1:def 5;
A21:    d in Seg len F by A19,FINSEQ_1:def 3;
        then consider m being Element of NAT such that
A22:    F.d in prd.m and
A23:    fKF.d = m by A15;
        m in KF by A16,A21,A23,FUNCT_1:12;
        then m <= K by XXREAL_2:def 8;
        then prd.m c= prd.k by A18,Th79,XXREAL_0:2;
        hence thesis by A20,A22;
      end;
A24:  F is with_the_same_arity Element of (HFuncs NAT)* by FINSEQ_1:def 11;
      prd.kf c= prd.k by Th79,XXREAL_0:25;
      then f*<:F:> in mcocl(k) by A6,A9,A17,A24;
      then f*<:F:> in prd.k \/ mcocl(k) by XBOOLE_0:def 3;
      then f*<:F:> in PR-closure (prd.k) \/ composition-closure(prd.k) by
XBOOLE_0:def 3;
      then f*<:F:> in prd.(k+1) by Def23;
      hence f*<:F:> in UP by A1,CARD_5:10;
    end;
  end;
  deffunc mprcl(Element of NAT) = {g where g is Element of HFuncs NAT: ex f1,
f2 being Element of HFuncs NAT, i being Element of NAT st f1 in prd.$1 & f2 in
  prd.$1 & g is_primitive-recursively_expressed_by f1,f2,i};
  let g, f1, f2 be Element of HFuncs NAT, i being Element of NAT such that
A25: g is_primitive-recursively_expressed_by f1,f2,i and
A26: f1 in UP and
A27: f2 in UP;
  consider k2 being set such that
A28: k2 in dom prd and
A29: f2 in prd.k2 by A27,CARD_5:10;
  reconsider k2 as Element of NAT by A28;
  consider k1 being set such that
A30: k1 in dom prd and
A31: f1 in prd.k1 by A26,CARD_5:10;
  reconsider k1 as Element of NAT by A30;
  per cases;
  suppose
    k1 <= k2;
    then prd.k1 c= prd.k2 by Th79;
    then g in mprcl(k2) by A25,A31,A29;
    then g in prd.k2 \/ mprcl(k2) by XBOOLE_0:def 3;
    then g in PR-closure (prd.k2) \/ composition-closure(prd.k2) by
XBOOLE_0:def 3;
    then g in prd.(k2+1) by Def23;
    hence thesis by A1,CARD_5:10;
  end;
  suppose
    k2 <= k1;
    then prd.k2 c= prd.k1 by Th79;
    then g in mprcl(k1) by A25,A31,A29;
    then g in prd.k1 \/ mprcl(k1) by XBOOLE_0:def 3;
    then g in PR-closure (prd.k1) \/ composition-closure(prd.k1) by
XBOOLE_0:def 3;
    then g in prd.(k1+1) by Def23;
    hence thesis by A1,CARD_5:10;
  end;
end;

theorem Th81:
  PrimRec = Union PrimRec-Approximation
proof
  set prd = PrimRec-Approximation;
  defpred p[Element of NAT] means prd.$1 c= PrimRec;
A1: now
    let m being Element of NAT such that
A2: p[m];
    thus p[m+1]
    proof
      set mcocl = {f*<:F:> where f is Element of HFuncs NAT, F is
with_the_same_arity Element of (HFuncs NAT)*: f in prd.m & arity f = len F &
      rng F c= prd.m};
      set mprcl = {g where g is Element of HFuncs NAT: ex f1,f2 being Element
      of HFuncs NAT, i being Element of NAT st f1 in prd.m & f2 in prd.m & g
      is_primitive-recursively_expressed_by f1,f2,i};
      let x be set;
A3:   prd.(m+1) = (PR-closure (prd.m)) \/ (composition-closure (prd.m))
      by Def23;
      assume
A4:   x in prd.(m+1);
      per cases by A4,A3,XBOOLE_0:def 3;
      suppose
A5:     x in PR-closure (prd.m);
        thus thesis
        proof
          per cases by A5,XBOOLE_0:def 3;
          suppose
            x in prd.m;
            hence thesis by A2;
          end;
          suppose
A6:         x in mprcl;
A7:         PrimRec is primitive-recursion_closed by Def17;
            ex g being Element of HFuncs NAT st x = g & ex f1,f2 being
Element of HFuncs NAT, i being Element of NAT st f1 in prd.m & f2 in prd. m & g
            is_primitive-recursively_expressed_by f1,f2,i by A6;
            hence thesis by A2,A7,Def16;
          end;
        end;
      end;
      suppose
A8:     x in composition-closure (prd.m);
        thus thesis
        proof
          per cases by A8,XBOOLE_0:def 3;
          suppose
            x in prd.m;
            hence thesis by A2;
          end;
          suppose
A9:         x in mcocl;
A10:        PrimRec is composition_closed by Def17;
            consider f being Element of HFuncs NAT, F being
            with_the_same_arity Element of (HFuncs NAT)* such that
A11:        x = f*<:F:> and
A12:        f in prd.m and
A13:        arity f = len F and
A14:        rng F c= prd.m by A9;
            rng F c= PrimRec by A2,A14,XBOOLE_1:1;
            hence thesis by A2,A11,A12,A13,A10,Def15;
          end;
        end;
      end;
    end;
  end;
A15: p[0]
  proof
    let x be set;
    assume
A16: x in prd.0;
    prd.0 = {0 const 0, 1 succ 1} \/ {n proj i where n,i is Element of NAT
    : 1 <= i & i <= n} by Def23;
    then
A17: x in {0 const 0, 1 succ 1} or x in {n proj i where n,i is Element of
    NAT: 1 <= i & i <= n} by A16,XBOOLE_0:def 3;
    per cases by A17,TARSKI:def 2;
    suppose
      x = 0 const 0;
      hence thesis by Def17;
    end;
    suppose
      x = 1 succ 1;
      hence thesis by Def17;
    end;
    suppose
      x in {n proj i where n,i is Element of NAT: 1 <= i & i <= n};
      then ex n, i being Element of NAT st x = n proj i & 1 <= i & i <= n;
      hence thesis by Def17;
    end;
  end;
A18: for k being Element of NAT holds p[k] from NAT_1:sch 1(A15, A1);
A19: Union prd c= PrimRec
  proof
    let x be set;
    assume that
A20: x in Union prd and
A21: not x in PrimRec;
    consider X being set such that
A22: x in X and
A23: X in rng prd by A20,TARSKI:def 4;
    consider m being set such that
A24: m in dom prd and
A25: prd.m = X by A23,FUNCT_1:def 5;
    reconsider m as Element of NAT by A24;
    prd.m c= PrimRec by A18;
    hence contradiction by A21,A22,A25;
  end;
  PrimRec c= Union prd by Th78,Th80;
  hence thesis by A19,XBOOLE_0:def 10;
end;

theorem Th82:
  for f being Element of HFuncs(NAT) st f in PrimRec-Approximation
  .m holds f is quasi_total
proof
  defpred p[Element of NAT] means for f being Element of HFuncs(NAT) st f in
  PrimRec-Approximation.$1 holds f is quasi_total;
  set prd = PrimRec-Approximation;
A1: for m be Element of NAT st p[m] holds p[m+1]
  proof
    let m be Element of NAT;
    assume
A2: p[m];
    let f be Element of HFuncs(NAT);
    assume
    f in prd.(m+1);
    then
A3: f in (PR-closure (prd.m)) \/ (composition-closure (prd.m)) by Def23;
    per cases by A3,XBOOLE_0:def 3;
    suppose
A4:   f in (PR-closure (prd.m));
      thus f is quasi_total
      proof
        per cases by A4,XBOOLE_0:def 3;
        suppose
          f in prd.m;
          hence thesis by A2;
        end;
        suppose
          f in {g where g is Element of HFuncs NAT: ex f1,f2 being
Element of HFuncs NAT, i being Element of NAT st f1 in prd.m & f2 in prd.m & g
          is_primitive-recursively_expressed_by f1,f2,i};
          then consider g being Element of HFuncs NAT such that
A5:       f = g and
A6:       ex f1,f2 being Element of HFuncs NAT, i being Element of
NAT st f1 in prd.m & f2 in prd.m & g is_primitive-recursively_expressed_by f1,
          f2,i;
          consider f1, f2 being Element of HFuncs NAT, i being Element of NAT
          such that
A7:       f1 in prd.m and
A8:       f2 in prd.m and
A9:       g is_primitive-recursively_expressed_by f1,f2,i by A6;
A10:      f2 is quasi_total by A2,A8;
          f1 is quasi_total by A2,A7;
          hence thesis by A5,A9,A10,Th72;
        end;
      end;
    end;
    suppose
A11:  f in (composition-closure (prd.m));
      thus f is quasi_total
      proof
        per cases by A11,XBOOLE_0:def 3;
        suppose
          f in prd.m;
          hence thesis by A2;
        end;
        suppose
          f in {h*<:F:> where h is Element of HFuncs NAT, F is
with_the_same_arity Element of (HFuncs NAT)*: h in prd.m & arity h = len F &
          rng F c= prd.m};
          then consider
          h being Element of HFuncs NAT, F being with_the_same_arity
          Element of (HFuncs NAT)* such that
A12:      f = h*<:F:> and
A13:      h in prd.m and
A14:      arity h = len F and
A15:      rng F c= prd.m;
A16:      for h being Element of HFuncs NAT st h in rng F holds h is
          quasi_total by A2,A15;
          h is quasi_total by A2,A13;
          hence thesis by A12,A14,A16,Th50;
        end;
      end;
    end;
  end;
A17: p[0]
  proof
    let f be Element of HFuncs(NAT);
    assume
    f in prd.0;
    then f in initial-funcs by Def23;
    then
A18: f in {0 const 0, 1 succ 1} or f in {n proj i where n,i is Element of
    NAT: 1 <= i & i <= n} by XBOOLE_0:def 3;
    per cases by A18,TARSKI:def 2;
    suppose
      f = 0 const 0;
      hence thesis by Th32;
    end;
    suppose
      f = 1 succ 1;
      hence thesis by Th32;
    end;
    suppose
      f in {n proj i where n,i is Element of NAT: 1 <= i & i <= n};
      then ex n, i being Element of NAT st f = n proj i & 1 <= i & i <= n;
      hence thesis by Th32;
    end;
  end;
  for m being Element of NAT holds p[m] from NAT_1:sch 1(A17, A1);
  hence thesis;
end;

registration
  cluster -> quasi_total homogeneous Element of PrimRec;
  coherence
  proof
    set prd = PrimRec-Approximation;
    let f be Element of PrimRec;
    consider X being set such that
A1: f in X and
A2: X in rng prd by Th81,TARSKI:def 4;
    ex m being set st m in dom prd & prd.m = X by A2,FUNCT_1:def 5;
    hence thesis by A1,Th82;
  end;
end;

registration
  cluster primitive-recursive -> quasi_total Element of HFuncs NAT;
  coherence
  proof
    let f be Element of HFuncs NAT;
    assume
    f in PrimRec;
    hence thesis;
  end;
end;

registration
  cluster primitive-recursive -> len-total (NAT*-defined Function);
  coherence
  proof
    let x be NAT*-defined Function;
    assume
    x in PrimRec;
    then x is Element of PrimRec;
    hence thesis;
  end;
  cluster non empty Element of PrimRec;
  existence
  proof
    0 const 0 in PrimRec by Th73;
    hence thesis;
  end;
end;

begin :: Examples

definition
  let f be homogeneous Relation;
  attr f is nullary means
  :Def24:
  arity f = 0;
  attr f is unary means
  :Def25:
  arity f = 1;
  attr f is binary means
  :Def26:
  arity f = 2;
  attr f is ternary means
  :Def27:
  arity f = 3;
end;

registration
  cluster unary -> non empty (homogeneous Function);
  coherence
  proof
    let f be homogeneous Function;
    assume
    arity f = 1;
    then ex x being FinSequence st x in dom f by UNIALG_1:def 10;
    hence thesis;
  end;
  cluster binary -> non empty (homogeneous Function);
  coherence
  proof
    let f be homogeneous Function;
    assume
    arity f = 2;
    then ex x being FinSequence st x in dom f by UNIALG_1:def 10;
    hence thesis;
  end;
  cluster ternary -> non empty (homogeneous Function);
  coherence
  proof
    let f be homogeneous Function;
    assume
    arity f = 3;
    then ex x being FinSequence st x in dom f by UNIALG_1:def 10;
    hence thesis;
  end;
end;

registration
  cluster 1 proj 1 -> primitive-recursive;
  coherence
  proof
    1 proj 1 in PrimRec by Def17;
    hence thesis;
  end;
  cluster 2 proj 1 -> primitive-recursive;
  coherence
  proof
    2 proj 1 in PrimRec by Def17;
    hence thesis;
  end;
  cluster 2 proj 2 -> primitive-recursive;
  coherence
  proof
    2 proj 2 in PrimRec by Def17;
    hence thesis;
  end;
  cluster 1 succ 1 -> primitive-recursive;
  coherence
  proof
    1 succ 1 in PrimRec by Th74;
    hence thesis;
  end;
  cluster 3 succ 3 -> primitive-recursive;
  coherence
  proof
    3 succ 3 in PrimRec by Th74;
    hence thesis;
  end;
  let i be Element of NAT;
  cluster 0 const i -> nullary;
  coherence
  proof
    thus arity (0 const i) = 0 by Th35;
  end;
  cluster 1 const i -> unary;
  coherence
  proof
    thus arity (1 const i) = 1 by Th35;
  end;
  cluster 2 const i -> binary;
  coherence
  proof
    thus arity (2 const i) = 2 by Th35;
  end;
  cluster 3 const i -> ternary;
  coherence
  proof
    thus arity (3 const i) = 3 by Th35;
  end;
  cluster 1 proj i -> unary;
  coherence
  proof
    thus arity (1 proj i) = 1 by Th41;
  end;
  cluster 2 proj i -> binary;
  coherence
  proof
    thus arity (2 proj i) = 2 by Th41;
  end;
  cluster 3 proj i -> ternary;
  coherence
  proof
    thus arity (3 proj i) = 3 by Th41;
  end;
  cluster 1 succ i -> unary;
  coherence
  proof
    thus arity (1 succ i) = 1 by Th38;
  end;
  cluster 2 succ i -> binary;
  coherence
  proof
    thus arity (2 succ i) = 2 by Th38;
  end;
  cluster 3 succ i -> ternary;
  coherence
  proof
    thus arity (3 succ i) = 3 by Th38;
  end;
  let j be Element of NAT;
  cluster i const j -> primitive-recursive;
  coherence
  proof
    thus i const j in PrimRec by Th73;
  end;
end;

registration
  cluster nullary primitive-recursive non empty (homogeneous Function);
  existence by Def17;
  cluster unary primitive-recursive (homogeneous Function);
  existence by Def17;
  cluster binary primitive-recursive (homogeneous Function);
  existence
  proof
    take f=2 proj 1;
    thus f is binary;
    thus f in PrimRec by Def17;
  end;
  cluster ternary primitive-recursive (homogeneous Function);
  existence
  proof
    take f=3 proj 1;
    thus f is ternary;
    thus f in PrimRec by Def17;
  end;
end;

registration
  cluster non empty nullary len-total to-naturals (homogeneous NAT*-defined
    Function);
  existence
  proof
    0 const 0 is nullary;
    hence thesis;
  end;
  cluster non empty unary len-total to-naturals (homogeneous NAT*-defined
    Function);
  existence
  proof
    1 const 0 is unary;
    hence thesis;
  end;
  cluster non empty binary len-total to-naturals (homogeneous NAT*-defined
    Function);
  existence
  proof
    2 const 0 is binary;
    hence thesis;
  end;
  cluster non empty ternary len-total to-naturals (homogeneous NAT*-defined
    Function);
  existence
  proof
    3 const 0 is ternary;
    hence thesis;
  end;
end;

registration
  let f be nullary non empty (primitive-recursive Function);
  let g be binary (primitive-recursive Function);
  cluster primrec(f,g,1) -> primitive-recursive unary;
  coherence
  proof
A1: g in PrimRec by Def19;
A2: arity f = 0 by Def24;
    f is Element of PrimRec by Def19;
    then dom f = 0-tuples_on NAT by A2,Th25
      .= {<*>NAT} by FINSEQ_2:112;
    then
A3: {} in dom f by TARSKI:def 1;
A4: f in PrimRec by Def19;
A5: 1 <= 0+1;
    arity g = 0+2 by Def26;
    hence primrec(f,g,1) in PrimRec by A5,A2,A4,A1,Th77;
    reconsider ii= <*0*> as Element of 1-tuples_on NAT by FINSEQ_2:151;
    dom <*0*> = {1} by FINSEQ_1:4,55;
    then
A6: 1 in dom <*0*> by TARSKI:def 1;
    Del(<*0*>,1) = {} by WSIERP_1:26;
    then ii+*(1,0) in dom primrec(f,g,1) by A5,A2,A3,A6,Lm6;
    then
A7: <*0*> in dom primrec(f,g,1) by FUNCT_7:97;
    len <*0*> = 1 by FINSEQ_1:56;
    hence arity primrec(f,g,1) = 1 by A7,UNIALG_1:def 10;
  end;
end;

registration
  let f be unary (primitive-recursive Function);
  let g be ternary (primitive-recursive Function);
  cluster primrec(f,g,1) -> primitive-recursive binary;
  coherence
  proof
A1: g in PrimRec by Def19;
A2: 1 <= 1+1;
A3: arity g = 1+2 by Def27;
A4: arity f = 1 by Def25;
    f in PrimRec by Def19;
    hence primrec(f,g,1) in PrimRec by A2,A4,A3,A1,Th77;
    thus arity primrec(f,g,1) = 2 by A2,A4,A3,Th61;
  end;
  cluster primrec(f,g,2) -> primitive-recursive binary;
  coherence
  proof
A5: g in PrimRec by Def19;
A6: 2 <= 1+1;
A7: arity g = 1+2 by Def27;
A8: arity f = 1 by Def25;
    f in PrimRec by Def19;
    hence primrec(f,g,2) in PrimRec by A6,A8,A7,A5,Th77;
    thus arity primrec(f,g,2) = 2 by A6,A8,A7,Th61;
  end;
end;

theorem Th83:
  for f1 be unary len-total to-naturals (homogeneous NAT*-defined
Function), f2 be non empty to-naturals homogeneous NAT*-defined Function holds
  primrec(f1,f2,2).<*i,0*> = f1.<*i*>
proof
  let f1 be unary len-total to-naturals (homogeneous NAT*-defined Function),
  f2 be non empty to-naturals homogeneous NAT*-defined Function;
  arity f1 = 1 by Def25;
  then reconsider p = <*i,0*> as Element of (arity f1 +1)-tuples_on NAT by
FINSEQ_2:121;
  len p = 2 by FINSEQ_1:61;
  then
A1: 2 in dom p by FINSEQ_3:27;
  p+*(2,0) = p by Th3;
  hence primrec(f1,f2,2).<*i,0*> = f1.Del(p,2) by A1,Th64
    .= f1.<*i*> by WSIERP_1:26;
end;

theorem Th84:
  f1 is len-total & arity f1 = 0 implies primrec(f1,f2,1).<*0*> =
  f1.{}
proof
  assume that
A1: f1 is len-total and
A2: arity f1 = 0;
  reconsider p = <*0*> as Element of (arity f1 +1)-tuples_on NAT
  by A2,FINSEQ_2:151;
  len p = 1 by FINSEQ_1:56;
  then
A3: 1 in dom p by FINSEQ_3:27;
  p+*(1,0) = p by FUNCT_7:97;
  hence primrec(f1,f2,1).<*0*> = f1.Del(p,1) by A1,A3,Th64
    .= f1.{} by WSIERP_1:26;
end;

theorem Th85:
  for f1 being unary len-total to-naturals (homogeneous NAT*
  -defined Function), f2 being ternary len-total to-naturals (homogeneous NAT*
-defined Function) holds primrec(f1,f2,2).<*i,j+1*> = f2.<*i,j,primrec(f1,f2,2)
  .<*i,j*>*>
proof
  let f1 being unary len-total to-naturals (homogeneous NAT*-defined Function)
  , f2 being ternary len-total to-naturals (homogeneous NAT*-defined Function);
A1: arity f1 = 1 by Def25;
  then reconsider p = <*i,j*> as Element of (arity f1 +1)-tuples_on NAT by
FINSEQ_2:121;
A2: p+*(2,j+1) = <*i,j+1*> by Th3;
A3: p+*(2,j) = <*i,j*> by Th3;
  arity f1 +2 = arity f2 by A1,Def27;
  hence
  primrec(f1,f2,2).<*i,j+1*> = f2.((p+*(2,j))^<*primrec(f1,f2,2).(p+*(2,j
  ))*>) by A1,A2,Th67
    .= f2.<*i,j,primrec(f1,f2,2).<*i,j*>*> by A3,FINSEQ_1:60;
end;

theorem Th86:
  f1 is len-total & f2 is len-total & arity f1 = 0 & arity f2 = 2
  implies primrec(f1,f2,1).<*i+1*> = f2.<*i,primrec(f1,f2,1).<*i*>*>
proof
  assume that
A1: f1 is len-total and
A2: f2 is len-total and
A3: arity f1 = 0 and
A4: arity f2 = 2;
  reconsider p = <*i*> as Element of (arity f1 +1)-tuples_on NAT
   by A3,FINSEQ_2:151;
A5: p+*(1,i+1) = <*i+1*> by FUNCT_7:97;
A6: p+*(1,i) = <*i*> by FUNCT_7:97;
  arity f1 +2 = arity f2 by A3,A4;
  hence
  primrec(f1,f2,1).<*i+1*> = f2.((p+*(1,i))^<*primrec(f1,f2,1).(p+*(1,i))
  *>) by A1,A2,A3,A5,Th67
    .= f2.<*i,primrec(f1,f2,1).<*i*>*> by A6,FINSEQ_1:def 9;
end;

Lm8: now
  reconsider z3 = <*0,0,0*> as FinSequence of NAT;
  let g be quasi_total homogeneous non empty PartFunc of NAT*, NAT;
  set G = g*<:<*3 proj 1, 3 proj 3*>:>;
A1: rng G c= NAT by RELAT_1:def 19;
  assume
B2:  arity g = 2;
  then
A2: dom g = 2-tuples_on NAT by Th25;

  thus
A3: dom <:<*3 proj 1,3 proj 3*>:>=dom (3 proj 1)/\dom (3 proj 3) by FUNCT_6:62;

  hence
A4: dom <:<*3 proj 1, 3 proj 3*>:> = (3-tuples_on NAT) /\ dom (3 proj 3
  ) by Th40

    .= (3-tuples_on NAT) /\ (3-tuples_on NAT) by Th40
    .= (3-tuples_on NAT);
  now
    set f = <*3 proj 1, 3 proj 3*>;
    let x be set;
    set F = <:f:>;

A5: product rngs f = product <*rng (3 proj 1),rng (3 proj 3)*> by FUNCT_6:34

      .= product <*NAT, rng (3 proj 3)*> by Th40
      .=product <*NAT, NAT*> by Th40
      .= 2-tuples_on NAT by FUNCT_6:6;
    hereby
A6:   rng F c= product rngs f by FUNCT_6:49;
      assume
      x in rng F;
      hence x in dom g by A2,A5,A6;
    end;
    assume
    x in dom g;
    then x is Element of 2-tuples_on NAT by B2,Th25;
    then consider d1, d2 being Element of NAT such that
A7: x = <*d1, d2*> by FINSEQ_2:120;

    reconsider x9 = <*d1, 0, d2*> as Element of 3-tuples_on NAT by FINSEQ_2:124
;

    F.x9 = <*(3 proj 1).x9, (3 proj 3).x9*> by A3,A4,FUNCT_6:62
      .= <*x9.1, (3 proj 3).x9*> by Th42
      .= <*x9.1, x9.3*> by Th42
      .= <*d1, x9.3*> by FINSEQ_1:62
      .= x by A7,FINSEQ_1:62;
    hence x in rng F by A4,FUNCT_1:def 5;
  end;
  then rng <:<*3 proj 1, 3 proj 3*>:> = dom g by TARSKI:2;

  hence
A8: dom (g*<:<*3 proj 1, 3 proj 3*>:>) = 3-tuples_on NAT by A4,RELAT_1:46;

  then reconsider G as PartFunc of NAT*, NAT by A1,FINSEQ_2:162,RELSET_1:11;
  reconsider G as homogeneous PartFunc of NAT*, NAT by A8,UNIALG_1:def 1;
  take G;
  thus G = g*<:<*3 proj 1, 3 proj 3*>:>;
  G is Element of PFuncs(NAT* , NAT) by PARTFUN1:119;
  then G in HFuncs NAT;
  hence G is Element of HFuncs NAT;
  len z3 = 3 by FINSEQ_1:62;
  then
A11: z3 is Element of 3-tuples_on NAT by FINSEQ_2:110;

  for x being FinSequence st x in dom G holds 3 = len x by A8,FINSEQ_1:def 18;

  hence arity G = 3 by A11,A8,UNIALG_1:def 10;
  hence G is quasi_total non empty by A8,Th25;
end;

definition
  let g be Function;
  func (1,2)->(1,?,2) g -> Function equals
  g * <:<*3 proj 1, 3 proj 3*>:>;
  coherence;
end;

registration
  let g be to-naturals NAT*-defined Function;
  cluster (1,2)->(1,?,2) g -> to-naturals NAT*-defined;
  coherence
  proof
    set G = (1,2)->(1,?,2) g;
A1: (3-tuples_on NAT) c= NAT* by FINSEQ_2:162;
    dom <:<*3 proj 1, 3 proj 3*>:> = dom (3 proj 1) /\ dom (3 proj 3) by
FUNCT_6:62;
    then
A2: dom <:<*3 proj 1, 3 proj 3*>:> = (3-tuples_on NAT) /\ dom (3 proj 3)
    by Th40
      .= (3-tuples_on NAT)/\(3-tuples_on NAT) by Th40
      .= (3-tuples_on NAT);
    dom G c= dom <:<*3 proj 1, 3 proj 3*>:> by RELAT_1:44;
    then dom G c= NAT* by A2,A1,XBOOLE_1:1;
    hence thesis by RELAT_1:def 18;
  end;
end;

registration
  let g be homogeneous Function;
  cluster (1,2)->(1,?,2) g -> homogeneous;
  coherence
  proof
    set G = (1,2)->(1,?,2) g;
    dom <:<*3 proj 1, 3 proj 3*>:> = dom (3 proj 1) /\ dom (3 proj 3) by
FUNCT_6:62;
    then dom <:<*3 proj 1, 3 proj 3*>:> = (3-tuples_on NAT) /\ dom (3 proj 3)
    by Th40
      .= (3-tuples_on NAT)/\(3-tuples_on NAT) by Th40
      .=(3-tuples_on NAT);
    then dom G c= 3-tuples_on NAT by RELAT_1:44;
    hence dom G is with_common_domain;
  end;
end;

registration
  let g be binary len-total to-naturals (homogeneous NAT*-defined Function);
  cluster (1,2)->(1,?,2) g -> non empty ternary len-total;
  coherence
  proof
A1: g is quasi_total homogeneous non empty PartFunc of NAT*, NAT by Th20;
    arity g = 2 by Def26;
    then consider G being homogeneous PartFunc of NAT*, NAT such that
A2: G = g*<:<*3 proj 1, 3 proj 3*>:> and
    G is Element of HFuncs NAT and
A3: arity G = 3 and
A4: G is quasi_total non empty by A1,Lm8;
    reconsider G9 = G as quasi_total non empty homogeneous PartFunc of NAT*,
    NAT by A4;
    G9 is non empty ternary len-total to-naturals (homogeneous NAT*
    -defined Function) by A3,Def27;
    hence thesis by A2;
  end;
end;

theorem Th87:
  for f being binary len-total to-naturals (homogeneous NAT*
  -defined Function) holds ((1,2)->(1,?,2) f).<*i,j,k*> = f.<*i,k*>
proof
  let f be binary len-total to-naturals (homogeneous NAT*-defined Function);
  reconsider ff=f as quasi_total homogeneous non empty PartFunc of NAT*, NAT
  by Th20;
  reconsider ijk = <*i,j,k*> as Element of 3-tuples_on NAT by FINSEQ_2:124;
A1: arity ff = 2 by Def26;
  then
A2: dom <:<*3 proj 1, 3 proj 3*>:> = dom (3 proj 1) /\ dom (3 proj 3) by Lm8;
A3: dom <:<*3 proj 1, 3 proj 3*>:> = (3-tuples_on NAT) by A1,Lm8;
  dom (ff*<:<*3 proj 1, 3 proj 3*>:>) = 3-tuples_on NAT by A1,Lm8;
  hence ((1,2)->(1,?,2) f).<*i,j,k*> = f.(<:<*3 proj 1, 3 proj 3*>:>.ijk) by
FUNCT_1:22
    .= f.<*(3 proj 1).ijk, (3 proj 3).ijk*> by A2,A3,FUNCT_6:62
    .= f.<*ijk.1, (3 proj 3).ijk*> by Th42
    .= f.<*ijk.1, ijk.3*> by Th42
    .= f.<*i, ijk.3*> by FINSEQ_1:62
    .= f.<*i,k*> by FINSEQ_1:62;
end;

theorem Th88:
  for g being binary (primitive-recursive Function) holds
  (1,2)->(1,?,2) g in PrimRec
proof
A1: 3 proj 3 in PrimRec by Def17;
A2: 2-tuples_on PrimRec c= (PrimRec)* by FINSEQ_2:162;
  3 proj 1 in PrimRec by Def17;
  then <*3 proj 1, 3 proj 3*> in 2-tuples_on PrimRec by A1,FINSEQ_2:121;
  then reconsider F = <*3 proj 1, 3 proj 3*> as Element of (PrimRec)* by A2;
  F is with_the_same_arity
  proof
    let f,g be Function;
    assume that
A3: f in rng F and
A4: g in rng F;
A5: rng F = {3 proj 1, 3 proj 3} by FINSEQ_2:147;
    hence f is empty implies g is empty or dom g = {{}} by A3,TARSKI:def 2;
    assume that
    f is non empty and
    g is non empty;
    take 3, NAT;
    f = 3 proj 1 or f = 3 proj 3 by A3,A5,TARSKI:def 2;
    hence dom f c= 3-tuples_on NAT by Th40;
    g = 3 proj 1 or g = 3 proj 3 by A4,A5,TARSKI:def 2;
    hence thesis by Th40;
  end;
  then reconsider F as with_the_same_arity Element of (PrimRec)*;
  let g be binary (primitive-recursive Function);
  arity g = 2 by Def26;
  then
A6: arity g = len F by FINSEQ_1:61;
  g is Element of PrimRec by Def19;
  hence thesis by A6,Th76;
end;

registration
  let f be binary primitive-recursive (homogeneous Function);
  cluster (1,2)->(1,?,2) f -> primitive-recursive ternary;
  coherence
  proof
    thus (1,2)->(1,?,2) f in PrimRec by Th88;
    thus arity ((1,2)->(1,?,2) f) = 3 by Def27;
  end;
end;

definition
  func [+] -> binary (primitive-recursive Function) equals
  primrec(1 proj 1, 3
  succ 3, 2);
  coherence;
end;

theorem Th89:
  [+].<*i,j*> = i+j
proof
  reconsider q = <*i*> as Element of 1-tuples_on NAT by FINSEQ_2:151;
  defpred p[Element of NAT] means [+].<*i,$1*> = i+$1;
A1: now
    let j be Element of NAT;
    reconsider r = <*i,j,i+j*> as Element of 3-tuples_on NAT by FINSEQ_2:124;
    assume
    p[j];
    then [+].<*i,j+1*> = (3 succ 3).r by Th85
      .= (r/.3)+1 by Def10
      .= i+j+1 by FINSEQ_4:27
      .= i+(j+1);
    hence p[j+1];
  end;
  [+].<*i,0*> = (1 proj 1).q by Th83
    .= q.1 by Th42
    .= i+0 by FINSEQ_1:57;
  then
A2: p[0];
  for j being Element of NAT holds p[j] from NAT_1:sch 1(A2,A1);
  hence thesis;
end;

definition
  func [*] -> binary (primitive-recursive Function) equals
  primrec(1 const 0,
  (1,2)->(1,?,2) [+], 2);
  coherence;
end;

theorem Th90:
  for i, j being Element of NAT holds [*].<*i,j*> = i*j
proof
  let i be Element of NAT;
  defpred p[Element of NAT] means [*].<*i,$1*> = i*$1;
A1: now
    let j be Element of NAT;
    assume
    p[j];
    then [*].<*i,j+1*> = ((1,2)->(1,?,2) [+]).<*i,j,i*j*> by Th85
      .= [+].<*i,i*j*> by Th87
      .= (i*1)+i*j by Th89
      .= i*(j+1);
    hence p[j+1];
  end;
  reconsider ii = <*i*> as Element of 1-tuples_on NAT by FINSEQ_2:118;
  [*].<*i,0*> = (1 const 0).ii by Th83
    .= i*0 by FUNCOP_1:13;
  then
A2: p[0];
  thus for i be Element of NAT holds p[i] from NAT_1:sch 1(A2,A1);
end;

registration
  let g,h be binary primitive-recursive (homogeneous Function);
  cluster <*g,h*> -> with_the_same_arity;
  coherence
  proof
    reconsider g, h as Element of PrimRec by Def19;
A1: rng <*g,h*> = {g,h} by FINSEQ_2:147;
A2: now
      let f1,f2 be homogeneous Function;
      assume that
A3:   f1 in rng <*g,h*> and
A4:   f2 in rng <*g,h*>;
      f1 = g or f1 = h by A1,A3,TARSKI:def 2;
      then
A5:   arity f1 = 2 by Def26;
      f2 = g or f2 = h by A1,A4,TARSKI:def 2;
      hence arity f1 = arity f2 by A5,Def26;
    end;
    rng <*g,h*> c= PrimRec by FINSEQ_1:def 4;
    hence thesis by A2,Th33,XBOOLE_1:1;
  end;
end;

registration
  let f,g,h be binary (primitive-recursive Function);
  cluster f*<:<*g,h*>:> -> primitive-recursive;
  coherence
  proof
    reconsider g9 = g, h9 = h as Element of PrimRec by Def19;
A1: f in PrimRec by Def19;
A2: rng <*g9,h9*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g,h*> c= HFuncs NAT by XBOOLE_1:1;
    then reconsider
    F = <*g,h*> as with_the_same_arity FinSequence of HFuncs NAT by
FINSEQ_1:def 4;
A3: PrimRec is composition_closed by Def17;
A4: arity f = 2 by Def26;
    len F = 2 by FINSEQ_1:61;
    hence f*<:<*g,h*>:> in PrimRec by A2,A1,A3,A4,Def15;
  end;
end;

registration
  let f,g,h be binary (primitive-recursive Function);
  cluster f*<:<*g,h*>:> -> binary;
  coherence
  proof
    consider x being Element of 2-tuples_on NAT;
    reconsider f9 = f, fgh = f*<:<*g,h*>:>, g9 = g, h9 = h as Element of
    PrimRec by Def19;
A1: f9 = f;
    rng <*g9,h9*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g,h*> c= HFuncs NAT by XBOOLE_1:1;
    then reconsider
    F = <*g,h*> as with_the_same_arity FinSequence of HFuncs NAT by
FINSEQ_1:def 4;
A2: dom <:F:> = dom g /\ dom h by FUNCT_6:62;
A3: arity g = 2 by Def26;
    rng F = {g, h } by FINSEQ_2:147;
    then g in rng F by TARSKI:def 2;
    then
A4: arity F = 2 by A3,Def7;
    arity f = 2 by Def26;
    then
A5: dom f9 = 2-tuples_on NAT by Lm1;
    arity h = 2 by Def26;
    then
A6: dom h9 = 2-tuples_on NAT by Lm1;
A7: dom g9 = 2-tuples_on NAT by A3,Lm1;
    then <:F:>.x = <*g9.x,h9.x*> by A6,A2,FUNCT_6:62;
    then <:F:>.x is Element of 2-tuples_on NAT by FINSEQ_2:121;
    then fgh is non empty by A5,A7,A6,A2,FUNCT_1:21,RELAT_1:60;
    hence arity (f*<:<*g,h*>:>) = 2 by A1,A4,Th48;
  end;
end;

registration
  let f be unary (primitive-recursive Function);
  let g be primitive-recursive Function;
  cluster f*<:<*g*>:> -> primitive-recursive;
  coherence
  proof
    reconsider g9 = g as Element of PrimRec by Def19;
A1: f in PrimRec by Def19;
A2: rng <*g9*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g*> c= HFuncs NAT by XBOOLE_1:1;
    then reconsider
    F = <*g9*> as with_the_same_arity FinSequence of HFuncs NAT by
FINSEQ_1:def 4;
A3: PrimRec is composition_closed by Def17;
A4: arity f = 1 by Def25;
    len F = 1 by FINSEQ_1:56;
    hence f*<:<*g*>:> in PrimRec by A2,A1,A3,A4,Def15;
  end;
end;

registration
  let f be unary (primitive-recursive Function);
  let g be binary (primitive-recursive Function);
  cluster f*<:<*g*>:> -> binary;
  coherence
  proof
    consider x being Element of 2-tuples_on NAT;
    reconsider f9 = f, fg = f*<:<*g*>:>, g9 = g as Element of PrimRec by Def19;
A1: f9 = f;
    rng <*g9*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g*> c= HFuncs NAT by XBOOLE_1:1;
    then reconsider
    F = <*g9*> as with_the_same_arity FinSequence of HFuncs NAT by
FINSEQ_1:def 4;
A2: dom <:F:> = dom g by FUNCT_6:61;
    arity f = 1 by Def25;
    then
A3: dom f9 = 1-tuples_on NAT by Lm1;
A4: arity g = 2 by Def26;
    rng F = { g} by FINSEQ_1:56;
    then g in rng F by TARSKI:def 1;
    then
A5: arity F = 2 by A4,Def7;
A6: dom g9 = 2-tuples_on NAT by A4,Lm1;
    then <:F:>.x = <*g9.x*> by FUNCT_6:61;
    then <:F:>.x in 1-tuples_on NAT by FINSEQ_2:118;
    then fg is non empty by A6,A2,A3,FUNCT_1:21,RELAT_1:60;
    hence arity (f*<:<*g*>:>) = 2 by A1,A5,Th48;
  end;
end;

definition
  func [!] -> unary (primitive-recursive Function) equals
  primrec(0 const 1,
  [*]*<:<*(1 succ 1)*<:<*2 proj 1*>:>, 2 proj 2*>:>, 1);
  coherence;
end;

scheme
  Primrec1{F() -> unary len-total to-naturals (homogeneous NAT*-defined
  Function), G() -> binary len-total to-naturals (homogeneous NAT*-defined
  Function), f(set) -> Element of NAT, g(set,set) -> Element of NAT}: for i, j
  being Element of NAT holds (F()*<:<*G()*>:>).<*i,j*> = f(g(i,j))
provided
A1: for i being Element of NAT holds F().<*i*> = f(i) and
A2: for i,j being Element of NAT holds G().<*i,j*> = g(i,j)
proof
  let i, j be Element of NAT;
  arity G() = 2 by Def26;
  then
A3: dom G() = 2-tuples_on NAT by Th26;
  dom <:<*G()*>:> = dom G() by FUNCT_6:61;
  hence (F()*<:<*G()*>:>).<*i,j*> = F().(<:<*G()*>:>.<*i,j*>) by A3,
FINSEQ_2:121,FUNCT_1:23
    .= F().<*G().<*i,j*>*> by A3,FINSEQ_2:121,FUNCT_6:61
    .= F().<*g(i,j)*> by A2
    .= f(g(i,j)) by A1;
end;

scheme
  Primrec2{F,G,H() -> binary len-total to-naturals (homogeneous NAT*-defined
  Function), f,g,h(set,set) -> Element of NAT}: for i, j being Element of NAT
  holds (F()*<:<*G(),H()*>:>).<*i,j*> = f(g(i,j),h(i,j))
provided
A1: for i,j being Element of NAT holds F().<*i,j*> = f(i,j) and
A2: for i,j being Element of NAT holds G().<*i,j*> = g(i,j) and
A3: for i,j being Element of NAT holds H().<*i,j*> = h(i,j)
proof
  let i, j being Element of NAT;
  arity G() = 2 by Def26;
  then
A4: dom G() = 2-tuples_on NAT by Th26;
  arity H() = 2 by Def26;
  then
A5: dom H() = 2-tuples_on NAT by Th26;
A6: dom <:<*G(),H()*>:> = dom G() /\ dom H() by FUNCT_6:62;
  hence (F()*<:<*G(),H()*>:>).<*i,j*> = F().(<:<*G(),H()*>:>.<*i,j*>) by A4,A5,
FINSEQ_2:121,FUNCT_1:23
    .= F().<*G().<*i,j*>,H().<*i,j*>*> by A6,A4,A5,FINSEQ_2:121,FUNCT_6:62
    .= F().<*g(i,j),H().<*i,j*>*> by A2
    .= F().<*g(i,j),h(i,j)*> by A3
    .= f(g(i,j),h(i,j)) by A1;
end;

theorem
  [!].<*i*> = i!
proof
  defpred p[Element of NAT] means [!].<*$1*> = $1!;
  deffunc c(Element of NAT,Element of NAT) = $2;
  deffunc a(Element of NAT,Element of NAT) = $1*$2;
  deffunc g(Element of NAT,Element of NAT) = $1;
  deffunc f(Element of NAT) = $1+1;
  set g = [*]*<:<*(1 succ 1)*<:<*2 proj 1*>:>, 2 proj 2*>:>;
  deffunc b(Element of NAT,Element of NAT) = f(g($1,$2));
A1: for i,j being Element of NAT holds (2 proj 1).<*i,j*> = g(i,j)
  proof
    let i,j be Element of NAT;
    reconsider ij = <*i,j*> as Element of 2-tuples_on NAT by FINSEQ_2:121;
    thus (2 proj 1).<*i,j*> = ij.1 by Th42
      .= i by FINSEQ_1:61;
  end;
A2: for i being Element of NAT holds (1 succ 1).<*i*> = f(i)
  proof
    let i be Element of NAT;
   reconsider ij = <*i*> as Element of 1-tuples_on NAT by FINSEQ_2:151;
    thus (1 succ 1).<*i*> = ij/.1+1 by Def10
      .= i+1 by FINSEQ_4:25;
  end;
  for i, j being Element of NAT holds ((1 succ 1)*<:<*2 proj 1*>:>).<*i,j
  *> = f(g(i,j)) from Primrec1(A2,A1);
  then
A3: for i, j being Element of NAT holds ((1 succ 1)*<:<*2 proj 1*>:>).<*i,j
  *> = b (i,j);
A4: for i, j being Element of NAT holds (2 proj 2).<*i,j*> = c(i,j)
  proof
    let i,j be Element of NAT;
    reconsider ij = <*i,j*> as Element of 2-tuples_on NAT by FINSEQ_2:121;
    thus (2 proj 2).<*i,j*> = ij.2 by Th42
      .= j by FINSEQ_1:61;
  end;
A5: for i, j being Element of NAT holds [*].<*i,j*> = a(i,j) by Th90;
A6: for i, j being Element of NAT holds g.<*i,j*> = a(b(i,j),c(i,j)) from
  Primrec2(A5,A3,A4);
A7: arity (0 const 1) = 0 by Th35;
A8: arity g = 2 by Def26;
A9: now
    let i be Element of NAT;
    reconsider ie = i! as Element of NAT;
    assume
    p[i];
    then [!].<*i+1*> = g.<*i,ie*> by A8,A7,Th86
      .= (i+1)*ie by A6
      .= (i+1)! by NEWTON:21;
    hence p[i+1];
  end;
  0-tuples_on NAT = {{}} by Th8;
  then
A10: {} in 0-tuples_on NAT by TARSKI:def 1;
  [!].<*0*> = (0 const 1).{} by A7,Th84
    .= 0! by A10,FUNCOP_1:13,NEWTON:18;
  then
A11: p[0];
  for i being Element of NAT holds p[i] from NAT_1:sch 1(A11, A9);
  hence thesis;
end;

definition
  func [^] -> binary (primitive-recursive Function) equals
  primrec(1 const 1,
  (1,2)->(1,?,2) [*], 2);
  coherence;
end;

theorem
  [^].<*i,j*> = i |^ j
proof
  defpred p[Element of NAT] means [^].<*i,$1*> = i |^ $1;
A1: now
    let j be Element of NAT;
    reconsider ij = i|^j as Element of NAT;
    assume
    p[j];
    then [^].<*i,j+1*> = ((1,2)->(1,?,2) [*]).<*i,j,ij*> by Th85
      .= [*].<*i,ij*> by Th87
      .= i*ij by Th90
      .= i|^(j+1) by NEWTON:11;
    hence p[j+1];
  end;
  reconsider ii = <*i*> as Element of 1-tuples_on NAT by FINSEQ_2:151;
  [^].<*i,0*>=(1 const 1).ii by Th83
    .= 1 by FUNCOP_1:13
    .= i|^0 by NEWTON:9;
  then
A2: p[0];
  for j being Element of NAT holds p[j] from NAT_1:sch 1(A2,A1);
  hence thesis;
end;

definition
  func [pred] -> unary (primitive-recursive Function) equals
  primrec(0 const 0
  , 2 proj 1, 1);
  coherence;
end;

theorem Th93:
  [pred].<*0*> = 0 & [pred].<*i+1*> = i
proof
  0-tuples_on NAT = {{}} by Th8;
  then
A1: {} in 0-tuples_on NAT by TARSKI:def 1;
  defpred p[Element of NAT] means [pred].<*$1+1*> = $1;
  reconsider p0 = <*0, 0*> as Element of 2-tuples_on NAT by FINSEQ_2:121;
A2: arity (0 const 0) = 0 by Th35;
A3: arity (2 proj 1) = 2 by Th41;
A4: now
    let i be Element of NAT;
    reconsider p0 = <*i+1,i*> as Element of 2-tuples_on NAT by FINSEQ_2:121;
    assume
    p[i];
    then [pred].<*(i+1)+1*> = (2 proj 1).p0 by A2,A3,Th86
      .= <*i+1, i*>.1 by Th42
      .= i+1 by FINSEQ_1:61;
    hence p[i+1];
  end;
  thus [pred].<*0*> = (0 const 0).{} by A2,Th84
    .= 0 by A1,FUNCOP_1:13;
  then [pred].<*0+1*> = (2 proj 1).p0 by A2,A3,Th86
    .= <*0, 0*>.1 by Th42
    .= 0 by FINSEQ_1:61;
  then
A5: p[0];
  for i holds p[i] from NAT_1:sch 1(A5, A4);
  hence thesis;
end;

definition
  func [-] -> binary (primitive-recursive Function) equals
  primrec(1 proj 1,
  (1,2)->(1,?,2) ([pred]*<:<*2 proj 2*>:>), 2);
  coherence;
end;

theorem
  [-].<*i,j*> = i -' j
proof
  set F = <*2 proj 2*>;
  set g = [pred]*<:F:>;
  rng F c= PrimRec
  proof
    let x be set;
    assume
    x in rng F;
    then x in {2 proj 2} by FINSEQ_1:56;
    then x = 2 proj 2 by TARSKI:def 1;
    hence thesis by Def17;
  end;
  then reconsider F as with_the_same_arity FinSequence of PrimRec by
FINSEQ_1:def 4;
  defpred p[Element of NAT] means [-].<*i,$1*> = i -' $1;
A1: for i, j holds g.<*i,0*> = 0 & g.<*i,j+1*> = j
  proof
    let i, j;
    reconsider i0 = <*i,0*> as Element of 2-tuples_on NAT by FINSEQ_2:121;
    reconsider ij = <*i,j+1*> as Element of 2-tuples_on NAT by FINSEQ_2:121;
A2: dom (2 proj 2) = 2-tuples_on NAT by Th40;
A3: dom <:F:> = dom (2 proj 2) by FUNCT_6:61;
    hence g.<*i,0*> = [pred].(<:F:>.i0) by A2,FUNCT_1:23
      .= [pred].<*(2 proj 2).i0*> by A2,FUNCT_6:61
      .= [pred].<*i0.2*> by Th42
      .= 0 by Th93,FINSEQ_1:61;
    thus g.<*i,j+1*> = [pred].(<:F:>.ij) by A3,A2,FUNCT_1:23
      .= [pred].<*(2 proj 2).ij*> by A2,FUNCT_6:61
      .= [pred].<*ij.2*> by Th42
      .= [pred].<*j+1*> by FINSEQ_1:61
      .= j by Th93;
  end;
A4: now
    let j;
    assume
A5: p[j];
A6: now
      per cases by NAT_1:6;
      suppose
A7:     i-'j = 0;
        then i <= j by NAT_D:36;
        then i < j+1 by NAT_1:13;
        then
A8:     i-(j+1) < 0 by XREAL_1:51;
        thus g.<*i,i-'j*> = 0 by A1,A7
          .= i-'(j+1) by A8,XREAL_0:def 2;
      end;
      suppose
        ex k being Nat st i-'j = k+1;
        then consider k being Nat such that
A9:     i-'j = k+1;
        reconsider k as Element of NAT by ORDINAL1:def 13;
        i - j = k+1 by A9,XREAL_0:def 2;
        then
A10:    i-(j+1) = k;
        thus g.<*i,i-'j*> = k by A1,A9
          .= i-'(j+1) by A10,XREAL_0:def 2;
      end;
    end;
    [-].<*i,j+1*> =((1,2)->(1,?,2) g).<*i,j,[-].<*i,j*>*> by Th85
      .= i-'(j+1) by A5,A6,Th87;
    hence p[j+1];
  end;
  reconsider ii = <*i*> as Element of 1-tuples_on NAT by FINSEQ_2:118;
  [-].<*i,0*> = (1 proj 1).<*i*> by Th83
    .= ii.1 by Th42
    .= i by FINSEQ_1:57
    .= i+0-'0 by NAT_D:34
    .= i-'0;
  then
A11: p[0];
  for j holds p[j] from NAT_1:sch 1(A11, A4);
  hence thesis;
end;

