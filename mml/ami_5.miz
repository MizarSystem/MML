:: On the Decomposition of the States of SCM
::  by Yasushi Tanaka
::
:: Received November 23, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies NUMBERS, AMI_3, SUBSET_1, AMI_2, AMI_1, STRUCT_0, XBOOLE_0,
      FSM_1, RELAT_1, FUNCT_1, TARSKI, FINSET_1, QC_LANG1, CARD_1, XXREAL_0,
      FINSEQ_1, MCART_1, GRAPHSP, AMISTD_1, SCMNORM, ARYTM_3, ARYTM_1, INT_1,
      FUNCT_4, FUNCOP_1, CIRCUIT2, AMI_4, MSUALG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, CARD_1, XCMPLX_0,
      MCART_1, DOMAIN_1, RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1, STRUCT_0,
      FINSET_1, FINSEQ_1, AMI_1, SCMNORM, AMI_2, AMI_3, AMI_4, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, FINSEQ_4, AMI_4, SCMNORM, RELSET_1,
      AMI_2;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, NUMBERS,
      XREAL_0, INT_1, FINSEQ_1, CARD_3, AMI_1, AMI_2, AMI_3, FINSET_1, CARD_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions AMI_1, TARSKI, AMI_3, FUNCOP_1, CARD_1, AMI_2, SCMNORM, RELAT_1;
 theorems AMI_1, AMI_2, AMI_3, GRFUNC_1, NAT_1, TARSKI, FUNCOP_1, FUNCT_4,
      FUNCT_1, MCART_1, GR_CY_1, FUNCT_2, CARD_3, ZFMISC_1, AMI_4, ENUMSET1,
      RELAT_1, ORDINAL1, XBOOLE_0, XBOOLE_1, SYSREL, SCMNORM;

begin

canceled 17;

reserve x,y for set;

theorem Th18:
  for dl being Data-Location ex i being Element of NAT st dl = dl. i
proof
  let dl be Data-Location;
  dl in SCM-Data-Loc by AMI_3:def 2;
  then consider x,y such that
A1: x in {1} and
A2: y in NAT and
A3: dl = [x,y] by ZFMISC_1:103;
  reconsider k = y as Element of NAT by A2;
  take k;
  thus thesis by A1,A3,TARSKI:def 1;
end;

canceled;

theorem Th20:
  for dl being Data-Location holds dl <> IC SCM
proof
  let dl be Data-Location;
  ex i being Element of NAT st dl = dl.i by Th18;
  hence thesis by AMI_3:57;
end;

canceled;

theorem Th22:
  for il being Instruction-Location of SCM, dl being Data-Location
  holds il <> dl
proof
  let il be Instruction-Location of SCM, dl be Data-Location;
  ex j being Element of NAT st dl = dl.j by Th18;
  hence thesis by AMI_3:56;
end;

reserve i, j, k for Element of NAT;

theorem
  the carrier of SCM = {IC SCM} \/ SCM-Data-Loc \/ NAT by AMI_3:4;

theorem
  for s being State of SCM, d being Data-Location, l being
  Instruction-Location of SCM holds d in dom s & l in dom s
proof
  let s be State of SCM, d be Data-Location, l be Instruction-Location of SCM;
  d in SCM-Data-Loc by AMI_3:def 2;
  then d in {IC SCM} \/ SCM-Data-Loc by XBOOLE_0:def 3;
  then d in {IC SCM} \/ SCM-Data-Loc \/ NAT by XBOOLE_0:def 3;
  hence d in dom s by AMI_1:79,AMI_3:4;
  l in NAT by AMI_1:def 4;
  then l in {IC SCM} \/ SCM-Data-Loc \/ NAT by XBOOLE_0:def 3;
  hence thesis by AMI_1:79,AMI_3:4;
end;

canceled;

theorem
  for s1,s2 being State of SCM st IC(s1) = IC(s2) & (for a being
  Data-Location holds s1.a = s2.a) & (for i being Instruction-Location of SCM
  holds s1.i = s2.i) holds s1 = s2
proof
  let s1,s2 be State of SCM such that
A1: IC(s1) = IC(s2) and
A2: for a being Data-Location holds s1.a = s2.a and
A3: for i being Instruction-Location of SCM holds s1.i = s2.i;
  consider g1 being Function such that
A4: s1 = g1 and
A5: dom g1 = dom SCM-OK and
  for x being set st x in dom SCM-OK holds g1.x in SCM-OK.x by CARD_3:def 5;
  consider g2 being Function such that
A6: s2 = g2 and
A7: dom g2 = dom SCM-OK and
  for x being set st x in dom SCM-OK holds g2.x in SCM-OK.x by CARD_3:def 5;
A8: now
    let x be set;
    assume
    x in SCM-Memory;
    then
A9: x in {IC SCM} \/ SCM-Data-Loc or x in NAT by AMI_3:4,XBOOLE_0:def 3;
    per cases by A9,XBOOLE_0:def 3;
    suppose
      x in {IC SCM};
      then x = IC SCM by TARSKI:def 1;
      hence g1.x = g2.x by A1,A4,A6;
    end;
    suppose
      x in SCM-Data-Loc;
      then x is Data-Location by AMI_3:def 2;
      hence g1.x = g2.x by A2,A4,A6;
    end;
    suppose
      x in NAT;
      then reconsider l = x as Instruction-Location of SCM by AMI_1:def 4;
      g1.l = g2.l by A3,A4,A6;
      hence g1.x = g2.x;
    end;
  end;
  SCM-Memory = dom g1 by A5,FUNCT_2:def 1;
  hence thesis by A4,A5,A6,A7,A8,FUNCT_1:9;
end;

theorem
  for s being State of SCM holds SCM-Data-Loc c= dom s by AMI_3:72,SCMNORM:13;

theorem Th28:
  for s being State of SCM holds NAT c= dom s
proof
  let s be State of SCM;
  NAT c= {IC SCM} \/ SCM-Data-Loc \/ NAT by XBOOLE_1:10;
  hence thesis by AMI_1:79,AMI_3:4;
end;

canceled;

theorem
  for s being State of SCM holds dom (s|NAT) = NAT
proof
  let s be State of SCM;
  NAT c= dom s by Th28;
  hence thesis by RELAT_1:91;
end;

theorem
  SCM-Data-Loc is not finite;

theorem
  NAT is not finite;

registration
  cluster SCM-Data-Loc -> infinite;
  coherence;
end;

definition
  canceled;
  let I be Instruction of SCM;
  func @I -> Element of SCM-Instr equals
  I;
  coherence;
end;

definition
 canceled;
  let loc be Element of SCM-Data-Loc;
  func loc@ -> Data-Location equals
  loc;
  coherence by AMI_3:def 2;
end;

reserve I,J,K for Element of Segm 9,
  a,a1 for Element of NAT,
  b,b1,c for
  Element of SCM-Data-Loc;

canceled 3;

theorem Th36:
  for l being Instruction of SCM holds InsCode(l) <= 8
proof
  let l be Instruction of SCM;
  l in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>] : K
  in { 7,8 } } or l in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 3;
  then
A1: l in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } or l in { [K,<*a1,b1*>]
  : K in { 7,8 } } or l in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by
XBOOLE_0:def 3;
  per cases by A1,XBOOLE_0:def 3;
  suppose
    l in { [SCM-Halt,{}] };
    then l = [SCM-Halt,{}] by TARSKI:def 1;
    then l`1 = 0 by MCART_1:7;
    hence thesis;
  end;
  suppose
    l in { [J,<*a*>] : J = 6 };
    then ex J,a st l = [J,<*a*>] & J = 6;
    then l`1 = 6 by MCART_1:7;
    hence thesis;
  end;
  suppose
    l in { [K,<*a1,b1*>] : K in { 7,8 } };
    then ex K,a1,b1 st l = [K,<*a1,b1*>] & K in { 7,8 };
    then l`1 in { 7,8 } by MCART_1:7;
    then l`1 = 7 or l`1 = 8 by TARSKI:def 2;
    hence thesis;
  end;
  suppose
    l in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
    then ex I,b,c st l = [I,<*b,c*>] & I in { 1,2,3,4,5};
    then l`1 in { 1,2,3,4,5} by MCART_1:7;
    then l`1 = 1 or l`1 = 2 or l`1 = 3 or l`1 = 4 or l`1 = 5 by ENUMSET1:def 3;
    hence thesis;
  end;
end;

reserve a, b for Data-Location,
  loc for Instruction-Location of SCM;

theorem Th37:
  InsCode (halt SCM) = 0 by AMI_3:71,MCART_1:7;

reserve I,J,K for Element of Segm 9,
  a,a1 for Element of NAT,
  b,b1,c for
  Element of SCM-Data-Loc,
  da,db for Data-Location,
  loc for Instruction-Location
  of SCM;

canceled 8;

theorem Th46:
  for ins being Instruction of SCM st InsCode ins = 0 holds ins =
  halt SCM
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 0;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
  now
    assume
    ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
    then ex I,b,c st ins = [I,<*b,c*>] & I in { 1,2,3,4,5};
    hence contradiction by A1,MCART_1:7;
  end;
  then
A3: ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>] :
  K in { 7,8 } } by XBOOLE_0:def 3;
  now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then ex K,a1,b1 st ins = [K,<*a1,b1*>] & K in { 7,8 };
    hence contradiction by A1,MCART_1:7;
  end;
  then ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A3,XBOOLE_0:def 3;
  then ins in {[SCM-Halt,{}]} by A2,XBOOLE_0:def 3;
  hence thesis by AMI_3:71,TARSKI:def 1;
end;

theorem Th47:
  for ins being Instruction of SCM st InsCode ins = 1 holds ex da,
  db st ins = da:=db
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 1;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
A3: now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then consider K,a1,b1 such that
A4: ins = [K,<*a1,b1*>] and
A5: K in { 7,8 };
    InsCode ins = K by A4,MCART_1:7;
    hence contradiction by A1,A5,TARSKI:def 2;
  end;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then
  not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>
  ] : K in { 7,8 } } by A3,XBOOLE_0:def 3;
  then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 3;
  then consider I,b,c such that
A6: ins = [I,<*b,c*>] and
  I in { 1,2,3,4,5};
  reconsider da = b@ ,db = c@ as Data-Location;
  take da,db;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem Th48:
  for ins being Instruction of SCM st InsCode ins = 2 holds ex da,
  db st ins = AddTo(da,db)
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 2;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
A3: now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then consider K,a1,b1 such that
A4: ins = [K,<*a1,b1*>] and
A5: K in { 7,8 };
    InsCode ins = K by A4,MCART_1:7;
    hence contradiction by A1,A5,TARSKI:def 2;
  end;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then
  not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>
  ] : K in { 7,8 } } by A3,XBOOLE_0:def 3;
  then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 3;
  then consider I,b,c such that
A6: ins = [I,<*b,c*>] and
  I in { 1,2,3,4,5};
  reconsider da = b@ ,db = c@ as Data-Location;
  take da,db;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem Th49:
  for ins being Instruction of SCM st InsCode ins = 3 holds ex da,
  db st ins = SubFrom(da,db)
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 3;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
A3: now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then consider K,a1,b1 such that
A4: ins = [K,<*a1,b1*>] and
A5: K in { 7,8 };
    InsCode ins = K by A4,MCART_1:7;
    hence contradiction by A1,A5,TARSKI:def 2;
  end;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then
  not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>
  ] : K in { 7,8 } } by A3,XBOOLE_0:def 3;
  then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 3;
  then consider I,b,c such that
A6: ins = [I,<*b,c*>] and
  I in { 1,2,3,4,5};
  reconsider da = b@ ,db = c@ as Data-Location;
  take da,db;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem Th50:
  for ins being Instruction of SCM st InsCode ins = 4 holds ex da,
  db st ins = MultBy(da,db)
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 4;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
A3: now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then consider K,a1,b1 such that
A4: ins = [K,<*a1,b1*>] and
A5: K in { 7,8 };
    InsCode ins = K by A4,MCART_1:7;
    hence contradiction by A1,A5,TARSKI:def 2;
  end;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then
  not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>
  ] : K in { 7,8 } } by A3,XBOOLE_0:def 3;
  then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 3;
  then consider I,b,c such that
A6: ins = [I,<*b,c*>] and
  I in { 1,2,3,4,5};
  reconsider da = b@ ,db = c@ as Data-Location;
  take da,db;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem Th51:
  for ins being Instruction of SCM st InsCode ins = 5 holds ex da,
  db st ins = Divide(da,db)
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 5;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
A3: now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then consider K,a1,b1 such that
A4: ins = [K,<*a1,b1*>] and
A5: K in { 7,8 };
    InsCode ins = K by A4,MCART_1:7;
    hence contradiction by A1,A5,TARSKI:def 2;
  end;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then
  not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>
  ] : K in { 7,8 } } by A3,XBOOLE_0:def 3;
  then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 3;
  then consider I,b,c such that
A6: ins = [I,<*b,c*>] and
  I in { 1,2,3,4,5};
  reconsider da = b@ ,db = c@ as Data-Location;
  take da,db;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem Th52:
  for ins being Instruction of SCM st InsCode ins = 6 holds ex loc
  st ins = goto loc
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 6;
  now
    assume
    ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
    then consider I,b,c such that
A2: ins = [I,<*b,c*>] and
A3: I in { 1,2,3,4,5};
    InsCode ins = I by A2,MCART_1:7;
    hence contradiction by A1,A3,ENUMSET1:def 3;
  end;
  then
A4: ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>] :
  K in { 7,8 } } by XBOOLE_0:def 3;
  now
    assume
    ins in { [K,<*a1,b1*>] : K in { 7,8 } };
    then consider K,a1,b1 such that
A5: ins = [K,<*a1,b1*>] and
A6: K in { 7,8 };
    InsCode ins = K by A5,MCART_1:7;
    hence contradiction by A1,A6,TARSKI:def 2;
  end;
  then
A7: ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A4,XBOOLE_0:def 3;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then ins in { [J,<*a*>] : J = 6 } by A7,XBOOLE_0:def 3;
  then consider J,a such that
A8: ins = [J,<*a*>] & J = 6;
  reconsider loc = il.a as Instruction-Location of SCM;
  take loc;
  thus thesis by A8;
end;

theorem Th53:
  for ins being Instruction of SCM st InsCode ins = 7 holds ex loc
  ,da st ins = da=0_goto loc
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 7;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
  now
    assume
    ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
    then consider I,b,c such that
A3: ins = [I,<*b,c*>] and
A4: I in { 1,2,3,4,5};
    InsCode ins = I by A3,MCART_1:7;
    hence contradiction by A1,A4,ENUMSET1:def 3;
  end;
  then
A5: ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>] :
  K in { 7,8 } } by XBOOLE_0:def 3;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then ins in { [K,<*a1,b1*>] : K in { 7,8 } } by A5,XBOOLE_0:def 3;
  then consider K,a1,b1 such that
A6: ins = [K,<*a1,b1*>] and
  K in { 7,8 };
  reconsider da = b1@ as Data-Location;
  reconsider loc = il.a1 as Instruction-Location of SCM;
  take loc,da;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem Th54:
  for ins being Instruction of SCM st InsCode ins = 8 holds ex loc
  ,da st ins = da>0_goto loc
proof
  let ins be Instruction of SCM such that
A1: InsCode ins = 8;
A2: now
    assume
    ins in { [J,<*a*>] : J = 6 };
    then ex J,a st ins = [J,<*a*>] & J = 6;
    hence contradiction by A1,MCART_1:7;
  end;
  now
    assume
    ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
    then consider I,b,c such that
A3: ins = [I,<*b,c*>] and
A4: I in { 1,2,3,4,5};
    InsCode ins = I by A3,MCART_1:7;
    hence contradiction by A1,A4,ENUMSET1:def 3;
  end;
  then
A5: ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/ { [K,<*a1,b1*>] :
  K in { 7,8 } } by XBOOLE_0:def 3;
  not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
  then not ins in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } by A2,
XBOOLE_0:def 3;
  then ins in { [K,<*a1,b1*>] : K in { 7,8 } } by A5,XBOOLE_0:def 3;
  then consider K,a1,b1 such that
A6: ins = [K,<*a1,b1*>] and
  K in { 7,8 };
  reconsider da = b1@ as Data-Location;
  reconsider loc = il.a1 as Instruction-Location of SCM;
  take loc,da;
  thus thesis by A1,A6,MCART_1:7;
end;

theorem
  for loc being Instruction-Location of SCM holds (@(goto loc))
  jump_address = loc
proof
  reconsider roku=6 as Element of Segm 9 by NAT_1:45;
  let loc be Instruction-Location of SCM;
  reconsider mk=loc as Element of NAT by AMI_1:def 4;
  @(goto loc) = [ roku, <*mk*>];
  hence thesis by AMI_2:24;
end;

theorem
  for loc being Instruction-Location of SCM, a being Data-Location holds
  (@(a=0_goto loc)) cjump_address = loc & (@(a=0_goto loc)) cond_address = a
proof
  reconsider nana=7 as Element of Segm 9 by NAT_1:45;
  let loc be Instruction-Location of SCM, a be Data-Location;
  reconsider mk=loc as Element of NAT by AMI_1:def 4;
  reconsider aa=a as Element of SCM-Data-Loc by AMI_3:def 2;
  @(a=0_goto loc) = [ nana, <*mk,aa*>];
  hence thesis by AMI_2:25;
end;

theorem
  for loc being Instruction-Location of SCM, a being Data-Location holds
  (@(a>0_goto loc)) cjump_address = loc & (@(a>0_goto loc)) cond_address = a
proof
  reconsider hachi=8 as Element of Segm 9 by NAT_1:45;
  let loc be Instruction-Location of SCM, a be Data-Location;
  reconsider mk=loc as Element of NAT by AMI_1:def 4;
  reconsider aa=a as Element of SCM-Data-Loc by AMI_3:def 2;
  @(a>0_goto loc) = [ hachi, <*mk,aa*>];
  hence thesis by AMI_2:25;
end;

theorem Th58:
  for s1,s2 being State of SCM st (s1 | (SCM-Data-Loc \/ {IC SCM})
) = (s2 | (SCM-Data-Loc \/ {IC SCM})) for l being Instruction of SCM holds Exec
(l,s1) | (SCM-Data-Loc \/ {IC SCM}) = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM})
proof
  IC SCM in {IC SCM} by TARSKI:def 1;
  then
A1: IC SCM in (SCM-Data-Loc \/ {IC SCM}) by XBOOLE_0:def 3;
  let s1,s2 be State of SCM such that
A2: (s1 | (SCM-Data-Loc \/ {IC SCM})) = (s2 | (SCM-Data-Loc \/ {IC SCM})
  );
A3: (SCM-Data-Loc \/ {IC SCM}) c= the carrier of SCM by AMI_3:4,XBOOLE_1:7;
  then (SCM-Data-Loc \/ {IC SCM}) c= dom s2 by AMI_1:79;
  then
A4: IC SCM in dom (s2 | (SCM-Data-Loc \/ {IC SCM})) by A1,RELAT_1:91;
  (SCM-Data-Loc \/ {IC SCM}) c= dom s1 by A3,AMI_1:79;
  then IC SCM in dom (s1 | (SCM-Data-Loc \/ {IC SCM})) by A1,RELAT_1:91;
  then
A5: IC s1 = (s2 | (SCM-Data-Loc \/ {IC SCM})).IC SCM by A2,FUNCT_1:70
    .= IC s2 by A4,FUNCT_1:70;
  let l be Instruction of SCM;
A6: dom Exec(l,s1) = the carrier of SCM & dom Exec(l,s2) = the carrier of
  SCM by AMI_1:79;
A7: SCM-Data-Loc c= (SCM-Data-Loc \/ {IC SCM}) by XBOOLE_1:7;
  per cases by Th36,NAT_1:33;
  suppose
    InsCode (l) = 0;
    then
A8: l = halt SCM by Th46;
    hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM}) = s2 | (SCM-Data-Loc \/ {IC
    SCM}) by A2,AMI_1:def 8
      .= Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A8,AMI_1:def 8;
  end;
  suppose
    InsCode (l) = 1;
    then consider da,db such that
A9: l = da:=db by Th47;
A10: for x being set st x in ((SCM-Data-Loc) \ {da}) holds (Exec (l,s1) |
    (SCM-Data-Loc \ {da})).x = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
    proof
      let x be set;
      assume
A11:  x in ((SCM-Data-Loc) \ {da});
      then
A12:  x in SCM-Data-Loc by XBOOLE_0:def 5;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A13:  a in (SCM-Data-Loc \/ {IC SCM}) by A12,XBOOLE_0:def 3;
      not x in {da} by A11,XBOOLE_0:def 5;
      then
A14:  a <> da by TARSKI:def 1;
      thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x = (Exec (l,s1)).a by A11,
FUNCT_1:72
        .= s1.a by A9,A14,AMI_3:8
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A13,FUNCT_1:72
        .= s2.a by A2,A13,FUNCT_1:72
        .= (Exec (l,s2)).a by A9,A14,AMI_3:8
        .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A11,FUNCT_1:72;
    end;
    dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) &
    dom (( Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) by A6,
RELAT_1:91;
    then
A15: Exec (l,s1) | (SCM-Data-Loc \ {da} ) = Exec (l,s2) | (SCM-Data-Loc \
    {da} ) by A10,FUNCT_1:9;
A16: db in SCM-Data-Loc by AMI_3:def 2;
    Exec (l,s1).IC SCM = Next IC s1 by A9,AMI_3:8
      .= Exec (l,s2).IC SCM by A5,A9,AMI_3:8;
    then
A17: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
    da in SCM-Data-Loc by AMI_3:def 2;
    then
A18: SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
      .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
    Exec (l,s1).da = s1.db by A9,AMI_3:8
      .= (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A7,A16,FUNCT_1:72
      .= s2.db by A2,A7,A16,FUNCT_1:72
      .= Exec (l,s2).da by A9,AMI_3:8;
    then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A6,GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A18,A15,AMI_3:72
,RELAT_1:185;
    hence thesis by A17,AMI_3:72,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 2;
    then consider da,db such that
A19: l = AddTo(da,db) by Th48;
A20: for x being set st x in ((SCM-Data-Loc) \ {da}) holds (Exec (l,s1) |
    (SCM-Data-Loc \ {da})).x = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
    proof
      let x be set;
      assume
A21:  x in ((SCM-Data-Loc) \ {da});
      then
A22:  x in SCM-Data-Loc by XBOOLE_0:def 5;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A23:  a in (SCM-Data-Loc \/ {IC SCM}) by A22,XBOOLE_0:def 3;
      not x in {da} by A21,XBOOLE_0:def 5;
      then
A24:  a <> da by TARSKI:def 1;
      thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x = (Exec (l,s1)).a by A21,
FUNCT_1:72
        .= s1.a by A19,A24,AMI_3:9
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A23,FUNCT_1:72
        .= s2.a by A2,A23,FUNCT_1:72
        .= (Exec (l,s2)).a by A19,A24,AMI_3:9
        .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A21,FUNCT_1:72;
    end;
    dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) &
    dom (( Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) by A6,
RELAT_1:91;
    then
A25: Exec (l,s1) | (SCM-Data-Loc \ {da} ) = Exec (l,s2) | (SCM-Data-Loc \
    {da} ) by A20,FUNCT_1:9;
    da in SCM-Data-Loc by AMI_3:def 2;
    then
A26: SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
      .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
    Exec (l,s1).IC SCM = Next IC s1 by A19,AMI_3:9
      .= Exec (l,s2).IC SCM by A5,A19,AMI_3:9;
    then
A27: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A28: da in SCM-Data-Loc by AMI_3:def 2;
    then
A29: s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
      .= s2.da by A2,A7,A28,FUNCT_1:72;
A30: db in SCM-Data-Loc by AMI_3:def 2;
    then
A31: s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A7,FUNCT_1:72
      .= s2.db by A2,A7,A30,FUNCT_1:72;
    Exec (l,s1).da = s1.da + s1.db by A19,AMI_3:9
      .= Exec (l,s2).da by A19,A29,A31,AMI_3:9;
    then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A6,GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A26,A25,AMI_3:72
,RELAT_1:185;
    hence thesis by A27,AMI_3:72,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 3;
    then consider da,db such that
A32: l = SubFrom(da,db) by Th49;
A33: for x being set st x in ((SCM-Data-Loc) \ {da}) holds (Exec (l,s1) |
    (SCM-Data-Loc \ {da})).x = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
    proof
      let x be set;
      assume
A34:  x in ((SCM-Data-Loc) \ {da});
      then
A35:  x in SCM-Data-Loc by XBOOLE_0:def 5;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A36:  a in (SCM-Data-Loc \/ {IC SCM}) by A35,XBOOLE_0:def 3;
      not x in {da} by A34,XBOOLE_0:def 5;
      then
A37:  a <> da by TARSKI:def 1;
      thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x = (Exec (l,s1)).a by A34,
FUNCT_1:72
        .= s1.a by A32,A37,AMI_3:10
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A36,FUNCT_1:72
        .= s2.a by A2,A36,FUNCT_1:72
        .= (Exec (l,s2)).a by A32,A37,AMI_3:10
        .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A34,FUNCT_1:72;
    end;
    dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) &
    dom (( Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) by A6,
RELAT_1:91;
    then
A38: Exec (l,s1) | (SCM-Data-Loc \ {da} ) = Exec (l,s2) | (SCM-Data-Loc \
    {da} ) by A33,FUNCT_1:9;
    da in SCM-Data-Loc by AMI_3:def 2;
    then
A39: SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
      .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
    Exec (l,s1).IC SCM = Next IC s1 by A32,AMI_3:10
      .= Exec (l,s2).IC SCM by A5,A32,AMI_3:10;
    then
A40: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A41: da in SCM-Data-Loc by AMI_3:def 2;
    then
A42: s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
      .= s2.da by A2,A7,A41,FUNCT_1:72;
A43: db in SCM-Data-Loc by AMI_3:def 2;
    then
A44: s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A7,FUNCT_1:72
      .= s2.db by A2,A7,A43,FUNCT_1:72;
    Exec (l,s1).da = s1.da - s1.db by A32,AMI_3:10
      .= Exec (l,s2).da by A32,A42,A44,AMI_3:10;
    then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A6,GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A39,A38,AMI_3:72
,RELAT_1:185;
    hence thesis by A40,AMI_3:72,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 4;
    then consider da,db such that
A45: l = MultBy(da,db) by Th50;
A46: for x being set st x in ((SCM-Data-Loc) \ {da}) holds (Exec (l,s1) |
    (SCM-Data-Loc \ {da})).x = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
    proof
      let x be set;
      assume
A47:  x in ((SCM-Data-Loc) \ {da});
      then
A48:  x in SCM-Data-Loc by XBOOLE_0:def 5;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A49:  a in (SCM-Data-Loc \/ {IC SCM}) by A48,XBOOLE_0:def 3;
      not x in {da} by A47,XBOOLE_0:def 5;
      then
A50:  a <> da by TARSKI:def 1;
      thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x = (Exec (l,s1)).a by A47,
FUNCT_1:72
        .= s1.a by A45,A50,AMI_3:11
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A49,FUNCT_1:72
        .= s2.a by A2,A49,FUNCT_1:72
        .= (Exec (l,s2)).a by A45,A50,AMI_3:11
        .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A47,FUNCT_1:72;
    end;
    dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) &
    dom (( Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) by A6,
RELAT_1:91;
    then
A51: Exec (l,s1) | (SCM-Data-Loc \ {da} ) = Exec (l,s2) | (SCM-Data-Loc \
    {da} ) by A46,FUNCT_1:9;
    da in SCM-Data-Loc by AMI_3:def 2;
    then
A52: SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
      .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
    Exec (l,s1).IC SCM = Next IC s1 by A45,AMI_3:11
      .= Exec (l,s2).IC SCM by A5,A45,AMI_3:11;
    then
A53: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A54: da in SCM-Data-Loc by AMI_3:def 2;
    then
A55: s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
      .= s2.da by A2,A7,A54,FUNCT_1:72;
A56: db in SCM-Data-Loc by AMI_3:def 2;
    then
A57: s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A7,FUNCT_1:72
      .= s2.db by A2,A7,A56,FUNCT_1:72;
    Exec (l,s1).da = s1.da * s1.db by A45,AMI_3:11
      .= Exec (l,s2).da by A45,A55,A57,AMI_3:11;
    then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A6,GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A52,A51,AMI_3:72
,RELAT_1:185;
    hence thesis by A53,AMI_3:72,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 5;
    then consider da,db such that
A58: l = Divide(da,db) by Th51;
    thus thesis
    proof
      per cases;
      suppose
A59:    da=db;
A60:    for x being set st x in ((SCM-Data-Loc) \ {da}) holds (Exec (l,
s1) | (SCM-Data-Loc \ {da})).x = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
        proof
          let x be set;
          assume
A61:      x in ((SCM-Data-Loc) \ {da});
          then
A62:      x in SCM-Data-Loc by XBOOLE_0:def 5;
          then reconsider a = x as Data-Location by AMI_3:def 2;
A63:      a in (SCM-Data-Loc \/ {IC SCM}) by A62,XBOOLE_0:def 3;
          not x in {da} by A61,XBOOLE_0:def 5;
          then
A64:      a <> da by TARSKI:def 1;
          thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x = (Exec (l,s1)).a by A61
,FUNCT_1:72
            .= s1.a by A58,A59,A64,AMI_3:12
            .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A63,FUNCT_1:72
            .= s2.a by A2,A63,FUNCT_1:72
            .= (Exec (l,s2)).a by A58,A59,A64,AMI_3:12
            .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A61,FUNCT_1:72;
        end;
        dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {
da}) & dom (( Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da}) by
A6,RELAT_1:91;
        then
A65:    Exec (l,s1) | (SCM-Data-Loc \ {da} ) = Exec (l,s2) | (
        SCM-Data-Loc \ {da} ) by A60,FUNCT_1:9;
        da in SCM-Data-Loc by AMI_3:def 2;
        then
A66:    SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
          .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
        Exec (l,s1).IC SCM = Next IC s1 by A58,AMI_3:12
          .= Exec (l,s2).IC SCM by A5,A58,AMI_3:12;
        then
A67:    Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A68:    da in SCM-Data-Loc by AMI_3:def 2;
        then
A69:    s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
          .= s2.da by A2,A7,A68,FUNCT_1:72;
        Exec (l,s1).da = s1.da mod s1.da by A58,A59,AMI_3:12
          .= Exec (l,s2).da by A58,A59,A69,AMI_3:12;
        then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A6,GRFUNC_1:90;
        then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A66,A65,AMI_3:72
,RELAT_1:185;
        hence thesis by A67,AMI_3:72,RELAT_1:185;
      end;
      suppose
A70:    da <> db;
        Exec (l,s1).IC SCM = Next IC s1 by A58,AMI_3:12
          .= Exec (l,s2).IC SCM by A5,A58,AMI_3:12;
        then
A71:    Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A72:    db in SCM-Data-Loc by AMI_3:def 2;
        then
A73:    s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A7,FUNCT_1:72
          .= s2.db by A2,A7,A72,FUNCT_1:72;
A74:    for x being set st x in ((SCM-Data-Loc) \ {da,db}) holds (Exec (
l,s1) | (SCM-Data-Loc \ {da,db})).x = (Exec (l,s2) | (SCM-Data-Loc \ {da,db})).
        x
        proof
          let x be set;
          assume
A75:      x in ((SCM-Data-Loc) \ {da,db});
          then
A76:      x in SCM-Data-Loc by XBOOLE_0:def 5;
          then reconsider a = x as Data-Location by AMI_3:def 2;
A77:      a in (SCM-Data-Loc \/ {IC SCM}) by A76,XBOOLE_0:def 3;
          not x in {da,db} by A75,XBOOLE_0:def 5;
          then
A78:      a <> da & a <> db by TARSKI:def 2;
          thus (Exec (l,s1) | (SCM-Data-Loc \ {da,db})).x = (Exec (l,s1)).a by
A75,FUNCT_1:72
            .= s1.a by A58,A78,AMI_3:12
            .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A77,FUNCT_1:72
            .= s2.a by A2,A77,FUNCT_1:72
            .= (Exec (l,s2)).a by A58,A78,AMI_3:12
            .= (Exec (l,s2) | (SCM-Data-Loc \ {da,db})).x by A75,FUNCT_1:72;
        end;
        dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da,db})) = (SCM-Data-Loc \
{da,db}) & dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da,db})) = (SCM-Data-Loc \ {
        da,db}) by A6,RELAT_1:91;
        then
A79:    Exec (l,s1) | (SCM-Data-Loc \ {da,db} ) = Exec (l,s2) | (
        SCM-Data-Loc \ {da,db} ) by A74,FUNCT_1:9;
        da in SCM-Data-Loc & db in SCM-Data-Loc by AMI_3:def 2;
        then
A80:    SCM-Data-Loc = SCM-Data-Loc \/ {da,db} by ZFMISC_1:48
          .= (SCM-Data-Loc \ {da,db} ) \/ {da,db} by XBOOLE_1:39;
A81:    da in SCM-Data-Loc by AMI_3:def 2;
        then
A82:    s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
          .= s2.da by A2,A7,A81,FUNCT_1:72;
A83:    Exec (l,s1).db = s1.da mod s1.db by A58,AMI_3:12
          .= Exec (l,s2).db by A58,A82,A73,AMI_3:12;
        Exec (l,s1).da = s1.da div s1.db by A58,A70,AMI_3:12
          .= Exec (l,s2).da by A58,A70,A82,A73,AMI_3:12;
        then Exec (l,s1) | {da,db} = Exec(l,s2) | {da,db} by A6,A83,GRFUNC_1:91
;
        then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A80,A79,AMI_3:72
,RELAT_1:185;
        hence thesis by A71,AMI_3:72,RELAT_1:185;
      end;
    end;
  end;
  suppose
    InsCode (l) = 6;
    then consider loc such that
A84: l = goto loc by Th52;
A85: for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A86:  x in SCM-Data-Loc;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A87:  a in (SCM-Data-Loc \/ {IC SCM}) by A86,XBOOLE_0:def 3;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A86,AMI_3:72
,FUNCT_1:72
        .= s1.a by A84,AMI_3:13
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A87,FUNCT_1:72
        .= s2.a by A2,A87,FUNCT_1:72
        .= (Exec (l,s2)).a by A84,AMI_3:13
        .= (DataPart Exec (l,s2)).x by A86,AMI_3:72,FUNCT_1:72;
    end;
    Exec (l,s1).IC SCM = loc by A84,AMI_3:13
      .= Exec (l,s2).IC SCM by A84,AMI_3:13;
    then
A88: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
    dom DataPart Exec(l,s1) = SCM-Data-Loc & dom DataPart Exec (l,s2) =
    SCM-Data-Loc by A6,AMI_3:72,RELAT_1:91;
    then Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A85,
AMI_3:72,FUNCT_1:9;
    hence thesis by A88,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 7;
    then consider loc,da such that
A89: l = da=0_goto loc by Th53;
    Exec (l,s1).IC SCM = Exec (l,s2).IC SCM
    proof
A90:  da in SCM-Data-Loc by AMI_3:def 2;
      then
A91:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
        .= s2.da by A2,A7,A90,FUNCT_1:72;
      per cases;
      suppose
A92:    s1.da = 0;
        hence Exec (l,s1).IC SCM = loc by A89,AMI_3:14
          .= Exec (l,s2).IC SCM by A89,A91,A92,AMI_3:14;
      end;
      suppose
A93:    s1.da <> 0;
        hence Exec (l,s1).IC SCM = Next IC s1 by A89,AMI_3:14
          .= Exec (l,s2).IC SCM by A5,A89,A91,A93,AMI_3:14;
      end;
    end;
    then
A94: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A95: for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A96:  x in SCM-Data-Loc;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A97:  a in (SCM-Data-Loc \/ {IC SCM}) by A96,XBOOLE_0:def 3;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A96,AMI_3:72
,FUNCT_1:72
        .= s1.a by A89,AMI_3:14
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A97,FUNCT_1:72
        .= s2.a by A2,A97,FUNCT_1:72
        .= (Exec (l,s2)).a by A89,AMI_3:14
        .= (DataPart Exec (l,s2)).x by A96,AMI_3:72,FUNCT_1:72;
    end;
    dom (DataPart (Exec (l,s1))) = SCM-Data-Loc & dom ((DataPart Exec (l
    ,s2))) = SCM-Data-Loc by A6,AMI_3:72,RELAT_1:91;
    then Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A95,
AMI_3:72,FUNCT_1:9;
    hence thesis by A94,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 8;
    then consider loc,da such that
A98: l = da>0_goto loc by Th54;
    Exec (l,s1).IC SCM = Exec (l,s2).IC SCM
    proof
A99:  da in SCM-Data-Loc by AMI_3:def 2;
      then
A100: s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A7,FUNCT_1:72
        .= s2.da by A2,A7,A99,FUNCT_1:72;
      per cases;
      suppose
A101:   s1.da > 0;
        hence Exec (l,s1).IC SCM = loc by A98,AMI_3:15
          .= Exec (l,s2).IC SCM by A98,A100,A101,AMI_3:15;
      end;
      suppose
A102:   s1.da <= 0;
        hence Exec (l,s1).IC SCM = Next IC s1 by A98,AMI_3:15
          .= Exec (l,s2).IC SCM by A5,A98,A100,A102,AMI_3:15;
      end;
    end;
    then
A103: Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A6,GRFUNC_1:90;
A104: for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A105: x in SCM-Data-Loc;
      then reconsider a = x as Data-Location by AMI_3:def 2;
A106: a in (SCM-Data-Loc \/ {IC SCM}) by A105,XBOOLE_0:def 3;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A105,AMI_3:72
,FUNCT_1:72
        .= s1.a by A98,AMI_3:15
        .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A106,FUNCT_1:72
        .= s2.a by A2,A106,FUNCT_1:72
        .= (Exec (l,s2)).a by A98,AMI_3:15
        .= (DataPart Exec (l,s2)).x by A105,AMI_3:72,FUNCT_1:72;
    end;
    dom (DataPart Exec (l,s1)) = SCM-Data-Loc & dom (DataPart Exec (l,s2
    )) = SCM-Data-Loc by A6,AMI_3:72,RELAT_1:91;
    then Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A104,
AMI_3:72,FUNCT_1:9;
    hence thesis by A103,RELAT_1:185;
  end;
end;

theorem Th59:
  for i being Instruction of SCM, s being State of SCM holds Exec
  (i, s) | NAT = s | NAT
proof
  let i be Instruction of SCM, s be State of SCM;
A1: for x being set st x in NAT holds (Exec (i, s) | NAT).x = (s | NAT).x
  proof
    let x be set;
    assume
    x in NAT;
    then reconsider l = x as Instruction-Location of SCM by AMI_1:def 4;
A2: l in NAT by AMI_1:def 4;
    hence (Exec (i, s) | NAT).x = (Exec (i, s)).l by FUNCT_1:72
      .= s.l by AMI_1:def 13
      .= (s | NAT).x by A2,FUNCT_1:72;
  end;
  dom s = the carrier of SCM by AMI_1:79;
  then
A3: dom (s | NAT) = NAT by RELAT_1:91;
  dom (Exec (i,s)) = the carrier of SCM by AMI_1:79;
  then dom (Exec (i, s) | NAT) = NAT by RELAT_1:91;
  hence thesis by A3,A1,FUNCT_1:9;
end;

begin :: Finite partial states of SCM

canceled 17;

theorem
  for i being Instruction of SCM, s being State of SCM, p being NAT
  -defined FinPartState of SCM holds Exec (i, s +* p) = Exec (i,s) +* p
proof
  let i be Instruction of SCM, s be State of SCM, p be NAT-defined
  FinPartState of SCM;
A1: Exec (i, s +* p)|NAT = (s +* p)|NAT by Th59
    .= s |NAT +* p|NAT by FUNCT_4:75
    .= Exec (i,s) |NAT +* p|NAT by Th59
    .= (Exec (i, s) +* p)|NAT by FUNCT_4:75;
  now
    assume
    {IC SCM} meets NAT;
    then consider x being set such that
A2: x in {IC SCM} and
A3: x in NAT by XBOOLE_0:3;
    reconsider l = x as Instruction-Location of SCM by A3,AMI_1:def 4;
    l = IC SCM by A2,TARSKI:def 1;
    hence contradiction by AMI_1:48;
  end;
  then dom p c= NAT & SCM-Data-Loc \/ {IC SCM} misses NAT by AMI_2:29
,RELAT_1:def 18,XBOOLE_1:70;
  then
A4: SCM-Data-Loc \/ {IC SCM} misses dom p by XBOOLE_1:63;
  then
A5: s|(SCM-Data-Loc \/ {IC SCM}) = (s +* p) | (SCM-Data-Loc \/ {IC SCM}) by
FUNCT_4:76;
A6: (Exec(i,s) +* p)|(SCM-Data-Loc \/ {IC SCM}) = Exec(i,s)|(SCM-Data-Loc \/
  {IC SCM}) by A4,FUNCT_4:76
    .= Exec(i,s +* p) | (SCM-Data-Loc \/ {IC SCM}) by A5,Th58;
  thus Exec (i, s +* p) = Exec (i, s +* p)| dom(Exec (i, s +* p)) by RELAT_1:97
    .= Exec (i, s +* p)| ({IC SCM} \/ SCM-Data-Loc \/ NAT) by AMI_1:79,AMI_3:4
    .= (Exec (i, s) +* p)| ({IC SCM} \/ SCM-Data-Loc) +* (Exec (i, s) +* p)|
  NAT by A6,A1,FUNCT_4:83
    .= (Exec (i,s) +* p)| the carrier of SCM by AMI_3:4,FUNCT_4:83
    .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by AMI_1:79
    .= Exec (i,s) +* p by RELAT_1:97;
end;

canceled 2;

theorem
  for s being State of SCM, iloc being Instruction-Location of SCM, a
  being Data-Location holds s.a = (s +* Start-At iloc).a
proof
  let s be State of SCM, iloc be Instruction-Location of SCM, a be
  Data-Location;
  a in the carrier of SCM;
  then a in dom s by AMI_1:79;
  then
A1: dom (Start-At iloc) = {IC SCM} & a in dom s \/ dom (Start-At iloc) by
FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC SCM by Th20;
  then not a in {IC SCM} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

begin :: Autonomic finite partial states of SCM

canceled 2;

theorem Th83:
  for p being autonomic FinPartState of SCM st DataPart p <> {}
  holds IC SCM in dom p
proof
  let p be autonomic FinPartState of SCM;
  assume
  DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume
A2: not IC SCM in dom p;
  p is not autonomic
  proof
    dom p misses {IC SCM} by A2,ZFMISC_1:56;
    then
A3: dom p /\ {IC SCM} = {} by XBOOLE_0:def 7;
    consider il being Element of (NAT) \ dom p;
    consider d2 being Element of SCM-Data-Loc \ dom p;
    consider d1 being Element of dom DataPart p;
A4: d1 in dom DataPart p by A1;
    dom DataPart p c= the carrier of SCM by AMI_1:80;
    then reconsider d1 as Element of SCM by A4;
    not SCM-Data-Loc c= dom p;
    then
A5: SCM-Data-Loc \ dom p <> {} by XBOOLE_1:37;
    then d2 in SCM-Data-Loc by XBOOLE_0:def 5;
    then reconsider d2 as Data-Location by AMI_3:def 2;
A6: not d2 in dom p by A5,XBOOLE_0:def 5;
    then dom p misses {d2} by ZFMISC_1:56;
    then
A7: dom p /\ {d2} = {} by XBOOLE_0:def 7;
    not NAT c= dom p;
    then
A8: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then il is Element of NAT by XBOOLE_0:def 5;
    then reconsider il as Instruction-Location of SCM by AMI_1:def 4;
A9: not il in dom p by A8,XBOOLE_0:def 5;
    then
A10: dom p misses {il} by ZFMISC_1:56;
    dom DataPart p c= SCM-Data-Loc by AMI_3:72,RELAT_1:87;
    then reconsider d1 as Data-Location by A4,AMI_3:def 2;
A11: dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) = dom (il .--> (d1:=d2)) \/
    dom ( d2.--> 0) by FUNCT_4:def 1;
    set p2 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il);
    set p1 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il);
    consider s1 being State of SCM such that
A12: p1 c= s1 by CARD_3:97;
    dom p misses {d2} by A6,ZFMISC_1:56;
    then
A13: dom p /\ {d2} = {} by XBOOLE_0:def 7;
A14: dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) = dom ((il
    .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il) by FUNCT_4:def 1;
    consider s2 being State of SCM such that
A15: p2 c= s2 by CARD_3:97;
    dom ( Computation(s2,1)) = the carrier of SCM by AMI_1:79;
    then
A16: dom ( Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
    dom ( Computation(s1,1)) = the carrier of SCM by AMI_1:79;
    then
A17: dom ( Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A18: dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) = dom (il .--> (d1:=d2)) \/
    dom ( d2.--> 1) by FUNCT_4:def 1;
A19: dom p misses {il} by A9,ZFMISC_1:56;
A20: dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At
    il) by FUNCT_4:def 1;
A21: dom(Start-At il) = {IC SCM} by FUNCOP_1:19;
    then
A22: IC SCM in dom (Start-At il) by TARSKI:def 1;
    then
A23: IC SCM in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) by A14,
XBOOLE_0:def 3;
    then IC SCM in dom p2 by A20,XBOOLE_0:def 3;
    then
A24: IC s2 = p2.IC SCM by A15,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).IC SCM by A23,
FUNCT_4:14
      .= (Start-At il).IC SCM by A22,FUNCT_4:14
      .= il by FUNCOP_1:87;
    d2 <> IC SCM by Th20;
    then
A25: not d2 in dom (Start-At il) by A21,TARSKI:def 1;
A26: dom (d2 .--> 1) = {d2} by FUNCOP_1:19;
    then
A27: d2 in dom (d2 .--> 1) by TARSKI:def 1;
    then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A18,XBOOLE_0:def 3;
    then
A28: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) by A14,
XBOOLE_0:def 3;
    then d2 in dom p2 by A20,XBOOLE_0:def 3;
    then
A29: s2.d2 = p2.d2 by A15,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).d2 by A28,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).d2 by A25,FUNCT_4:12
      .= (d2.--> 1).d2 by A27,FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    il <> IC SCM by AMI_1:48;
    then
A30: not il in dom (Start-At il) by A21,TARSKI:def 1;
    il <> d2 by Th22;
    then
A31: not il in dom (d2 .--> 1) by A26,TARSKI:def 1;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
    then il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A18,XBOOLE_0:def 3;
    then
A32: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) by A14,
XBOOLE_0:def 3;
    then il in dom p2 by A20,XBOOLE_0:def 3;
    then
A33: s2.il = p2.il by A15,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).il by A32,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).il by A30,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A31,FUNCT_4:12
      .=(d1:=d2) by FUNCOP_1:87;
A34: Computation(s2,0+1).d1 = (Following Computation(s2,0)).d1 by AMI_1:14
      .= (Following s2).d1 by AMI_1:13
      .= 1 by A24,A33,A29,AMI_3:8;
    dom p misses {IC SCM} by A2,ZFMISC_1:56;
    then
A35: dom p /\ {IC SCM} = {} by XBOOLE_0:def 7;
    DataPart p c= p by RELAT_1:88;
    then
A36: dom DataPart p c= dom p by RELAT_1:25;
    take s1,s2;
    dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) = dom((il .-->
    (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il) by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ {IC SCM} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0) \/ {IC SCM} by FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> 0) \/ {IC SCM} by FUNCOP_1:19
      .= {il} \/ {d2} \/ {IC SCM} by FUNCOP_1:19;
    then
    dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) = dom
    p /\ ({il} \/ {d2}) \/ {} by A35,XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A7,XBOOLE_1:23
      .= {} by A10,XBOOLE_0:def 7;
    then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
    by XBOOLE_0:def 7;
    then p c= p1 by FUNCT_4:33;
    hence p c= s1 by A12,XBOOLE_1:1;
A37: dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At
    il) by FUNCT_4:def 1;
    dom ((il .--> (d1:=d2)) +* (d2.--> 1) +* Start-At il) = dom((il .-->
    (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il) by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ {IC SCM} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 1) \/ {IC SCM} by FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> 1) \/ {IC SCM} by FUNCOP_1:19
      .= {il} \/ {d2} \/ {IC SCM} by FUNCOP_1:19;
    then
    dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) = dom
    p /\ ({il} \/ {d2}) \/ {} by A3,XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A13,XBOOLE_1:23
      .= {} by A19,XBOOLE_0:def 7;
    then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
    by XBOOLE_0:def 7;
    then p c= p2 by FUNCT_4:33;
    hence p c= s2 by A15,XBOOLE_1:1;
    take 1;
A38: dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) = dom ((il
    .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il) by FUNCT_4:def 1;
A39: dom(Start-At il) = {IC SCM} by FUNCOP_1:19;
    then
A40: IC SCM in dom (Start-At il) by TARSKI:def 1;
    then
A41: IC SCM in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) by A38,
XBOOLE_0:def 3;
    then IC SCM in dom p1 by A37,XBOOLE_0:def 3;
    then
A42: IC s1 = p1.IC SCM by A12,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).IC SCM by A41,
FUNCT_4:14
      .= (Start-At il).IC SCM by A40,FUNCT_4:14
      .= il by FUNCOP_1:87;
    d2 <> IC SCM by Th20;
    then
A43: not d2 in dom (Start-At il) by A39,TARSKI:def 1;
A44: dom (d2 .--> 0) = {d2} by FUNCOP_1:19;
    then
A45: d2 in dom (d2 .--> 0) by TARSKI:def 1;
    then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A11,XBOOLE_0:def 3;
    then
A46: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) by A38,
XBOOLE_0:def 3;
    then d2 in dom p1 by A37,XBOOLE_0:def 3;
    then
A47: s1.d2 = p1.d2 by A12,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).d2 by A46,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).d2 by A43,FUNCT_4:12
      .= (d2.--> 0).d2 by A45,FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    il <> IC SCM by AMI_1:48;
    then
A48: not il in dom (Start-At il) by A39,TARSKI:def 1;
    il <> d2 by Th22;
    then
A49: not il in dom (d2 .--> 0) by A44,TARSKI:def 1;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
    then il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A11,XBOOLE_0:def 3;
    then
A50: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) by A38,
XBOOLE_0:def 3;
    then il in dom p1 by A37,XBOOLE_0:def 3;
    then
A51: s1.il = p1.il by A12,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).il by A50,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).il by A48,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A49,FUNCT_4:12
      .=(d1:=d2) by FUNCOP_1:87;
    Computation(s1,0+1).d1 = (Following Computation(s1,0)).d1 by AMI_1:14
      .= (Following s1).d1 by AMI_1:13
      .= 0 by A42,A51,A47,AMI_3:8;
    then ( Computation(s1,1)|dom p).d1 = 0 by A4,A36,A17,FUNCT_1:70;
    hence thesis by A4,A36,A16,A34,FUNCT_1:70;
  end;
  hence contradiction;
end;

registration
  cluster autonomic non NAT-defined FinPartState of SCM;
  existence
  proof
    take p = (Start-At il.0) +* Euclide-Algorithm +* (dl.0,dl.1) --> (1,1);
    (dl.0,dl.1) --> (1,1) in dom Euclide-Function by AMI_4:11;
    then
    ex s being FinPartState of SCM st (dl.0,dl.1) --> (1,1) = s & (Start-At
il.0) +* Euclide-Algorithm +* s is pre-program of SCM & Euclide-Function.s c=
    Result((Start-At il.0) +* Euclide-Algorithm +* s ) by AMI_1:def 29,AMI_4:13
    ;
    hence p is autonomic;
    take IC SCM;
    dom (Start-At il.0) = {IC SCM} by FUNCOP_1:19;
    then dom ((Start-At il.0) +* Euclide-Algorithm) = dom (Start-At il.0) \/
    dom ( Euclide-Algorithm) & IC SCM in dom (Start-At il.0) by FUNCT_4:def 1
,TARSKI:def 1;
    then
    dom p = dom ((Start-At il.0) +* Euclide-Algorithm) \/ dom((dl.0,dl.1)
    --> (1, 1)) & IC SCM in dom ((Start-At il.0) +* Euclide-Algorithm) by
FUNCT_4:def 1,XBOOLE_0:def 3;
    hence IC SCM in dom p by XBOOLE_0:def 3;
    assume
    IC SCM in NAT;
    hence contradiction by AMI_3:4;
  end;
end;

theorem Th84:
  for p being autonomic non NAT-defined FinPartState of SCM holds
  IC SCM in dom p
proof
  let p be autonomic non NAT-defined FinPartState of SCM;
A1: dom p = dom p /\ the carrier of SCM by AMI_1:80,XBOOLE_1:28
    .= dom p /\ ({IC SCM} \/ SCM-Data-Loc) \/ dom p /\ NAT by AMI_3:4
,XBOOLE_1:23;
  not dom p c= NAT by RELAT_1:def 18;
  then dom p /\ ({IC SCM} \/ SCM-Data-Loc) <> {} by A1,XBOOLE_1:17;
  then
A2: dom p /\ {IC SCM} \/ dom p /\ SCM-Data-Loc <> {} by XBOOLE_1:23;
  per cases by A2;
  suppose
    dom p /\ {IC SCM} <> {};
    then dom p meets {IC SCM} by XBOOLE_0:def 7;
    hence thesis by ZFMISC_1:56;
  end;
  suppose
    dom p /\ SCM-Data-Loc <> {};
    then DataPart p <> {} by AMI_3:72,RELAT_1:60,90;
    hence thesis by Th83;
  end;
end;

theorem
  for p being autonomic FinPartState of SCM st IC SCM in dom p holds IC
  p in dom p
proof
  let p be autonomic FinPartState of SCM;
  assume
A1: IC SCM in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto il.0));
  set p2 = p +* ((il .--> goto il.1));
  consider s1 being State of SCM such that
A2: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCM such that
A3: p2 c= s2 by CARD_3:97;
  assume
A4: not IC p in dom p;
  p is not autonomic
  proof
    take s1,s2;
A5: dom (il .--> (goto il.1)) = {il} by FUNCOP_1:19;
    then
A6: il in dom (il .--> (goto il.1)) by TARSKI:def 1;
A7: dom p misses {il} by A4,ZFMISC_1:56;
    then
A8: p c= p2 by A5,FUNCT_4:33;
    dom p2 = dom p \/ dom ((il .--> goto il.1)) by FUNCT_4:def 1;
    then il in dom p2 by A6,XBOOLE_0:def 3;
    then s2.il = p2.il by A3,GRFUNC_1:8
      .= ((il .--> goto il.1)).il by A6,FUNCT_4:14
      .= goto il.1 by FUNCOP_1:87;
    then
A9: (Following s2).IC SCM = Exec (goto il.1,s2).IC SCM by A1,A3,A8,AMI_1:97
,XBOOLE_1:1
      .= il.1 by AMI_3:13;
A10: dom (il .--> (goto il.0)) = {il} by FUNCOP_1:19;
    then
A11: il in dom (il .--> (goto il.0)) by TARSKI:def 1;
A12: p c= p1 by A10,A7,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A2,A3,A8,XBOOLE_1:1;
    take 1;
    assume
A13: Computation(s1,1)|dom p = Computation(s2,1)|dom p;
A14: (Following(s1))|dom p = (Following ( Computation(s1,0)))|dom p by AMI_1:13
      .= Computation(s1,0+1)|dom p by AMI_1:14
      .= (Following ( Computation(s2,0)))|dom p by A13,AMI_1:14
      .= (Following(s2))|dom p by AMI_1:13;
    dom p1 = dom p \/ dom ((il .--> goto il.0)) by FUNCT_4:def 1;
    then il in dom p1 by A11,XBOOLE_0:def 3;
    then s1.il = p1.il by A2,GRFUNC_1:8
      .= ((il .--> goto il.0)).il by A11,FUNCT_4:14
      .= goto il.0 by FUNCOP_1:87;
    then (Following s1).IC SCM = Exec (goto il.0,s1).IC SCM by A1,A2,A12,
AMI_1:97,XBOOLE_1:1
      .= il.0 by AMI_3:13;
    then il.0 = ((Following(s1))|dom p).IC SCM by A1,FUNCT_1:72
      .= il.1 by A1,A9,A14,FUNCT_1:72;
    hence contradiction;
  end;
  hence contradiction;
end;

theorem Th86:
  for p being autonomic non NAT-defined FinPartState of SCM, s
being State of SCM st p c= s for i being Element of NAT holds IC Computation(s,
  i) in dom ProgramPart(p)
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s be State of SCM
  such that
A1: p c= s;
  let i be Element of NAT;
  set Csi = Computation(s,i);
  set loc = IC Csi;
  reconsider ll = loc as Element of NAT by ORDINAL1:def 13;
  set loc1 = il.(ll+1);
A2: loc in NAT by AMI_1:def 4;
A3: loc in dom ProgramPart p iff loc in dom p /\ NAT by RELAT_1:90;
  assume
  not IC Computation(s,i) in dom ProgramPart(p);
  then
A4: not loc in dom p by A2,A3,XBOOLE_0:def 4;
  set p2 = p +* (loc .--> goto loc1);
  set p1 = p +* (loc .--> goto loc);
A5: dom p1 = dom p \/ dom (loc .--> goto loc) by FUNCT_4:def 1;
A6: dom (loc .--> goto loc1) = {loc} by FUNCOP_1:19;
  then
A7: loc in dom (loc .--> goto loc1) by TARSKI:def 1;
A8: dom p2 = dom p \/ dom (loc .--> goto loc1) by FUNCT_4:def 1;
  then
A9: loc in dom p2 by A7,XBOOLE_0:def 3;
  consider s2 being State of SCM such that
A10: p2 c= s2 by CARD_3:97;
  set Cs2i = Computation(s2,i);
  consider s1 being State of SCM such that
A11: p1 c= s1 by CARD_3:97;
  set Cs1i = Computation(s1,i);
A12: dom (loc .--> goto loc) = {loc} by FUNCOP_1:19;
  then
A13: loc in dom (loc .--> goto loc) by TARSKI:def 1;
  then
A14: loc in dom p1 by A5,XBOOLE_0:def 3;
  p is not autonomic
  proof
A15: now
      let x be set;
      assume
A16:  x in dom p;
      dom p misses dom (loc .--> goto loc1) by A4,A6,ZFMISC_1:56;
      then
A17:  p.x = p2.x by A16,FUNCT_4:17;
      x in dom p2 by A8,A16,XBOOLE_0:def 3;
      hence p.x = s2.x by A10,A17,GRFUNC_1:8;
    end;
    (loc .--> goto loc1).loc = goto loc1 by FUNCOP_1:87;
    then p2.loc = goto loc1 by A7,FUNCT_4:14;
    then s2.loc = goto loc1 by A9,A10,GRFUNC_1:8;
    then
A18: Cs2i.loc = goto loc1 by AMI_1:54;
    (loc .--> goto loc).loc = goto loc by FUNCOP_1:87;
    then p1.loc = goto loc by A13,FUNCT_4:14;
    then s1.loc = goto loc by A14,A11,GRFUNC_1:8;
    then
A19: Cs1i.loc = goto loc by AMI_1:54;
    take s1, s2;
A20: now
      let x be set;
      assume
A21:  x in dom p;
      dom p misses dom (loc .--> goto loc) by A4,A12,ZFMISC_1:56;
      then
A22:  p.x = p1.x by A21,FUNCT_4:17;
      x in dom p1 by A5,A21,XBOOLE_0:def 3;
      hence p.x = s1.x by A11,A22,GRFUNC_1:8;
    end;
    dom s1 = the carrier of SCM by AMI_1:79;
    then dom p c= dom s1 by AMI_1:80;
    hence
A23: p c= s1 by A20,GRFUNC_1:8;
    then
A24: (Cs1i|dom p) = (Csi|dom p) by A1,AMI_1:def 25;
    dom s2 = the carrier of SCM by AMI_1:79;
    then dom p c= dom s2 by AMI_1:80;
    hence p c= s2 by A15,GRFUNC_1:8;
    then
A25: (Cs1i|dom p) = (Cs2i|dom p) by A23,AMI_1:def 25;
    take k = i+1;
    set Cs1k = Computation(s1,k);
A26: Cs1k = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A27: Csi.IC SCM = (Csi|dom p).IC SCM by Th84,FUNCT_1:72;
    then Cs1i.IC SCM = loc by A24,Th84,FUNCT_1:72;
    then
A28: Cs1k.IC SCM = loc by A26,A19,AMI_3:13;
    set Cs2k = Computation(s2,k);
A29: Cs2k = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
    Cs2i.IC SCM = loc by A24,A27,A25,Th84,FUNCT_1:72;
    then
A30: Cs2k.IC SCM = loc1 by A29,A18,AMI_3:13;
    (Cs1k|dom p).IC SCM = Cs1k.IC SCM & (Cs2k|dom p).IC SCM = Cs2k.IC SCM
    by Th84,FUNCT_1:72;
    hence thesis by A28,A30;
  end;
  hence contradiction;
end;

theorem Th87:
  for p being autonomic non NAT-defined FinPartState of SCM, s1,
s2 being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, I being
Instruction of SCM st I = CurInstr ( Computation(s1,i)) holds IC Computation(s1
  ,i) = IC Computation(s2,i) & I = CurInstr ( Computation(s2,i))
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 and
A2: p c= s2;
  let i be Element of NAT, I be Instruction of SCM such that
A3: I = CurInstr ( Computation(s1,i));
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
  thus
A4: IC Cs1i = IC Cs2i
  proof
    assume
A5: IC Computation(s1,i) <> IC Computation(s2,i);
    (Cs1i|dom p).IC SCM = Cs1i.IC SCM & (Cs2i|dom p).IC SCM = Cs2i.IC SCM
    by Th84,FUNCT_1:72;
    hence contradiction by A1,A2,A5,AMI_1:def 25;
  end;
  thus I = CurInstr ( Computation(s2,i))
  proof
    ProgramPart p c= p by RELAT_1:88;
    then
A6: dom ProgramPart p c= dom p by GRFUNC_1:8;
    IC Cs2i in dom ProgramPart p by A2,Th86;
    then
A7: (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i by A6,FUNCT_1:72;
    IC Cs1i in dom ProgramPart p by A1,Th86;
    then
A8: (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i by A6,FUNCT_1:72;
    assume
    I <> CurInstr ( Computation(s2,i));
    hence contradiction by A1,A2,A3,A4,A8,A7,AMI_1:def 25;
  end;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st I = CurInstr ( Computation(
  s1,i)) holds I = da := db & da in dom p implies Computation(s1,i).db =
  Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Data-Location, I be Instruction of SCM
  such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs2i = Computation(s2,i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A4: I = da := db and
A5: da in dom p & Computation(s1,i).db <> Computation(s2,i).db;
  I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
  then
A6: Cs2i1.da = Cs2i.db by A3,A4,AMI_3:8;
  set Cs1i1 = Computation(s1,i+1);
  set Cs1i = Computation(s1,i);
A7: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then Cs1i1.da = Cs1i.db by A2,A4,AMI_3:8;
  hence contradiction by A1,A7,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st I = CurInstr ( Computation(
  s1,i)) holds I = AddTo(da, db) & da in dom p implies Computation(s1,i).da +
  Computation(s1,i).db = Computation(s2,i).da + Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Data-Location, I be Instruction of SCM
  such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs2i = Computation(s2,i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A4: I = AddTo(da, db) and
A5: da in dom p & Computation(s1,i).da + Computation(s1,i).db <>
  Computation(s2, i).da + Computation(s2,i).db;
  I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
  then
A6: Cs2i1.da = Cs2i.da + Cs2i.db by A3,A4,AMI_3:9;
  set Cs1i1 = Computation(s1,i+1);
  set Cs1i = Computation(s1,i);
A7: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then Cs1i1.da = Cs1i.da + Cs1i.db by A2,A4,AMI_3:9;
  hence contradiction by A1,A7,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st I = CurInstr ( Computation(
  s1,i)) holds I = SubFrom(da, db) & da in dom p implies Computation(s1,i).da -
  Computation(s1,i).db = Computation(s2,i).da - Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Data-Location, I be Instruction of SCM
  such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs2i = Computation(s2,i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A4: I = SubFrom(da, db) and
A5: da in dom p & Computation(s1,i).da - Computation(s1,i).db <>
  Computation(s2, i).da - Computation(s2,i).db;
  I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
  then
A6: Cs2i1.da = Cs2i.da - Cs2i.db by A3,A4,AMI_3:10;
  set Cs1i1 = Computation(s1,i+1);
  set Cs1i = Computation(s1,i);
A7: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then Cs1i1.da = Cs1i.da - Cs1i.db by A2,A4,AMI_3:10;
  hence contradiction by A1,A7,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st I = CurInstr ( Computation(
  s1,i)) holds I = MultBy(da, db) & da in dom p implies Computation(s1,i).da *
  Computation(s1,i).db = Computation(s2,i).da * Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Data-Location, I be Instruction of SCM
  such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs2i = Computation(s2,i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A4: I = MultBy(da, db) and
A5: da in dom p & Computation(s1,i).da * Computation(s1,i).db <>
  Computation(s2, i).da * Computation(s2,i).db;
  I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
  then
A6: Cs2i1.da = Cs2i.da * Cs2i.db by A3,A4,AMI_3:11;
  set Cs1i1 = Computation(s1,i+1);
  set Cs1i = Computation(s1,i);
A7: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then Cs1i1.da = Cs1i.da * Cs1i.db by A2,A4,AMI_3:11;
  hence contradiction by A1,A7,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st I = CurInstr ( Computation(
s1,i)) holds I = Divide(da, db) & da in dom p & da <> db implies Computation(s1
,i).da div Computation(s1,i).db = Computation(s2,i).da div Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Data-Location, I be Instruction of SCM
  such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs2i = Computation(s2,i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A4: I = Divide(da, db) and
A5: da in dom p and
A6: da <> db and
A7: Computation(s1,i).da div Computation(s1,i).db <> Computation(s2,i).
  da div Computation(s2,i).db;
  I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
  then
A8: Cs2i1.da = Cs2i.da div Cs2i.db by A3,A4,A6,AMI_3:12;
  set Cs1i1 = Computation(s1,i+1);
  set Cs1i = Computation(s1,i);
A9: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then Cs1i1.da = Cs1i.da div Cs1i.db by A2,A4,A6,AMI_3:12;
  hence contradiction by A1,A9,A5,A7,A8,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st I = CurInstr ( Computation(
s1,i)) holds I = Divide(da, db) & db in dom p implies Computation(s1,i).da mod
  Computation(s1,i).db = Computation(s2,i).da mod Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Data-Location, I be Instruction of SCM
  such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs1i1 = Computation(s1,i+1);
  set Cs1i = Computation(s1,i);
  set Cs2i1 = Computation(s2,i+1);
  set Cs2i = Computation(s2,i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A4: I = Divide(da, db) and
A5: db in dom p and
A6: Computation(s1,i).da mod Computation(s1,i).db <> Computation(s2,i).
  da mod Computation(s2,i).db;
A7: (Cs1i1|dom p).db = Cs1i1.db & (Cs2i1|dom p).db = Cs2i1.db by A5,FUNCT_1:72;
  I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
  then
A8: Cs2i1.db = Cs2i.da mod Cs2i.db by A3,A4,AMI_3:12;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then Cs1i1.db = Cs1i.da mod Cs1i.db by A2,A4,AMI_3:12;
  hence contradiction by A1,A6,A7,A8,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da being
  Data-Location, loc being Instruction-Location of SCM, I being Instruction of
SCM st I = CurInstr ( Computation(s1,i)) holds I = da=0_goto loc & loc <> Next
(IC Computation(s1,i)) implies ( Computation(s1,i).da = 0 iff Computation(s2,i)
  .da = 0)
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Data-Location, loc be Instruction-Location of
  SCM, I be Instruction of SCM such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: (Cs1i1|dom p).IC SCM = Cs1i1.IC SCM & (Cs2i1|dom p).IC SCM = Cs2i1.IC
  SCM by Th84,FUNCT_1:72;
  assume that
A6: I = da=0_goto loc and
A7: loc <> Next (IC Computation(s1,i));
A8: I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
A9: now
    assume
    Computation(s2,i).da = 0 & Computation(s1,i).da <> 0;
    then Cs2i1.IC SCM = loc & Cs1i1.IC SCM = Next IC Cs1i by A2,A8,A3,A4,A6,
AMI_3:14;
    hence contradiction by A1,A5,A7,AMI_1:def 25;
  end;
A10: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  now
    assume
    Computation(s1,i).da = 0 & Computation(s2,i).da <> 0;
    then Cs1i1.IC SCM = loc & Cs2i1.IC SCM = Next IC Cs2i by A2,A8,A3,A4,A6,
AMI_3:14;
    hence contradiction by A1,A2,A5,A10,A7,Th87;
  end;
  hence thesis by A9;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2 for i being Element of NAT, da being
  Data-Location, loc being Instruction-Location of SCM, I being Instruction of
SCM st I = CurInstr ( Computation(s1,i)) holds I = da>0_goto loc & loc <> Next
(IC Computation(s1,i)) implies ( Computation(s1,i).da > 0 iff Computation(s2,i)
  .da > 0)
proof
  let p be autonomic non NAT-defined FinPartState of SCM, s1, s2 be State of
  SCM such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Data-Location, loc be Instruction-Location of
  SCM, I be Instruction of SCM such that
A2: I = CurInstr ( Computation(s1,i));
  set Cs2i1 = Computation(s2,i+1);
  set Cs1i1 = Computation(s1,i+1);
A3: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: (Cs1i1|dom p).IC SCM = Cs1i1.IC SCM & (Cs2i1|dom p).IC SCM = Cs2i1.IC
  SCM by Th84,FUNCT_1:72;
A6: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A7: I = da>0_goto loc and
A8: loc <> Next (IC Computation(s1,i));
A9: I = CurInstr ( Computation(s2,i)) by A1,A2,Th87;
A10: now
    assume that
A11: Computation(s2,i).da > 0 and
A12: Computation(s1,i).da <= 0;
    Cs2i1.IC SCM = loc by A9,A6,A7,A11,AMI_3:15;
    hence contradiction by A2,A4,A5,A3,A7,A8,A12,AMI_3:15;
  end;
A13: IC Cs1i = IC Cs2i by A1,A2,Th87;
  now
    assume that
A14: Computation(s1,i).da > 0 and
A15: Computation(s2,i).da <= 0;
    Cs1i1.IC SCM = loc by A2,A4,A7,A14,AMI_3:15;
    hence contradiction by A13,A9,A6,A5,A3,A7,A8,A15,AMI_3:15;
  end;
  hence thesis by A10;
end;

