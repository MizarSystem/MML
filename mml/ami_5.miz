:: On the Decomposition of the States of SCM
::  by Yasushi Tanaka
::
:: Received November 23, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies BOOLE, NAT_1, ARYTM_1, FUNCT_1, RELAT_1, FUNCT_4,
      AMI_3, AMI_1, AMI_2, GR_CY_1, FINSEQ_1, FINSET_1, TARSKI, CAT_1,
      FUNCOP_1, MCART_1, ORDINAL2, QC_LANG1, AMI_4, AMI_5, INT_1;
 notations TARSKI, XBOOLE_0, SETFAM_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      CARD_1, ZFMISC_1, CARD_3, MCART_1, DOMAIN_1, RELAT_1, FUNCT_1, FUNCT_2,
      FUNCT_4, INT_1, NAT_1, NAT_D, STRUCT_0, FINSET_1, FINSEQ_1,
      AMI_1, AMI_2, AMI_3, AMI_4, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, NAT_1, NAT_D, FINSEQ_4, AMI_2,
      AMI_4;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1,
      ARYTM_3, FRAENKEL, NUMBERS, XREAL_0, INT_1, FINSEQ_1, CARD_3, STRUCT_0,
      AMI_1, AMI_2, AMI_3, FINSET_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions AMI_1, TARSKI, AMI_3, WELLORD2, FUNCT_1, XBOOLE_0, FUNCOP_1,
      CARD_1, AMI_2;
 theorems AMI_1, AMI_2, AMI_3, GRFUNC_1, NAT_1, SCM_1, CQC_LANG, TARSKI,
      FUNCOP_1, FUNCT_4, FUNCT_1, MCART_1, GR_CY_1, FUNCT_2, CARD_3,
      FINSET_1, ZFMISC_1, AMI_4, ENUMSET1, CARD_1, CARD_4, RELAT_1, ORDINAL1,
      XBOOLE_0, XBOOLE_1, NAT_D, SYSREL;
 schemes FUNCT_2;

begin

canceled 17;

reserve x,y for set;

theorem Th18:
 for dl being Data-Location ex i being Element of NAT
  st dl = dl.i
 proof
  let dl be Data-Location;
      dl in SCM-Data-Loc by AMI_3:def 2;
  then consider x,y such that
W1: x in {1} and
W2: y in NAT and
W3: dl = [x,y] by ZFMISC_1:103;
  reconsider k = y as Element of NAT by W2;
  A1: dl = [1,k] by W1,W3,TARSKI:def 1;
  take k;
  thus dl = dl.k by A1;
 end;

theorem Th19:
 for il being Instruction-Location of SCM ex i being Element of NAT
  st il = il.i
 proof
  let il be Instruction-Location of SCM;
  consider k being Element of NAT such that
  A1:  il = k;
  take k;
  thus il = il.k by A1;
 end;

theorem Th20:
 for dl being Data-Location holds
  dl <> IC SCM
  proof
    let dl be Data-Location;
    consider i being Element of NAT such that
A1:  dl = dl.i by Th18;
    thus thesis by A1,AMI_3:57;
  end;

canceled;

theorem Th22:
 for il being Instruction-Location of SCM,
     dl being Data-Location holds
  il <> dl
  proof
   let il be Instruction-Location of SCM,
       dl be Data-Location;
   consider i being Element of NAT such that A1: il = il.i by Th19;
   consider j being Element of NAT such that A2: dl = dl.j by Th18;
   thus il <> dl by A1,A2,AMI_3:56;
  end;

reserve i, j, k for Element of NAT;

theorem Th23:
 the carrier of SCM = {IC SCM} \/ SCM-Data-Loc \/ SCM-Instr-Loc
               by AMI_3:4;

theorem
     for s being State of SCM,
     d being Data-Location,
     l being Instruction-Location of SCM
  holds d in dom s & l in dom s
   proof
    let s be State of SCM,
        d be Data-Location,
        l be Instruction-Location of SCM;
        d in SCM-Data-Loc by AMI_3:def 2;
    then d in {IC SCM} \/ SCM-Data-Loc by XBOOLE_0:def 2;
    then d in {IC SCM} \/ SCM-Data-Loc \/ SCM-Instr-Loc by XBOOLE_0:def 2;
   hence d in dom s by Th23,AMI_1:79;
       l in {IC SCM} \/ SCM-Data-Loc \/ SCM-Instr-Loc by XBOOLE_0:def 2;
  hence l in dom s by Th23,AMI_1:79;
 end;

canceled;

theorem
     for s1,s2 being State of SCM
       st IC(s1) = IC(s2) &
          (for a being Data-Location holds s1.a = s2.a) &
          (for i being Instruction-Location of SCM holds s1.i = s2.i)
  holds s1 = s2
   proof
    let s1,s2 be State of SCM such that
A1:  IC(s1) = IC(s2) and
A2:  (for a being Data-Location holds s1.a = s2.a) and
A3:  (for i being Instruction-Location of SCM holds s1.i = s2.i);
     consider g1 being Function such that
A4:  s1 = g1 & dom g1 = dom SCM-OK &
     for x being set st x in dom SCM-OK holds g1.x in SCM-OK.x by CARD_3:def 5;
     consider g2 being Function such that
A5:   s2 = g2 & dom g2 = dom SCM-OK &
      for x being set st x in dom SCM-OK holds g2.x in
 SCM-OK.x by CARD_3:def 5;
A6:   SCM-Memory = dom g1 & SCM-Memory = dom g2
              by A4,A5,FUNCT_2:def 1;
        now let x be set such that
A7:  x in SCM-Memory;
     A8: x in {IC SCM} \/
 SCM-Data-Loc or x in SCM-Instr-Loc by A7,Th23,XBOOLE_0:def 2;
     per cases by A8,XBOOLE_0:def 2;
     suppose x in {IC SCM};
then x = IC SCM by TARSKI:def 1;
     hence g1.x = g2.x by A4,A5,A1;
     end;
     suppose x in SCM-Data-Loc;
     then x is Data-Location by AMI_3:def 2;
     hence g1.x = g2.x by A2,A4,A5;
     end;
     suppose
    x in SCM-Instr-Loc;
      then reconsider l = x as Instruction-Location of SCM by AMI_1:def 4;
       g1.l = g2.l by A3,A4,A5;
     hence g1.x = g2.x;
    end;
    end;
    hence s1 = s2 by A4,A5,A6,FUNCT_1:9;
   end;

theorem Th27:
 for s being State of SCM holds SCM-Data-Loc c= dom s
  proof
   let s be State of SCM;
       SCM-Data-Loc c= SCM-Data-Loc \/ SCM-Instr-Loc by XBOOLE_1:10;
   then SCM-Data-Loc c= {IC SCM} \/ (SCM-Data-Loc \/ SCM-Instr-Loc) by
XBOOLE_1:10;
   then SCM-Data-Loc c= {IC SCM} \/ SCM-Data-Loc \/ SCM-Instr-Loc by XBOOLE_1:
4
;
  hence SCM-Data-Loc c= dom s by Th23,AMI_1:79;
end;

theorem Th28:
 for s being State of SCM holds SCM-Instr-Loc c= dom s
  proof
   let s be State of SCM;
       SCM-Instr-Loc c= {IC SCM} \/ SCM-Data-Loc \/ SCM-Instr-Loc by XBOOLE_1:
10
;
  hence SCM-Instr-Loc c= dom s by Th23,AMI_1:79;
end;

theorem
     for s being State of SCM holds dom (s|SCM-Data-Loc) = SCM-Data-Loc
proof
 let s be State of SCM;
      SCM-Data-Loc c= dom s by Th27;
 hence dom (s|SCM-Data-Loc) = SCM-Data-Loc by RELAT_1:91;
end;

theorem
     for s being State of SCM holds dom (s|SCM-Instr-Loc) = SCM-Instr-Loc
proof
 let s be State of SCM;
      SCM-Instr-Loc c= dom s by Th28;
 hence dom (s|SCM-Instr-Loc) = SCM-Instr-Loc by RELAT_1:91;
end;

theorem Th31:
 SCM-Data-Loc is not finite
 proof
 deffunc F(Element of NAT) = [1,$1];
 1 in {1} by TARSKI:def 1;
 then
A: for x being Element of NAT holds F(x) is Element of SCM-Data-Loc
           by ZFMISC_1:106;
 consider f being Function of NAT, SCM-Data-Loc such that
A1: for x being Element of NAT holds f.x = F(x) from FUNCT_2:sch 9(A);
A2: dom f = NAT by FUNCT_2:def 1;
    NAT,SCM-Data-Loc are_equipotent
    proof
     take f;
     thus f is one-to-one
      proof
       let x1,x2 be set such that A3: x1 in dom f and
                                  A4: x2 in dom f and
                                  A5: f.x1 = f.x2;
        reconsider k1 = x1 ,k2 = x2 as Element of NAT by A3,A4,FUNCT_2:def 1;
            dl.k1 = f.k1 by A1
                  .= dl.k2 by A1,A5;
        hence x1 = x2 by AMI_3:52;
      end;
     thus dom f = NAT by FUNCT_2:def 1;
     thus rng f c= SCM-Data-Loc
      proof
       let y be set; assume y in rng f;
 then consider x be set such that A6: x in dom f and
                                   A7: y = f.x by FUNCT_1:def 5;
       reconsider x as Element of NAT by A6,FUNCT_2:def 1;
           y = dl.x by A1,A7;
       hence y in SCM-Data-Loc by AMI_3:def 2;
      end;
     thus SCM-Data-Loc c= rng f
      proof
       let y be set such that A8: y in SCM-Data-Loc;
        reconsider d = y as Data-Location by A8,AMI_3:def 2;
       consider k being Element of NAT such that A9: d = dl.k by Th18;
           y = f.k by A9,A1;
       hence y in rng f by A2,FUNCT_1:def 5;
      end;
    end;
    hence SCM-Data-Loc is not finite by CARD_1:68,CARD_4:15;
 end;

theorem Th32:
 the Instruction-Locations of SCM is not finite
 proof
 deffunc F(Element of NAT) = $1;
 consider f being Function of NAT, NAT;
    thus the Instruction-Locations of SCM is not finite by CARD_4:15;
 end;

registration
  cluster SCM-Data-Loc -> infinite;
coherence by Th31;
  cluster the Instruction-Locations of SCM -> infinite;
coherence by Th32;
end;

registration
 let I be Instruction of SCM;
 cluster InsCode I -> natural;
 coherence
  proof
 dom [: NAT, (union {INT} \/ SCM-Memory)* :] = NAT by SYSREL:12;
then A1:  dom the Instructions of SCM c= NAT by RELAT_1:25;
    InsCode I in dom the Instructions of SCM;
   hence thesis by A1,ORDINAL1:def 13;
  end;
end;

definition
 canceled;
 let I be Instruction of SCM;
 func @I -> Element of SCM-Instr equals
   I;
 coherence;
end;

definition
 let loc be Element of SCM-Instr-Loc;
 func loc@ -> Instruction-Location of SCM equals
   loc;
 coherence by AMI_1:def 4;
end;

definition
 let loc be Element of SCM-Data-Loc;
 func loc@ -> Data-Location equals
  loc;
 coherence by AMI_3:def 2;
end;

reserve I,J,K for Element of Segm 9,
        a,a1 for Element of SCM-Instr-Loc,
        b,b1,c for Element of SCM-Data-Loc;

canceled 3;

theorem Th36:
 for l being Instruction of SCM holds
  InsCode(l) <= 8
 proof let l be Instruction of SCM;
    l in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/
       { [K,<*a1,b1*>] : K in { 7,8 } } or
       l in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 2;
   then A1: l in { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } or
    l in { [K,<*a1,b1*>] : K in { 7,8 } } or
    l in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:def 2;
  per cases by A1, XBOOLE_0:def 2;
  suppose l in { [SCM-Halt,{}] };
   then l = [SCM-Halt,{}] by TARSKI:def 1;
   then l`1 = 0 by MCART_1:7;
  hence InsCode(l) <= 8;
  end;
  suppose l in { [J,<*a*>] : J = 6 };
   then ex J,a st l = [J,<*a*>] & J = 6;
   then l`1 = 6 by MCART_1:7;
  hence InsCode(l) <= 8;
  end;
  suppose l in { [K,<*a1,b1*>] : K in { 7,8 } };
   then ex K,a1,b1 st l = [K,<*a1,b1*>] & K in { 7,8 };
   then l`1 in { 7,8 } by MCART_1:7;
   then l`1 = 7 or l`1 = 8 by TARSKI:def 2;
  hence InsCode(l) <= 8;
  end;
  suppose l in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
   then ex I,b,c st l = [I,<*b,c*>] & I in { 1,2,3,4,5};
   then l`1 in { 1,2,3,4,5} by MCART_1:7;
   then l`1 = 1 or l`1 = 2 or l`1 = 3 or l`1 = 4 or l`1 = 5 by ENUMSET1:def 3;
  hence InsCode(l) <= 8;
  end;
 end;

reserve a, b for Data-Location,
        loc for Instruction-Location of SCM;

theorem Th37:
 InsCode (halt SCM) = 0 by AMI_3:71,MCART_1:7;

reserve I,J,K for Element of Segm 9,
        a,a1 for Element of SCM-Instr-Loc,
        b,b1,c for Element of SCM-Data-Loc,
        da,db for Data-Location,
        loc for Instruction-Location of SCM;

canceled 8;

theorem Th46:
 for ins being Instruction of SCM st InsCode ins = 0
  holds ins = halt SCM
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 0;
A2: now assume ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
 then consider I,b,c such that A3: ins = [I,<*b,c*>] and
                                   A4: I in { 1,2,3,4,5};
         InsCode ins = I by A3,MCART_1:7;
     hence contradiction by A1,A4,ENUMSET1:def 3;
    end;
A5: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A6: ins = [K,<*a1,b1*>] and
                                     A7: K in { 7,8 };
         InsCode ins = K by A6,MCART_1:7;
     hence contradiction by A1,A7,TARSKI:def 2;
    end;

A8: now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A9: ins = [J,<*a*>] and
                                 A10: J = 6; thus contradiction by A1,A9,A10,
MCART_1:7;
    end;
         ins in { [SCM-Halt,{}] } \/
         { [J,<*a*>] : J = 6 } \/
         { [K,<*a1,b1*>] : K in { 7,8 } } by A2,XBOOLE_0:def 2;
     then ins in { [SCM-Halt,{}] } \/
         { [J,<*a*>] : J = 6 } by A5,XBOOLE_0:def 2;
     then ins in {[SCM-Halt,{}]} by A8,XBOOLE_0:def 2;
     hence ins = halt SCM by AMI_3:71,TARSKI:def 1;
   end;

theorem Th47:
 for ins being Instruction of SCM st InsCode ins = 1
  holds ex da,db st ins = da:=db
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 1;
A2: not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A4: ins = [K,<*a1,b1*>] and
                                     A5: K in { 7,8 };
         InsCode ins = K by A4,MCART_1:7;
     hence contradiction by A1,A5,TARSKI:def 2;
    end;
    now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A6: ins = [J,<*a*>] and
                                 A7: J = 6; thus contradiction by A1,A6,A7,
MCART_1:7;
    end;

   then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } by A2,XBOOLE_0:def 2;
then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } \/
             { [K,<*a1,b1*>] : K in { 7,8 } } by A3,XBOOLE_0:def 2;
     then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:
def 2;
 then consider I,b,c such that A8: ins = [I,<*b,c*>] and
                                            I in { 1,2,3,4,5};
     reconsider da = b@ ,db = c@ as Data-Location;
     take da,db;
     thus ins = da:=db by A1,A8,MCART_1:7;
   end;

theorem Th48:
 for ins being Instruction of SCM st InsCode ins = 2
  holds ex da,db st ins = AddTo(da,db)
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 2;
A2: not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A4: ins = [K,<*a1,b1*>] and
                                     A5: K in { 7,8 };
         InsCode ins = K by A4,MCART_1:7;
     hence contradiction by A1,A5,TARSKI:def 2;
    end;
    now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A6: ins = [J,<*a*>] and
                                 A7: J = 6; thus contradiction by A1,A6,A7,
MCART_1:7;
    end;

   then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } by A2,XBOOLE_0:def 2;
then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } \/
             { [K,<*a1,b1*>] : K in { 7,8 } } by A3,XBOOLE_0:def 2;
     then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:
def 2;
 then consider I,b,c such that A8: ins = [I,<*b,c*>] and
                                            I in { 1,2,3,4,5};
     reconsider da = b@ ,db = c@ as Data-Location;
     take da,db;
    thus ins = AddTo(da,db) by A1,A8,MCART_1:7;
   end;

theorem Th49:
 for ins being Instruction of SCM st InsCode ins = 3
  holds ex da,db st ins = SubFrom(da,db)
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 3;
A2: not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A4: ins = [K,<*a1,b1*>] and
                                     A5: K in { 7,8 };
         InsCode ins = K by A4,MCART_1:7;
     hence contradiction by A1,A5,TARSKI:def 2;
    end;
    now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A6: ins = [J,<*a*>] and
                                 A7: J = 6; thus contradiction by A1,A6,A7,
MCART_1:7;
    end;

   then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } by A2,XBOOLE_0:def 2;
then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } \/
             { [K,<*a1,b1*>] : K in { 7,8 } } by A3,XBOOLE_0:def 2;
     then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:
def 2;
 then consider I,b,c such that A8: ins = [I,<*b,c*>] and
                                            I in { 1,2,3,4,5};
     reconsider da = b@ ,db = c@ as Data-Location;
     take da,db;
    thus ins = SubFrom(da,db) by A1,A8,MCART_1:7;
   end;

theorem Th50:
 for ins being Instruction of SCM st InsCode ins = 4
  holds ex da,db st ins = MultBy(da,db)
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 4;
A2: not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A4: ins = [K,<*a1,b1*>] and
                                     A5: K in { 7,8 };
         InsCode ins = K by A4,MCART_1:7;
     hence contradiction by A1,A5,TARSKI:def 2;
    end;
    now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A6: ins = [J,<*a*>] and
                                 A7: J = 6; thus contradiction by A1,A6,A7,
MCART_1:7;
    end;

   then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } by A2,XBOOLE_0:def 2;
then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } \/
             { [K,<*a1,b1*>] : K in { 7,8 } } by A3,XBOOLE_0:def 2;
     then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:
def 2;
 then consider I,b,c such that A8: ins = [I,<*b,c*>] and
                                            I in { 1,2,3,4,5};
     reconsider da = b@ ,db = c@ as Data-Location;
     take da,db;
    thus ins = MultBy(da,db) by A1,A8,MCART_1:7;
   end;

theorem Th51:
 for ins being Instruction of SCM st InsCode ins = 5
  holds ex da,db st ins = Divide(da,db)
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 5;
A2: not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A4: ins = [K,<*a1,b1*>] and
                                     A5: K in { 7,8 };
         InsCode ins = K by A4,MCART_1:7;
     hence contradiction by A1,A5,TARSKI:def 2;
    end;
    now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A6: ins = [J,<*a*>] and
                                 A7: J = 6; thus contradiction by A1,A6,A7,
MCART_1:7;
    end;

   then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } by A2,XBOOLE_0:def 2;
then not ins in { [SCM-Halt,{}] } \/
             { [J,<*a*>] : J = 6 } \/
             { [K,<*a1,b1*>] : K in { 7,8 } } by A3,XBOOLE_0:def 2;
     then ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} } by XBOOLE_0:
def 2;
 then consider I,b,c such that A8: ins = [I,<*b,c*>] and
                                            I in { 1,2,3,4,5};
     reconsider da = b@ ,db = c@ as Data-Location;
     take da,db;
    thus ins = Divide (da,db) by A1,A8,MCART_1:7;
   end;

theorem Th52:
 for ins being Instruction of SCM st InsCode ins = 6
  holds ex loc st ins = goto loc
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 6;
A2: not ins in { [SCM-Halt,{}] } by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [K,<*a1,b1*>] : K in { 7,8 } };
 then consider K,a1,b1 such that A4: ins = [K,<*a1,b1*>] and
                                     A5: K in { 7,8 };
         InsCode ins = K by A4,MCART_1:7;
     hence contradiction by A1,A5,TARSKI:def 2;
    end;
    now assume ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
 then consider I,b,c such that A6: ins = [I,<*b,c*>] and
                                   A7: I in { 1,2,3,4,5};
         InsCode ins = I by A6,MCART_1:7;
     hence contradiction by A1,A7,ENUMSET1:def 3;
    end;
     then ins in { [SCM-Halt,{}] } \/
           { [J,<*a*>] : J = 6 } \/
           { [K,<*a1,b1*>] : K in { 7,8 } } by XBOOLE_0:def 2;
     then ins in { [SCM-Halt,{}] } \/
           { [J,<*a*>] : J = 6 } by A3,XBOOLE_0:def 2;
     then ins in { [J,<*a*>] : J = 6 } by A2,XBOOLE_0:def 2;
 then consider J,a such that A8: ins = [J,<*a*>] and
                                 A9: J = 6;
     reconsider loc = a@ as Instruction-Location of SCM;
     take loc;
     thus ins = goto loc by A8,A9;
   end;

theorem Th53:
 for ins being Instruction of SCM st InsCode ins = 7
  holds ex loc,da st ins = da=0_goto loc
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 7;
A2: not ins in { [SCM-Halt,{}] }
      by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A4: ins = [J,<*a*>] and
                                 A5: J = 6; thus contradiction by A1,A4,A5,
MCART_1:7;
    end;
A6: now assume ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
 then consider I,b,c such that A7: ins = [I,<*b,c*>] and
                                   A8: I in { 1,2,3,4,5};
         InsCode ins = I by A7,MCART_1:7;
     hence contradiction by A1,A8,ENUMSET1:def 3;
    end;

A9: not ins in { [SCM-Halt,{}] } \/
            { [J,<*a*>] : J = 6 } by A2,A3,XBOOLE_0:def 2;
         ins in { [SCM-Halt,{}] } \/
           { [J,<*a*>] : J = 6 } \/
           { [K,<*a1,b1*>] : K in { 7,8 } } by A6,XBOOLE_0:def 2;
     then ins in { [K,<*a1,b1*>] : K in { 7,8 } } by A9,XBOOLE_0:def 2;
 then consider K,a1,b1 such that A10: ins = [K,<*a1,b1*>] and
                                              K in { 7,8 };
     reconsider loc = a1@ as Instruction-Location of SCM;
     reconsider da = b1@ as Data-Location;
     take loc,da;
    thus ins = da=0_goto loc by A1,A10,MCART_1:7;
   end;

theorem Th54:
 for ins being Instruction of SCM st InsCode ins = 8
  holds ex loc,da st ins = da>0_goto loc
   proof
    let ins be Instruction of SCM such that
A1: InsCode ins = 8;
A2: not ins in { [SCM-Halt,{}] }
     by A1,Th37,AMI_3:71,TARSKI:def 1;
A3: now assume ins in { [J,<*a*>] : J = 6 };
 then consider J,a such that A4: ins = [J,<*a*>] and
                                 A5: J = 6; thus contradiction by A1,A4,A5,
MCART_1:7;
    end;
A6: now assume ins in { [I,<*b,c*>] : I in { 1,2,3,4,5} };
 then consider I,b,c such that A7: ins = [I,<*b,c*>] and
                                   A8: I in { 1,2,3,4,5};
         InsCode ins = I by A7,MCART_1:7;
     hence contradiction by A1,A8,ENUMSET1:def 3;
    end;
A9: not ins in { [SCM-Halt,{}] } \/
            { [J,<*a*>] : J = 6 } by A2,A3,XBOOLE_0:def 2;
         ins in { [SCM-Halt,{}] } \/
           { [J,<*a*>] : J = 6 } \/
           { [K,<*a1,b1*>] : K in { 7,8 } } by A6,XBOOLE_0:def 2;
     then ins in { [K,<*a1,b1*>] : K in { 7,8 } } by A9,XBOOLE_0:def 2;
 then consider K,a1,b1 such that A10: ins = [K,<*a1,b1*>] and
                                              K in { 7,8 };
     reconsider loc = a1@ as Instruction-Location of SCM;
     reconsider da = b1@ as Data-Location;
     take loc,da;
    thus ins = da>0_goto loc by A1,A10,MCART_1:7;
   end;

theorem
     for loc being Instruction-Location of SCM
  holds (@(goto loc)) jump_address = loc
  proof
   let loc be Instruction-Location of SCM;
   reconsider roku=6 as Element of Segm 9 by GR_CY_1:10;
   reconsider mk=loc as Element of SCM-Instr-Loc;
       @(goto loc) = [ roku, <*mk*>];
   hence (@(goto loc)) jump_address = loc by AMI_2:24;
  end;

theorem
     for loc being Instruction-Location of SCM,
       a being Data-Location
  holds (@(a=0_goto loc)) cjump_address = loc &
        (@(a=0_goto loc)) cond_address = a
  proof
   let loc be Instruction-Location of SCM,
         a be Data-Location;
   reconsider nana=7 as Element of Segm 9 by GR_CY_1:10;
   reconsider mk=loc as Element of SCM-Instr-Loc;
   reconsider aa=a as Element of SCM-Data-Loc by AMI_3:def 2;
       @(a=0_goto loc) = [ nana, <*mk,aa*>];
   hence (@(a=0_goto loc)) cjump_address = loc &
          (@(a=0_goto loc)) cond_address = a by AMI_2:25;
  end;

theorem
     for loc being Instruction-Location of SCM,
       a being Data-Location
  holds (@(a>0_goto loc)) cjump_address = loc &
        (@(a>0_goto loc)) cond_address = a
  proof
   let loc be Instruction-Location of SCM,
         a be Data-Location;
   reconsider hachi=8 as Element of Segm 9 by GR_CY_1:10;
   reconsider mk=loc as Element of SCM-Instr-Loc;
   reconsider aa=a as Element of SCM-Data-Loc by AMI_3:def 2;
       @(a>0_goto loc) = [ hachi, <*mk,aa*>];
   hence (@(a>0_goto loc)) cjump_address = loc &
          (@(a>0_goto loc)) cond_address = a by AMI_2:25;
  end;

theorem Th58:
  for s1,s2 being State of SCM st
       (s1 | (SCM-Data-Loc \/ {IC SCM})) = (s2 | (SCM-Data-Loc \/ {IC SCM}))
  for l being Instruction of SCM
   holds
      Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
    = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM})
    proof
     let s1,s2 be State of SCM such that
A1:   (s1 | (SCM-Data-Loc \/ {IC SCM})) = (s2 | (SCM-Data-Loc \/ {IC SCM}));
         IC SCM in {IC SCM} by TARSKI:def 1;
then A2:  IC SCM in (SCM-Data-Loc \/ {IC SCM}) by XBOOLE_0:def 2;
     A3:  (SCM-Data-Loc \/ {IC SCM}) c= the carrier of SCM by Th23,XBOOLE_1:7
;
      then (SCM-Data-Loc \/ {IC SCM}) c= dom s1 by AMI_1:79;
then A4:   IC SCM in dom (s1 | (SCM-Data-Loc \/ {IC SCM})) by A2,RELAT_1:91;
          (SCM-Data-Loc \/ {IC SCM}) c= dom s2 by A3,AMI_1:79;
then A5:   IC SCM in dom (s2 | (SCM-Data-Loc \/ {IC SCM})) by A2,RELAT_1:91;

A6:   IC s1 = (s2 | (SCM-Data-Loc \/ {IC SCM})).IC SCM by A1,A4,FUNCT_1:70
            .= IC s2 by A5,FUNCT_1:70;
     let l be Instruction of SCM;
A7:  dom Exec(l,s1) = the carrier of SCM by AMI_1:79;
A8:  dom Exec(l,s2) = the carrier of SCM by AMI_1:79;
A9: SCM-Data-Loc c= (SCM-Data-Loc \/ {IC SCM}) by XBOOLE_1:7;
A10:  InsCode(l) <= 8 by Th36;

     per cases by A10,NAT_1:33;
     suppose InsCode (l) = 0;
 then A11: l = halt SCM by Th46;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
          = s2 | (SCM-Data-Loc \/ {IC SCM}) by A1,AMI_1:def 8
         .= Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A11,AMI_1:def 8;
     end;
     suppose InsCode (l) = 1;
      then consider da,db such that A12: l = da:=db by Th47;
            da in SCM-Data-Loc by AMI_3:def 2;
then A13:     SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
                    .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
A14:  dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A7,RELAT_1:91;
A15:  dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A8,RELAT_1:91;
          for x being set st x in ((SCM-Data-Loc) \ {da})
       holds (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
       proof
        let x be set;
        assume A16: x in ((SCM-Data-Loc) \ {da});
then A17:     x in SCM-Data-Loc by XBOOLE_0:def 4;
A18:     not x in {da} by A16,XBOOLE_0:def 4;
 reconsider a = x as Data-Location by A17,AMI_3:def 2;
A19:      a <> da by A18,TARSKI:def 1;
A20:     a in (SCM-Data-Loc \/ {IC SCM}) by A17,XBOOLE_0:def 2;
        thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s1)).a by A16,FUNCT_1:72
          .= s1.a by A12,A19,AMI_3:8
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A20,FUNCT_1:72
          .= s2.a by A1,A20,FUNCT_1:72
          .= (Exec (l,s2)).a by A12,A19,AMI_3:8
          .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A16,FUNCT_1:72;
       end;
 then A21:  Exec (l,s1) | (SCM-Data-Loc \ {da} )
    = Exec (l,s2) | (SCM-Data-Loc \ {da} )
     by A14,A15,FUNCT_1:9;
 A22: db in SCM-Data-Loc by AMI_3:def 2;
        Exec (l,s1).da = s1.db by A12,AMI_3:8
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A9,A22,FUNCT_1:72
          .= s2.db by A1,A9,A22,FUNCT_1:72
          .= Exec (l,s2).da by A12,AMI_3:8;
then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A7,A8,GRFUNC_1:90;
then A23:       Exec (l,s1) | SCM-Data-Loc
             = Exec (l,s2) | SCM-Data-Loc by A13,A21,RELAT_1:185;

           Exec (l,s1).IC SCM = Next IC s1 by A12,AMI_3:8
                         .= Exec (l,s2).IC SCM by A6,A12,AMI_3:8;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
                 by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A23,RELAT_1:185;
     end;
     suppose InsCode (l) = 2;
      then consider da,db such that A24: l = AddTo(da,db) by Th48;
            da in SCM-Data-Loc by AMI_3:def 2;
then A25:     SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
                    .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
A26:  dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A7,RELAT_1:91;
A27:  dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A8,RELAT_1:91;
          for x being set st x in ((SCM-Data-Loc) \ {da})
       holds (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
       proof
        let x be set;
        assume A28: x in ((SCM-Data-Loc) \ {da});
then A29:     x in SCM-Data-Loc by XBOOLE_0:def 4;
A30:     not x in {da} by A28,XBOOLE_0:def 4;
 reconsider a = x as Data-Location by A29,AMI_3:def 2;
A31:      a <> da by A30,TARSKI:def 1;
A32:     a in (SCM-Data-Loc \/ {IC SCM}) by A29,XBOOLE_0:def 2;
        thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s1)).a by A28,FUNCT_1:72
          .= s1.a by A24,A31,AMI_3:9
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A32,FUNCT_1:72
          .= s2.a by A1,A32,FUNCT_1:72
          .= (Exec (l,s2)).a by A24,A31,AMI_3:9
          .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A28,FUNCT_1:72;
       end;
 then A33:  Exec (l,s1) | (SCM-Data-Loc \ {da} )
    = Exec (l,s2) | (SCM-Data-Loc \ {da} )
     by A26,A27,FUNCT_1:9;
 A34: db in SCM-Data-Loc by AMI_3:def 2;
 A35: da in SCM-Data-Loc by AMI_3:def 2;
then A36:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A35,FUNCT_1:72;
A37:  s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A9,A34,FUNCT_1:72
          .= s2.db by A1,A9,A34,FUNCT_1:72;
           Exec (l,s1).da = s1.da + s1.db by A24,AMI_3:9
          .= Exec (l,s2).da by A24,A36,A37,AMI_3:9;
then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A7,A8,GRFUNC_1:90;
then A38:       Exec (l,s1) | SCM-Data-Loc
             = Exec (l,s2) | SCM-Data-Loc by A25,A33,RELAT_1:185;
           Exec (l,s1).IC SCM = Next IC s1 by A24,AMI_3:9
                         .= Exec (l,s2).IC SCM by A6,A24,AMI_3:9;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
        by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A38,RELAT_1:185;
     end;
     suppose InsCode (l) = 3;
      then consider da,db such that A39: l = SubFrom(da,db) by Th49;
            da in SCM-Data-Loc by AMI_3:def 2;
then A40:     SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
                    .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
A41:  dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A7,RELAT_1:91;
A42:  dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A8,RELAT_1:91;
          for x being set st x in ((SCM-Data-Loc) \ {da})
       holds (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
       proof
        let x be set;
        assume A43: x in ((SCM-Data-Loc) \ {da});
then A44:     x in SCM-Data-Loc by XBOOLE_0:def 4;
A45:     not x in {da} by A43,XBOOLE_0:def 4;
 reconsider a = x as Data-Location by A44,AMI_3:def 2;
A46:      a <> da by A45,TARSKI:def 1;
A47:     a in (SCM-Data-Loc \/ {IC SCM}) by A44,XBOOLE_0:def 2;
        thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s1)).a by A43,FUNCT_1:72
          .= s1.a by A39,A46,AMI_3:10
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A47,FUNCT_1:72
          .= s2.a by A1,A47,FUNCT_1:72
          .= (Exec (l,s2)).a by A39,A46,AMI_3:10
          .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A43,FUNCT_1:72;
       end;
 then A48:  Exec (l,s1) | (SCM-Data-Loc \ {da} )
    = Exec (l,s2) | (SCM-Data-Loc \ {da} )
     by A41,A42,FUNCT_1:9;
 A49: db in SCM-Data-Loc by AMI_3:def 2;
 A50: da in SCM-Data-Loc by AMI_3:def 2;
then A51:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A50,FUNCT_1:72;
A52:  s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A9,A49,FUNCT_1:72
          .= s2.db by A1,A9,A49,FUNCT_1:72;
          Exec (l,s1).da = s1.da - s1.db by A39,AMI_3:10
          .= Exec (l,s2).da by A39,A51,A52,AMI_3:10;
then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A7,A8,GRFUNC_1:90;
then A53:       Exec (l,s1) | SCM-Data-Loc
             = Exec (l,s2) | SCM-Data-Loc by A40,A48,RELAT_1:185;

           Exec (l,s1).IC SCM = Next IC s1 by A39,AMI_3:10
                         .= Exec (l,s2).IC SCM by A6,A39,AMI_3:10;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
        by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A53,RELAT_1:185;
     end;
     suppose InsCode (l) = 4;
      then consider da,db such that A54: l = MultBy(da,db) by Th50;
            da in SCM-Data-Loc by AMI_3:def 2;
then A55:     SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
                    .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
A56:  dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A7,RELAT_1:91;
A57:  dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A8,RELAT_1:91;
          for x being set st x in ((SCM-Data-Loc) \ {da})
       holds (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
       proof
        let x be set;
        assume A58: x in ((SCM-Data-Loc) \ {da});
then A59:     x in SCM-Data-Loc by XBOOLE_0:def 4;
A60:     not x in {da} by A58,XBOOLE_0:def 4;
 reconsider a = x as Data-Location by A59,AMI_3:def 2;
A61:      a <> da by A60,TARSKI:def 1;
A62:     a in (SCM-Data-Loc \/ {IC SCM}) by A59,XBOOLE_0:def 2;
        thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s1)).a by A58,FUNCT_1:72
          .= s1.a by A54,A61,AMI_3:11
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A62,FUNCT_1:72
          .= s2.a by A1,A62,FUNCT_1:72
          .= (Exec (l,s2)).a by A54,A61,AMI_3:11
          .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A58,FUNCT_1:72;
       end;
 then A63:  Exec (l,s1) | (SCM-Data-Loc \ {da} )
    = Exec (l,s2) | (SCM-Data-Loc \ {da} )
     by A56,A57,FUNCT_1:9;
 A64: db in SCM-Data-Loc by AMI_3:def 2;
 A65: da in SCM-Data-Loc by AMI_3:def 2;
then A66:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A65,FUNCT_1:72;
A67:  s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A9,A64,FUNCT_1:72
          .= s2.db by A1,A9,A64,FUNCT_1:72;
         Exec (l,s1).da = s1.da * s1.db by A54,AMI_3:11
          .= Exec (l,s2).da by A54,A66,A67,AMI_3:11;
then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A7,A8,GRFUNC_1:90;
then A68:       Exec (l,s1) | SCM-Data-Loc
             = Exec (l,s2) | SCM-Data-Loc by A55,A63,RELAT_1:185;

           Exec (l,s1).IC SCM = Next IC s1 by A54,AMI_3:11
                         .= Exec (l,s2).IC SCM by A6,A54,AMI_3:11;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
        by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A68,RELAT_1:185;
     end;
     suppose InsCode (l) = 5;
      then consider da,db such that A69: l = Divide(da,db) by Th51;
       thus thesis
        proof per cases;
        suppose A70: da=db;
            da in SCM-Data-Loc by AMI_3:def 2;
then A71:     SCM-Data-Loc = SCM-Data-Loc \/ {da} by ZFMISC_1:46
                    .= (SCM-Data-Loc \ {da} ) \/ {da} by XBOOLE_1:39;
A72:  dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A7,RELAT_1:91;
A73:  dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da})) = (SCM-Data-Loc \ {da})
                            by A8,RELAT_1:91;
          for x being set st x in ((SCM-Data-Loc) \ {da})
       holds (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s2) | (SCM-Data-Loc \ {da})).x
       proof
        let x be set;
        assume A74: x in ((SCM-Data-Loc) \ {da});
then A75:     x in SCM-Data-Loc by XBOOLE_0:def 4;
A76:     not x in {da} by A74,XBOOLE_0:def 4;
 reconsider a = x as Data-Location by A75,AMI_3:def 2;
A77:      a <> da by A76,TARSKI:def 1;
A78:     a in (SCM-Data-Loc \/ {IC SCM}) by A75,XBOOLE_0:def 2;
        thus (Exec (l,s1) | (SCM-Data-Loc \ {da})).x
           = (Exec (l,s1)).a by A74,FUNCT_1:72
          .= s1.a by A69,A70,A77,AMI_3:12
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A78,FUNCT_1:72
          .= s2.a by A1,A78,FUNCT_1:72
          .= (Exec (l,s2)).a by A69,A70,A77,AMI_3:12
          .= (Exec (l,s2) | (SCM-Data-Loc \ {da})).x by A74,FUNCT_1:72;
       end;
 then A79:  Exec (l,s1) | (SCM-Data-Loc \ {da} )
    = Exec (l,s2) | (SCM-Data-Loc \ {da} ) by A72,A73,FUNCT_1:9;
 A80: da in SCM-Data-Loc by AMI_3:def 2;
then A81: s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A80,FUNCT_1:72;
          Exec (l,s1).da = s1.da mod s1.da by A69,A70,AMI_3:12
          .= Exec (l,s2).da by A69,A70,A81,AMI_3:12;
then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A7,A8,GRFUNC_1:90;
then A82:       Exec (l,s1) | SCM-Data-Loc
             = Exec (l,s2) | SCM-Data-Loc by A71,A79,RELAT_1:185;
           Exec (l,s1).IC SCM = Next IC s1 by A69,AMI_3:12
                         .= Exec (l,s2).IC SCM by A6,A69,AMI_3:12;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
        by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A82,RELAT_1:185;
        end;
        suppose A83: da <> db;
A84:    da in SCM-Data-Loc by AMI_3:def 2;
            db in SCM-Data-Loc by AMI_3:def 2;
then A85:     SCM-Data-Loc = SCM-Data-Loc \/ {da,db} by A84,ZFMISC_1:48
                    .= (SCM-Data-Loc \ {da,db} ) \/ {da,db} by XBOOLE_1:39;
A86:  dom ((Exec (l,s1)) | (SCM-Data-Loc \ {da,db})) = (SCM-Data-Loc \ {da
,db})
                            by A7,RELAT_1:91;
A87:  dom ((Exec (l,s2)) | (SCM-Data-Loc \ {da,db})) = (SCM-Data-Loc \ {da
,db})
                            by A8,RELAT_1:91;
          for x being set st x in ((SCM-Data-Loc) \ {da,db})
       holds (Exec (l,s1) | (SCM-Data-Loc \ {da,db})).x
           = (Exec (l,s2) | (SCM-Data-Loc \ {da,db})).x
       proof
        let x be set;
        assume A88: x in ((SCM-Data-Loc) \ {da,db});
then A89:     x in SCM-Data-Loc by XBOOLE_0:def 4;
A90:     not x in {da,db} by A88,XBOOLE_0:def 4;
 reconsider a = x as Data-Location by A89,AMI_3:def 2;
A91:      a <> da & a <> db by A90,TARSKI:def 2;
A92:     a in (SCM-Data-Loc \/ {IC SCM}) by A89,XBOOLE_0:def 2;
        thus (Exec (l,s1) | (SCM-Data-Loc \ {da,db})).x
           = (Exec (l,s1)).a by A88,FUNCT_1:72
          .= s1.a by A69,A91,AMI_3:12
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A92,FUNCT_1:72
          .= s2.a by A1,A92,FUNCT_1:72
          .= (Exec (l,s2)).a by A69,A91,AMI_3:12
          .= (Exec (l,s2) | (SCM-Data-Loc \ {da,db})).x by A88,FUNCT_1:72;
       end;
 then A93:  Exec (l,s1) | (SCM-Data-Loc \ {da,db} )
    = Exec (l,s2) | (SCM-Data-Loc \ {da,db} )
     by A86,A87,FUNCT_1:9;
 A94: db in SCM-Data-Loc by AMI_3:def 2;
 A95: da in SCM-Data-Loc by AMI_3:def 2;
then A96:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A95,FUNCT_1:72;
A97:  s1.db = (s1 | (SCM-Data-Loc \/ {IC SCM})).db by A9,A94,FUNCT_1:72
          .= s2.db by A1,A9,A94,FUNCT_1:72;
A98:  Exec (l,s1).da = s1.da div s1.db by A69,A83,AMI_3:12
          .= Exec (l,s2).da by A69,A83,A96,A97,AMI_3:12;
           Exec (l,s1).db = s1.da mod s1.db by A69,AMI_3:12
          .= Exec (l,s2).db by A69,A96,A97,AMI_3:12;
then Exec (l,s1) | {da,db} = Exec(l,s2) | {da,db} by A7,A8,A98,GRFUNC_1:91;
then A99:       Exec (l,s1) | SCM-Data-Loc
             = Exec (l,s2) | SCM-Data-Loc by A85,A93,RELAT_1:185;

           Exec (l,s1).IC SCM = Next IC s1 by A69,AMI_3:12
                         .= Exec (l,s2).IC SCM by A6,A69,AMI_3:12;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
        by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A99,RELAT_1:185;
      end;
      end;
     end;
     suppose InsCode (l) = 6;
      then consider loc such that A100: l = goto loc by Th52;
A101:  dom ((Exec (l,s1)) | SCM-Data-Loc) = SCM-Data-Loc by A7,RELAT_1:91;
A102:  dom ((Exec (l,s2)) | SCM-Data-Loc) = SCM-Data-Loc by A8,RELAT_1:91;
          for x being set st x in SCM-Data-Loc
       holds (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s2) | SCM-Data-Loc ).x
       proof
        let x be set;
        assume A103: x in SCM-Data-Loc;
 then reconsider a = x as Data-Location by AMI_3:def 2;
A104:     a in (SCM-Data-Loc \/ {IC SCM}) by A103,XBOOLE_0:def 2;
        thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).a by A103,FUNCT_1:72
          .= s1.a by A100,AMI_3:13
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A104,FUNCT_1:72
          .= s2.a by A1,A104,FUNCT_1:72
          .= (Exec (l,s2)).a by A100,AMI_3:13
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A103,FUNCT_1:72;
       end;
 then A105:  Exec (l,s1) | (SCM-Data-Loc )
    = Exec (l,s2) | (SCM-Data-Loc )
     by A101,A102,FUNCT_1:9;
           Exec (l,s1).IC SCM = loc by A100,AMI_3:13
                         .= Exec (l,s2).IC SCM by A100,AMI_3:13;
       then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM}
        by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A105,RELAT_1:185;
     end;
     suppose InsCode (l) = 7;
      then consider loc,da such that A106: l = da=0_goto loc by Th53;
A107:  dom ((Exec (l,s1)) | SCM-Data-Loc) = SCM-Data-Loc by A7,RELAT_1:91;
A108:  dom ((Exec (l,s2)) | SCM-Data-Loc) = SCM-Data-Loc by A8,RELAT_1:91;
          for x being set st x in SCM-Data-Loc
       holds (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s2) | SCM-Data-Loc ).x
       proof
        let x be set;
        assume A109: x in SCM-Data-Loc;
 then reconsider a = x as Data-Location by AMI_3:def 2;
A110:     a in (SCM-Data-Loc \/ {IC SCM}) by A109,XBOOLE_0:def 2;
        thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).a by A109,FUNCT_1:72
          .= s1.a by A106,AMI_3:14
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A110,FUNCT_1:72
          .= s2.a by A1,A110,FUNCT_1:72
          .= (Exec (l,s2)).a by A106,AMI_3:14
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A109,FUNCT_1:72;
       end;
 then A111:  Exec (l,s1) | (SCM-Data-Loc )
    = Exec (l,s2) | (SCM-Data-Loc )
     by A107,A108,FUNCT_1:9;
           Exec (l,s1).IC SCM = Exec (l,s2).IC SCM
         proof
 A112: da in SCM-Data-Loc by AMI_3:def 2;
then A113:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A112,FUNCT_1:72;

          per cases;
          suppose A114: s1.da = 0;
          hence Exec (l,s1).IC SCM = loc by A106,AMI_3:14
                                  .= Exec (l,s2).IC SCM by A106,A113,A114,
AMI_3:14;
          end;
          suppose A115: s1.da <> 0;
          hence Exec (l,s1).IC SCM = Next IC s1 by A106,AMI_3:14
                                  .= Exec (l,s2).IC SCM by A6,A106,A113,A115,
AMI_3:14;
         end;
         end;
 then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A111,RELAT_1:185;

     end;
     suppose InsCode (l) = 8;
      then consider loc,da such that A116: l = da>0_goto loc by Th54;
A117:  dom ((Exec (l,s1)) | SCM-Data-Loc) = SCM-Data-Loc by A7,RELAT_1:91;
A118:  dom ((Exec (l,s2)) | SCM-Data-Loc) = SCM-Data-Loc by A8,RELAT_1:91;
          for x being set st x in SCM-Data-Loc
       holds (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s2) | SCM-Data-Loc ).x
       proof
        let x be set;
        assume A119: x in SCM-Data-Loc;
 then reconsider a = x as Data-Location by AMI_3:def 2;
A120:     a in (SCM-Data-Loc \/ {IC SCM}) by A119,XBOOLE_0:def 2;
        thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).a by A119,FUNCT_1:72
          .= s1.a by A116,AMI_3:15
          .= (s1 | (SCM-Data-Loc \/ {IC SCM})).a by A120,FUNCT_1:72
          .= s2.a by A1,A120,FUNCT_1:72
          .= (Exec (l,s2)).a by A116,AMI_3:15
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A119,FUNCT_1:72;
       end;
 then A121:  Exec (l,s1) | (SCM-Data-Loc )
    = Exec (l,s2) | (SCM-Data-Loc )
     by A117,A118,FUNCT_1:9;
           Exec (l,s1).IC SCM = Exec (l,s2).IC SCM
         proof
 A122: da in SCM-Data-Loc by AMI_3:def 2;
then A123:  s1.da = (s1 | (SCM-Data-Loc \/ {IC SCM})).da by A9,FUNCT_1:72
          .= s2.da by A1,A9,A122,FUNCT_1:72;

          per cases;
          suppose A124: s1.da > 0;
          hence Exec (l,s1).IC SCM = loc by A116,AMI_3:15
                                  .= Exec (l,s2).IC SCM by A116,A123,A124,
AMI_3:15;
          end;
          suppose A125: s1.da <= 0;

          hence Exec (l,s1).IC SCM = Next IC s1 by A116,AMI_3:15
                                  .= Exec (l,s2).IC SCM by A6,A116,A123,A125,
AMI_3:15;
         end;
         end;
 then Exec (l,s1) | {IC SCM} = Exec (l,s2) | {IC SCM} by A7,A8,GRFUNC_1:90;
      hence Exec (l,s1) | (SCM-Data-Loc \/ {IC SCM})
         = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCM}) by A121,RELAT_1:185;
    end;
    end;

theorem Th59:
  for i being Instruction of SCM,
      s being State of SCM
   holds
      Exec (i, s) | SCM-Instr-Loc = s | SCM-Instr-Loc
   proof
    let i be Instruction of SCM,
        s be State of SCM;
        dom (Exec (i,s)) = the carrier of SCM by AMI_1:79;
then A1: dom (Exec (i, s) | SCM-Instr-Loc) = SCM-Instr-Loc by RELAT_1:91;
        dom s = the carrier of SCM by AMI_1:79;
then A2: dom (s | SCM-Instr-Loc) = SCM-Instr-Loc by RELAT_1:91;
        for x being set st x in SCM-Instr-Loc
      holds (Exec (i, s) | SCM-Instr-Loc).x = (s | SCM-Instr-Loc).x
      proof
       let x be set;
       assume  x in SCM-Instr-Loc;
       then reconsider l = x as Instruction-Location of SCM by AMI_1:def 4;
       thus (Exec (i, s) | SCM-Instr-Loc).x
              = (Exec (i, s)).l by FUNCT_1:72
             .= s.l by AMI_1:def 13
             .= (s | SCM-Instr-Loc).x by FUNCT_1:72;
      end;
    hence Exec (i, s) | SCM-Instr-Loc = s | SCM-Instr-Loc by A1,A2,FUNCT_1:9;
   end;

begin :: Finite partial states of SCM

Lm1:
 for p being FinPartState of SCM
 holds DataPart p = p | SCM-Data-Loc
 proof
     now assume IC SCM in SCM-Data-Loc;
 then IC SCM is Data-Location by AMI_3:def 2;
  hence contradiction by Th20;
 end;
 then SCM-Data-Loc misses {IC SCM} by ZFMISC_1:56;
 then A1: SCM-Data-Loc misses {IC SCM} \/ SCM-Instr-Loc
  by AMI_2:29,XBOOLE_1:70;
     the carrier of SCM =
 {IC SCM} \/ (the Instruction-Locations of SCM) \/ SCM-Data-Loc
          by Th23,XBOOLE_1:4;
 then (the carrier of SCM) \ ({IC SCM} \/ the Instruction-Locations of SCM)
    = SCM-Data-Loc \ ({IC SCM} \/ the Instruction-Locations of SCM) by
XBOOLE_1:40
   .= SCM-Data-Loc by A1,XBOOLE_1:83;
  hence thesis;
 end;

Lm2:
 for f being FinPartState of SCM holds
  f is data-only iff dom f c= SCM-Data-Loc
proof let f be FinPartState of SCM;
     dom f c= the carrier of SCM by AMI_1:80;
 then A1: dom f c= {IC SCM} \/ SCM-Instr-Loc \/ SCM-Data-Loc by Th23,XBOOLE_1:4
;
     now assume IC SCM in SCM-Data-Loc;
 then IC SCM is Data-Location by AMI_3:def 2;
  hence contradiction by Th20;
 end;
 then SCM-Data-Loc misses {IC SCM} by ZFMISC_1:56;
 then SCM-Data-Loc misses {IC SCM} \/ SCM-Instr-Loc by AMI_2:29,XBOOLE_1:70;
 then dom f misses {IC SCM} \/ SCM-Instr-Loc
  iff dom f c= SCM-Data-Loc by A1,XBOOLE_1:63,73;
 hence thesis by AMI_1:def 50;
end;

canceled 9;

theorem
     for p being FinPartState of SCM
  holds dom DataPart p c= SCM-Data-Loc
  proof
   let p be FinPartState of SCM;
       DataPart p = p|SCM-Data-Loc by Lm1;
   hence dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
  end;

canceled 7;

theorem
      for i being Instruction of SCM,
      s being State of SCM,
      p being programmed FinPartState of SCM
   holds
      Exec (i, s +* p) = Exec (i,s) +* p
    proof
     let i be Instruction of SCM,
         s be State of SCM,
         p be programmed FinPartState of SCM;
      A1: dom p c= the Instruction-Locations of SCM by AMI_1:def 40;
          now assume {IC SCM} meets SCM-Instr-Loc;
      then consider x being set such that
A2:    x in {IC SCM} and
A3:    x in SCM-Instr-Loc by XBOOLE_0:3;
       reconsider l = x as Instruction-Location of SCM by AMI_1:def 4,A3;
           l = IC SCM by A2,TARSKI:def 1;
       hence contradiction by AMI_1:48;
      end;
 then SCM-Data-Loc \/ {IC SCM} misses SCM-Instr-Loc by AMI_2:29,XBOOLE_1:70;
then A4:        SCM-Data-Loc \/ {IC SCM} misses dom p by A1,XBOOLE_1:63;
then A5:   s|(SCM-Data-Loc \/ {IC SCM}) = (s +* p) | (SCM-Data-Loc \/ {IC SCM})
                                                         by FUNCT_4:76;
A6:    (Exec(i,s) +* p)|(SCM-Data-Loc \/ {IC SCM})
           = Exec(i,s)|(SCM-Data-Loc \/ {IC SCM}) by A4,FUNCT_4:76
          .= Exec(i,s +* p) | (SCM-Data-Loc \/ {IC SCM}) by A5,Th58;
A7:     Exec (i, s +* p)|SCM-Instr-Loc
            = (s +* p)|SCM-Instr-Loc by Th59
           .= s |SCM-Instr-Loc +* p|SCM-Instr-Loc by FUNCT_4:75
           .= Exec (i,s) |SCM-Instr-Loc +* p|SCM-Instr-Loc by Th59
           .= (Exec (i, s) +* p)|SCM-Instr-Loc by FUNCT_4:75;
     thus Exec (i, s +* p)
             = Exec (i, s +* p)| dom(Exec (i, s +* p)) by RELAT_1:97
            .= Exec (i, s +* p)| ({IC SCM} \/ SCM-Data-Loc \/ SCM-Instr-Loc)
                                                            by Th23,AMI_1:79
            .= (Exec (i, s) +* p)| ({IC SCM} \/ SCM-Data-Loc)
                 +* (Exec (i, s) +* p)|SCM-Instr-Loc by A6,A7,FUNCT_4:83
            .= (Exec (i,s) +* p)| the carrier of SCM by FUNCT_4:83,Th23
            .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by AMI_1:79
            .= Exec (i,s) +* p by RELAT_1:97;
    end;

canceled 2;

theorem
     for s being State of SCM,
     iloc being Instruction-Location of SCM,
     a    being Data-Location
  holds s.a = (s +* Start-At iloc).a
  proof
   let s    be State of SCM,
       iloc be Instruction-Location of SCM,
       a    be Data-Location;
A1: dom (Start-At iloc) = {IC SCM} by FUNCOP_1:19;
        a in the carrier of SCM;
    then a in dom s by AMI_1:79;
then A2: a in dom s \/ dom (Start-At iloc) by XBOOLE_0:def 2;
        a <> IC SCM by Th20;
    then not a in {IC SCM} by TARSKI:def 1;
    hence s.a = (s +* Start-At iloc).a by A1,A2,FUNCT_4:def 1;
  end;

begin :: Autonomic finite partial states of SCM

canceled 2;

theorem Th83:
 for p being autonomic FinPartState of SCM st DataPart p <> {}
 holds IC SCM in dom p
  proof
   let p be autonomic FinPartState of SCM;
   assume DataPart p <> {};
 then A1: dom DataPart p <> {} by RELAT_1:64;
   assume A2: not IC SCM in dom p;
       p is not autonomic
    proof
     consider d1 being Element of dom DataPart p;
A3:  d1 in dom DataPart p by A1;
         dom DataPart p c= the carrier of SCM by AMI_1:80;
     then reconsider d1 as Element of SCM by A3;
         DataPart p = p | SCM-Data-Loc by Lm1;
     then dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
     then reconsider d1 as Data-Location by A3,AMI_3:def 2;
     consider d2 being Element of SCM-Data-Loc \ dom p;
      not SCM-Data-Loc c= dom p by FINSET_1:13;
     then A4: SCM-Data-Loc \ dom p <> {} by XBOOLE_1:37;
 then d2 in SCM-Data-Loc by XBOOLE_0:def 4;
     then reconsider d2 as Data-Location by AMI_3:def 2;
     consider il being Element of (the Instruction-Locations of SCM) \ dom p;
      not the Instruction-Locations of SCM c= dom p by FINSET_1:13;
 then A5: (the Instruction-Locations of SCM) \ dom p <> {} by XBOOLE_1:37;
     then il is Element of the Instruction-Locations of SCM by XBOOLE_0:def 4;
     then reconsider il as Instruction-Location of SCM by AMI_1:def 4;
     set p1 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il);
     set p2 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il);
     consider s1 being State of SCM such that A6: p1 c= s1 by AMI_1:82;
     consider s2 being State of SCM such that A7: p2 c= s2 by AMI_1:82;
     take s1,s2;
     A8: not d2 in dom p by A4,XBOOLE_0:def 4;
     A9: not il in dom p by A5,XBOOLE_0:def 4;
        dom p misses {IC SCM} by A2,ZFMISC_1:56;
then A10:  dom p /\ {IC SCM} = {} by XBOOLE_0:def 7;
        dom p misses {d2} by A8,ZFMISC_1:56;
then A11:  dom p /\ {d2} = {} by XBOOLE_0:def 7;
    A12: dom p misses {il} by A9,ZFMISC_1:56;
         dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
       = dom((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il)
                                               by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ {IC SCM} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0) \/ {IC SCM} by FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> 0) \/ {IC SCM} by CQC_LANG:5
      .= {il} \/ {d2} \/ {IC SCM} by CQC_LANG:5;
    then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
       = dom p /\ ({il} \/ {d2}) \/ {} by A10,XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A11,XBOOLE_1:23
      .= {} by A12,XBOOLE_0:def 7;
   then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
    by XBOOLE_0:def 7;
   then p c= p1 by FUNCT_4:33;
   hence p c= s1 by A6,XBOOLE_1:1;
        dom p misses {IC SCM} by A2,ZFMISC_1:56;
then A13:  dom p /\ {IC SCM} = {} by XBOOLE_0:def 7;
        dom p misses {d2} by A8,ZFMISC_1:56;
then A14:  dom p /\ {d2} = {} by XBOOLE_0:def 7;
    A15: dom p misses {il} by A9,ZFMISC_1:56;
        dom ((il .--> (d1:=d2)) +* (d2.--> 1) +* Start-At il)
       = dom((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il)
                                               by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ {IC SCM} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 1) \/ {IC SCM} by FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> 1) \/ {IC SCM} by CQC_LANG:5
      .= {il} \/ {d2} \/ {IC SCM} by CQC_LANG:5;
    then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
       = dom p /\ ({il} \/ {d2}) \/ {} by A13,XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A14,XBOOLE_1:23
      .= {} by A15,XBOOLE_0:def 7;
   then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
     by XBOOLE_0:def 7;
   then p c= p2 by FUNCT_4:33;
   hence p c= s2 by A7,XBOOLE_1:1;
    take 1;
         DataPart p c= p by RELAT_1:88;
     then A16: dom DataPart p c= dom p by RELAT_1:25;
         dom ((Computation s1).1) = the carrier of SCM by AMI_1:79;
     then dom p c= dom ((Computation s1).1) by AMI_1:80;
then A17:  dom ((Computation s1).1|dom p) = dom p by RELAT_1:91;
A18:  dom(Start-At il) = {IC SCM} by FUNCOP_1:19;
then A19: IC SCM in dom (Start-At il) by TARSKI:def 1;
A20:  dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
         = dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il)
                                 by FUNCT_4:def 1;
then A21: IC SCM in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
                                 by A19,XBOOLE_0:def 2;
A22:  dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
                                 by FUNCT_4:def 1;
then IC SCM in dom p1 by A21,XBOOLE_0:def 2;
then A23:  IC s1 = p1.IC SCM by A6,GRFUNC_1:8
          .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).IC SCM
                                              by A21,FUNCT_4:14
          .= (Start-At il).IC SCM by A19,FUNCT_4:14
          .= il by CQC_LANG:6;
         dom (il .--> (d1:=d2)) = {il} by CQC_LANG:5;
then A24: il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A25:  dom (d2 .--> 0) = {d2} by CQC_LANG:5;
         il <> d2 by Th22;
then A26: not il in dom (d2 .--> 0) by A25,TARSKI:def 1;
A27:   dom ((il .--> (d1:=d2)) +* ( d2.--> 0))
         = dom (il .--> (d1:=d2)) \/ dom ( d2.--> 0) by FUNCT_4:def 1;
then A28: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A24,XBOOLE_0:def 2;
         il <> IC SCM by AMI_1:48;
then A29: not il in dom (Start-At il) by A18,TARSKI:def 1;
A30: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
                               by A20,A28,XBOOLE_0:def 2;
     then il in dom p1 by A22,XBOOLE_0:def 2;
then A31:  s1.il = p1.il by A6,GRFUNC_1:8
          .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).il
                                                 by A30,FUNCT_4:14
          .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).il by A29,FUNCT_4:12
          .= (il .--> (d1:=d2)).il by A26,FUNCT_4:12
          .=(d1:=d2) by CQC_LANG:6;
A32: d2 in dom (d2 .--> 0) by A25,TARSKI:def 1;
then A33: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A27,XBOOLE_0:def 2;
         d2 <> IC SCM by Th20;
then A34: not d2 in dom (Start-At il) by A18,TARSKI:def 1;
A35: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
                                        by A20,A33,XBOOLE_0:def 2;
     then d2 in dom p1 by A22,XBOOLE_0:def 2;
then A36:  s1.d2 = p1.d2 by A6,GRFUNC_1:8
          .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).d2
                                                 by A35,FUNCT_4:14
          .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).d2 by A34,FUNCT_4:12
          .= (d2.--> 0).d2 by A32,FUNCT_4:14
          .= 0 by CQC_LANG:6;
      (Computation s1).(0+1).d1 = (Following (Computation s1).0).d1 by
AMI_1:def 19
                           .= (Following s1).d1 by AMI_1:def 19
                           .= 0 by A23,A31,A36,AMI_3:8;
then A37:  ((Computation s1).1|dom p).d1 = 0 by A3,A16,A17,FUNCT_1:70;
         dom ((Computation s2).1) = the carrier of SCM by AMI_1:79;
     then dom p c= dom ((Computation s2).1) by AMI_1:80;
then A38:  dom ((Computation s2).1|dom p) = dom p by RELAT_1:91;
A39:  dom(Start-At il) = {IC SCM} by FUNCOP_1:19;
then A40: IC SCM in dom (Start-At il) by TARSKI:def 1;
A41:  dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
         = dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il)
                                 by FUNCT_4:def 1;
then A42: IC SCM in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
                                 by A40,XBOOLE_0:def 2;
A43:  dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
                                 by FUNCT_4:def 1;
then IC SCM in dom p2 by A42,XBOOLE_0:def 2;
then A44:  IC s2 = p2.IC SCM by A7,GRFUNC_1:8
          .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).IC SCM
                                              by A42,FUNCT_4:14
          .= (Start-At il).IC SCM by A40,FUNCT_4:14
          .= il by CQC_LANG:6;
         dom (il .--> (d1:=d2)) = {il} by CQC_LANG:5;
then A45: il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A46:  dom (d2 .--> 1) = {d2} by CQC_LANG:5;
         il <> d2 by Th22;
then A47: not il in dom (d2 .--> 1) by A46,TARSKI:def 1;
A48:  dom ((il .--> (d1:=d2)) +* ( d2.--> 1))
         = dom (il .--> (d1:=d2)) \/ dom ( d2.--> 1) by FUNCT_4:def 1;
then A49: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A45,XBOOLE_0:def 2;
         il <> IC SCM by AMI_1:48;
then A50: not il in dom (Start-At il) by A39,TARSKI:def 1;
A51: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
                               by A41,A49,XBOOLE_0:def 2;
     then il in dom p2 by A43,XBOOLE_0:def 2;
then A52:  s2.il = p2.il by A7,GRFUNC_1:8
          .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).il
                                                 by A51,FUNCT_4:14
          .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).il by A50,FUNCT_4:12
          .= (il .--> (d1:=d2)).il by A47,FUNCT_4:12
          .=(d1:=d2) by CQC_LANG:6;
A53: d2 in dom (d2 .--> 1) by A46,TARSKI:def 1;
then A54: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A48,XBOOLE_0:def 2;
         d2 <> IC SCM by Th20;
then A55: not d2 in dom (Start-At il) by A39,TARSKI:def 1;
A56: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
                                        by A41,A54,XBOOLE_0:def 2;
     then d2 in dom p2 by A43,XBOOLE_0:def 2;
then A57:  s2.d2 = p2.d2 by A7,GRFUNC_1:8
          .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).d2
                                                 by A56,FUNCT_4:14
          .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).d2 by A55,FUNCT_4:12
          .= (d2.--> 1).d2 by A53,FUNCT_4:14
          .= 1 by CQC_LANG:6;
      (Computation s2).(0+1).d1 = (Following (Computation s2).0).d1 by
AMI_1:def 19
                           .= (Following s2).d1 by AMI_1:def 19
                           .= 1 by A44,A52,A57,AMI_3:8;
    hence (Computation s1).1|dom p <> (Computation s2).1|dom p by A3,A16,A37
,A38,FUNCT_1:70;
   end;
   hence contradiction;
  end;

registration
 cluster autonomic non programmed FinPartState of SCM;
 existence
  proof
   take p = (Start-At il.0) +* Euclide-Algorithm +* (dl.0,dl.1) --> (1,1);
       (dl.0,dl.1) --> (1,1) in dom Euclide-Function by AMI_4:11;
   then consider s being FinPartState of SCM such that
 A1: (dl.0,dl.1) --> (1,1) = s and
 A2: (Start-At il.0) +* Euclide-Algorithm +* s is pre-program of SCM and
         Euclide-Function.s c= Result((Start-At il.0) +* Euclide-Algorithm +* s
)
       by AMI_1:def 29,AMI_4:13;
   thus p is autonomic by A1,A2;
   take IC SCM;
A3: dom p = dom ((Start-At il.0) +* Euclide-Algorithm) \/
           dom((dl.0,dl.1) --> (1,1)) by FUNCT_4:def 1;
A4: dom ((Start-At il.0) +* Euclide-Algorithm)
          = dom (Start-At il.0) \/ dom (Euclide-Algorithm) by FUNCT_4:def 1;
       dom (Start-At il.0) = {IC SCM} by FUNCOP_1:19;
   then IC SCM in dom (Start-At il.0) by TARSKI:def 1;
   then IC SCM in dom ((Start-At il.0) +* Euclide-Algorithm) by A4,
XBOOLE_0:def 2;
   hence IC SCM in dom p by A3,XBOOLE_0:def 2;
   assume
  IC SCM in the Instruction-Locations of SCM;
    then reconsider il = IC SCM as Instruction-Location of SCM by AMI_1:def 4;
     il in the Instruction-Locations of SCM;
   hence contradiction by Th19,SCM_1:7;
  end;
end;

theorem Th84:
 for p being autonomic non programmed FinPartState of SCM holds
  IC SCM in dom p
  proof
   let p be autonomic non programmed FinPartState of SCM;
   A1: not dom p c= SCM-Instr-Loc by AMI_1:def 40;
       dom p c= the carrier of SCM by AMI_1:80;
   then dom p = dom p /\ the carrier of SCM by XBOOLE_1:28
        .= dom p /\ ({IC SCM} \/ SCM-Data-Loc) \/ dom p /\ SCM-Instr-Loc
                                      by Th23,XBOOLE_1:23;
 then dom p /\ ({IC SCM} \/ SCM-Data-Loc) <> {} by A1,XBOOLE_1:17;
 then A2: dom p /\ {IC SCM} \/ dom p /\ SCM-Data-Loc <> {} by XBOOLE_1:23;
    per cases by A2;
    suppose dom p /\ {IC SCM} <> {};
    then dom p meets {IC SCM} by XBOOLE_0:def 7;
    hence IC SCM in dom p by ZFMISC_1:56;
    end;
    suppose A3: dom p /\ SCM-Data-Loc <> {};
        DataPart p = p | SCM-Data-Loc by Lm1;
    then DataPart p <> {} by A3,RELAT_1:60,90;
   hence IC SCM in dom p by Th83;
  end;
  end;

theorem
      for p being autonomic FinPartState of SCM st IC SCM in dom p
   holds IC p in dom p
    proof
     let p be autonomic FinPartState of SCM;
     assume
A1:        IC SCM in dom p;
     assume
A2:        not IC p in dom p;
     set il = IC p;
     set p1 = p +* ((il .--> goto il.0));
     set p2 = p +* ((il .--> goto il.1));
     consider s1 being State of SCM such that A3: p1 c= s1 by AMI_1:82;
     consider s2 being State of SCM such that A4: p2 c= s2 by AMI_1:82;
         p is not autonomic
      proof
A5:    dom (il .--> (goto il.1)) = {il} by CQC_LANG:5;
A6:    dom (il .--> (goto il.0)) = {il} by CQC_LANG:5;
       take s1,s2;
       dom p misses {il} by A2,ZFMISC_1:56;
     then p c= p1 & p c= p2 by A5,A6,FUNCT_4:33;
       hence A7: p c= s1 & p c= s2 by A3,A4,XBOOLE_1:1;
       take 1;
A8:     il in dom (il .--> (goto il.1)) by A5,TARSKI:def 1;
A9:     il in dom (il .--> (goto il.0)) by A6,TARSKI:def 1;
            dom p1 = dom p \/ dom ((il .--> goto il.0)) by FUNCT_4:def 1;
        then il in dom p1 by A9,XBOOLE_0:def 2;
then A10:     s1.il = p1.il by A3,GRFUNC_1:8
             .= ((il .--> goto il.0)).il by A9,FUNCT_4:14
             .= goto il.0 by CQC_LANG:6;
            dom p2 = dom p \/ dom ((il .--> goto il.1)) by FUNCT_4:def 1;
        then il in dom p2 by A8,XBOOLE_0:def 2;
then A11:     s2.il = p2.il by A4,GRFUNC_1:8
             .= ((il .--> goto il.1)).il by A8,FUNCT_4:14
             .= goto il.1 by CQC_LANG:6;
A12:    (Following s1).IC SCM
        = Exec (goto il.0,s1).IC SCM by A1,A7,A10,AMI_1:97
       .= il.0 by AMI_3:13;
A13:    (Following s2).IC SCM
        = Exec (goto il.1,s2).IC SCM by A1,A7,A11,AMI_1:97
       .= il.1 by AMI_3:13;

       assume A14: (Computation s1).1|dom p = (Computation s2).1|dom p;
         A15: (Following(s1))|dom p
                      = (Following ((Computation s1).0))|dom p by AMI_1:def 19
                     .= (Computation s1).(0+1)|dom p by AMI_1:def 19
                     .= (Following ((Computation s2).0))|dom p by A14,
AMI_1:def 19
                     .= (Following(s2))|dom p by AMI_1:def 19;
                il.0 = ((Following(s1))|dom p).IC SCM by A1,A12,FUNCT_1:72
                .= il.1 by A1,A13,A15,FUNCT_1:72;
       hence contradiction;
    end;
     hence contradiction;
  end;

theorem Th86:
 for p being autonomic non programmed FinPartState of SCM,
     s being State of SCM st p c= s
 for i being Element of NAT
  holds IC (Computation s).i in dom ProgramPart(p)
  proof
   let p be autonomic non programmed FinPartState of SCM,
       s be State of SCM such that
A1:  p c= s;
   let i be Element of NAT;
   set Csi = (Computation s).i;
   set loc = IC Csi;
   consider ll being Element of NAT such that
A2:   loc = il.ll by Th19;
   set loc1 = il.(ll+1);
  assume
A3: not IC (Computation s).i in dom ProgramPart(p);
     loc in dom ProgramPart p iff loc in dom p /\ SCM-Instr-Loc by
FUNCT_1:68;
then A4:not loc in dom p by A3,XBOOLE_0:def 3;

    set p1 = p +* (loc .--> goto loc);
    set p2 = p +* (loc .--> goto loc1);

A5:  dom p1 = dom p \/ dom (loc .--> goto loc) &
         dom p2 = dom p \/ dom (loc .--> goto loc1) by FUNCT_4:def 1;
A6:  dom (loc .--> goto loc) = {loc} &
         dom (loc .--> goto loc1) = {loc} by CQC_LANG:5;
then A7:  loc in dom (loc .--> goto loc) &
         loc in dom (loc .--> goto loc1) by TARSKI:def 1;
then A8:   loc in dom p1 & loc in dom p2 by A5,XBOOLE_0:def 2;

    consider s1 being State of SCM such that
A9: p1 c= s1 by AMI_1:82;
    consider s2 being State of SCM such that
A10: p2 c= s2 by AMI_1:82;

 set Cs1i = (Computation s1).i;
 set Cs2i = (Computation s2).i;

A11:  IC SCM in dom p by Th84;
      p is not autonomic
   proof
     take s1, s2;
         dom s1 = the carrier of SCM & dom s2 = the carrier of SCM
                                                    by AMI_1:79;
then A12: dom p c= dom s1 & dom p c= dom s2 by AMI_1:80;
         now let x be set; assume
A13:    x in dom p;
       then dom p misses dom (loc .--> goto loc) &
       x in dom p1 by A4,A5,A6,XBOOLE_0:def 2,ZFMISC_1:56;
       then p.x = p1.x & p1.x = s1.x by A9,A13,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s1.x;
     end;
    hence A14: p c= s1 by A12,GRFUNC_1:8;
        now let x be set; assume
A15:   x in dom p;
 then dom p misses dom (loc .--> goto loc1) &
      x in dom p2 by A4,A5,A6,XBOOLE_0:def 2,ZFMISC_1:56;
      then p.x = p2.x & p2.x = s2.x by A10,A15,FUNCT_4:17,GRFUNC_1:8;
     hence p.x = s2.x;
    end;
   hence A16: p c= s2 by A12,GRFUNC_1:8;
           (loc .--> goto loc).loc = goto loc &
       (loc .--> goto loc1).loc = goto loc1 by CQC_LANG:6;
       then p1.loc = goto loc & p2.loc = goto loc1 by A7,FUNCT_4:14;
then A17:  s1.loc = goto loc & s2.loc = goto loc1 by A8,A9,A10,GRFUNC_1:8;

  take k = i+1;

  set Cs1k = (Computation s1).k;
  set Cs2k = (Computation s2).k;
A18: Cs1k = Following Cs1i by AMI_1:def 19
          .= Exec (CurInstr Cs1i, Cs1i);
A19: Cs2k = Following Cs2i by AMI_1:def 19
          .= Exec (CurInstr Cs2i, Cs2i);
      A20:   Cs1i.loc = goto loc & Cs2i.loc = goto loc1 by A17,AMI_1:54;
A21:  (Cs1i|dom p) = (Csi|dom p) by A1,A14,AMI_1:def 25;
A22: Cs1i.IC SCM = (Cs1i|dom p).IC SCM &
     Csi.IC SCM = (Csi|dom p).IC SCM by A11,FUNCT_1:72;
      (Cs1i|dom p) = (Cs2i|dom p) by A14,A16,AMI_1:def 25;
 then   Cs1i.IC SCM = loc & Cs2i.IC SCM = loc by A11,A21,A22,FUNCT_1:72;
then A23:   Cs1k.IC SCM = loc & Cs2k.IC SCM = loc1 by A18,A19,A20,AMI_3:13;
         (Cs1k|dom p).IC SCM = Cs1k.IC SCM & (Cs2k|dom p).IC SCM = Cs2k.IC SCM
                                                    by A11,FUNCT_1:72;
   hence Cs1k|dom p <> Cs2k|dom p by A2,A23;
  end;
 hence contradiction;
end;

theorem Th87:
 for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds IC (Computation s1).i = IC (Computation s2).i &
          I = CurInstr ((Computation s2).i)
 proof
   let p be autonomic non programmed FinPartState of SCM,
       s1, s2 be State of SCM such that
A1:  p c= s1 & p c= s2;
    let i be Element of NAT,
        I be Instruction of SCM such that
A2:  I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3: IC SCM in dom p by Th84;
   thus
A4: IC Cs1i = IC Cs2i
   proof assume
A5:  IC (Computation s1).i <> IC (Computation s2).i;
        (Cs1i|dom p).IC SCM = Cs1i.IC SCM & (Cs2i|dom p).IC SCM = Cs2i.IC SCM
                                                     by A3,FUNCT_1:72;
   hence contradiction by A1,A5,AMI_1:def 25;
  end;
 thus I = CurInstr ((Computation s2).i)
   proof assume
A6:  I <> CurInstr ((Computation s2).i);
A7:  IC Cs1i in dom ProgramPart p & IC Cs2i in dom ProgramPart p
                                                     by A1,Th86;
        ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
 then (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i & (Cs2i|dom p).IC Cs2i = Cs2i.IC
Cs2i
                                                     by A7,FUNCT_1:72;
   hence contradiction by A1,A2,A4,A6,AMI_1:def 25;
  end;
end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da, db being Data-Location,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = da := db & da in dom p
                      implies (Computation s1).i.db = (Computation s2).i.db
proof
 let p be autonomic non programmed FinPartState of SCM,
     s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da, db be Data-Location,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
   set Cs1i = (Computation s1).i;
   set Cs2i = (Computation s2).i;
A3: I = CurInstr ((Computation s2).i) by A1,A2,Th87;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A4:    Cs1i1 = Following Cs1i by AMI_1:def 19
               .= Exec (CurInstr Cs1i, Cs1i);
A5:    Cs2i1 = Following Cs2i by AMI_1:def 19
               .= Exec (CurInstr Cs2i, Cs2i);
A6: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
          (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
     assume
A7:        I = da := db & da in dom p &
         (Computation s1).i.db <> (Computation s2).i.db;
 then Cs1i1.da = Cs1i.db & Cs2i1.da = Cs2i.db
                         by A2,A3,A4,A5,AMI_3:8;
   hence contradiction by A1,A6,A7,AMI_1:def 25;
end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da, db being Data-Location,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = AddTo(da, db) & da in dom p
                       implies (Computation s1).i.da + (Computation s1).i.db
                             = (Computation s2).i.da + (Computation s2).i.db
proof
 let p be autonomic non programmed FinPartState of SCM,
     s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da, db be Data-Location,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3:    I = CurInstr ((Computation s2).i) by A1,A2,Th87;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
            .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
            .= Exec (CurInstr Cs2i, Cs2i);
A6: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
                          (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
    assume
A7: I = AddTo(da, db) & da in dom p &
   (Computation s1).i.da + (Computation s1).i.db
   <> (Computation s2).i.da + (Computation s2).i.db;
 then Cs1i1.da = Cs1i.da + Cs1i.db & Cs2i1.da = Cs2i.da + Cs2i.db
                            by A2,A3,A4,A5,AMI_3:9;
   hence contradiction by A1,A6,A7,AMI_1:def 25;
end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da, db being Data-Location,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = SubFrom(da, db) & da in dom p
                       implies (Computation s1).i.da - (Computation s1).i.db
                             = (Computation s2).i.da - (Computation s2).i.db
 proof
   let p be autonomic non programmed FinPartState of SCM,
      s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da, db be Data-Location,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3:    I = CurInstr ((Computation s2).i) by A1,A2,Th87;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
            .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
            .= Exec (CurInstr Cs2i, Cs2i);
A6: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
                      (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A7: I = SubFrom(da, db) & da in dom p &
   (Computation s1).i.da - (Computation s1).i.db
   <> (Computation s2).i.da - (Computation s2).i.db;
 then Cs1i1.da = Cs1i.da - Cs1i.db & Cs2i1.da = Cs2i.da - Cs2i.db
                            by A2,A3,A4,A5,AMI_3:10;
   hence contradiction by A1,A6,A7,AMI_1:def 25;
end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da, db being Data-Location,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = MultBy(da, db) & da in dom p
                    implies (Computation s1).i.da * (Computation s1).i.db
                          = (Computation s2).i.da * (Computation s2).i.db
proof
 let p be autonomic non programmed FinPartState of SCM,
     s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da, db be Data-Location,
     I be Instruction of SCM such that
A2:         I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3:    I = CurInstr ((Computation s2).i) by A1,A2,Th87;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
            .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
            .= Exec (CurInstr Cs2i, Cs2i);
A6: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
                     (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A7: I = MultBy(da, db) & da in dom p &
   (Computation s1).i.da * (Computation s1).i.db
   <> (Computation s2).i.da * (Computation s2).i.db;
 then Cs1i1.da = Cs1i.da * Cs1i.db & Cs2i1.da = Cs2i.da * Cs2i.db
                                 by A2,A3,A4,A5,AMI_3:11;
   hence contradiction by A1,A6,A7,AMI_1:def 25;
 end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da, db being Data-Location,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = Divide(da, db) & da in dom p & da <> db
                     implies (Computation s1).i.da div (Computation s1).i.db
                           = (Computation s2).i.da div (Computation s2).i.db
proof
 let p be autonomic non programmed FinPartState of SCM,
     s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da, db be Data-Location,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3:    I = CurInstr ((Computation s2).i) by A1,A2,Th87;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
            .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
            .= Exec (CurInstr Cs2i, Cs2i);
A6: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
                          (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A7: I = Divide(da, db) & da in dom p & da <> db &
   (Computation s1).i.da div (Computation s1).i.db
   <> (Computation s2).i.da div (Computation s2).i.db;
 then Cs1i1.da = Cs1i.da div Cs1i.db & Cs2i1.da = Cs2i.da div Cs2i.db
                            by A2,A3,A4,A5,AMI_3:12;
   hence contradiction by A1,A6,A7,AMI_1:def 25;
 end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da, db being Data-Location,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = Divide(da, db) & db in dom p & da <> db
                     implies (Computation s1).i.da mod (Computation s1).i.db
                           = (Computation s2).i.da mod (Computation s2).i.db
proof
 let p be autonomic non programmed FinPartState of SCM,
     s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da, db be Data-Location,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
     set Cs1i = (Computation s1).i;
     set Cs2i = (Computation s2).i;
A3:     I = CurInstr ((Computation s2).i) by A1,A2,Th87;
    set Cs1i1 = (Computation s1).(i+1);
    set Cs2i1 = (Computation s2).(i+1);
A4:  Cs1i1 = Following Cs1i by AMI_1:def 19
             .= Exec (CurInstr Cs1i, Cs1i);
A5:  Cs2i1 = Following Cs2i by AMI_1:def 19
             .= Exec (CurInstr Cs2i, Cs2i);
  assume
A6: I = Divide(da, db) & db in dom p & da <> db &
   (Computation s1).i.da mod (Computation s1).i.db
   <> (Computation s2).i.da mod (Computation s2).i.db;
then A7: (Cs1i1|dom p).db = Cs1i1.db &
                    (Cs2i1|dom p).db = Cs2i1.db by FUNCT_1:72;
       Cs1i1.db = Cs1i.da mod Cs1i.db & Cs2i1.db = Cs2i.da mod Cs2i.db
                            by A2,A3,A4,A5,A6,AMI_3:12;
   hence contradiction by A1,A6,A7,AMI_1:def 25;
 end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da being Data-Location,
     loc being Instruction-Location of SCM,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = da=0_goto loc & loc <> Next (IC (Computation s1).i)
          implies ((Computation s1).i.da = 0 iff (Computation s2).i.da = 0)
proof
 let p be autonomic non programmed FinPartState of SCM,
     s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da be Data-Location,
     loc be Instruction-Location of SCM,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3: IC SCM in dom p by Th84;
A4: I = CurInstr ((Computation s2).i) by A1,A2,Th87;
    set Cs1i1 = (Computation s1).(i+1);
    set Cs2i1 = (Computation s2).(i+1);
A5:  Cs1i1 = Following Cs1i by AMI_1:def 19
             .= Exec (CurInstr Cs1i, Cs1i);
A6:  Cs2i1 = Following Cs2i by AMI_1:def 19
             .= Exec (CurInstr Cs2i, Cs2i);
A7:(Cs1i1|dom p).IC SCM = Cs1i1.IC SCM &
               (Cs2i1|dom p).IC SCM = Cs2i1.IC SCM by A3,FUNCT_1:72;
A8:  (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A9: I = da=0_goto loc & loc <> Next (IC (Computation s1).i);
A10: now assume
     (Computation s1).i.da = 0 & (Computation s2).i.da <> 0;
    then Cs1i1.IC SCM = loc & Cs2i1.IC SCM = Next IC Cs2i
                            by A2,A4,A5,A6,A9,AMI_3:14;
    hence contradiction by A1,A2,A7,A8,A9,Th87;
   end;
       now assume
       (Computation s2).i.da = 0 & (Computation s1).i.da <> 0;
    then Cs2i1.IC SCM = loc & Cs1i1.IC SCM = Next IC Cs1i
                            by A2,A4,A5,A6,A9,AMI_3:14;
    hence contradiction by A1,A7,A9,AMI_1:def 25;
   end;
  hence (Computation s1).i.da = 0 iff (Computation s2).i.da = 0 by A10;
 end;

theorem
     for p being autonomic non programmed FinPartState of SCM,
     s1, s2 being State of SCM
  st p c= s1 & p c= s2
   for i being Element of NAT,
     da being Data-Location,
     loc being Instruction-Location of SCM,
     I being Instruction of SCM
    st I = CurInstr ((Computation s1).i)
    holds I = da>0_goto loc & loc <> Next (IC (Computation s1).i)
        implies ((Computation s1).i.da > 0 iff (Computation s2).i.da > 0)
 proof
  let p be autonomic non programmed FinPartState of SCM,
      s1, s2 be State of SCM such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,
     da be Data-Location,
     loc be Instruction-Location of SCM,
     I be Instruction of SCM such that
A2: I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A3: IC SCM in dom p by Th84;
A4: IC Cs1i = IC Cs2i by A1,A2,Th87;
A5: I = CurInstr ((Computation s2).i) by A1,A2,Th87;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A6: Cs1i1 = Following Cs1i by AMI_1:def 19
            .= Exec (CurInstr Cs1i, Cs1i);
A7: Cs2i1 = Following Cs2i by AMI_1:def 19
            .= Exec (CurInstr Cs2i, Cs2i);
A8: (Cs1i1|dom p).IC SCM = Cs1i1.IC SCM &
         (Cs2i1|dom p).IC SCM = Cs2i1.IC SCM by A3,FUNCT_1:72;
A9:   (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A10: I = da>0_goto loc & loc <> Next (IC (Computation s1).i);
A11: now assume
A12: (Computation s1).i.da > 0 & (Computation s2).i.da <= 0;
  then Cs1i1.IC SCM = loc by A2,A6,A10,AMI_3:15;
    hence contradiction by A4,A5,A7,A8,A9,A10,A12,AMI_3:15;
   end;
       now assume
A13: (Computation s2).i.da > 0 & (Computation s1).i.da <= 0;
  then Cs2i1.IC SCM = loc by A5,A7,A10,AMI_3:15;
    hence contradiction by A2,A6,A8,A9,A10,A13,AMI_3:15;
   end;
  hence (Computation s1).i.da > 0 iff (Computation s2).i.da > 0 by A11;
 end;

theorem
   for p being FinPartState of SCM holds
    DataPart p = p | SCM-Data-Loc by Lm1;

theorem
   for f being FinPartState of SCM holds
  f is data-only iff dom f c= SCM-Data-Loc by Lm2;

