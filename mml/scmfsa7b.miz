:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, AMI_1, SCMFSA_2, RELAT_1, SCMFSA_7,
      ARYTM_3, ARYTM_1, TARSKI, FUNCT_1, XXREAL_0, PARTFUN1, CAT_1, NAT_1,
      CARD_1, FUNCOP_1, SCMFSA6A, ORDINAL4, AMI_3, FUNCT_4, INT_1, GRAPHSP,
      FSM_1, CIRCUIT2, SCMNORM, SCMFSA6B, GLIB_000, SF_MASTR, MSUALG_1,
      XBOOLE_0, PRE_POLY, UNIALG_2, AMISTD_2, SCMFSA7B, ORDINAL1, AFINSQ_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1,
      FINSEQ_2, NAT_D, FUNCOP_1, AFINSQ_1, AFINSQ_2,
      COMPOS_1, EXTPRO_1, AMI_1, SCMFSA_2,
      SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B, INT_2, XXREAL_0, PRE_POLY;
 constructors ENUMSET1, XXREAL_0, REAL_1, AMI_5, SCMFSA_7, SCMFSA6A, SF_MASTR,
      SCMFSA6B, NAT_D, RELSET_1, PRE_POLY, DOMAIN_1, AFINSQ_2, PARTFUN3, AMI_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, FUNCT_7, AMI_1, SCMFSA_2,
      SF_MASTR, SCMFSA6B, ORDINAL1, FINSET_1, FINSEQ_2, CARD_1, AFINSQ_1,
      COMPOS_1, AFINSQ_2, ORDINAL5, EXTPRO_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, AFINSQ_1, RELAT_1, FINSEQ_1, FINSEQ_2, SCMFSA_2, FUNCOP_1,
      SCMFSA6A, COMPOS_1, SCMFSA_7, EXTPRO_1;
 definitions AMI_1, AFINSQ_2;
 theorems SCMFSA_7, NAT_1, GRFUNC_1, FUNCT_1, FUNCT_4, FUNCT_7, AMI_1,
      ENUMSET1, SCMFSA_2, FUNCOP_1, INT_1, RELAT_1, TARSKI, SCMFSA6A,
      SF_MASTR, SCMFSA6B, XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, AFINSQ_1,
      COMPOS_1, AFINSQ_2, CARD_1, EXTPRO_1;
 schemes NAT_1, AFINSQ_1;

begin

reserve m for Element of NAT;
set A = NAT;

canceled 6;

theorem
  for i being Instruction of SCM+FSA holds (i = halt SCM+FSA implies (
  Directed Macro i). 0 = goto  2) & (i <> halt SCM+FSA implies (
  Directed Macro i). 0 = i)
proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  let i be Instruction of SCM+FSA;
A2: (Macro i). 0 = i by COMPOS_1:148;
   0 in { 0, 1} by TARSKI:def 2;
  then
A3:  0 in dom Macro i by COMPOS_1:149;
A4: card Macro i = 2 by COMPOS_1:150;
  hereby
A5: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
    assume
A6: i = halt SCM+FSA;
    dom (halt SCM+FSA .--> goto  2) = {halt SCM+FSA} by FUNCOP_1:19;
    then
A7: i in dom (halt SCM+FSA .--> goto  2) by A6,TARSKI:def 1;
    rng Macro i c= the Instructions of SCM+FSA by RELAT_1:def 19;
    hence
    (Directed Macro i). 0 = (((id the Instructions of SCM+FSA) +* (
    halt SCM+FSA, goto  2))*Macro i). 0 by A4,FUNCT_7:118
      .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
     2))*Macro i). 0 by A5,FUNCT_7:def 3
      .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
    2)).i by A3,A2,FUNCT_1:23
      .= (halt SCM+FSA .--> goto  2).i by A7,FUNCT_4:14
      .= goto  2 by A6,FUNCOP_1:87;
  end;
A8: dom (halt SCM+FSA .--> goto  2) = {halt SCM+FSA} by FUNCOP_1:19;
  assume i <> halt SCM+FSA;
  then
A9: not i in dom (halt SCM+FSA .--> goto  2) by A8,TARSKI:def 1;
  rng Macro i c= the Instructions of SCM+FSA by RELAT_1:def 19;
  hence (Directed Macro i). 0 = (((id the Instructions of SCM+FSA) +* (
  halt SCM+FSA, goto  2))* Macro i). 0 by A4,FUNCT_7:118
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
  2))* Macro i). 0 by A1,FUNCT_7:def 3
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto  2
  )).i by A3,A2,FUNCT_1:23
    .= (id the Instructions of SCM+FSA).i by A9,FUNCT_4:12
    .= i by FUNCT_1:35;
end;

theorem
  for i being Instruction of SCM+FSA holds (Directed Macro i). 1 = goto  2
proof
  let i be Instruction of SCM+FSA;
A1: (Macro i). 1 = halt SCM+FSA by COMPOS_1:148;
   1 in { 0, 1} by TARSKI:def 2;
  then
A2:  1 in dom Macro i by COMPOS_1:149;
  dom (halt SCM+FSA .--> goto  2 ) = {halt SCM+FSA} by FUNCOP_1:19;
  then
A3: halt SCM+FSA in dom (halt SCM+FSA .--> goto  2) by TARSKI:def 1;
A4: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  card Macro i = 2 & rng Macro i c= the Instructions of SCM+FSA
   by COMPOS_1:150,RELAT_1:def 19;
  hence (Directed Macro i). 1 = (((id the Instructions of SCM+FSA) +* (
  halt SCM+FSA,goto  2))* Macro i). 1 by FUNCT_7:118
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
  2))* Macro i). 1 by A4,FUNCT_7:def 3
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto  2
  )). halt SCM+FSA by A2,A1,FUNCT_1:23
    .= (halt SCM+FSA .--> goto  2).halt SCM+FSA by A3,FUNCT_4:14
    .= goto  2 by FUNCOP_1:87;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> initial non empty
    NAT-defined (the Instructions of SCM+FSA)-valued;
  coherence
  proof
     a := k = aSeq(a,k) ^ <% halt SCM+FSA %> by SCMFSA_7:33;
    hence thesis;
  end;
end;

Lm1: for s being State of SCM+FSA st IC s =  0 for a being Int-Location,
k being Integer st a := k c= s holds ProgramPart s halts_on s

proof
  let s be State of SCM+FSA;
  assume
A1: IC s =  0;
  let a be Int-Location, k be Integer;
  assume
A2: a := k c= s;
  per cases;
  suppose
A3: k > 0;
    then consider k1 being Element of NAT such that
A4: k1 + 1 = k and
A5: a := k = <% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0)) ^
    <% halt SCM+FSA %> by SCMFSA_7:def 2;
A6: len (<% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0))) = len <% a :=
    intloc 0 %> + len (k1 --> AddTo(a,intloc 0)) by AFINSQ_1:20
      .= 1 + len (k1 --> AddTo(a,intloc 0)) by AFINSQ_1:38
      .= k by A4,CARD_1:106;
    set f = <% a:=intloc 0 %> ^ (k1 --> AddTo(a,intloc 0)) ^ <% halt SCM+FSA
    %>;
A7: f.0 = (<% a := intloc 0 %> ^ ((k1 --> AddTo(a,intloc 0)) ^ <%halt
    SCM+FSA%>)).0 by AFINSQ_1:30
      .= a := intloc 0 by AFINSQ_1:39;
    reconsider k as Element of NAT by A3,INT_1:16;
B9:  len f = len (<% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0))) + len
    <% halt SCM+FSA %> by AFINSQ_1:20
      .= k + 1 by A6,AFINSQ_1:38;
A10: now
      let i be Element of NAT;
      assume that
A11:  i <= k;
      i < k + 1 by A11,NAT_1:13;
      hence  i in dom  f by B9,NAT_1:45;
    end;
A13: now
      let i be Element of NAT;
      assume that
A14:  i <= k;
   i in dom  f by A10,A14;
      hence s.i = f.i by A2,A5,GRFUNC_1:8;
    end;
    then
A16: s. 0 = a := intloc 0 by A7;
A17: now
      let n be Element of NAT;
      assume n = 0;
      hence
A18:  Comput(ProgramPart(s),s,n) = s by EXTPRO_1:3;

      hence
  CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s,n
)) = a:= intloc 0
 by A1,A16,COMPOS_1:38;
      thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
      Comput(ProgramPart(s),s,n)) by EXTPRO_1:4
        .= Exec(a:= intloc 0,s) by A18,A1,A16,COMPOS_1:38;
    end;
A20: now
      let i be Element of NAT;
      assume that
A24:  1 <= i and
A25:  i < k;
      reconsider i1 = i - 1 as Element of NAT by A24,INT_1:18;
      i - 1 < k - 1 by A25,XREAL_1:11;
      then
A27:  i1 in k1 by A4,NAT_1:45;
A28:  len <%a:= intloc 0%> = 1 by AFINSQ_1:36;
TT:   len(k1-->AddTo(a,intloc 0)) = k1 by CARD_1:106;
      i in dom (<%a:=intloc 0%>^(k1-->AddTo(a,intloc 0)))
           by A25,A6,NAT_1:45;
      hence f.i=(<%a:=intloc 0%>^(k1-->AddTo(a,intloc 0))).i by AFINSQ_1:def 4
        .= (k1-->AddTo(a,intloc 0)).(i - 1)
         by A24,A25,A28,TT,A4,AFINSQ_1:21
        .= AddTo(a,intloc 0) by A27,FUNCOP_1:13;
    end;
A26: now
      let i be Element of NAT;
      assume that
A30:  0 < i and
A31:  i < k;
A32:  0+1 <= i by A30,NAT_1:13;
      thus s. i = f.(i) by A13,A31
        .=AddTo(a,intloc 0) by A20,A32,A31;
    end;
A30: for i being Element of NAT st i <= k
      holds IC Comput(ProgramPart(s),s,i) = i
    proof
      defpred P[Nat] means $1 <= k implies IC Comput(ProgramPart(s),s,$1) =
       $1;

      let i be Element of NAT;
      assume
A31:  i <= k;
A32:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A33:    P[n];
        assume
A34:    n+1 <= k;
        then
A35:    n < k by NAT_1:13;
        per cases;
        suppose
A36:      n=0;
          hence IC Comput(ProgramPart(s),s,n+1)
            = Exec(a:= intloc 0,s).IC SCM+FSA by A17
            .= succ n by A1,A36,SCMFSA_2:89
            .= n+1 by NAT_1:39;
        end;
        suppose
A37:      n>0;
          n + 0 <= n + 1 by XREAL_1:9;

          then
A38:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). n by A33,A34,COMPOS_1:38,XXREAL_0:2

            .= s. n by AMI_1:54
            .= AddTo(a,intloc 0) by A26,A35,A37;
A39:      Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,n)) by EXTPRO_1:4

            .= Exec(AddTo(a,intloc 0), Comput(ProgramPart(s),s,n))
                 by A38,AMI_1:123;
          thus IC Comput(ProgramPart(s),s,n+1)
             = succ IC Comput(ProgramPart(s),s,n) by A39,SCMFSA_2:90
            .= n+1 by A33,A34,NAT_1:13,39;
        end;
      end;
A40:  P[0] by A1,EXTPRO_1:3;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A40,A32);
      hence thesis by A31;
    end;
   k < k + len <%halt SCM+FSA%> by XREAL_1:31;
   then
    f.(k) = <% halt SCM+FSA %>.(k - k) by A6,AFINSQ_1:21
      .= halt SCM+FSA by AFINSQ_1:38;
    then
A41: s. k = halt SCM+FSA by A13;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
    CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k))
     = ( Comput(ProgramPart(s),s,k)).IC Comput(ProgramPart(s),s,k)
    by TX,COMPOS_1:38

      .= ( Comput(ProgramPart(s),s,k)). k by A30
      .= halt SCM+FSA by A41,AMI_1:54;
    hence thesis by EXTPRO_1:30;
  end;
  suppose
A42: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A43: k1 + k = 1 and

A44: a:=k =  (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)) ^ <%
    halt SCM+FSA%>) by A42,SCMFSA_7:def 2;

A45: len (<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0))) = len<%a:=intloc 0%>
    + len(k1-->SubFrom(a,intloc 0)) by AFINSQ_1:20

      .= 1 + len(k1-->SubFrom(a,intloc 0)) by AFINSQ_1:38
      .= mk+1+1 by A43,CARD_1:106;
    set f = <%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)) ^ <%halt SCM+FSA%>;

A46: f.0 = (<%a:=intloc 0%>^((k1-->SubFrom(a,intloc 0))^<%halt SCM+FSA%>))
    .0 by AFINSQ_1:30

      .= a := intloc 0 by AFINSQ_1:39;

A47: len f = len(<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0)))+len<%halt
    SCM+FSA %> by AFINSQ_1:20

      .= mk+1+1 + 1 by A45,AFINSQ_1:38;
A49: now
      let i be Element of NAT;
      assume that
      0 <= i and
A70:  i <= mk+1+1;
      i < mk+1+1+1 by A70,NAT_1:13;
      hence  i in dom  f by A47,NAT_1:45;
    end;
A52: now
      let i be Element of NAT;
      assume that
      0 <= i and
A73:  i <= mk+1+1;
   i in dom  f by A49,A73;
      hence s.i = f.i by A2,A44,GRFUNC_1:8;
    end;
    then
A55: s.0 = a := intloc 0 by A46;
A56: now
      let n be Element of NAT;
      assume n = 0;
      hence
A57:  Comput(ProgramPart(s),s,n) = s by EXTPRO_1:3;

      hence
  CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s,n
))
 = a:= intloc 0 by A1,A55,COMPOS_1:38;
      thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
      Comput(ProgramPart(s),s,n)) by EXTPRO_1:4
        .= Exec(a:= intloc 0,s) by A57,A1,A55,COMPOS_1:38;
    end;
A59: now
A79:  len <%a:= intloc 0%> = 1 by AFINSQ_1:36;
      let i be Element of NAT;
      assume that
A80:  1 <= i and
A81:  i < mk+1+1;
      reconsider i1 = i - 1 as Element of NAT by A80,INT_1:18;
      i-1 < k1+1-1 by A81,A43,XREAL_1:11;
      then
A84:  i1 in k1 by NAT_1:45;
TT:   len(k1-->SubFrom(a,intloc 0)) = k1 by CARD_1:106;
      i in dom (<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0)))
       by A81,A45,NAT_1:45;
      hence f.i = (<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0))).i by
AFINSQ_1:def 4
        .= (k1-->SubFrom(a,intloc 0)).(i - 1)
             by A43,A80,A81,A79,TT,AFINSQ_1:21
        .= SubFrom(a,intloc 0) by A84,FUNCOP_1:13;
    end;
A66: now
      let i be Element of NAT;
      assume that
A86:  0 < i and
A87:  i < mk+1+1;
A88:   0+1 <= i by A86,NAT_1:13;
      thus s. i = f.(i) by A52,A87
        .=SubFrom(a,intloc 0) by A59,A88,A87;
    end;

A70: for i being Element of NAT st i <= mk+1+1 holds IC Comput(ProgramPart(s),s
,i) =
     i

    proof

      defpred P[Nat] means $1<=mk+1+1 implies IC Comput(ProgramPart(s),s,$1)=
       $1;

      let i be Element of NAT;
      assume
A71:  i <= mk+1+1;
A72:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A73:    P[n];
        assume
A74:    n+1 <= mk+1+1;
        then
A75:    n < mk+1+1 by NAT_1:13;
        per cases;
        suppose
A76:      n=0;
          hence IC Comput(ProgramPart(s),s,n+1)
             = Exec(a:= intloc 0,s).IC SCM+FSA by A56
            .= succ n by A1,A76,SCMFSA_2:89
            .= n+1 by NAT_1:39;
        end;
        suppose
A77:      n>0;
          n + 0 <= n + 1 by XREAL_1:9;

          then
A78:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). n by A73,A74,COMPOS_1:38,XXREAL_0:2

            .= s. n by AMI_1:54
            .= SubFrom(a,intloc 0) by A66,A75,A77;
A79:      Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,n)) by EXTPRO_1:4

            .= Exec(SubFrom(a,intloc 0), Comput(ProgramPart(s),s,n))
             by A78,AMI_1:123;

          thus IC Comput(ProgramPart(s),s,n+1)
             = succ IC Comput(ProgramPart(s),s,n) by A79,SCMFSA_2:91
            .= n+1 by A73,A74,NAT_1:13,39;
        end;
      end;
A80:  P[0] by A1,EXTPRO_1:3;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A80,A72);
      hence thesis by A71;
    end;

  len (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0))) <= mk+1+1 &
  mk+1+1 < len (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)))
   + len <%halt SCM+FSA%> implies
   f.(mk+1+1)=<%halt SCM+FSA%>.(mk+1+1-
   len (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0))))
           by AFINSQ_1:21;
   then
    f.(mk+1+1) = halt SCM+FSA by A45,AFINSQ_1:38,XREAL_1:31;
    then
A81: s. (mk+1+1) = halt SCM+FSA by A52;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,mk+1+1)
by AMI_1:123;
   CurInstr(ProgramPart s,Comput(ProgramPart(s),s,mk+1+1))
    = ( Comput(ProgramPart(s),s,mk+1+1)).IC
    Comput(ProgramPart(s),s,mk+1+1) by TX,COMPOS_1:38

      .= ( Comput(ProgramPart(s),s,mk+1+1)). (mk+1+1) by A70
      .= halt SCM+FSA by A81,AMI_1:54;
    hence thesis by EXTPRO_1:30;
  end;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> parahalting;
  correctness
  proof
    now
A1:   IC SCM+FSA in dom (a := k +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
      let s be State of SCM+FSA;
      assume
A2:   a := k +* Start-At( 0,SCM+FSA) c= s;
      IC s = IC(a := k +* Start-At( 0,SCM+FSA)) by A2,A1,GRFUNC_1:8
        .=  0 by COMPOS_1:142;
      hence ProgramPart s halts_on s by A2,Lm1,COMPOS_1:131;
    end;
    then a := k +* Start-At( 0,SCM+FSA) is halting by EXTPRO_1:def 10;
    hence thesis by SCMFSA6B:def 3;
  end;
end;

theorem
  for s being State of SCM+FSA for a being read-write Int-Location, k
  being Integer holds IExec(a := k,s).a = k & (for b being read-write
  Int-Location st b <> a holds IExec(a := k,s).b = s.b) & for f being
  FinSeq-Location holds IExec(a := k,s).f = s.f
proof
  let s be State of SCM+FSA;
  let a be read-write Int-Location;
  let k be Integer;
  set s1 = s +* Initialized (a := k);
A1: IExec(a := k,s) = Result(ProgramPart(s1),s1) +* s | A by SCMFSA6B:def 1;
  intloc 0 in dom Initialized (a := k) by SCMFSA6A:45;
  then
A2: s1.intloc 0 = (Initialized (a := k)).intloc 0 by FUNCT_4:14
    .= 1 by SCMFSA6A:46;
  IC SCM+FSA in dom Initialized (a := k) by SCMFSA6A:24;
  then s1.IC SCM+FSA = (Initialized (a := k)).IC SCM+FSA by FUNCT_4:14
    .=  0 by SCMFSA6A:46;
  then
 IC s1 =  0;
  then reconsider s1 as 0-started State of SCM+FSA by COMPOS_1:def 20;
  Initialized (a := k) c= s1 & a := k c= Initialized (a := k) by FUNCT_4:26
,SCMFSA6A:26;
  then
A4: a := k c= s1 by XBOOLE_1:1;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then not a in dom (s | A) by RELAT_1:90;
  hence IExec(a := k,s).a = (Result(ProgramPart(s1),s1)).a by A1,FUNCT_4:12
    .= k by A2,A4,SCMFSA_7:38;
  hereby
    let b be read-write Int-Location;
    assume
A6: b <> a;
A7: not b in dom Initialized (a := k) by SCMFSA6A:48;
    not b in A by SCMFSA_2:84;
    then not b in dom s /\ A by XBOOLE_0:def 4;
    then not b in dom (s | A) by RELAT_1:90;
    hence IExec(a := k,s).b = (Result(ProgramPart(s1),s1)).b by A1,FUNCT_4:12
      .= s1.b by A2,A4,A6,SCMFSA_7:38
      .= s.b by A7,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
A9: not f in dom Initialized (a := k) by SCMFSA6A:49;
  not f in A by SCMFSA_2:85;
  then not f in dom s /\ A by XBOOLE_0:def 4;
  then not f in dom (s | A) by RELAT_1:90;
  hence IExec(a := k,s).f = (Result(ProgramPart(s1),s1)).f by A1,FUNCT_4:12
    .= s1.f by A2,A4,SCMFSA_7:38
    .= s.f by A9,FUNCT_4:12;
end;

Lm2: for p1,p2,p3,p4 being XFinSequence
 holds p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3 ^ p4)

proof
  let p1,p2,p3,p4 be XFinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4 by AFINSQ_1:30
    .= p1 ^ (p2 ^ p3 ^ p4) by AFINSQ_1:30;
end;

Lm5: for c0 being Element of NAT
 for s being c0-started State of SCM+FSA
for a being Int-Location, k being Integer st
 for c being Element of NAT st c < len aSeq(a,k)
  holds aSeq(a,k).c = s. (c0 + c)
for i being Element of NAT st i <= len aSeq(a,k)
 holds IC Comput(ProgramPart(s),s,i) = c0 + i

proof
  let c0 be Element of NAT;
  let s be c0-started State of SCM+FSA;
A1: IC s =  c0 by COMPOS_1:def 20;
  let a be Int-Location;
  let k be Integer;
  assume
A2: for c being Element of NAT st c < len aSeq(a,k)
    holds aSeq(a,k).c = s. (c0 + c);
S4: for c being Element of NAT st c in dom aSeq(a,k)
   holds aSeq(a,k).c = s.(c0 + c)
    proof let c be Element of NAT;
     assume c in dom aSeq(a,k);
      then c < len aSeq(a,k) by AFINSQ_1:70;
     hence aSeq(a,k).c = s.(c0 + c) by A2;
    end;
  per cases;
  suppose
A3: k > 0;
    then reconsider k9= k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A4: k1 + 1 = k9 and

A5: aSeq(a,k9) = <%a:=intloc 0%> ^ (k1 --> AddTo(a,intloc 0)) by A3,
SCMFSA_7:def 3;

    defpred Q[Nat] means $1 <= k9 implies IC Comput(ProgramPart(s),s,$1) =
     (c0 + $1);

A6: len aSeq(a,k9) = len <%a:=intloc 0%> + len (k1-->AddTo(a,intloc 0)) by A5,
AFINSQ_1:20

      .= 1 + len(k1-->AddTo(a,intloc 0)) by AFINSQ_1:38
      .= k9 by A4,CARD_1:106;

    for i being Element of NAT st i <= len aSeq(a,k9)
     holds IC Comput(ProgramPart(s),s,i) =  (c0 + i)

    proof
A7:  now
        let i be Element of NAT;
        assume that
A17:    1 <= i and
A18:    i < k9;
        reconsider i1 = i - 1 as Element of NAT by A17,INT_1:18;
         i = i1 + 1;
         then
      i1 < k1 by A18,A4,XREAL_1:8;
        then
A20:     i1 in k1 by NAT_1:45;
TT:      len (k1 --> AddTo(a,intloc 0)) = k1 by CARD_1:106;
         len <% a:= intloc 0 %> = 1 by AFINSQ_1:36;
        hence aSeq(a,k9).i = (k1 --> AddTo(a,intloc 0)).(i - 1)
            by A17,A5,TT,A4,A18,AFINSQ_1:21
          .= AddTo(a,intloc 0) by A20,FUNCOP_1:13;
      end;
S10: for i being Element of NAT st i < k9 holds i in dom aSeq(a,k9)
     by A6,NAT_1:45;
A12:  now
        let i be Element of NAT;
        assume that
A22:    0 < i and
A23:    i < k9;
A24:     0+1 <= i by A22,NAT_1:13;
        thus s. (c0 + i) = aSeq(a,k9).(i) by S4,S10,A23
          .=AddTo(a,intloc 0) by A7,A24,A23;
      end;
A16:  s. (c0 + 0) = aSeq(a,k9).0 by A2,A3,A6
        .= a:= intloc 0 by A5,AFINSQ_1:39;
A17:  now
        let n be Element of NAT;
        assume n = 0;
        hence
A18:    Comput(ProgramPart(s),s,n) = s by EXTPRO_1:3;

        hence
    CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s
,n))
 = a:= intloc 0 by A1,A16,COMPOS_1:38;
        thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
        Comput(ProgramPart(s),s,n)) by EXTPRO_1:4
          .= Exec(a:= intloc 0,s) by A18,A1,A16,COMPOS_1:38;
      end;
A20:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A21:    Q[n];
        assume
A22:    n + 1 <= k9;
        per cases;
        suppose
A23:      n = 0;
          hence IC Comput(ProgramPart(s),s,n+1)
             = Exec(a:= intloc 0,s).IC SCM+FSA by A17
            .= succ c0 + n by A1,A23,SCMFSA_2:89
            .= c0 + 1 + n by NAT_1:39
            .= c0 + (n + 1);
        end;
        suppose
A24:      n > 0;
A25:      n < k9 by A22,NAT_1:13;
A26:      n + 0 <= n + 1 by XREAL_1:9;

          then
A27:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). (c0 + n)
          by A21,A22,COMPOS_1:38,XXREAL_0:2

            .= s. (c0 + n) by AMI_1:54
            .= AddTo(a,intloc 0) by A12,A24,A25;
A28:      Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,n)) by EXTPRO_1:4

            .= Exec(AddTo(a,intloc 0), Comput(ProgramPart(s),s,n))
                by A27,AMI_1:123;

          thus IC Comput(ProgramPart(s),s,n+1)
             = succ IC Comput(ProgramPart(s),s,n) by A28,SCMFSA_2:90
            .=  (c0 + n + 1) by A21,A22,A26,NAT_1:39,XXREAL_0:2
            .=  (c0 + (n + 1));
        end;
      end;
      let i be Element of NAT;
      assume
A29:  i <= len aSeq(a,k9);
A30:  Q[0] by A1,EXTPRO_1:3;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A30,A20);
      hence thesis by A6,A29;
    end;
    hence thesis;
  end;
  suppose
A31: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:16;

    defpred Q[Nat] means $1 <= mk+1+1 implies IC Comput(ProgramPart(s),s,$1)
    =  (c0 + $1);

    consider k1 being Element of NAT such that
A32: k1 + k = 1 and

A33: aSeq(a,k) = <%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)) by A31,
SCMFSA_7:def 3;

A34: len aSeq(a,k) = len <% a:=intloc 0 %> + len (k1-->SubFrom(a,intloc 0)
    ) by A33,AFINSQ_1:20

      .= 1 + len (k1-->SubFrom(a,intloc 0)) by AFINSQ_1:38
      .= mk+1+1 by A32,CARD_1:106;

    for i being Element of NAT st i <= len aSeq(a,k) holds IC Comput(
ProgramPart(s),s,i) =  (c0 + i)

    proof
A35:  now
        let i be Element of NAT;
        assume that
A51:    1 <= i and
A52:    i < mk+1+1;
A53:    i - 1 < mk+1+1 - 1 by A52,XREAL_1:11;
        reconsider i1 = i - 1 as Element of NAT by A51,INT_1:18;
A55:    i1 in k1 by A32,A53,NAT_1:45;
TT:   len(k1 --> SubFrom(a,intloc 0)) = k1 by CARD_1:106;
        len <% a:= intloc 0 %> = 1 by AFINSQ_1:36;
        hence aSeq(a,k).i = (k1-->SubFrom(a,intloc 0)).(i - 1)
         by A33,A51,TT,A32,A52,AFINSQ_1:21
          .= SubFrom(a,intloc 0) by A55,FUNCOP_1:13;
      end;
S44: for i being Element of NAT st i < mk+1+1 holds i in dom  aSeq(a,k)
        by A34,NAT_1:45;
A41:  now
        let i be Element of NAT;
        assume that
A57:    0 < i and
A58:    i < mk+1+1;
A59:    0+1 <= i by A57,NAT_1:13;
        thus s. (c0 + i) = aSeq(a,k).(i) by S4,S44,A58
          .=SubFrom(a,intloc 0) by A35,A59,A58;
      end;
A45:  s. (c0 + 0) = aSeq(a,k).0 by A2,A34
        .= a:= intloc 0 by A33,AFINSQ_1:39;

A46:  for n being Element of NAT st n = 0 holds Comput(ProgramPart(s),s,n) = s
&

CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s,n)) = a
:= intloc 0 &
Comput(ProgramPart(s),s,n+1) = Exec(a:= intloc
      0,s)

      proof
        let n be Element of NAT;
        assume n = 0;
        hence
A47:    Comput(ProgramPart(s),s,n) = s by EXTPRO_1:3;

        hence
    CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s
,n))
 = a:= intloc 0 by A1,A45,COMPOS_1:38;
        thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
        Comput(ProgramPart(s),s,n)) by EXTPRO_1:4
          .= Exec(a:= intloc 0,s) by A47,A1,A45,COMPOS_1:38;
      end;
A49:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A50:    Q[n];
        assume
A51:    n + 1 <= mk+1+1;
        per cases;
        suppose
A52:      n = 0;
          hence IC Comput(ProgramPart(s),s,n+1)
             = Exec(a:= intloc 0,s).IC SCM+FSA by A46
            .= succ  (c0 + n) by A1,A52,SCMFSA_2:89
            .= c0 + n + 1 by NAT_1:39
            .= c0 + (n + 1);
        end;
        suppose
A53:      n > 0;
A54:      n < mk+1+1 by A51,NAT_1:13;
A55:      n + 0 <= n + 1 by XREAL_1:9;

          then
A56:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). (c0 + n)
          by A50,A51,COMPOS_1:38,XXREAL_0:2

            .= s. (c0 + n) by AMI_1:54
            .= SubFrom(a,intloc 0) by A41,A53,A54;
A57:      Comput(ProgramPart(s),s,n+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,n))
 by EXTPRO_1:4

            .= Exec(SubFrom(a,intloc 0), Comput(ProgramPart(s),s,n))
              by A56,AMI_1:123;

          thus IC Comput(ProgramPart(s),s,n+1)
             = succ IC Comput(ProgramPart(s),s,n) by A57,SCMFSA_2:91
            .= c0 + n + 1 by A50,A51,A55,NAT_1:39,XXREAL_0:2
            .= c0 + (n + 1);
        end;
      end;
      let i be Element of NAT;
      assume
A58:  i <= len aSeq(a,k);
A59:  Q[0] by A1,EXTPRO_1:3;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A59,A49);
      hence thesis by A34,A58;
    end;
    hence thesis;
  end;
end;

Lm6: for s being 0-started State of SCM+FSA for a being Int-Location,
k being Integer st  aSeq(a,k) c= s
for i being Element of NAT st i <= len aSeq(a,k)
 holds IC Comput(ProgramPart(s),s,i) =  i
proof
  let s be 0-started State of SCM+FSA;
  let a be Int-Location;
  let k be Integer;
  assume
A2:  aSeq(a,k) c= s;
A3: now
    let c be Element of NAT;
    assume c < len aSeq(a,k);
    then c in dom  aSeq(a,k) by NAT_1:45;
   hence s.(0+c) = ( aSeq(a,k)). c by A2,GRFUNC_1:8;
  end;
  let i be Element of NAT;
  assume i <= len aSeq(a,k);
  then IC Comput(ProgramPart(s),s,i) = (0+i) by A3,Lm5;
  hence thesis;
end;

Lm7: for s being 0-started State of SCM+FSA for f being
FinSeq-Location, p being FinSequence of INT st f := p c= s
 holds ProgramPart s halts_on s

proof
  set a2 = intloc 2;
  set a1 = intloc 1;
  let s be 0-started State of SCM+FSA;
  set D = the Instructions of SCM+FSA;
  let f be FinSeq-Location;
  let p be FinSequence of INT;

  set q = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %> ^ aSeq(f,p) ^ <% halt
  SCM+FSA %>;

  set q0 = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %>;
  assume
A3: f := p c= s;
  set q = aSeq(a1,len p)^<% f:=<0,...,0>a1 %>^aSeq(f,p)^<% halt SCM+FSA %>;
A7: now
    let i,k be Element of NAT;
    assume i < len q;
    then
A10:  i in dom  q by NAT_1:45;
    thus ( Comput(ProgramPart(s),s,k)). i = s. i by AMI_1:54
      .= q.(i) by A3,A10,GRFUNC_1:8;
  end;
  consider pp being XFinSequence of D^omega such that
A9: len pp = len p & for k being Element of NAT st k < len pp
   ex i being Integer st i = p.(k+1) &
  pp.k = (aSeq(a1,k+1) ^ aSeq(a2,i) ^ <% (f,a1):= a2 %>) and
A10: aSeq(f,p) = FlattenSeq pp by SCMFSA_7:def 4;
  len q = len (q0 ^ FlattenSeq pp) + 1 by A10,AFINSQ_1:79;
  then
A11: len (q0 ^ FlattenSeq pp) < len q by NAT_1:13;

  defpred P[XFinSequence] means $1 c= pp implies
  ex pp0 being XFinSequence of D^omega
  st (pp0 = $1 & for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
  holds IC Comput(ProgramPart(s),s,i) =  i);

A15: for r being XFinSequence, x being set st P[r] holds P[r ^ <% x %>]
  proof
    let r be XFinSequence;
    let x be set;
    assume
A16: P[r];
    set r1 = len r;
    len<% x %> =1 by AFINSQ_1:38;
    then len (r ^ <% x %>) = r1+1 by AFINSQ_1:20;
    then r1 < len (r ^ <% x %>) by XREAL_1:31;
    then
A17: r1 in dom (r ^ <% x %>) by NAT_1:45;
    assume
A18: r ^ <% x %> c= pp;
    then
A19: dom (r ^ <% x %>) c= dom pp by GRFUNC_1:8;
    then r1 < len pp by A17,NAT_1:45;
    then consider pr1 being Integer such that
    pr1 = p.(r1+1) and
A20: pp.r1 = aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %> by A9;
    r c= r ^ <% x %> by AFINSQ_1:78;
    then consider pp0 being XFinSequence of D^omega such that
A21: pp0 = r and

A22: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
    holds IC Comput(ProgramPart(s),s,i) =  i by A16,A18,XBOOLE_1:1;
    set c2 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1));
    set c1 = len (q0 ^ FlattenSeq pp0);
 IC Comput(ProgramPart(s),s,c1) =  c1 by A22;
    then reconsider s1 = Comput(ProgramPart s,s,c1) as
      c1-started State of SCM+FSA by COMPOS_1:def 20;

A23: x = (r ^ <% x %>).r1 by AFINSQ_1:40
      .= pp.r1 by A18,A17,GRFUNC_1:8;
    then x in D^omega by A17,A19,FUNCT_1:172;
    then reconsider pp1 = pp0 ^ <% x %> as XFinSequence of D^omega;
    take pp1;
    thus pp1 = r ^ <% x %> by A21;
    reconsider x as Element of D^omega by A17,A19,A23,FUNCT_1:172;
A24: FlattenSeq pp1 = FlattenSeq pp0 ^ FlattenSeq <% x %> by AFINSQ_2:87
      .= FlattenSeq pp0 ^ x by AFINSQ_2:85;
    set s2 = Comput(ProgramPart(s),s,c2);

A26: x = aSeq(a1,r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1):=a2 %>)
 by A20,A23,AFINSQ_1:30;
    then
A27: len q0 + len FlattenSeq pp1 = len q0 + len (FlattenSeq pp0 ^ aSeq(a1,
    r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1):=a2 %>)) by A24,AFINSQ_1:30

      .= len (q0 ^ (FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1)
    :=a2 %>))) by AFINSQ_1:20

      .= len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1)
    :=a2 %>)) by Lm2

      .= c2 + len (aSeq(a2,pr1) ^ <% (f,a1):=a2 %>) by AFINSQ_1:20
      .= c2 + (len aSeq(a2,pr1) + len <% (f,a1):=a2 %>) by AFINSQ_1:20
      .= c2 + (len aSeq(a2,pr1) + 1) by AFINSQ_1:38
      .= c2 + len aSeq(a2,pr1) + 1;

    then
A28: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(a2,pr1) + 1 by AFINSQ_1:20;

    then
A29: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(a2,pr1) by NAT_1:13;
A30: FlattenSeq pp1 c= FlattenSeq pp by A18,A21,AFINSQ_2:94;
A31: now
      let p be XFinSequence;
      assume p c= x;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp0 ^ x by AFINSQ_2:93;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp by A30,A24,XBOOLE_1:1;
      then q0 ^ (FlattenSeq pp0 ^ p) c= q0 ^ FlattenSeq pp by AFINSQ_2:93;
      then
A32:  q0 ^ FlattenSeq pp0 ^ p c= q0 ^ FlattenSeq pp by AFINSQ_1:30;
      q0 ^ FlattenSeq pp c= q by A10,AFINSQ_1:78;
      hence q0 ^ FlattenSeq pp0 ^ p c= q by A32,XBOOLE_1:1;
    end;
A33: for c being Element of NAT st c < len aSeq(a1,r1+1)
      holds aSeq(a1,r1+1).c = s1.(c1 + c)

    proof
      let c be Element of NAT;
      assume c < len aSeq(a1,r1+1);
      then
A48:  c in dom aSeq(a1,r1+1) by AFINSQ_1:70;
      then
A49:  c1 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1)) by AFINSQ_1:26;
A51:  q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) c= q by A26,A31,AFINSQ_1:78;
      then
B52:   dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1)) c= dom q by GRFUNC_1:8;
      thus aSeq(a1,r1+1).c = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1)).(c1 + c)
       by A48,AFINSQ_1:def 4
        .= q.(c1 + c) by A51,A49,GRFUNC_1:8
        .= s. (c1 + c) by A3,B52,A49,GRFUNC_1:8
        .= s1. (c1 + c) by AMI_1:54;
    end;
    set c3 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1));
A38: c2 = c1 + len aSeq(a1,r1+1) by AFINSQ_1:20;
A42: q0 ^ FlattenSeq pp1 = q0 ^ FlattenSeq pp0 ^ x by A24,AFINSQ_1:30;
    then len (q0 ^ FlattenSeq pp1) <= len q by A31,NAT_1:44;
    then
A43: c2 + len aSeq(a2,pr1) < len q by A28,NAT_1:13;
A44: c3 = c2 + len aSeq(a2,pr1) by AFINSQ_1:20;

T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c1)
by AMI_1:123;
A45: Comput(ProgramPart(s),s,c2)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,c1),
    len aSeq(a1,r1+1)) by A38,EXTPRO_1:5;

 IC Comput(ProgramPart(s),s,c2) =  c2 by A38,A45,A33,Lm5,T;
  then reconsider s2 as c2-started State of SCM+FSA by COMPOS_1:def 20;
A46: for c being Element of NAT st c < len aSeq(a2,pr1)
     holds aSeq(a2,pr1).c = s2.(c2+ c)

    proof
      let c be Element of NAT;
      assume c < len aSeq(a2,pr1);
      then
A61:  c in dom aSeq(a2,pr1) by AFINSQ_1:70;
      then
A62:  c2 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1)) by
AFINSQ_1:26;
      q0 ^ FlattenSeq pp0 ^ (aSeq(a1,r1+1) ^ aSeq(a2,pr1)) c= q by A20,A23,A31,
AFINSQ_1:78;
      then
A64:  q0 ^FlattenSeq pp0^aSeq(a1,r1+1) ^ aSeq(a2,pr1) c= q by AFINSQ_1:30;
      then
B65: dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1)) c= dom q by
GRFUNC_1:8;
      thus aSeq(a2,pr1).c
          = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1)).(c2 + c)
               by A61,AFINSQ_1:def 4
        .= q.(c2 + c) by A62,A64,GRFUNC_1:8
        .= s. (c2 + c) by A3,B65,A62,GRFUNC_1:8
        .= s2. (c2 + c) by AMI_1:54;
    end;
A51: now
      let i be Element of NAT;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:123;
      assume i <= len aSeq(a2,pr1);

      hence  (c2 + i) = IC Comput(ProgramPart(s),
Comput(ProgramPart(s),s,c2),i) by A46,Lm5,T

        .= IC Comput(ProgramPart(s),s,c2+i) by EXTPRO_1:5;
    end;
A52: now
      let i be Element of NAT;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c1)
by AMI_1:123;
      assume i <= len aSeq(a1,r1+1);

      hence  (c1 + i) = IC Comput(ProgramPart(s),
           Comput(ProgramPart(s),s,c1),i) by A33,Lm5,T

        .= IC Comput(ProgramPart(s),s,c1 + i) by EXTPRO_1:5;
    end;
A53: for i being Element of NAT st i < len (q0 ^ FlattenSeq pp1) holds IC
    Comput(ProgramPart(s),s,i) =  i

    proof
      let i be Element of NAT;
      assume
A54:  i < len (q0 ^ FlattenSeq pp1);
A55:  now
A56:    i < len q0 + len FlattenSeq pp1 by A54,AFINSQ_1:20;
        assume
A57:    not i <= c1;
        assume not (c1 + 1 <= i & i <= c2);

        hence c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1) by A27,A57,A56,NAT_1:13;

      end;
      per cases by A55;
      suppose
        i <= len (q0 ^ FlattenSeq pp0);
        hence thesis by A22;
      end;
      suppose
A58:    c1 + 1 <= i & i <= c2;
        then c1 + 1 - c1 <= i - c1 by XREAL_1:11;
        then reconsider ii = i - c1 as Element of NAT by INT_1:16;
        i - c1 <= c2 - c1 by A58,XREAL_1:11;
        hence i = IC Comput(ProgramPart(s),s,c1+ii) by A38,A52
          .= IC Comput(ProgramPart(s),s,i);
        thus thesis;
      end;
      suppose
A59:    c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1);
        then c2 + 1 - c2 <= i - c2 by XREAL_1:11;
        then reconsider ii = i - c2 as Element of NAT by INT_1:16;
        i - c2 <= c2 + len aSeq(a2,pr1) - c2 by A59,XREAL_1:11;
        hence  i = IC Comput(ProgramPart(s),s,c2+ii)by A51
          .= IC Comput(ProgramPart(s),s,i);
      end;
    end;

 q0 ^ FlattenSeq pp0 ^ x c= q by A31;
    then consider rq being XFinSequence of D such that
W:   (q0 ^ FlattenSeq pp0 ^ x)^rq = q by AFINSQ_2:92;
 len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(a2,pr1) + 1 by A27,AFINSQ_1:20;
    then
A78: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(a2,pr1) by NAT_1:13;
    then
YY: c3 in dom(q0 ^ FlattenSeq pp0 ^ x)
       by A42,A44,AFINSQ_1:70;
    dom<% (f,a1):=a2 %> = 1 by AFINSQ_1:36;
    then
SS: 0 in dom<% (f,a1):=a2 %> by CARD_1:87,TARSKI:def 1;
    len<% (f,a1):=a2 %> = 1 by AFINSQ_1:38;
    then len(aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>)
      = len (aSeq(a1,r1+1) ^ aSeq(a2,pr1)) + 1 by AFINSQ_1:20;
    then len (aSeq(a1,r1+1) ^ aSeq(a2,pr1))
      < len(aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>) by XREAL_1:31;
    then
ZZ: len (aSeq(a1,r1+1) ^ aSeq(a2,pr1))
        in dom(aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>) by AFINSQ_1:70;
A76: c3 = c1 + len aSeq(a1,r1+1) + len aSeq(a2,pr1) by A38,AFINSQ_1:20;
Y:  (ProgramPart Comput(ProgramPart(s),s,c3))/.IC Comput(ProgramPart(s),s,c3)
 = Comput(ProgramPart(s),s,c3).IC Comput(ProgramPart(s),s,c3) by COMPOS_1:38;
    CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),
       Comput(ProgramPart(s),s,c3))
     = Comput(ProgramPart(s),s,c3). c3 by A44,A53,Y,A78
      .= q.(c3 ) by A7,A44,A43
      .= (q0 ^ FlattenSeq pp0 ^ x).
         (c1 + (len aSeq(a1,r1+1) + (len aSeq(a2,pr1))))
             by A76,YY,W,AFINSQ_1:def 4
      .= (q0 ^ FlattenSeq pp0 ^ x).
         (c1 + len(aSeq(a1,r1+1) ^ aSeq(a2,pr1))) by AFINSQ_1:20;
    then
A60: CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),
      Comput(ProgramPart(s),s,c3))
       = (aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>).
          (len (aSeq(a1,r1+1) ^ aSeq(a2,pr1))+0) by ZZ,A20,A23,AFINSQ_1:def 4
      .= <% (f,a1):=a2 %>.0 by SS,AFINSQ_1:def 4
      .= (f,a1):=a2 by AFINSQ_1:38;
    Comput(ProgramPart(s),s,c3+1) =
    Following(ProgramPart s,Comput(ProgramPart(s),s,
c3))
     by EXTPRO_1:4
      .= Exec((f,a1):=a2, Comput(ProgramPart(s),s,c3)) by A60,AMI_1:123;

    then
A61: IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)) = Exec((f,a1):=a2,
    Comput(ProgramPart(s),s,c3)).IC SCM+FSA by A28,AFINSQ_1:20

      .= succ IC Comput(ProgramPart(s),s,c3) by SCMFSA_2:99
      .= succ  c3 by A44,A53,A29;

    thus for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp1) holds IC
    Comput(ProgramPart(s),s,i) =  i

    proof
      let i be Element of NAT;
      assume
A62:  i <= len (q0 ^ FlattenSeq pp1);
      per cases by A62,XXREAL_0:1;
      suppose
        i < len (q0 ^ FlattenSeq pp1);
        hence thesis by A53;
      end;
      suppose
        i = len (q0 ^ FlattenSeq pp1);
        hence thesis by A44,A28,A61,NAT_1:39;
      end;
    end;
  end;
  set k = len aSeq(a1,len p);
A63: len q0 = k + 1 by AFINSQ_1:79;

  q = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %> ^ (aSeq(f,p) ^ <% halt
  SCM+FSA %>) by AFINSQ_1:30

    .= aSeq(a1,len p) ^ (<% f :=<0,...,0> a1 %> ^ (aSeq(f,p) ^ <% halt
  SCM+FSA %>)) by AFINSQ_1:30;

  then
A64:  aSeq(a1,len p) c= f:=p by AFINSQ_1:78;
A65: P[{}]
  proof
    assume {} c= pp;
    take <%>(D^omega);
    thus <%>(D^omega) = {};

A67: q = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %> ^ (aSeq(f,p) ^ <% halt
    SCM+FSA %>) by AFINSQ_1:30;

    then len q = len q0 + len ((aSeq(f,p) ^ <% halt SCM+FSA %>)) by AFINSQ_1:20
;

    then len q0 <= len q by NAT_1:11;
    then
A68: k < len q by A63,NAT_1:13;
A69: now
      let i be Element of NAT;
      assume
  i < len q0;
      then i <= len aSeq(a1,len p) by A63,NAT_1:13;

      hence IC Comput(ProgramPart(s),s,i) =  i by A3,A64,Lm6,XBOOLE_1:1;
    end;
OO:  k < len q0 by A63,NAT_1:13;
    then
RR:  k in dom q0 by AFINSQ_1:70;
A71: IC Comput(ProgramPart(s),s,k) =  k by A69,OO;

    then
A72: CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s),s,k)
)
 = ( Comput(ProgramPart(s),s,k)). k by COMPOS_1:38

      .= q.k by A7,A68
      .= q0.k by A67,RR,AFINSQ_1:def 4
      .= f:=<0,...,0>a1 by AFINSQ_1:40;
A73: Comput(ProgramPart(s),s,len q0) =
Following(ProgramPart s,Comput(ProgramPart(s),s,k))
 by A63,EXTPRO_1:4
      .= Exec(f:=<0,...,0>a1, Comput(ProgramPart(s),s,k)) by A72,AMI_1:123;

A74: IC Comput(ProgramPart(s),s,len q0)
       = succ IC Comput(ProgramPart(s),s,k) by A73,SCMFSA_2:101
      .=  len q0 by A63,A71,NAT_1:39;
A75: now
      let i be Element of NAT;
      assume i <= len q0;
      then i < len q0 or i = len q0 by XXREAL_0:1;
      hence IC Comput(ProgramPart(s),s,i) =  i by A69,A74;
    end;
    q0 ^ FlattenSeq <%>(D^omega) = q0 ^ <%>D by AFINSQ_2:86
      .= q0 by AFINSQ_1:32;
    hence thesis by A75;
  end;
TX: ProgramPart s =
 ProgramPart Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp))
by AMI_1:123;
  for r being XFinSequence holds P[r] from AFINSQ_1:sch 3(A65,A15);

  then ex pp0 being XFinSequence of D^omega st pp0 = pp &
  for i being Element of NAT
  st i <= len (q0 ^ FlattenSeq pp0) holds IC Comput(ProgramPart(s),s,i) =  i;

  then IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)) =  len (q0 ^
  FlattenSeq pp);

  then CurInstr(ProgramPart s,
      Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)))
   = ( Comput(ProgramPart(s),s,len
  (q0 ^ FlattenSeq pp)).  len (q0 ^ FlattenSeq pp)) by TX,COMPOS_1:38

    .= q.len (q0 ^ FlattenSeq pp) by A7,A11
    .= halt SCM+FSA by A10,AFINSQ_1:40;
  hence thesis by EXTPRO_1:30;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> initial non empty
  NAT-defined (the Instructions of SCM+FSA)-valued;
  coherence;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> parahalting;
  correctness
  proof
    now
A1:   IC SCM+FSA in dom ((f := p) +* Start-At( 0,SCM+FSA))
 by COMPOS_1:141;
      let s be State of SCM+FSA;
      assume
A2:    (f := p) +* Start-At( 0,SCM+FSA) c= s;
       IC s = IC((f := p) +* Start-At( 0,SCM+FSA)) by A2,A1,GRFUNC_1:8
        .=  0 by COMPOS_1:142;
       then s is 0-started by COMPOS_1:def 20;
      hence ProgramPart s halts_on s by A2,Lm7,COMPOS_1:131;
    end;
    then (f := p) +* Start-At( 0,SCM+FSA) is halting by EXTPRO_1:def 10;
    hence thesis by SCMFSA6B:def 3;
  end;
end;

theorem
  for s being State of SCM+FSA, f being FinSeq-Location, p being
  FinSequence of INT holds IExec(f := p,s).f = p & (for a being read-write
Int-Location st a <> intloc 1 & a <> intloc 2 holds IExec(f := p,s).a = s.a) &
  for g being FinSeq-Location st g <> f holds IExec(f := p,s).g = s.g
proof
  let s be State of SCM+FSA;
  let f be FinSeq-Location;
  let p be FinSequence of INT;
A1: IExec((f := p),s) = Result(ProgramPart(s+*Initialized(f:=p)),s+*Initialized
(f:=p)) +* s | A by SCMFSA6B:def 1
;
  intloc 0 in dom Initialized (f := p) by SCMFSA6A:45;
  then
A2: (s+*Initialized(f:=p)).intloc 0 = (Initialized (f := p)).intloc 0 by
FUNCT_4:14
    .= 1 by SCMFSA6A:46;
  IC SCM+FSA in dom Initialized (f := p) by SCMFSA6A:24;
  then
  (s+*Initialized(f:=p)).IC SCM+FSA = (Initialized (f := p)).IC SCM+FSA by
FUNCT_4:14
    .=  0 by SCMFSA6A:46;
  then
 IC (s+*Initialized(f:=p)) =  0;
  then reconsider s1 = s+*Initialized(f:=p)
   as 0-started State of SCM+FSA by COMPOS_1:def 20;
  Initialized (f := p) c= s+*Initialized(f:=p) & (f := p) c= Initialized (
  f := p) by FUNCT_4:26,SCMFSA6A:26;
  then
A4: (f := p) c= s+*Initialized(f:=p) by XBOOLE_1:1;
  not f in A by SCMFSA_2:85;
  then not f in dom s /\ A by XBOOLE_0:def 4;
  then not f in dom (s | A) by RELAT_1:90;
  hence IExec(f := p,s).f = (Result(ProgramPart s1,s1)).f by A1,FUNCT_4:12
    .= p by A2,A4,SCMFSA_7:39;
  hereby
    let a be read-write Int-Location;
    assume
A6: a <> intloc 1 & a <> intloc 2;
A7: not a in dom Initialized (f := p) by SCMFSA6A:48;
    not a in A by SCMFSA_2:84;
    then not a in dom s /\ A by XBOOLE_0:def 4;
    then not a in dom (s | A) by RELAT_1:90;
    hence IExec((f := p),s).a = (Result(ProgramPart(s+*Initialized(f:=p)),s+*
Initialized(f:=p))).a by A1,FUNCT_4:12
      .= s1.a by A2,A4,A6,SCMFSA_7:39
      .= s.a by A7,FUNCT_4:12;
  end;
  let g be FinSeq-Location;
  assume
A9: g <> f;
A10: not g in dom Initialized (f := p) by SCMFSA6A:49;
  not g in A by SCMFSA_2:85;
  then not g in dom s /\ A by XBOOLE_0:def 4;
  then not g in dom (s | A) by RELAT_1:90;
  hence IExec((f := p),s).g = (Result(ProgramPart(s+*Initialized(f:=p)),s+*
Initialized(f:=p))).g by A1,FUNCT_4:12
    .= s1.g by A2,A4,A9,SCMFSA_7:39
    .= s.g by A10,FUNCT_4:12;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i refers a means
  not for b being Int-Location for l being
Element of NAT for f being FinSeq-Location holds b := a <> i &
  AddTo(b,a) <> i & SubFrom(b,a) <> i & MultBy(b,a) <> i & Divide(b,a) <> i &
Divide(a,b) <> i & a =0_goto l <> i & a >0_goto l <> i & b :=(f,a) <> i & (f,b)
  := a <> i & (f,a):= b <> i & f :=<0,...,0> a <> i;
end;

definition
  let I be preProgram of SCM+FSA;
  let a be Int-Location;
  pred I refers a means
  ex i being Instruction of SCM+FSA st i in rng I & i refers a;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i destroys a means
  :Def3:
  not for b being Int-Location for f being
  FinSeq-Location holds a := b <> i & AddTo(a,b) <> i & SubFrom(a,b) <> i &
  MultBy(a,b) <> i & Divide(a,b) <> i & Divide(b,a) <> i & a :=(f,b) <> i & a
  :=len f <> i;
end;

definition
  let I be FinPartState of SCM+FSA;
  let a be Int-Location;
  pred I destroys a means
  :Def4:
  ex i being Instruction of SCM+FSA st i in rng I & i destroys a;
end;

definition
  let I be FinPartState of SCM+FSA;
  attr I is good means
  :Def5:
  not I destroys intloc 0;
end;

theorem Th11:
  for a being Int-Location holds not halt SCM+FSA destroys a
proof
  let a be Int-Location;
  for b be Int-Location for l be Element of NAT for f be
  FinSeq-Location holds a := b <> halt SCM+FSA & AddTo(a,b) <> halt SCM+FSA &
  SubFrom(a,b) <> halt SCM+FSA & MultBy(a,b) <> halt SCM+FSA & Divide(a,b) <>
  halt SCM+FSA & Divide(b,a) <> halt SCM+FSA & a :=(f,b) <> halt SCM+FSA & a
  :=len f <> halt SCM+FSA by SCMFSA_2:42,43,44,45,46,50,52,124;
  hence thesis by Def3;
end;

theorem Th12:
  for a,b,c being Int-Location holds a <> b implies
   not b := c destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
    thus a := e <> b := c by A1,SF_MASTR:5;
A2: InsCode (b := c) = 1 by SCMFSA_2:42;
    hence AddTo(a,e) <> b := c by SCMFSA_2:43;
    thus SubFrom(a,e) <> b := c by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> b := c by A2,SCMFSA_2:45;
    thus Divide(a,e) <> b := c & Divide(e,a) <> b := c by A2,SCMFSA_2:46;
    thus a :=(f,e) <> b := c by A2,SCMFSA_2:50;
    thus a :=len f <> b := c by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem Th13:
  for a,b,c being Int-Location holds a <> b implies
  not AddTo(b,c) destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode AddTo(b,c) = 2 by SCMFSA_2:43;
    hence a := e <> AddTo(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> AddTo(b,c) by A1,SF_MASTR:6;
    thus SubFrom(a,e) <> AddTo(b,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> AddTo(b,c) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> AddTo(b,c) & Divide(e,a) <> AddTo(b,c) by A2,
SCMFSA_2:46;
    thus a :=(f,e) <> AddTo(b,c) by A2,SCMFSA_2:50;
    thus a :=len f <> AddTo(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem Th14:
  for a,b,c being Int-Location holds a <> b implies
   not SubFrom(b,c) destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode SubFrom(b,c) = 3 by SCMFSA_2:44;
    hence a := e <> SubFrom(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> SubFrom(b,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> SubFrom(b,c) by A1,SF_MASTR:7;
    thus MultBy(a,e) <> SubFrom(b,c) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> SubFrom(b,c) & Divide(e,a) <> SubFrom(b,c) by A2,
SCMFSA_2:46;
    thus a :=(f,e) <> SubFrom(b,c) by A2,SCMFSA_2:50;
    thus a :=len f <> SubFrom(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location holds a <> b implies
  not MultBy(b,c) destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode MultBy(b,c) = 4 by SCMFSA_2:45;
    hence a := e <> MultBy(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> MultBy(b,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> MultBy(b,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> MultBy(b,c) by A1,SF_MASTR:8;
    thus Divide(a,e) <> MultBy(b,c) & Divide(e,a) <> MultBy(b,c) by A2,
SCMFSA_2:46;
    thus a :=(f,e) <> MultBy(b,c) by A2,SCMFSA_2:50;
    thus a :=len f <> MultBy(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location holds a <> b & a <> c implies
  not Divide(b,c) destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b & a <> c;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let h be FinSeq-Location;
A2: InsCode Divide(b,c) = 5 by SCMFSA_2:46;
    hence a := e <> Divide(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> Divide(b,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> Divide(b,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> Divide(b,c) by A2,SCMFSA_2:45;
    thus Divide(e,a) <> Divide(b,c) & Divide(a,e) <> Divide(b,c) by A1,
SF_MASTR:9;
    thus a := (h,e) <> Divide(b,c) by A2,SCMFSA_2:50;
    thus a :=len h <> Divide(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a being Int-Location, l being Element of NAT
  holds not goto l destroy a
proof
  let a be Int-Location;
  let l be Element of NAT;
  now
    let b be Int-Location;
    let r be Element of NAT;
    let f be FinSeq-Location;
A1: InsCode goto l = 6 by SCMFSA_2:47;
    hence a := b <> goto l by SCMFSA_2:42;
    thus AddTo(a,b) <> goto l by A1,SCMFSA_2:43;
    thus SubFrom(a,b) <> goto l by A1,SCMFSA_2:44;
    thus MultBy(a,b) <> goto l by A1,SCMFSA_2:45;
    thus Divide(a,b) <> goto l & Divide(b,a) <> goto l by A1,SCMFSA_2:46;
    thus a :=(f,b) <> goto l by A1,SCMFSA_2:50;
    thus a :=len f <> goto l by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, l being Element of NAT
  holds not b =0_goto l destroy a
proof
  let a,b be Int-Location;
  let l be Element of NAT;
  now
    let e be Int-Location;
    let f be FinSeq-Location;
A1: InsCode (b =0_goto l) = 7 by SCMFSA_2:48;
    hence a := e <> b =0_goto l by SCMFSA_2:42;
    thus AddTo(a,e) <> b =0_goto l by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> b =0_goto l by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> b =0_goto l by A1,SCMFSA_2:45;
    thus Divide(a,e) <> b =0_goto l & Divide(e,a) <> b =0_goto l by A1,
SCMFSA_2:46;
    thus a :=(f,e) <> b =0_goto l by A1,SCMFSA_2:50;
    thus a :=len f <> b =0_goto l by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, l being Element of NAT
  holds not b >0_goto l destroy a
proof
  let a,b be Int-Location;
  let l be Element of NAT;
  now
    let e be Int-Location;
    let f be FinSeq-Location;
A1: InsCode (b >0_goto l) = 8 by SCMFSA_2:49;
    hence a := e <> b >0_goto l by SCMFSA_2:42;
    thus AddTo(a,e) <> b >0_goto l by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> b >0_goto l by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> b >0_goto l by A1,SCMFSA_2:45;
    thus Divide(a,e) <> b >0_goto l & Divide(e,a) <> b >0_goto l by A1,
SCMFSA_2:46;
    thus a :=(f,e) <> b >0_goto l by A1,SCMFSA_2:50;
    thus a :=len f <> b >0_goto l by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location, f being FinSeq-Location holds a <> b
  implies not b := (f,c) destroy a
proof
  let a,b,c be Int-Location;
  let f be FinSeq-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let h be FinSeq-Location;
A2: InsCode (b := (f,c)) = 9 by SCMFSA_2:50;
    hence a := e <> b := (f,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> b := (f,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> b := (f,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> b := (f,c) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> b := (f,c) & Divide(e,a) <> b := (f,c) by A2,
SCMFSA_2:46;
    thus a := (h,e) <> b := (f,c) by A1,SF_MASTR:13;
    thus a :=len h <> b := (f,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location, f being FinSeq-Location holds
  not (f,c):= b destroy a
proof
  let a,b,c be Int-Location;
  let f be FinSeq-Location;
  now
    let e be Int-Location;
    let h be FinSeq-Location;
A1: InsCode ((f,c) := b) = 10 by SCMFSA_2:51;
    hence a := e <> (f,c) := b by SCMFSA_2:42;
    thus AddTo(a,e) <> (f,c) := b by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> (f,c) := b by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> (f,c) := b by A1,SCMFSA_2:45;
    thus Divide(e,a) <> (f,c) := b & Divide(a,e) <> (f,c) := b by A1,
SCMFSA_2:46;
    thus a := (h,e) <> (f,c) := b by A1,SCMFSA_2:50;
    thus a :=len h <> (f,c) := b by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, f being FinSeq-Location holds a <> b
  implies not b :=len f destroy a
proof
  let a,b be Int-Location;
  let f be FinSeq-Location;
  assume
A1: a <> b;
  now
    let c be Int-Location;
    let g be FinSeq-Location;
A2: InsCode (b :=len f) = 11 by SCMFSA_2:52;
    hence a := c <> b :=len f by SCMFSA_2:42;
    thus AddTo(a,c) <> b :=len f by A2,SCMFSA_2:43;
    thus SubFrom(a,c) <> b :=len f by A2,SCMFSA_2:44;
    thus MultBy(a,c) <> b :=len f by A2,SCMFSA_2:45;
    thus Divide(a,c) <> b :=len f & Divide(c,a) <> b :=len f by A2,SCMFSA_2:46;
    thus a :=(g,c) <> b :=len f by A2,SCMFSA_2:50;
    thus a :=len g <> b :=len f by A1,SF_MASTR:15;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, f being FinSeq-Location holds
   not f:=<0,...,0> b destroy a
proof
  let a,b be Int-Location;
  let f be FinSeq-Location;
  now
    let e be Int-Location;
    let h be FinSeq-Location;
A1: InsCode (f :=<0,...,0> b) = 12 by SCMFSA_2:53;
    hence a := e <> f :=<0,...,0> b by SCMFSA_2:42;
    thus AddTo(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:45;
    thus Divide(a,e) <> f :=<0,...,0> b & Divide(e,a) <> f :=<0,...,0> b by A1,
SCMFSA_2:46;
    thus a :=(h,e) <> f :=<0,...,0> b by A1,SCMFSA_2:50;
    thus a :=len h <> f :=<0,...,0> b by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

definition
  canceled;
  let I be FinPartState of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_on s means
  :Def7:
  for k being Element of NAT holds IC
  Comput(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,
SCM+FSA)),k) in dom I;
  pred I is_halting_on s means
  :Def8:
  ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (I +* Start-At( 0,SCM+FSA));
end;

theorem Th24:
  for I being Program of SCM+FSA holds I is paraclosed iff for s
  being State of SCM+FSA holds I is_closed_on s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is paraclosed;
    let s be State of SCM+FSA;
    for k being Element of NAT holds IC Comput(ProgramPart(s +* (I +*
Start-At(
     0,SCM+FSA))),s +* (I +* Start-At(
     0,SCM+FSA)),k) in dom I by A1,FUNCT_4:26,SCMFSA6B:def 2;
    hence I is_closed_on s by Def7;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_closed_on s;
  now
    let s be State of SCM+FSA;
    let k be Element of NAT;
    assume I +* Start-At( 0,SCM+FSA) c= s;
    then
A3: s = s +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
    I is_closed_on s by A2;
    hence IC Comput(ProgramPart(s),s,k) in dom I by A3,Def7;
  end;
  hence thesis by SCMFSA6B:def 2;
end;

theorem
  for I being Program of SCM+FSA holds I is parahalting iff for s being
  State of SCM+FSA holds I is_halting_on s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is parahalting;
    let s be State of SCM+FSA;
    I +* Start-At( 0,SCM+FSA) c= s +* (I +* Start-At( 0,SCM+FSA))
     & I +*
    Start-At( 0,SCM+FSA) is halting by A1,FUNCT_4:26,SCMFSA6B:def 3;
    then ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (I +* Start-At( 0,SCM+FSA)) by EXTPRO_1:def 10;
    hence I is_halting_on s by Def8;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_halting_on s;
  now
    let s be State of SCM+FSA;
    assume I +* Start-At( 0,SCM+FSA) c= s;
    then
A3: s = s +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
    I is_halting_on s by A2;
    hence ProgramPart s halts_on s by A3,Def8;
  end;
  then I +* Start-At( 0,SCM+FSA) is halting by EXTPRO_1:def 10;
  hence thesis by SCMFSA6B:def 3;
end;

theorem Th26:
  for i being Instruction of SCM+FSA, a being Int-Location, s
  being State of SCM+FSA holds not i destroy a implies Exec(i,s).a = s.a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  let s be State of SCM+FSA;
  assume
A1: not i destroy a;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider da,db being Int-Location such that
A5: i = da := db by SCMFSA_2:54;
    da <> a by A1,A5,Def3;
    hence thesis by A5,SCMFSA_2:89;
  end;
  suppose
    InsCode i = 2;
    then consider da, db being Int-Location such that
A6: i = AddTo(da,db) by SCMFSA_2:55;
    da <> a by A1,A6,Def3;
    hence thesis by A6,SCMFSA_2:90;
  end;
  suppose
    InsCode i = 3;
    then consider da, db being Int-Location such that
A7: i = SubFrom(da, db) by SCMFSA_2:56;
    da <> a by A1,A7,Def3;
    hence thesis by A7,SCMFSA_2:91;
  end;
  suppose
    InsCode i = 4;
    then consider da, db being Int-Location such that
A8: i = MultBy(da,db) by SCMFSA_2:57;
    da <> a by A1,A8,Def3;
    hence thesis by A8,SCMFSA_2:92;
  end;
  suppose
    InsCode i = 5;
    then consider da, db being Int-Location such that
A9: i = Divide(da, db) by SCMFSA_2:58;
    da <> a & db <> a by A1,A9,Def3;
    hence thesis by A9,SCMFSA_2:93;
  end;
  suppose
    InsCode i = 6;
    then ex loc being Element of NAT st i = goto loc by SCMFSA_2:59;
    hence thesis by SCMFSA_2:95;
  end;
  suppose
    InsCode i = 7;
    then
    ex loc being Element of NAT, da being Int-Location st
    i = da=0_goto loc by SCMFSA_2:60;
    hence thesis by SCMFSA_2:96;
  end;
  suppose
    InsCode i = 8;
    then
    ex loc being Element of NAT, da being Int-Location st
    i = da>0_goto loc by SCMFSA_2:61;
    hence thesis by SCMFSA_2:97;
  end;
  suppose
    InsCode i = 9;
    then consider db, da being Int-Location, g being FinSeq-Location such that
A10: i = da := (g,db) by SCMFSA_2:62;
    da <> a by A1,A10,Def3;
    hence thesis by A10,SCMFSA_2:98;
  end;
  suppose
    InsCode i = 10;
    then ex db, da being Int-Location, g being FinSeq-Location st i = (g,db):=
    da by SCMFSA_2:63;
    hence thesis by SCMFSA_2:99;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, g being FinSeq-Location such that
A11: i = da :=len g by SCMFSA_2:64;
    da <> a by A1,A11,Def3;
    hence thesis by A11,SCMFSA_2:100;
  end;
  suppose
    InsCode i = 12;
    then
    ex da being Int-Location, g being FinSeq-Location st i = g :=<0,...,0>
    da by SCMFSA_2:65;
    hence thesis by SCMFSA_2:101;
  end;
end;

theorem Th27:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st not I destroy a & I is_closed_on s holds for k being
  Element of NAT holds Comput(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s
+* (I +* Start-At( 0,SCM+FSA)),k).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: not I destroy a;
  defpred P[Nat] means
   Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA)
),$1).a
  = s.a;
  dom I misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
  then
  I +* Start-At( 0,SCM+FSA) c= s+*(I+*Start-At( 0,SCM+FSA))
   & I c= I +* Start-At(
   0,SCM+FSA) by FUNCT_4:26,33;
  then
A2: I c= s+*(I+*Start-At( 0,SCM+FSA)) by XBOOLE_1:1;
  assume
A3: I is_closed_on s;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    set l = IC Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At
( 0,SCM+FSA)),k);
A6: l in dom I by A3,Def7;
    then (s+*(I+*Start-At( 0,SCM+FSA))).l = I.l by A2,GRFUNC_1:8;
    then (s+*(I+*Start-At( 0,SCM+FSA))).l in rng I by A6,FUNCT_1:def 5;
    then
A7: (s+*(I+*Start-At( 0,SCM+FSA))).l does not destroy a by A1,Def4;
    Comput(ProgramPart((s+*(I+*Start-At( 0,SCM+FSA)))),(s+*(I+*Start-At( 0,
SCM+FSA))),k + 1).a =
     (Following(ProgramPart ((s+*(I+*Start-At( 0,SCM+FSA)))),
     Comput(ProgramPart((s+*(I+*Start-At( 0,SCM+FSA)))),(s+*(I+*Start-At( 0,
SCM+FSA))),k))).a
      by EXTPRO_1:4
      .= Exec(CurInstr(
       ProgramPart Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*
Start-At( 0,SCM+FSA)),k),
          Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,
SCM+FSA)),k)),
       Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,
SCM+FSA)),k)).a by AMI_1:123
      .= Exec(Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At(
0,SCM+FSA)),k).l,
       Comput(ProgramPart(s+*(I
    +*Start-At( 0,SCM+FSA))),s+*(I
    +*Start-At( 0,SCM+FSA)),k)).a by COMPOS_1:38
      .= Exec( (s+*(I+*Start-At( 0,SCM+FSA))).l,
       Comput(ProgramPart(s+*(I+*Start-At(
     0,SCM+FSA))),s+*(I+*Start-At(
     0,SCM+FSA)),k)).a by AMI_1:54
      .= s.a by A5,A7,Th26;
    hence P[k+1];
  end;
A8: not a in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA))
,0).a =
   (s+*(I+*Start-At( 0,SCM+FSA)))
  .a by EXTPRO_1:3
    .= s.a by A8,FUNCT_4:12;
  then
A9: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A9, A4);
end;

registration
  cluster Stop SCM+FSA -> parahalting good;
  coherence
   proof
    thus Stop SCM+FSA is parahalting
proof
  now
    dom Stop SCM+FSA misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
    then
A1: Stop SCM+FSA c= Stop SCM+FSA +* Start-At( 0,SCM+FSA) by FUNCT_4:33;

A2: dom Stop SCM+FSA c= dom (Stop SCM+FSA +* Start-At( 0,SCM+FSA))
 by FUNCT_4:11;
A3:  0 in dom Stop SCM+FSA by AFINSQ_1:69;
A4: IC SCM+FSA in dom (Stop SCM+FSA +* Start-At( 0,SCM+FSA))
 by COMPOS_1:141;
    let s be State of SCM+FSA;
    assume
A5: Stop SCM+FSA +* Start-At( 0,SCM+FSA) c= s;
    CurInstr(ProgramPart s,Comput(ProgramPart(s),s,0))
     = CurInstr(ProgramPart s,s) by EXTPRO_1:3
      .= s.IC s by COMPOS_1:38
      .= s.(IC(Stop SCM+FSA +* Start-At( 0,SCM+FSA))) by A5,A4,GRFUNC_1:8
      .= s. 0 by COMPOS_1:142
      .= (Stop SCM+FSA +* Start-At( 0,SCM+FSA)). 0
       by A5,A2,A3,GRFUNC_1:8
      .= (Stop SCM+FSA). 0 by A1,A3,GRFUNC_1:8
      .= halt SCM+FSA by AFINSQ_1:38;
    hence ProgramPart s halts_on s by EXTPRO_1:30;
  end;
  then Stop SCM+FSA +* Start-At( 0,SCM+FSA) is halting by EXTPRO_1:def 10;
  hence thesis by SCMFSA6B:def 3;
end;
   thus Stop SCM+FSA does not destroy intloc 0
proof
  now
    let i be Instruction of SCM+FSA;
A1: rng Stop SCM+FSA = {halt SCM+FSA} by AFINSQ_1:36;
    assume i in rng Stop SCM+FSA;
    then i = halt SCM+FSA by A1,TARSKI:def 1;
    hence i does not destroy intloc 0 by Th11;
  end;
  hence thesis by Def4;
end;
   end;
end;

registration
  cluster parahalting good Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster paraclosed good -> keeping_0 Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed good;
    then
A2: I does not destroy intloc 0 by Def5;
    now
      let s be State of SCM+FSA;
      assume I +* Start-At( 0,SCM+FSA) c= s;
      then
A3:   s +* (I +* Start-At( 0,SCM+FSA)) = s by FUNCT_4:79;
      let k be Element of NAT;
      thus Comput(ProgramPart(s),s,k).intloc 0 = s.intloc 0
       by A2,A3,Th27,A1,Th24;
    end;
    hence thesis by SCMFSA6B:def 4;
  end;
end;

canceled;

theorem Th29:
  for a being Int-Location, k being Integer holds rng aSeq(a,k) c=
  {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
proof
  let a be Int-Location;
  let k be Integer;
  now
    let x be set;
    assume
A1: x in rng aSeq(a,k);
    per cases;
    suppose
A2:   k > 0 & k = 0 + 1;
      then
      ex k1 being Element of NAT st k1 + 1 = k & aSeq(a,k) = <% a := intloc
      0 %> ^ (k1 --> AddTo(a,intloc 0)) by SCMFSA_7:def 3;
      then aSeq(a,k) = <% a := intloc 0 %> ^ {} by A2
        .= <% a := intloc 0 %> by AFINSQ_1:32;
      then rng aSeq(a,k) = {a := intloc 0} by AFINSQ_1:36;
      then x = a := intloc 0 by A1,TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
    suppose
A3:   k > 0 & k <> 1;
      then consider k1 being Element of NAT such that
A4:   k1 + 1 = k and
A5:   aSeq(a,k) = <% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0)) by
SCMFSA_7:def 3;
A6:   k1 <> 0 by A3,A4;
      rng aSeq(a,k) = rng <% a := intloc 0 %> \/ rng (k1 --> AddTo(a,
      intloc 0)) by A5,AFINSQ_1:29
        .= {a := intloc 0} \/ rng ( k1 --> AddTo(a,intloc 0)) by AFINSQ_1:36
        .= {a := intloc 0} \/ {AddTo(a,intloc 0)} by A6,FUNCOP_1:14;
      then x in {a := intloc 0} or x in {AddTo(a,intloc 0)} by A1,
XBOOLE_0:def 3;
      then x = a := intloc 0 or x = AddTo(a,intloc 0) by TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
    suppose
A7:   not k > 0;
      then consider k1 being Element of NAT such that
A8:   k1 + k = 1 and
A9:   aSeq(a,k) = <% a := intloc 0 %> ^ (k1 --> SubFrom(a,intloc 0))
      by SCMFSA_7:def 3;
A10:  k1 <> 0 by A7,A8;
      rng aSeq(a,k) = rng <% a := intloc 0 %> \/ rng (k1 --> SubFrom(a,
      intloc 0)) by A9,AFINSQ_1:29
        .= {a := intloc 0} \/ rng ( k1 --> SubFrom(a,intloc 0)) by AFINSQ_1:36
        .= {a := intloc 0} \/ {SubFrom(a,intloc 0)} by A10,FUNCOP_1:14;
      then x in {a := intloc 0} or x in {SubFrom(a,intloc 0)} by A1,
XBOOLE_0:def 3;
      then x = a := intloc 0 or x = SubFrom(a,intloc 0) by TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th30:
  for a being Int-Location, k being Integer holds rng (a := k) c=
  {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
proof
  let a be Int-Location;
  let k be Integer;
  now
    let x be set;
A1: rng aSeq(a,k) c= {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0 )
    } by Th29;
A2: rng (a := k) = rng (aSeq(a,k) ^ <% halt SCM+FSA %>) by SCMFSA_7:33
      .= rng aSeq(a,k) \/ rng <% halt SCM+FSA %> by AFINSQ_1:29,SCMFSA_7:33
      .= rng aSeq(a,k) \/ {halt SCM+FSA} by AFINSQ_1:36;
    assume x in rng (a := k);
    then x in rng aSeq(a,k) or x in {halt SCM+FSA} by A2,XBOOLE_0:def 3;
    then
    x = a := intloc 0 or x = AddTo(a,intloc 0) or x = SubFrom(a,intloc 0)
    or x = halt SCM+FSA by A1,ENUMSET1:def 1,TARSKI:def 1;
    hence
    x in {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0
    )} by ENUMSET1:def 2;
  end;
  hence thesis by TARSKI:def 3;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> good;
  correctness
  proof
    now
      let i be Instruction of SCM+FSA;
A1:   rng (a := k) c= {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),
      SubFrom(a,intloc 0)} by Th30;
      assume
A2:   i in rng (a := k);
      per cases by A2,A1,ENUMSET1:def 2;
      suppose
        i = halt SCM+FSA;
        hence i does not destroy intloc 0 by Th11;
      end;
      suppose
        i = a := intloc 0;
        hence i does not destroy intloc 0 by Th12;
      end;
      suppose
        i = AddTo(a,intloc 0);
        hence i does not destroy intloc 0 by Th13;
      end;
      suppose
        i = SubFrom(a,intloc 0);
        hence i does not destroy intloc 0 by Th14;
      end;
    end;
    then a := k does not destroy intloc 0 by Def4;
    hence thesis by Def5;
  end;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> keeping_0;
  correctness;
end;

