:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, AMI_1, SCMFSA_2, RELAT_1, SCMFSA_7,
      ARYTM_3, ARYTM_1, TARSKI, FUNCT_1, XXREAL_0, PARTFUN1, CAT_1, NAT_1,
      CARD_1, FUNCOP_1, SCMFSA6A, ORDINAL4, AMI_3, FUNCT_4, INT_1, GRAPHSP,
      FSM_1, CIRCUIT2, SCMNORM, SCMFSA6B, GLIB_000, SF_MASTR, MSUALG_1,
      XBOOLE_0, PRE_POLY, UNIALG_2, AMISTD_2, SCMFSA7B, ORDINAL1, AFINSQ_1,
      PBOOLE, SCMFSA6C, STRUCT_0, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0, MEMSTR_0, COMPOS_1,
      EXTPRO_1, FUNCT_7, SCMFSA_2,
      AMISTD_1, AMISTD_2, FUNCOP_1, XXREAL_0, ENUMSET1,
      NAT_D, PBOOLE, AFINSQ_2, SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B, INT_2,
      PRE_POLY;
 constructors ENUMSET1, XXREAL_0, REAL_1, SCMFSA_7, SCMFSA6A, SF_MASTR,
      SCMFSA6B, NAT_D, RELSET_1, PRE_POLY, DOMAIN_1, AFINSQ_2, PARTFUN3,
      PBOOLE, AMISTD_1, AMISTD_2, AMI_3, MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, FUNCT_7, SCMFSA_2, SF_MASTR,
      SCMFSA6B, ORDINAL1, FINSET_1, FINSEQ_2, CARD_1, AFINSQ_1, COMPOS_1,
      AFINSQ_2, ORDINAL5, EXTPRO_1, PBOOLE, FUNCT_4, STRUCT_0, SCMFSA6A,
      SCMFSA_4, MEMSTR_0, VALUED_1, SCMFSA10, AMISTD_2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, AFINSQ_1, RELAT_1, FINSEQ_1, FINSEQ_2, SCMFSA_2, FUNCOP_1,
      SCMFSA6A, SCMFSA6B, COMPOS_1,
      AMISTD_1, SCMFSA_7, EXTPRO_1, MEMSTR_0, AFINSQ_2;
 theorems SCMFSA_7, NAT_1, GRFUNC_1, FUNCT_1, FUNCT_4, FUNCT_7, ENUMSET1,
      SCMFSA_2, FUNCOP_1, INT_1, RELAT_1, TARSKI, SCMFSA6A, SF_MASTR, SCMFSA6B,
      XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, AFINSQ_1, COMPOS_1, AFINSQ_2,
      CARD_1, EXTPRO_1, PARTFUN1, AMISTD_1, MEMSTR_0;
 schemes NAT_1, AFINSQ_1;

begin

reserve m for Element of NAT;
reserve P for Instruction-Sequence of SCM+FSA;
set A = NAT;



theorem
  for i being Instruction of SCM+FSA holds (i = halt SCM+FSA implies (
  Directed Macro i). 0 = goto  2) & (i <> halt SCM+FSA implies (
  Directed Macro i). 0 = i)
proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:45;
  let i be Instruction of SCM+FSA;
A2: (Macro i). 0 = i by COMPOS_1:58;
   0 in { 0, 1} by TARSKI:def 2;
  then
A3:  0 in dom Macro i by COMPOS_1:61;
A4: card Macro i = 2 by COMPOS_1:56;
  hereby
A5: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:45;
    assume
A6: i = halt SCM+FSA;
    dom (halt SCM+FSA .--> goto  2) = {halt SCM+FSA} by FUNCOP_1:13;
    then
A7: i in dom (halt SCM+FSA .--> goto  2) by A6,TARSKI:def 1;
    rng Macro i c= the Instructions of SCM+FSA by RELAT_1:def 19;
    hence
    (Directed Macro i). 0 = (((id the Instructions of SCM+FSA) +* (
    halt SCM+FSA, goto  2))*Macro i). 0 by A4,FUNCT_7:116
      .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
     2))*Macro i). 0 by A5,FUNCT_7:def 3
      .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
    2)).i by A3,A2,FUNCT_1:13
      .= (halt SCM+FSA .--> goto  2).i by A7,FUNCT_4:13
      .= goto  2 by A6,FUNCOP_1:72;
  end;
A8: dom (halt SCM+FSA .--> goto  2) = {halt SCM+FSA} by FUNCOP_1:13;
  assume i <> halt SCM+FSA;
  then
A9: not i in dom (halt SCM+FSA .--> goto  2) by A8,TARSKI:def 1;
  rng Macro i c= the Instructions of SCM+FSA by RELAT_1:def 19;
  hence (Directed Macro i). 0 = (((id the Instructions of SCM+FSA) +* (
  halt SCM+FSA, goto  2))* Macro i). 0 by A4,FUNCT_7:116
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
  2))* Macro i). 0 by A1,FUNCT_7:def 3
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto  2
  )).i by A3,A2,FUNCT_1:13
    .= (id the Instructions of SCM+FSA).i by A9,FUNCT_4:11
    .= i by FUNCT_1:18;
end;

theorem
  for i being Instruction of SCM+FSA holds (Directed Macro i). 1 = goto  2
proof
  let i be Instruction of SCM+FSA;
A1: (Macro i). 1 = halt SCM+FSA by COMPOS_1:59;
   1 in { 0, 1} by TARSKI:def 2;
  then
A2:  1 in dom Macro i by COMPOS_1:61;
  dom (halt SCM+FSA .--> goto  2 ) = {halt SCM+FSA} by FUNCOP_1:13;
  then
A3: halt SCM+FSA in dom (halt SCM+FSA .--> goto  2) by TARSKI:def 1;
A4: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:45;
  card Macro i = 2 & rng Macro i c= the Instructions of SCM+FSA
   by COMPOS_1:56,RELAT_1:def 19;
  hence (Directed Macro i). 1 = (((id the Instructions of SCM+FSA) +* (
  halt SCM+FSA,goto  2))* Macro i). 1 by FUNCT_7:116
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
  2))* Macro i). 1 by A4,FUNCT_7:def 3
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto  2
  )). halt SCM+FSA by A2,A1,FUNCT_1:13
    .= (halt SCM+FSA .--> goto  2).halt SCM+FSA by A3,FUNCT_4:13
    .= goto  2 by FUNCOP_1:72;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> initial non empty
    NAT-defined (the Instructions of SCM+FSA)-valued;
  coherence
  proof
     a := k = aSeq(a,k) ^ <% halt SCM+FSA %> by SCMFSA_7:1;
    hence thesis;
  end;
end;

Lm1: for s being State of SCM+FSA st IC s =  0
  for P being Instruction-Sequence of SCM+FSA
  for a being Int-Location, k being Integer
     st a := k c= P
   holds P halts_on s

proof
  let s be State of SCM+FSA;
  assume
A1: IC s =  0;
  let P be Instruction-Sequence of SCM+FSA;
A2: dom P = NAT by PARTFUN1:def 2;
  let a be Int-Location, k be Integer;
  assume
A3: a := k c= P;
  per cases;
  suppose
A4: k > 0;
    then consider k1 being Element of NAT such that
A5: k1 + 1 = k and
A6: a := k = <% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0)) ^
    <% halt SCM+FSA %> by SCMFSA_7:def 1;
A7: len (<% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0))) = len <% a :=
    intloc 0 %> + len (k1 --> AddTo(a,intloc 0)) by AFINSQ_1:17
      .= 1 + len (k1 --> AddTo(a,intloc 0)) by AFINSQ_1:34
      .= k by A5,CARD_1:64;
    set f = <% a:=intloc 0 %> ^ (k1 --> AddTo(a,intloc 0)) ^ <% halt SCM+FSA
    %>;
A8: f.0 = (<% a := intloc 0 %> ^ ((k1 --> AddTo(a,intloc 0)) ^ <%halt
    SCM+FSA%>)).0 by AFINSQ_1:27
      .= a := intloc 0 by AFINSQ_1:35;
    reconsider k as Element of NAT by A4,INT_1:3;
A9:  len f = len (<% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0))) + len
    <% halt SCM+FSA %> by AFINSQ_1:17
      .= k + 1 by A7,AFINSQ_1:34;
A10: now
      let i be Element of NAT;
      assume that
A11:  i <= k;
      i < k + 1 by A11,NAT_1:13;
      hence  i in dom  f by A9,NAT_1:44;
    end;
A12: now
      let i be Element of NAT;
      assume that
A13:  i <= k;
   i in dom  f by A10,A13;
      hence P.i = f.i by A3,A6,GRFUNC_1:2;
    end;
    then
A14: P. 0 = a := intloc 0 by A8;
A15: now
      let n be Element of NAT;
      assume n = 0;
      hence
A16:  Comput(P,s,n) = s by EXTPRO_1:2;

      hence CurInstr(P,Comput(P,s,n)) = a:= intloc 0
           by A1,A14,A2,PARTFUN1:def 6;
      thus Comput(P,s,n+1) = Following(P,
      Comput(P,s,n)) by EXTPRO_1:3
        .= Exec(a:= intloc 0,s) by A16,A1,A14,A2,PARTFUN1:def 6;
    end;
A17: now
      let i be Element of NAT;
      assume that
A18:  1 <= i and
A19:  i < k;
      reconsider i1 = i - 1 as Element of NAT by A18,INT_1:5;
      i - 1 < k - 1 by A19,XREAL_1:9;
      then
A20:  i1 in k1 by A5,NAT_1:44;
A21:  len <%a:= intloc 0%> = 1 by AFINSQ_1:33;
A22:   len(k1-->AddTo(a,intloc 0)) = k1 by CARD_1:64;
      i in dom (<%a:=intloc 0%>^(k1-->AddTo(a,intloc 0)))
           by A19,A7,NAT_1:44;
      hence f.i=(<%a:=intloc 0%>^(k1-->AddTo(a,intloc 0))).i by AFINSQ_1:def 3
        .= (k1-->AddTo(a,intloc 0)).(i - 1)
         by A18,A19,A21,A22,A5,AFINSQ_1:18
        .= AddTo(a,intloc 0) by A20,FUNCOP_1:7;
    end;
A23: now
      let i be Element of NAT;
      assume that
A24:  0 < i and
A25:  i < k;
A26:  0+1 <= i by A24,NAT_1:13;
      thus P. i = f.(i) by A12,A25
        .=AddTo(a,intloc 0) by A17,A26,A25;
    end;
A27: for i being Element of NAT st i <= k
      holds IC Comput(P,s,i) = i
    proof
      defpred P[Nat] means $1 <= k implies IC Comput(P,s,$1) =
       $1;

      let i be Element of NAT;
      assume
A28:  i <= k;
A29:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A30:    P[n];
        assume
A31:    n+1 <= k;
        then
A32:    n < k by NAT_1:13;
        per cases;
        suppose
A33:      n=0;
          hence IC Comput(P,s,n+1)
            = Exec(a:= intloc 0,s).IC SCM+FSA by A15
            .= succ n by A1,A33,SCMFSA_2:63
            .= n+1 by NAT_1:38;
        end;
        suppose
A34:      n>0;
          n + 0 <= n + 1 by XREAL_1:7;

          then
A35:      CurInstr(P,Comput(P,s,n)) = P. n
           by A30,A31,A2,PARTFUN1:def 6,XXREAL_0:2
            .= AddTo(a,intloc 0) by A23,A32,A34;
A36:      Comput(P,s,n+1) = Following(P,
Comput(P,s,n)) by EXTPRO_1:3

            .= Exec(AddTo(a,intloc 0), Comput(P,s,n))
                 by A35;
          thus IC Comput(P,s,n+1)
             = succ IC Comput(P,s,n) by A36,SCMFSA_2:64
            .= n+1 by A30,A31,NAT_1:13,38;
        end;
      end;
A37:  P[0] by A1,EXTPRO_1:2;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A37,A29);
      hence thesis by A28;
    end;
   k < k + len <%halt SCM+FSA%> by XREAL_1:29;
   then
A38: f.(k) = <% halt SCM+FSA %>.(k - k) by A7,AFINSQ_1:18
      .= halt SCM+FSA by AFINSQ_1:34;
    CurInstr(P,Comput(P,s,k)) = P.IC Comput(P,s,k) by A2,PARTFUN1:def 6
      .= P. k by A27
      .= halt SCM+FSA by A38,A12;
    hence thesis by EXTPRO_1:29;
  end;
  suppose
A39: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:3;
    consider k1 being Element of NAT such that
A40: k1 + k = 1 and

A41: a:=k =  (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)) ^ <%
    halt SCM+FSA%>) by A39,SCMFSA_7:def 1;

A42: len (<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0))) = len<%a:=intloc 0%>
    + len(k1-->SubFrom(a,intloc 0)) by AFINSQ_1:17

      .= 1 + len(k1-->SubFrom(a,intloc 0)) by AFINSQ_1:34
      .= mk+1+1 by A40,CARD_1:64;
    set f = <%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)) ^ <%halt SCM+FSA%>;

A43: f.0 = (<%a:=intloc 0%>^((k1-->SubFrom(a,intloc 0))^<%halt SCM+FSA%>))
    .0 by AFINSQ_1:27

      .= a := intloc 0 by AFINSQ_1:35;

A44: len f = len(<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0)))+len<%halt
    SCM+FSA %> by AFINSQ_1:17

      .= mk+1+1 + 1 by A42,AFINSQ_1:34;
A45: now
      let i be Element of NAT;
      assume that
      0 <= i and
A46:  i <= mk+1+1;
      i < mk+1+1+1 by A46,NAT_1:13;
      hence  i in dom  f by A44,NAT_1:44;
    end;
A47: now
      let i be Element of NAT;
      assume that
      0 <= i and
A48:  i <= mk+1+1;
   i in dom  f by A45,A48;
      hence P.i = f.i by A3,A41,GRFUNC_1:2;
    end;
    then
A49: P.0 = a := intloc 0 by A43;
A50: now
      let n be Element of NAT;
      assume n = 0;
      hence
A51:  Comput(P,s,n) = s by EXTPRO_1:2;

      hence CurInstr(P,Comput(P,s,n)) = a:= intloc 0
      by A1,A49,A2,PARTFUN1:def 6;
      thus Comput(P,s,n+1) = Following(P,
      Comput(P,s,n)) by EXTPRO_1:3
        .= Exec(a:= intloc 0,s) by A51,A1,A49,A2,PARTFUN1:def 6;
    end;
A52: now
A53:  len <%a:= intloc 0%> = 1 by AFINSQ_1:33;
      let i be Element of NAT;
      assume that
A54:  1 <= i and
A55:  i < mk+1+1;
      reconsider i1 = i - 1 as Element of NAT by A54,INT_1:5;
      i-1 < k1+1-1 by A55,A40,XREAL_1:9;
      then
A56:  i1 in k1 by NAT_1:44;
A57:   len(k1-->SubFrom(a,intloc 0)) = k1 by CARD_1:64;
      i in dom (<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0)))
       by A55,A42,NAT_1:44;
      hence f.i = (<%a:=intloc 0%>^(k1-->SubFrom(a,intloc 0))).i by
AFINSQ_1:def 3
        .= (k1-->SubFrom(a,intloc 0)).(i - 1)
             by A40,A54,A55,A53,A57,AFINSQ_1:18
        .= SubFrom(a,intloc 0) by A56,FUNCOP_1:7;
    end;
A58: now
      let i be Element of NAT;
      assume that
A59:  0 < i and
A60:  i < mk+1+1;
A61:   0+1 <= i by A59,NAT_1:13;
      thus P. i = f.(i) by A47,A60
        .=SubFrom(a,intloc 0) by A52,A61,A60;
    end;
A62: for i being Element of NAT st i <= mk+1+1 holds IC Comput(P,s,i) = i
    proof
      defpred P[Nat] means $1<=mk+1+1 implies IC Comput(P,s,$1)= $1;
      let i be Element of NAT;
      assume
A63:  i <= mk+1+1;
A64:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A65:    P[n];
        assume
A66:    n+1 <= mk+1+1;
        then
A67:    n < mk+1+1 by NAT_1:13;
        per cases;
        suppose
A68:      n=0;
          hence IC Comput(P,s,n+1)
             = Exec(a:= intloc 0,s).IC SCM+FSA by A50
            .= succ n by A1,A68,SCMFSA_2:63
            .= n+1 by NAT_1:38;
        end;
        suppose
A69:      n>0;
          n + 0 <= n + 1 by XREAL_1:7;

          then
A70:      CurInstr(P,Comput(P,s,n)) = P. n
           by A65,A66,A2,PARTFUN1:def 6,XXREAL_0:2
            .= SubFrom(a,intloc 0) by A58,A67,A69;
A71:      Comput(P,s,n+1) = Following(P,Comput(P,s,n)) by EXTPRO_1:3

            .= Exec(SubFrom(a,intloc 0), Comput(P,s,n))
             by A70;

          thus IC Comput(P,s,n+1)
             = succ IC Comput(P,s,n) by A71,SCMFSA_2:65
            .= n+1 by A65,A66,NAT_1:13,38;
        end;
      end;
A72:  P[0] by A1,EXTPRO_1:2;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A72,A64);
      hence thesis by A63;
    end;

  len (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0))) <= mk+1+1 &
  mk+1+1 < len (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)))
   + len <%halt SCM+FSA%> implies
   f.(mk+1+1)=<%halt SCM+FSA%>.(mk+1+1-
   len (<%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0))))
           by AFINSQ_1:18;
   then
A73: f.(mk+1+1) = halt SCM+FSA by A42,AFINSQ_1:34,XREAL_1:29;
   CurInstr(P,Comput(P,s,mk+1+1))
    = P.IC Comput(P,s,mk+1+1) by A2,PARTFUN1:def 6

      .= P. (mk+1+1) by A62
      .= halt SCM+FSA by A73,A47;
    hence thesis by EXTPRO_1:29;
  end;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> parahalting;
  correctness
  proof
B1:   IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
      let s be 0-started State of SCM+FSA;
A2:   Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
     let P be Instruction-Sequence of SCM+FSA
     such that
A3:   a := k c= P;
      IC s = IC Start-At(0,SCM+FSA) by A2,B1,GRFUNC_1:2
        .=  0 by FUNCOP_1:72;
      hence P halts_on s by Lm1,A3;
  end;
end;

theorem
  for s being State of SCM+FSA for a being read-write Int-Location, k
  being Integer holds IExec(a := k,P,s).a = k & (for b being read-write
  Int-Location st b <> a holds IExec(a := k,P,s).b = s.b) & for f being
  FinSeq-Location holds IExec(a := k,P,s).f = s.f
proof
  let s be State of SCM+FSA;
  let a be read-write Int-Location;
  let k be Integer;
  set s1 = s +* Initialize((intloc 0).-->1);
A1: s1.intloc 0 = (Initialize((intloc 0).-->1)).intloc 0
       by FUNCT_4:13,SCMFSA6A:41
    .= 1 by SCMFSA6A:43;
  reconsider s1 as 0-started State of SCM+FSA;
A2: a := k c= P+*(a:=k) by FUNCT_4:25;
  thus IExec(a := k,P,s).a = (Result(P+*(a:=k),s1)).a
    .= k by A1,A2,SCMFSA_7:6;
  hereby
    let b be read-write Int-Location;
    assume
A3: b <> a;
    b <> intloc 0 & b <> IC SCM+FSA by SCMFSA_2:56;
    then
B4: not b in dom Initialize((intloc 0).-->1) by SCMFSA6A:42,TARSKI:def 2;
    thus IExec(a := k,P,s).b = (Result(P+*(a:=k),s1)).b
      .= s1.b by A1,A2,A3,SCMFSA_7:6
      .= s.b by B4,FUNCT_4:11;
  end;
  let f be FinSeq-Location;
    f <> intloc 0 & f <> IC SCM+FSA by SCMFSA_2:57,58;
   then
B5: not f in dom Initialize((intloc 0).-->1) by SCMFSA6A:42,TARSKI:def 2;
  thus IExec(a := k,P,s).f = (Result(P+*(a:=k),s1)).f
    .= s1.f by A1,A2,SCMFSA_7:6
    .= s.f by B5,FUNCT_4:11;
end;

Lm2: for p1,p2,p3,p4 being XFinSequence
 holds p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3 ^ p4)

proof
  let p1,p2,p3,p4 be XFinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4 by AFINSQ_1:27
    .= p1 ^ (p2 ^ p3 ^ p4) by AFINSQ_1:27;
end;

Lm3:
 for c0 being Element of NAT
 for s being c0-started State of SCM+FSA
 for P being Instruction-Sequence of SCM+FSA
for a being Int-Location, k being Integer st
 for c being Element of NAT st c < len aSeq(a,k)
  holds aSeq(a,k).c = P. (c0 + c)
for i being Element of NAT st i <= len aSeq(a,k)
 holds IC Comput(P,s,i) = c0 + i

proof
  let c0 be Element of NAT;
  let s be c0-started State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA;
A1: dom P = NAT by PARTFUN1:def 2;
A2: IC s =  c0 by MEMSTR_0:def 9;
  let a be Int-Location;
  let k be Integer;
  assume
A3: for c being Element of NAT st c < len aSeq(a,k)
    holds aSeq(a,k).c = P. (c0 + c);
A4: for c being Element of NAT st c in dom aSeq(a,k)
   holds aSeq(a,k).c = P.(c0 + c)
    proof let c be Element of NAT;
     assume c in dom aSeq(a,k);
      then c < len aSeq(a,k) by AFINSQ_1:66;
     hence aSeq(a,k).c = P.(c0 + c) by A3;
    end;
  per cases;
  suppose
A5: k > 0;
    then reconsider k9= k as Element of NAT by INT_1:3;
    consider k1 being Element of NAT such that
A6: k1 + 1 = k9 and

A7: aSeq(a,k9) = <%a:=intloc 0%> ^ (k1 --> AddTo(a,intloc 0)) by A5,
SCMFSA_7:def 2;

    defpred Q[Nat] means $1 <= k9 implies IC Comput(P,s,$1) =
     (c0 + $1);

A8: len aSeq(a,k9) = len <%a:=intloc 0%> + len (k1-->AddTo(a,intloc 0)) by A7,
AFINSQ_1:17

      .= 1 + len(k1-->AddTo(a,intloc 0)) by AFINSQ_1:34
      .= k9 by A6,CARD_1:64;

    for i being Element of NAT st i <= len aSeq(a,k9)
     holds IC Comput(P,s,i) =  (c0 + i)

    proof
A9:  now
        let i be Element of NAT;
        assume that
A10:    1 <= i and
A11:    i < k9;
        reconsider i1 = i - 1 as Element of NAT by A10,INT_1:5;
         i = i1 + 1;
         then
      i1 < k1 by A11,A6,XREAL_1:6;
        then
A12:     i1 in k1 by NAT_1:44;
A13:      len (k1 --> AddTo(a,intloc 0)) = k1 by CARD_1:64;
         len <% a:= intloc 0 %> = 1 by AFINSQ_1:33;
        hence aSeq(a,k9).i = (k1 --> AddTo(a,intloc 0)).(i - 1)
            by A10,A7,A13,A6,A11,AFINSQ_1:18
          .= AddTo(a,intloc 0) by A12,FUNCOP_1:7;
      end;
A14: for i being Element of NAT st i < k9 holds i in dom aSeq(a,k9)
     by A8,NAT_1:44;
A15:  now
        let i be Element of NAT;
        assume that
A16:    0 < i and
A17:    i < k9;
A18:     0+1 <= i by A16,NAT_1:13;
        thus P. (c0 + i) = aSeq(a,k9).(i) by A4,A14,A17
          .=AddTo(a,intloc 0) by A9,A18,A17;
      end;
A19:  P. (c0 + 0) = aSeq(a,k9).0 by A3,A5,A8
        .= a:= intloc 0 by A7,AFINSQ_1:35;
A20:  now
        let n be Element of NAT;
        assume n = 0;
        hence
A21:    Comput(P,s,n) = s by EXTPRO_1:2;

        thus CurInstr(P,Comput(P,s,n))
           = P.IC Comput(P,s,n) by A1,PARTFUN1:def 6
          .= a:= intloc 0 by A19,A21,MEMSTR_0:def 9;
        thus Comput(P,s,n+1) = Following(P,Comput(P,s,n)) by EXTPRO_1:3
          .= Exec(a:= intloc 0,s) by A21,A2,A19,A1,PARTFUN1:def 6;
      end;
A22:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A23:    Q[n];
        assume
A24:    n + 1 <= k9;
        per cases;
        suppose
A25:      n = 0;
          hence IC Comput(P,s,n+1)
             = Exec(a:= intloc 0,s).IC SCM+FSA by A20
            .= succ c0 + n by A2,A25,SCMFSA_2:63
            .= c0 + 1 + n by NAT_1:38
            .= c0 + (n + 1);
        end;
        suppose
A26:      n > 0;
A27:      n < k9 by A24,NAT_1:13;
A28:      n + 0 <= n + 1 by XREAL_1:7;
A29:      CurInstr(P,Comput(P,s,n))
             = P.(c0 + n) by A23,A24,A28,A1,PARTFUN1:def 6,XXREAL_0:2
            .= AddTo(a,intloc 0) by A15,A26,A27;
A30:      Comput(P,s,n+1) = Following(P,Comput(P,s,n)) by EXTPRO_1:3

            .= Exec(AddTo(a,intloc 0), Comput(P,s,n))
                by A29;

          thus IC Comput(P,s,n+1)
             = succ IC Comput(P,s,n) by A30,SCMFSA_2:64
            .=  (c0 + n + 1) by A23,A24,A28,NAT_1:38,XXREAL_0:2
            .=  (c0 + (n + 1));
        end;
      end;
      let i be Element of NAT;
      assume
A31:  i <= len aSeq(a,k9);
A32:  Q[0] by A2,EXTPRO_1:2;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A32,A22);
      hence thesis by A8,A31;
    end;
    hence thesis;
  end;
  suppose
A33: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:3;

    defpred Q[Nat] means $1 <= mk+1+1 implies IC Comput(P,s,$1)
    =  (c0 + $1);

    consider k1 being Element of NAT such that
A34: k1 + k = 1 and

A35: aSeq(a,k) = <%a:=intloc 0%> ^ (k1 --> SubFrom(a,intloc 0)) by A33,
SCMFSA_7:def 2;

A36: len aSeq(a,k) = len <% a:=intloc 0 %> + len (k1-->SubFrom(a,intloc 0)
    ) by A35,AFINSQ_1:17

      .= 1 + len (k1-->SubFrom(a,intloc 0)) by AFINSQ_1:34
      .= mk+1+1 by A34,CARD_1:64;

    for i being Element of NAT st i <= len aSeq(a,k) holds IC Comput(
P,s,i) =  (c0 + i)

    proof
A37:  now
        let i be Element of NAT;
        assume that
A38:    1 <= i and
A39:    i < mk+1+1;
A40:    i - 1 < mk+1+1 - 1 by A39,XREAL_1:9;
        reconsider i1 = i - 1 as Element of NAT by A38,INT_1:5;
A41:    i1 in k1 by A34,A40,NAT_1:44;
A42:   len(k1 --> SubFrom(a,intloc 0)) = k1 by CARD_1:64;
        len <% a:= intloc 0 %> = 1 by AFINSQ_1:33;
        hence aSeq(a,k).i = (k1-->SubFrom(a,intloc 0)).(i - 1)
         by A35,A38,A42,A34,A39,AFINSQ_1:18
          .= SubFrom(a,intloc 0) by A41,FUNCOP_1:7;
      end;
A43: for i being Element of NAT st i < mk+1+1 holds i in dom  aSeq(a,k)
        by A36,NAT_1:44;
A44:  now
        let i be Element of NAT;
        assume that
A45:    0 < i and
A46:    i < mk+1+1;
A47:    0+1 <= i by A45,NAT_1:13;
        thus P. (c0 + i) = aSeq(a,k).(i) by A4,A43,A46
          .=SubFrom(a,intloc 0) by A37,A47,A46;
      end;
A48:  P. (c0 + 0) = aSeq(a,k).0 by A3,A36
        .= a:= intloc 0 by A35,AFINSQ_1:35;

A49:  for n being Element of NAT st n = 0 holds Comput(P,s,n) = s
&

  CurInstr(P,Comput(P,s,n)) = a:= intloc 0 &
  Comput(P,s,n+1) = Exec(a:= intloc 0,s)

      proof
        let n be Element of NAT;
        assume n = 0;
        hence
A50:    Comput(P,s,n) = s by EXTPRO_1:2;

        thus CurInstr(P,Comput(P,s,n))
               = P.IC Comput(P,s,n) by A1,PARTFUN1:def 6
              .= a:= intloc 0 by A48,A50,MEMSTR_0:def 9;
        thus Comput(P,s,n+1) = Following(P,Comput(P,s,n)) by EXTPRO_1:3
          .= Exec(a:= intloc 0,s) by A50,A2,A48,A1,PARTFUN1:def 6;
      end;
A51:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A52:    Q[n];
        assume
A53:    n + 1 <= mk+1+1;
        per cases;
        suppose
A54:      n = 0;
          hence IC Comput(P,s,n+1)
             = Exec(a:= intloc 0,s).IC SCM+FSA by A49
            .= succ  (c0 + n) by A2,A54,SCMFSA_2:63
            .= c0 + n + 1 by NAT_1:38
            .= c0 + (n + 1);
        end;
        suppose
A55:      n > 0;
A56:      n < mk+1+1 by A53,NAT_1:13;
A57:      n + 0 <= n + 1 by XREAL_1:7;
A58:      CurInstr(P,Comput(P,s,n))
             = P. (c0 + n) by A52,A53,A57,A1,PARTFUN1:def 6,XXREAL_0:2
            .= SubFrom(a,intloc 0) by A44,A55,A56;
A59:      Comput(P,s,n+1) = Following(P,Comput(P,s,n)) by EXTPRO_1:3

            .= Exec(SubFrom(a,intloc 0), Comput(P,s,n))
              by A58;

          thus IC Comput(P,s,n+1)
             = succ IC Comput(P,s,n) by A59,SCMFSA_2:65
            .= c0 + n + 1 by A52,A53,A57,NAT_1:38,XXREAL_0:2
            .= c0 + (n + 1);
        end;
      end;
      let i be Element of NAT;
      assume
A60:  i <= len aSeq(a,k);
A61:  Q[0] by A2,EXTPRO_1:2;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A61,A51);
      hence thesis by A36,A60;
    end;
    hence thesis;
  end;
end;

Lm4: for s being 0-started State of SCM+FSA
 for P being Instruction-Sequence of SCM+FSA
for a being Int-Location,
k being Integer st  aSeq(a,k) c= P
for i being Element of NAT st i <= len aSeq(a,k)
 holds IC Comput(P,s,i) =  i
proof
  let s be 0-started State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA;
  let a be Int-Location;
  let k be Integer;
  assume
A1:  aSeq(a,k) c= P;
A2: now
    let c be Element of NAT;
    assume c < len aSeq(a,k);
    then c in dom  aSeq(a,k) by NAT_1:44;
   hence P.(0+c) = ( aSeq(a,k)). c by A1,GRFUNC_1:2;
  end;
  let i be Element of NAT;
  assume i <= len aSeq(a,k);
  then IC Comput(P,s,i) = (0+i) by A2,Lm3;
  hence thesis;
end;

Lm5: for s being 0-started State of SCM+FSA
  for P being Instruction-Sequence of SCM+FSA
for f being
  FinSeq-Location, p being FinSequence of INT st f := p c= P
 holds P halts_on s

proof
  set a2 = intloc 2;
  set a1 = intloc 1;
  let s be 0-started State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA;
A1: dom P = NAT by PARTFUN1:def 2;
  set D = the Instructions of SCM+FSA;
  let f be FinSeq-Location;
  let p be FinSequence of INT;

  set q = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %> ^ aSeq(f,p) ^ <% halt
  SCM+FSA %>;

  set q0 = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %>;
  assume
A2: f := p c= P;
  set q = aSeq(a1,len p)^<% f:=<0,...,0>a1 %>^aSeq(f,p)^<% halt SCM+FSA %>;
A3: now
    let i,k be Element of NAT;
    assume i < len q;
    then
A4:  i in dom  q by NAT_1:44;
    thus P. i = q.(i) by A2,A4,GRFUNC_1:2;
  end;
  consider pp being XFinSequence of D^omega such that
A5: len pp = len p & for k being Element of NAT st k < len pp
   ex i being Integer st i = p.(k+1) &
  pp.k = (aSeq(a1,k+1) ^ aSeq(a2,i) ^ <% (f,a1):= a2 %>) and
A6: aSeq(f,p) = FlattenSeq pp by SCMFSA_7:def 3;
  len q = len (q0 ^ FlattenSeq pp) + 1 by A6,AFINSQ_1:75;
  then
A7: len (q0 ^ FlattenSeq pp) < len q by NAT_1:13;

  defpred P[XFinSequence] means $1 c= pp implies
  ex pp0 being XFinSequence of D^omega
  st (pp0 = $1 & for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
  holds IC Comput(P,s,i) =  i);

A8: for r being XFinSequence, x being set st P[r] holds P[r ^ <% x %>]
  proof
    let r be XFinSequence;
    let x be set;
    assume
A9: P[r];
    set r1 = len r;
    len<% x %> =1 by AFINSQ_1:34;
    then len (r ^ <% x %>) = r1+1 by AFINSQ_1:17;
    then r1 < len (r ^ <% x %>) by XREAL_1:29;
    then
A10: r1 in dom (r ^ <% x %>) by NAT_1:44;
    assume
A11: r ^ <% x %> c= pp;
    then
A12: dom (r ^ <% x %>) c= dom pp by GRFUNC_1:2;
    then r1 < len pp by A10,NAT_1:44;
    then consider pr1 being Integer such that
    pr1 = p.(r1+1) and
A13: pp.r1 = aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %> by A5;
    r c= r ^ <% x %> by AFINSQ_1:74;
    then consider pp0 being XFinSequence of D^omega such that
A14: pp0 = r and

A15: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
    holds IC Comput(P,s,i) =  i by A9,A11,XBOOLE_1:1;
    set c2 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1));
    set c1 = len (q0 ^ FlattenSeq pp0);
 IC Comput(P,s,c1) =  c1 by A15;
    then reconsider s1 = Comput(P,s,c1) as
      c1-started State of SCM+FSA by MEMSTR_0:def 9;

A16: x = (r ^ <% x %>).r1 by AFINSQ_1:36
      .= pp.r1 by A11,A10,GRFUNC_1:2;
    then x in D^omega by A10,A12,FUNCT_1:102;
    then reconsider pp1 = pp0 ^ <% x %> as XFinSequence of D^omega;
    take pp1;
    thus pp1 = r ^ <% x %> by A14;
    reconsider x as Element of D^omega by A10,A12,A16,FUNCT_1:102;
A17: FlattenSeq pp1 = FlattenSeq pp0 ^ FlattenSeq <% x %> by AFINSQ_2:75
      .= FlattenSeq pp0 ^ x by AFINSQ_2:73;
    set s2 = Comput(P,s,c2);

A18: x = aSeq(a1,r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1):=a2 %>)
 by A13,A16,AFINSQ_1:27;
    then
A19: len q0 + len FlattenSeq pp1 = len q0 + len (FlattenSeq pp0 ^ aSeq(a1,
    r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1):=a2 %>)) by A17,AFINSQ_1:27

      .= len (q0 ^ (FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1)
    :=a2 %>))) by AFINSQ_1:17

      .= len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ (aSeq(a2,pr1) ^ <% (f,a1)
    :=a2 %>)) by Lm2

      .= c2 + len (aSeq(a2,pr1) ^ <% (f,a1):=a2 %>) by AFINSQ_1:17
      .= c2 + (len aSeq(a2,pr1) + len <% (f,a1):=a2 %>) by AFINSQ_1:17
      .= c2 + (len aSeq(a2,pr1) + 1) by AFINSQ_1:34
      .= c2 + len aSeq(a2,pr1) + 1;

    then
A20: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(a2,pr1) + 1 by AFINSQ_1:17;

    then
A21: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(a2,pr1) by NAT_1:13;
A22: FlattenSeq pp1 c= FlattenSeq pp by A11,A14,AFINSQ_2:82;
A23: now
      let p be XFinSequence;
      assume p c= x;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp0 ^ x by AFINSQ_2:81;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp by A22,A17,XBOOLE_1:1;
      then q0 ^ (FlattenSeq pp0 ^ p) c= q0 ^ FlattenSeq pp by AFINSQ_2:81;
      then
A24:  q0 ^ FlattenSeq pp0 ^ p c= q0 ^ FlattenSeq pp by AFINSQ_1:27;
      q0 ^ FlattenSeq pp c= q by A6,AFINSQ_1:74;
      hence q0 ^ FlattenSeq pp0 ^ p c= q by A24,XBOOLE_1:1;
    end;
A25: for c being Element of NAT st c < len aSeq(a1,r1+1)
      holds aSeq(a1,r1+1).c = P.(c1 + c)

    proof
      let c be Element of NAT;
      assume c < len aSeq(a1,r1+1);
      then
A26:  c in dom aSeq(a1,r1+1) by AFINSQ_1:66;
      then
A27:  c1 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1)) by AFINSQ_1:23;
A28:  q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) c= q by A18,A23,AFINSQ_1:74;
      then
A29:   dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1)) c= dom q by GRFUNC_1:2;
      thus aSeq(a1,r1+1).c = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1)).(c1 + c)
       by A26,AFINSQ_1:def 3
        .= q.(c1 + c) by A28,A27,GRFUNC_1:2
        .= P. (c1 + c) by A2,A29,A27,GRFUNC_1:2;
    end;
    set c3 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1));
A30: c2 = c1 + len aSeq(a1,r1+1) by AFINSQ_1:17;
A31: q0 ^ FlattenSeq pp1 = q0 ^ FlattenSeq pp0 ^ x by A17,AFINSQ_1:27;
    then len (q0 ^ FlattenSeq pp1) <= len q by A23,NAT_1:43;
    then
A32: c2 + len aSeq(a2,pr1) < len q by A20,NAT_1:13;
A33: c3 = c2 + len aSeq(a2,pr1) by AFINSQ_1:17;
A34: Comput(P,s,c2) = Comput(P,s1, len aSeq(a1,r1+1)) by A30,EXTPRO_1:4;
 IC Comput(P,s,c2) =  c2 by A30,A34,A25,Lm3;
  then reconsider s2 as c2-started State of SCM+FSA by MEMSTR_0:def 9;
A35: for c being Element of NAT st c < len aSeq(a2,pr1)
     holds aSeq(a2,pr1).c = P.(c2+ c)

    proof
      let c be Element of NAT;
      assume c < len aSeq(a2,pr1);
      then
A36:  c in dom aSeq(a2,pr1) by AFINSQ_1:66;
      then
A37:  c2 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1)) by
AFINSQ_1:23;
      q0 ^ FlattenSeq pp0 ^ (aSeq(a1,r1+1) ^ aSeq(a2,pr1)) c= q by A13,A16,A23,
AFINSQ_1:74;
      then
A38:  q0 ^FlattenSeq pp0^aSeq(a1,r1+1) ^ aSeq(a2,pr1) c= q by AFINSQ_1:27;
      then
A39: dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1)) c= dom q by
GRFUNC_1:2;
      thus aSeq(a2,pr1).c
          = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1+1) ^ aSeq(a2,pr1)).(c2 + c)
               by A36,AFINSQ_1:def 3
        .= q.(c2 + c) by A37,A38,GRFUNC_1:2
        .= P. (c2 + c) by A2,A39,A37,GRFUNC_1:2;
    end;
A40: now
      let i be Element of NAT;
      assume i <= len aSeq(a2,pr1);
      hence c2 + i = IC Comput(P,s2,i) by A35,Lm3
        .= IC Comput(P,s,c2+i) by EXTPRO_1:4;
    end;
A41: now
      let i be Element of NAT;
      assume i <= len aSeq(a1,r1+1);
      hence c1 + i = IC Comput(P,s1,i) by A25,Lm3
        .= IC Comput(P,s,c1 + i) by EXTPRO_1:4;
    end;
A42: for i being Element of NAT st i < len (q0 ^ FlattenSeq pp1) holds IC
    Comput(P,s,i) =  i

    proof
      let i be Element of NAT;
      assume
A43:  i < len (q0 ^ FlattenSeq pp1);
A44:  now
A45:    i < len q0 + len FlattenSeq pp1 by A43,AFINSQ_1:17;
        assume
A46:    not i <= c1;
        assume not (c1 + 1 <= i & i <= c2);

        hence c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1) by A19,A46,A45,NAT_1:13;

      end;
      per cases by A44;
      suppose
        i <= len (q0 ^ FlattenSeq pp0);
        hence thesis by A15;
      end;
      suppose
A47:    c1 + 1 <= i & i <= c2;
        then c1 + 1 - c1 <= i - c1 by XREAL_1:9;
        then reconsider ii = i - c1 as Element of NAT by INT_1:3;
        i - c1 <= c2 - c1 by A47,XREAL_1:9;
        hence i = IC Comput(P,s,c1+ii) by A30,A41
          .= IC Comput(P,s,i);
        thus thesis;
      end;
      suppose
A48:    c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1);
        then c2 + 1 - c2 <= i - c2 by XREAL_1:9;
        then reconsider ii = i - c2 as Element of NAT by INT_1:3;
        i - c2 <= c2 + len aSeq(a2,pr1) - c2 by A48,XREAL_1:9;
        hence  i = IC Comput(P,s,c2+ii)by A40
          .= IC Comput(P,s,i);
      end;
    end;

 q0 ^ FlattenSeq pp0 ^ x c= q by A23;
    then consider rq being XFinSequence of D such that
A49:   (q0 ^ FlattenSeq pp0 ^ x)^rq = q by AFINSQ_2:80;
 len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(a2,pr1) + 1 by A19,AFINSQ_1:17;
    then
A50: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(a2,pr1) by NAT_1:13;
    then
A51: c3 in dom(q0 ^ FlattenSeq pp0 ^ x)
       by A31,A33,AFINSQ_1:66;
    dom<% (f,a1):=a2 %> = 1 by AFINSQ_1:33;
    then
A52: 0 in dom<% (f,a1):=a2 %> by CARD_1:49,TARSKI:def 1;
    len<% (f,a1):=a2 %> = 1 by AFINSQ_1:34;
    then len(aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>)
      = len (aSeq(a1,r1+1) ^ aSeq(a2,pr1)) + 1 by AFINSQ_1:17;
    then len (aSeq(a1,r1+1) ^ aSeq(a2,pr1))
      < len(aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>) by XREAL_1:29;
    then
A53: len (aSeq(a1,r1+1) ^ aSeq(a2,pr1))
        in dom(aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>) by AFINSQ_1:66;
A54: c3 = c1 + len aSeq(a1,r1+1) + len aSeq(a2,pr1) by A30,AFINSQ_1:17;
A55:  (P)/.IC Comput(P,s,c3) = P.IC Comput(P,s,c3) by A1,PARTFUN1:def 6;
    CurInstr(P,Comput(P,s,c3))
     = P. c3 by A33,A42,A55,A50
      .= q.(c3 ) by A3,A33,A32
      .= (q0 ^ FlattenSeq pp0 ^ x).
         (c1 + (len aSeq(a1,r1+1) + (len aSeq(a2,pr1))))
             by A54,A51,A49,AFINSQ_1:def 3
      .= (q0 ^ FlattenSeq pp0 ^ x).
         (c1 + len(aSeq(a1,r1+1) ^ aSeq(a2,pr1))) by AFINSQ_1:17;
    then
A56: CurInstr(P,Comput(P,s,c3))
       = (aSeq(a1,r1+1) ^ aSeq(a2,pr1) ^ <% (f,a1):=a2 %>).
          (len (aSeq(a1,r1+1) ^ aSeq(a2,pr1))+0)
           by A53,A13,A16,AFINSQ_1:def 3
      .= <% (f,a1):=a2 %>.0 by A52,AFINSQ_1:def 3
      .= (f,a1):=a2 by AFINSQ_1:34;
    Comput(P,s,c3+1) =
    Following(P,Comput(P,s,
c3))
     by EXTPRO_1:3
      .= Exec((f,a1):=a2, Comput(P,s,c3)) by A56;

    then
A57: IC Comput(P,s,len (q0 ^ FlattenSeq pp1)) = Exec((f,a1):=a2,
    Comput(P,s,c3)).IC SCM+FSA by A20,AFINSQ_1:17

      .= succ IC Comput(P,s,c3) by SCMFSA_2:73
      .= succ  c3 by A33,A42,A21;

    thus for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp1) holds IC
    Comput(P,s,i) =  i

    proof
      let i be Element of NAT;
      assume
A58:  i <= len (q0 ^ FlattenSeq pp1);
      per cases by A58,XXREAL_0:1;
      suppose
        i < len (q0 ^ FlattenSeq pp1);
        hence thesis by A42;
      end;
      suppose
        i = len (q0 ^ FlattenSeq pp1);
        hence thesis by A33,A20,A57,NAT_1:38;
      end;
    end;
  end;
  set k = len aSeq(a1,len p);
A59: len q0 = k + 1 by AFINSQ_1:75;

  q = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %> ^ (aSeq(f,p) ^ <% halt
  SCM+FSA %>) by AFINSQ_1:27

    .= aSeq(a1,len p) ^ (<% f :=<0,...,0> a1 %> ^ (aSeq(f,p) ^ <% halt
  SCM+FSA %>)) by AFINSQ_1:27;

  then
A60:  aSeq(a1,len p) c= f:=p by AFINSQ_1:74;
A61: P[{}]
  proof
    assume {} c= pp;
    take <%>(D^omega);
    thus <%>(D^omega) = {};

A62: q = aSeq(a1,len p) ^ <% f :=<0,...,0> a1 %> ^ (aSeq(f,p) ^ <% halt
    SCM+FSA %>) by AFINSQ_1:27;

    then len q = len q0 + len ((aSeq(f,p) ^ <% halt SCM+FSA %>)) by AFINSQ_1:17
;

    then len q0 <= len q by NAT_1:11;
    then
A63: k < len q by A59,NAT_1:13;
A64: now
      let i be Element of NAT;
      assume
  i < len q0;
      then i <= len aSeq(a1,len p) by A59,NAT_1:13;

      hence IC Comput(P,s,i) =  i by A2,A60,Lm4,XBOOLE_1:1;
    end;
A65:  k < len q0 by A59,NAT_1:13;
    then
A66:  k in dom q0 by AFINSQ_1:66;
A67: IC Comput(P,s,k) =  k by A64,A65;

    then
A68: CurInstr(P,Comput(P,s,k))
       = P. k by A1,PARTFUN1:def 6
      .= q.k by A3,A63
      .= q0.k by A62,A66,AFINSQ_1:def 3
      .= f:=<0,...,0>a1 by AFINSQ_1:36;
A69: Comput(P,s,len q0) = Following(P,Comput(P,s,k)) by A59,EXTPRO_1:3
      .= Exec(f:=<0,...,0>a1, Comput(P,s,k)) by A68;

A70: IC Comput(P,s,len q0)
       = succ IC Comput(P,s,k) by A69,SCMFSA_2:75
      .=  len q0 by A59,A67,NAT_1:38;
A71: now
      let i be Element of NAT;
      assume i <= len q0;
      then i < len q0 or i = len q0 by XXREAL_0:1;
      hence IC Comput(P,s,i) =  i by A64,A70;
    end;
    q0 ^ FlattenSeq <%>(D^omega) = q0 ^ <%>D by AFINSQ_2:74
      .= q0 by AFINSQ_1:29;
    hence thesis by A71;
  end;
  for r being XFinSequence holds P[r] from AFINSQ_1:sch 3(A61,A8);

  then ex pp0 being XFinSequence of D^omega st pp0 = pp &
  for i being Element of NAT
  st i <= len (q0 ^ FlattenSeq pp0) holds IC Comput(P,s,i) =  i;

  then IC Comput(P,s,len (q0 ^ FlattenSeq pp)) =  len (q0 ^
  FlattenSeq pp);

  then CurInstr(P,
      Comput(P,s,len (q0 ^ FlattenSeq pp)))
   =  P. len (q0 ^ FlattenSeq pp) by A1,PARTFUN1:def 6

    .= q.len (q0 ^ FlattenSeq pp) by A3,A7
    .= halt SCM+FSA by A6,AFINSQ_1:36;
  hence thesis by EXTPRO_1:29;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> initial non empty
  NAT-defined (the Instructions of SCM+FSA)-valued;
  coherence;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> parahalting;
  correctness
  proof
      let s be 0-started State of SCM+FSA;
      let P be Instruction-Sequence of SCM+FSA
      such that
A3:   f := p c= P;
      thus P halts_on s by Lm5,A3;
  end;
end;

theorem
  for s being State of SCM+FSA, f being FinSeq-Location, p being
  FinSequence of INT holds IExec(f := p,P,s).f = p &
  (for a being read-write Int-Location st a <> intloc 1 & a <> intloc 2
  holds IExec(f := p,P,s).a = s.a) &
  for g being FinSeq-Location st g <> f holds IExec(f := p,P,s).g = s.g
proof
  let s be State of SCM+FSA;
  let f be FinSeq-Location;
  let p be FinSequence of INT;
A1: (s+*Initialize((intloc 0).-->1)).intloc 0
     = (Initialize((intloc 0).-->1)).intloc 0 by FUNCT_4:13,SCMFSA6A:41
    .= 1 by SCMFSA6A:43;
  reconsider s1 = s+*Initialize((intloc 0).-->1)
   as 0-started State of SCM+FSA;
A2: (f := p) c= P+*(f:=p) by FUNCT_4:25;
  thus IExec(f := p,P,s).f = (Result(P+*(f := p),s1)).f
    .= p by A1,A2,SCMFSA_7:7;
  hereby
    let a be read-write Int-Location;
    a <> intloc 0 & a <> IC SCM+FSA by SCMFSA_2:56;
    then
B6: not a in dom Initialize((intloc 0).-->1) by SCMFSA6A:42,TARSKI:def 2;
    assume
A3: a <> intloc 1 & a <> intloc 2;
    thus IExec(f := p,P,s).a
       = (Result(P+*(f:=p),s+* Initialize((intloc 0).-->1))).a
      .= s1.a by A1,A2,A3,SCMFSA_7:7
      .= s.a by B6,FUNCT_4:11;
  end;
  let g be FinSeq-Location;
  assume
A5: g <> f;
    g <> intloc 0 & g <> IC SCM+FSA by SCMFSA_2:57,58;
    then
B6: not g in dom Initialize((intloc 0).-->1) by SCMFSA6A:42,TARSKI:def 2;
  thus IExec(f := p,P,s).g
     = (Result(P+*(f:=p),s+*Initialize((intloc 0).-->1))).g
    .= s1.g by A1,A2,A5,SCMFSA_7:7
    .= s.g by B6,FUNCT_4:11;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i refers a means
  not for b being Int-Location, l being Element of NAT
   for f being FinSeq-Location holds b := a <> i &
  AddTo(b,a) <> i & SubFrom(b,a) <> i & MultBy(b,a) <> i & Divide(b,a) <> i &
  Divide(a,b) <> i & a =0_goto l <> i & a >0_goto l <> i & b :=(f,a) <> i &
  (f,b) := a <> i & (f,a):= b <> i & f :=<0,...,0> a <> i;
end;

definition
  let I be preProgram of SCM+FSA;
  let a be Int-Location;
  pred I refers a means
  ex i being Instruction of SCM+FSA st i in rng I & i refers a;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i destroys a means
  :Def3:
  not for b being Int-Location for f being
  FinSeq-Location holds a := b <> i & AddTo(a,b) <> i & SubFrom(a,b) <> i &
  MultBy(a,b) <> i & Divide(a,b) <> i & Divide(b,a) <> i & a :=(f,b) <> i &
  a :=len f <> i;
end;

definition
  let I be NAT-defined (the Instructions of SCM+FSA)-valued Function;
  let a be Int-Location;
  pred I destroys a means
  :Def4:
  ex i being Instruction of SCM+FSA st i in rng I & i destroys a;
end;

definition
  let I be NAT-defined (the Instructions of SCM+FSA)-valued Function;
  attr I is good means
  :Def5:
  I does not destroy intloc 0;
end;

theorem Th11:
  for a being Int-Location holds halt SCM+FSA does not destroy a
proof
  let a be Int-Location;
  for b be Int-Location for l be Element of NAT for f be
  FinSeq-Location holds a := b <> halt SCM+FSA & AddTo(a,b) <> halt SCM+FSA &
  SubFrom(a,b) <> halt SCM+FSA & MultBy(a,b) <> halt SCM+FSA & Divide(a,b) <>
  halt SCM+FSA & Divide(b,a) <> halt SCM+FSA & a :=(f,b) <> halt SCM+FSA & a
  :=len f <> halt SCM+FSA;
  hence thesis by Def3;
end;

theorem Th12:
  for a,b,c being Int-Location holds a <> b implies
   b := c does not destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
    thus a := e <> b := c by A1,SF_MASTR:1;
A2: InsCode (b := c) = 1 by SCMFSA_2:18;
    hence AddTo(a,e) <> b := c by SCMFSA_2:19;
    thus SubFrom(a,e) <> b := c by A2,SCMFSA_2:20;
    thus MultBy(a,e) <> b := c by A2,SCMFSA_2:21;
    thus Divide(a,e) <> b := c & Divide(e,a) <> b := c by A2,SCMFSA_2:22;
    thus a :=(f,e) <> b := c by A2,SCMFSA_2:26;
    thus a :=len f <> b := c by A2,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem Th13:
  for a,b,c being Int-Location holds a <> b implies
   AddTo(b,c) does not destroy  a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode AddTo(b,c) = 2 by SCMFSA_2:19;
    hence a := e <> AddTo(b,c) by SCMFSA_2:18;
    thus AddTo(a,e) <> AddTo(b,c) by A1,SF_MASTR:2;
    thus SubFrom(a,e) <> AddTo(b,c) by A2,SCMFSA_2:20;
    thus MultBy(a,e) <> AddTo(b,c) by A2,SCMFSA_2:21;
    thus Divide(a,e) <> AddTo(b,c) & Divide(e,a) <> AddTo(b,c) by A2,
SCMFSA_2:22;
    thus a :=(f,e) <> AddTo(b,c) by A2,SCMFSA_2:26;
    thus a :=len f <> AddTo(b,c) by A2,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem Th14:
  for a,b,c being Int-Location holds a <> b implies
   SubFrom(b,c) does not destroy  a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode SubFrom(b,c) = 3 by SCMFSA_2:20;
    hence a := e <> SubFrom(b,c) by SCMFSA_2:18;
    thus AddTo(a,e) <> SubFrom(b,c) by A2,SCMFSA_2:19;
    thus SubFrom(a,e) <> SubFrom(b,c) by A1,SF_MASTR:3;
    thus MultBy(a,e) <> SubFrom(b,c) by A2,SCMFSA_2:21;
    thus Divide(a,e) <> SubFrom(b,c) & Divide(e,a) <> SubFrom(b,c) by A2,
SCMFSA_2:22;
    thus a :=(f,e) <> SubFrom(b,c) by A2,SCMFSA_2:26;
    thus a :=len f <> SubFrom(b,c) by A2,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location holds a <> b implies
   MultBy(b,c) does not destroy  a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode MultBy(b,c) = 4 by SCMFSA_2:21;
    hence a := e <> MultBy(b,c) by SCMFSA_2:18;
    thus AddTo(a,e) <> MultBy(b,c) by A2,SCMFSA_2:19;
    thus SubFrom(a,e) <> MultBy(b,c) by A2,SCMFSA_2:20;
    thus MultBy(a,e) <> MultBy(b,c) by A1,SF_MASTR:4;
    thus Divide(a,e) <> MultBy(b,c) & Divide(e,a) <> MultBy(b,c) by A2,
SCMFSA_2:22;
    thus a :=(f,e) <> MultBy(b,c) by A2,SCMFSA_2:26;
    thus a :=len f <> MultBy(b,c) by A2,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location holds a <> b & a <> c implies
   Divide(b,c) does not destroy  a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b & a <> c;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let h be FinSeq-Location;
A2: InsCode Divide(b,c) = 5 by SCMFSA_2:22;
    hence a := e <> Divide(b,c) by SCMFSA_2:18;
    thus AddTo(a,e) <> Divide(b,c) by A2,SCMFSA_2:19;
    thus SubFrom(a,e) <> Divide(b,c) by A2,SCMFSA_2:20;
    thus MultBy(a,e) <> Divide(b,c) by A2,SCMFSA_2:21;
    thus Divide(e,a) <> Divide(b,c) & Divide(a,e) <> Divide(b,c) by A1,
SF_MASTR:5;
    thus a := (h,e) <> Divide(b,c) by A2,SCMFSA_2:26;
    thus a :=len h <> Divide(b,c) by A2,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem
  for a being Int-Location, l being Element of NAT
  holds goto l does not destroy  a
proof
  let a be Int-Location;
  let l be Element of NAT;
   for b being Int-Location, t being Element of NAT, f being FinSeq-Location
    holds a := b <> goto l & AddTo(a,b) <> goto l & SubFrom(a,b) <> goto l &
     MultBy(a,b) <> goto l & Divide(a,b) <> goto l & Divide(b,a) <> goto l &
     a :=(f,b) <> goto l & a :=len f <> goto l;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, l being Element of NAT
  holds b =0_goto l does not destroy  a
proof
  let a,b be Int-Location;
  let l be Element of NAT;
   for e being Int-Location, f being FinSeq-Location
    holds a := e <> b=0_goto l & AddTo(a,e) <> b=0_goto l &
     SubFrom(a,e) <> b=0_goto l & MultBy(a,e) <> b=0_goto l &
     Divide(a,e) <> b=0_goto l & Divide(e,a) <> b=0_goto l &
     a :=(f,e) <> b=0_goto l & a :=len f <> b=0_goto l;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, l being Element of NAT
  holds b >0_goto l does not destroy  a
proof
  let a,b be Int-Location;
  let l be Element of NAT;
   for e being Int-Location, f being FinSeq-Location
    holds a := e <> b>0_goto l & AddTo(a,e) <> b>0_goto l &
     SubFrom(a,e) <> b>0_goto l & MultBy(a,e) <> b>0_goto l &
     Divide(a,e) <> b>0_goto l & Divide(e,a) <> b>0_goto l &
     a :=(f,e) <> b>0_goto l & a :=len f <> b>0_goto l;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location, f being FinSeq-Location holds a <> b
  implies b := (f,c) does not destroy a
proof
  let a,b,c be Int-Location;
  let f be FinSeq-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let h be FinSeq-Location;
A2: InsCode (b := (f,c)) = 9 by SCMFSA_2:26;
    hence a := e <> b := (f,c) by SCMFSA_2:18;
    thus AddTo(a,e) <> b := (f,c) by A2,SCMFSA_2:19;
    thus SubFrom(a,e) <> b := (f,c) by A2,SCMFSA_2:20;
    thus MultBy(a,e) <> b := (f,c) by A2,SCMFSA_2:21;
    thus Divide(a,e) <> b := (f,c) & Divide(e,a) <> b := (f,c) by A2,
SCMFSA_2:22;
    thus a := (h,e) <> b := (f,c) by A1,SF_MASTR:9;
    thus a :=len h <> b := (f,c) by A2,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location, f being FinSeq-Location holds
   (f,c):= b does not destroy a
proof
  let a,b,c be Int-Location;
  let f be FinSeq-Location;
  now
    let e be Int-Location;
    let h be FinSeq-Location;
A1: InsCode ((f,c) := b) = 10 by SCMFSA_2:27;
    hence a := e <> (f,c) := b by SCMFSA_2:18;
    thus AddTo(a,e) <> (f,c) := b by A1,SCMFSA_2:19;
    thus SubFrom(a,e) <> (f,c) := b by A1,SCMFSA_2:20;
    thus MultBy(a,e) <> (f,c) := b by A1,SCMFSA_2:21;
    thus Divide(e,a) <> (f,c) := b & Divide(a,e) <> (f,c) := b by A1,
SCMFSA_2:22;
    thus a := (h,e) <> (f,c) := b by A1,SCMFSA_2:26;
    thus a :=len h <> (f,c) := b by A1,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, f being FinSeq-Location holds a <> b
  implies b :=len f does not destroy a
proof
  let a,b be Int-Location;
  let f be FinSeq-Location;
  assume
A1: a <> b;
  now
    let c be Int-Location;
    let g be FinSeq-Location;
A2: InsCode (b :=len f) = 11 by SCMFSA_2:28;
    hence a := c <> b :=len f by SCMFSA_2:18;
    thus AddTo(a,c) <> b :=len f by A2,SCMFSA_2:19;
    thus SubFrom(a,c) <> b :=len f by A2,SCMFSA_2:20;
    thus MultBy(a,c) <> b :=len f by A2,SCMFSA_2:21;
    thus Divide(a,c) <> b :=len f & Divide(c,a) <> b :=len f by A2,SCMFSA_2:22;
    thus a :=(g,c) <> b :=len f by A2,SCMFSA_2:26;
    thus a :=len g <> b :=len f by A1,SF_MASTR:11;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, f being FinSeq-Location holds
    f:=<0,...,0> b does not destroy a
proof
  let a,b be Int-Location;
  let f be FinSeq-Location;
  now
    let e be Int-Location;
    let h be FinSeq-Location;
A1: InsCode (f :=<0,...,0> b) = 12 by SCMFSA_2:29;
    hence a := e <> f :=<0,...,0> b by SCMFSA_2:18;
    thus AddTo(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:19;
    thus SubFrom(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:20;
    thus MultBy(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:21;
    thus Divide(a,e) <> f :=<0,...,0> b & Divide(e,a) <> f :=<0,...,0> b by A1,
SCMFSA_2:22;
    thus a :=(h,e) <> f :=<0,...,0> b by A1,SCMFSA_2:26;
    thus a :=len h <> f :=<0,...,0> b by A1,SCMFSA_2:28;
  end;
  hence thesis by Def3;
end;

definition

  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA;
  pred I is_closed_on s,P means
  :Def7:
  for k being Element of NAT holds
   IC Comput(P+*I,Initialize s,k) in dom I;
  pred I is_halting_on s,P means
  :Def8:
   P +* I halts_on Initialize s;
end;

theorem Th24:
  for I being Program of SCM+FSA holds I is paraclosed iff
   for s being State of SCM+FSA
   for P being Instruction-Sequence of SCM+FSA
    holds I is_closed_on s,P
proof
  let I be Program of SCM+FSA;
  thus  I is paraclosed implies
   for s being State of SCM+FSA
   for P being Instruction-Sequence of SCM+FSA
    holds I is_closed_on s,P
   proof
    assume
A1: I is paraclosed;
   let s be State of SCM+FSA;
   let P be Instruction-Sequence of SCM+FSA;
   let k be Element of NAT;
     I c= P+*I by FUNCT_4:25;
   hence IC Comput(P+*I,Initialize s,k) in dom I
           by A1,AMISTD_1:def 10;
  end;
  assume
A2: for s being State of SCM+FSA
   for P being Instruction-Sequence of SCM+FSA
    holds I is_closed_on s,P;
  let s be 0-started State of SCM+FSA,
      P be Instruction-Sequence of SCM+FSA such that
A3: I c= P;
  let n be Element of NAT;
A4: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
A5: P = P+*I by A3,FUNCT_4:98;
A6: s = Initialize s by A4,FUNCT_4:98;
   I is_closed_on s,P by A2;
  hence IC Comput(P,s,n) in dom I by A5,A6,Def7;
end;

theorem
  for I being Program of SCM+FSA
   holds I is parahalting iff
  for s being State of SCM+FSA
  for P being Instruction-Sequence of SCM+FSA
   holds I is_halting_on s,P
proof
set SAt = Start-At(0,SCM+FSA);
  let I be Program of SCM+FSA;
  thus I is parahalting implies
   for s being State of SCM+FSA
  for P being Instruction-Sequence of SCM+FSA
   holds I is_halting_on s,P
  proof
    assume
A1: I is parahalting;
   let s be State of SCM+FSA;
   let P be Instruction-Sequence of SCM+FSA;
  I c= P +* I by FUNCT_4:25;
   hence P +* I halts_on Initialize s by A1,AMISTD_1:def 11;
  end;
  assume
A4: for s being State of SCM+FSA
  for P being Instruction-Sequence of SCM+FSA
   holds I is_halting_on s,P;
  let s be 0-started State of SCM+FSA;
A5: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA such that
A6: I c= P;
A7: P = P+*I by A6,FUNCT_4:98;
A8: Initialize s = s by A5,FUNCT_4:98;
   I is_halting_on s,P by A4;
  hence P halts_on s by A7,A8,Def8;
end;

theorem Th26:
  for i being Instruction of SCM+FSA, a being Int-Location, s
  being State of SCM+FSA st i does not destroy  a holds Exec(i,s).a = s.a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  let s be State of SCM+FSA;
  assume
A1: i does not destroy  a;
  per cases by NAT_1:36,SCMFSA_2:16;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
    hence thesis by EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider da,db being Int-Location such that
A5: i = da := db by SCMFSA_2:30;
    da <> a by A1,A5,Def3;
    hence thesis by A5,SCMFSA_2:63;
  end;
  suppose
    InsCode i = 2;
    then consider da, db being Int-Location such that
A6: i = AddTo(da,db) by SCMFSA_2:31;
    da <> a by A1,A6,Def3;
    hence thesis by A6,SCMFSA_2:64;
  end;
  suppose
    InsCode i = 3;
    then consider da, db being Int-Location such that
A7: i = SubFrom(da, db) by SCMFSA_2:32;
    da <> a by A1,A7,Def3;
    hence thesis by A7,SCMFSA_2:65;
  end;
  suppose
    InsCode i = 4;
    then consider da, db being Int-Location such that
A8: i = MultBy(da,db) by SCMFSA_2:33;
    da <> a by A1,A8,Def3;
    hence thesis by A8,SCMFSA_2:66;
  end;
  suppose
    InsCode i = 5;
    then consider da, db being Int-Location such that
A9: i = Divide(da, db) by SCMFSA_2:34;
    da <> a & db <> a by A1,A9,Def3;
    hence thesis by A9,SCMFSA_2:67;
  end;
  suppose
    InsCode i = 6;
    then ex loc being Element of NAT st i = goto loc by SCMFSA_2:35;
    hence thesis by SCMFSA_2:69;
  end;
  suppose
    InsCode i = 7;
    then
    ex loc being Element of NAT, da being Int-Location st
    i = da=0_goto loc by SCMFSA_2:36;
    hence thesis by SCMFSA_2:70;
  end;
  suppose
    InsCode i = 8;
    then
    ex loc being Element of NAT, da being Int-Location st
    i = da>0_goto loc by SCMFSA_2:37;
    hence thesis by SCMFSA_2:71;
  end;
  suppose
    InsCode i = 9;
    then consider db, da being Int-Location, g being FinSeq-Location such that
A10: i = da := (g,db) by SCMFSA_2:38;
    da <> a by A1,A10,Def3;
    hence thesis by A10,SCMFSA_2:72;
  end;
  suppose
    InsCode i = 10;
    then ex db, da being Int-Location, g being FinSeq-Location st i = (g,db):=
    da by SCMFSA_2:39;
    hence thesis by SCMFSA_2:73;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, g being FinSeq-Location such that
A11: i = da :=len g by SCMFSA_2:40;
    da <> a by A1,A11,Def3;
    hence thesis by A11,SCMFSA_2:74;
  end;
  suppose
    InsCode i = 12;
    then
    ex da being Int-Location, g being FinSeq-Location st i = g :=<0,...,0>
    da by SCMFSA_2:41;
    hence thesis by SCMFSA_2:75;
  end;
end;

theorem Th27:
  for s being State of SCM+FSA,
      P being Instruction-Sequence of SCM+FSA,
      I being Program of SCM+FSA, a being Int-Location
       st I does not destroy  a & I is_closed_on s,P
    for k being
  Element of NAT holds Comput(P +* I,Initialize s,k).a
        = s.a
proof
  let s be State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A2: I does not destroy a;
  defpred P[Nat] means
   Comput(P+*I,Initialize s,$1).a = s.a;
A3: I c= P+*I by FUNCT_4:25;
  assume
A4: I is_closed_on s,P;
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    set l = IC Comput(P+*I,Initialize s,k);
A7: l in dom I by A4,Def7;
    then (P+*I).l = I.l by A3,GRFUNC_1:2;
    then (P+*I).l in rng I by A7,FUNCT_1:def 3;
    then
A8: (P+*I).l does not destroy a by A2,Def4;
A9: dom(P+*I) = NAT by PARTFUN1:def 2;
    Comput(P+*I,(Initialize s),k + 1).a =
     (Following(P+*I,Comput(P+*I,(Initialize s),k))).a
      by EXTPRO_1:3
      .=(Exec((P+*I).
         IC Comput(P+*I,Initialize s,k),
          Comput(P+*I,Initialize s,k))).a
                by A9,PARTFUN1:def 6
      .= Comput(P+*I,s+* Start-At(0,SCM+FSA),k).a by A8,Th26
      .= s.a by A6;
    hence P[k+1];
  end;
A10: not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  Comput(P+*I,Initialize s,0).a =
   (Initialize s).a by EXTPRO_1:2
    .= s.a by A10,FUNCT_4:11;
  then
A11: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A11, A5);
end;

registration
  cluster Stop SCM+FSA -> parahalting good;
  coherence
   proof
    thus Stop SCM+FSA is parahalting
proof
A1:  0 in dom Stop SCM+FSA by AFINSQ_1:65;
B2: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
    let s be 0-started State of SCM+FSA;
A3: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA
    such that
A4:  Stop SCM+FSA c= P;
A6:  dom P = NAT by PARTFUN1:def 2;
    CurInstr(P,Comput(P,s,0))
     = CurInstr(P,s) by EXTPRO_1:2
      .= P.IC s by A6,PARTFUN1:def 6
      .= P.(IC Start-At(0,SCM+FSA)) by A3,B2,GRFUNC_1:2
      .= P. 0 by FUNCOP_1:72
      .= (Stop SCM+FSA). 0 by A1,A4,GRFUNC_1:2
      .= halt SCM+FSA by AFINSQ_1:34;
  hence thesis by EXTPRO_1:29;
end;
   thus Stop SCM+FSA does not destroy intloc 0
proof
  now
    let i be Instruction of SCM+FSA;
A7: rng Stop SCM+FSA = {halt SCM+FSA} by AFINSQ_1:33;
    assume i in rng Stop SCM+FSA;
    then i = halt SCM+FSA by A7,TARSKI:def 1;
    hence i does not destroy intloc 0 by Th11;
  end;
  hence thesis by Def4;
end;
   end;
end;

registration
  cluster parahalting good for Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster paraclosed good -> keeping_0 for Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed good;
    then
A2: I does not destroy intloc 0 by Def5;
      let s be 0-started State of SCM+FSA;
A3:   Initialize s = s by MEMSTR_0:44;
    let P such that
A4:    I c= P;
      let k be Element of NAT;
XX:    I is_closed_on s,P by A1,Th24;
       P +* I = P by A4,FUNCT_4:98;
      hence Comput(P,s,k).intloc 0 = s.intloc 0 by A2,A3,Th27,XX;
  end;
end;



theorem Th29:
  for a being Int-Location, k being Integer holds rng aSeq(a,k) c=
  {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
proof
  let a be Int-Location;
  let k be Integer;
  now
    let x be set;
    assume
A1: x in rng aSeq(a,k);
    per cases;
    suppose
A2:   k > 0 & k = 0 + 1;
      then
      ex k1 being Element of NAT st k1 + 1 = k & aSeq(a,k) = <% a := intloc
      0 %> ^ (k1 --> AddTo(a,intloc 0)) by SCMFSA_7:def 2;
      then aSeq(a,k) = <% a := intloc 0 %> ^ {} by A2
        .= <% a := intloc 0 %> by AFINSQ_1:29;
      then rng aSeq(a,k) = {a := intloc 0} by AFINSQ_1:33;
      then x = a := intloc 0 by A1,TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
    suppose
A3:   k > 0 & k <> 1;
      then consider k1 being Element of NAT such that
A4:   k1 + 1 = k and
A5:   aSeq(a,k) = <% a := intloc 0 %> ^ (k1 --> AddTo(a,intloc 0)) by
SCMFSA_7:def 2;
A6:   k1 <> 0 by A3,A4;
      rng aSeq(a,k) = rng <% a := intloc 0 %> \/ rng (k1 --> AddTo(a,
      intloc 0)) by A5,AFINSQ_1:26
        .= {a := intloc 0} \/ rng ( k1 --> AddTo(a,intloc 0)) by AFINSQ_1:33
        .= {a := intloc 0} \/ {AddTo(a,intloc 0)} by A6,FUNCOP_1:8;
      then x in {a := intloc 0} or x in {AddTo(a,intloc 0)} by A1,
XBOOLE_0:def 3;
      then x = a := intloc 0 or x = AddTo(a,intloc 0) by TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
    suppose
A7:   not k > 0;
      then consider k1 being Element of NAT such that
A8:   k1 + k = 1 and
A9:   aSeq(a,k) = <% a := intloc 0 %> ^ (k1 --> SubFrom(a,intloc 0))
      by SCMFSA_7:def 2;
A10:  k1 <> 0 by A7,A8;
      rng aSeq(a,k) = rng <% a := intloc 0 %> \/ rng (k1 --> SubFrom(a,
      intloc 0)) by A9,AFINSQ_1:26
        .= {a := intloc 0} \/ rng ( k1 --> SubFrom(a,intloc 0)) by AFINSQ_1:33
        .= {a := intloc 0} \/ {SubFrom(a,intloc 0)} by A10,FUNCOP_1:8;
      then x in {a := intloc 0} or x in {SubFrom(a,intloc 0)} by A1,
XBOOLE_0:def 3;
      then x = a := intloc 0 or x = SubFrom(a,intloc 0) by TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th30:
  for a being Int-Location, k being Integer holds rng (a := k) c=
  {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
proof
  let a be Int-Location;
  let k be Integer;
  now
    let x be set;
A1: rng aSeq(a,k) c= {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0 )
    } by Th29;
A2: rng (a := k) = rng (aSeq(a,k) ^ <% halt SCM+FSA %>) by SCMFSA_7:1
      .= rng aSeq(a,k) \/ rng <% halt SCM+FSA %> by AFINSQ_1:26
      .= rng aSeq(a,k) \/ {halt SCM+FSA} by AFINSQ_1:33;
    assume x in rng (a := k);
    then x in rng aSeq(a,k) or x in {halt SCM+FSA} by A2,XBOOLE_0:def 3;
    then
    x = a := intloc 0 or x = AddTo(a,intloc 0) or x = SubFrom(a,intloc 0)
    or x = halt SCM+FSA by A1,ENUMSET1:def 1,TARSKI:def 1;
    hence
    x in {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0
    )} by ENUMSET1:def 2;
  end;
  hence thesis by TARSKI:def 3;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> good;
  correctness
  proof
    now
      let i be Instruction of SCM+FSA;
A1:   rng (a := k) c= {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),
      SubFrom(a,intloc 0)} by Th30;
      assume
A2:   i in rng (a := k);
      per cases by A2,A1,ENUMSET1:def 2;
      suppose
        i = halt SCM+FSA;
        hence i does not destroy intloc 0 by Th11;
      end;
      suppose
        i = a := intloc 0;
        hence i does not destroy intloc 0 by Th12;
      end;
      suppose
        i = AddTo(a,intloc 0);
        hence i does not destroy intloc 0 by Th13;
      end;
      suppose
        i = SubFrom(a,intloc 0);
        hence i does not destroy intloc 0 by Th14;
      end;
    end;
    then a := k does not destroy intloc 0 by Def4;
    hence thesis by Def5;
  end;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> keeping_0;
  correctness;
end;

