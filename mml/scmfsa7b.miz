:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, AMI_1, SCMFSA_2, RELAT_1, SCMFSA_7,
      ARYTM_3, ARYTM_1, TARSKI, FUNCT_1, XXREAL_0, PARTFUN1, CAT_1, NAT_1,
      CARD_1, FUNCOP_1, SCMFSA6A, ORDINAL4, AMI_3, FUNCT_4, INT_1, GRAPHSP,
      FSM_1, FINSEQ_2, CIRCUIT2, SCMNORM, SCMFSA6B, GLIB_000, SF_MASTR,
      MSUALG_1, XBOOLE_0, PRE_POLY, COMPLEX1, UNIALG_2, AMISTD_2, SCMFSA7B,
      ORDINAL1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1,
      FINSEQ_2, NAT_D, FUNCOP_1, AFINSQ_1,
      AMI_1, SCMNORM, SCMFSA_2, SCMFSA_7, SCMFSA6A,
      SF_MASTR, SCMFSA6B, INT_2, XXREAL_0, PRE_POLY;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, INT_2, FINSEQ_4, FINSOP_1,
      PARTFUN1, DTCONSTR, AMI_5, SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMNORM, SCMFSA_4, AFINSQ_1, NAT_D, RELSET_1, PRE_POLY, SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, CARD_3, FUNCT_7, AMI_1,
      SCMFSA_2, SF_MASTR, SCMFSA6B, ORDINAL1, SCMNORM, FINSET_1, FINSEQ_2,
      CARD_1, RELSET_1, AFINSQ_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FINSEQ_1, FINSEQ_2, SCMFSA_2, FUNCOP_1, SCMFSA6A, SCMNORM;
 theorems SCMFSA_7, FINSEQ_1, FINSEQ_2, NAT_1, GRFUNC_1, FUNCT_1, FUNCT_4,
      FUNCT_7, FINSEQ_3, FINSEQ_4, AMI_1, ENUMSET1, SCMFSA_2, FUNCOP_1, INT_1,
      FINSEQ_6, RELAT_1, TARSKI, AMI_3, SCMFSA6A, SF_MASTR, SCMFSA6B, XBOOLE_0,
      XBOOLE_1, XREAL_1, ABSVALUE, XXREAL_0, PARTFUN1, ORDINAL1, 
      AFINSQ_1, NAT_D, PRE_POLY;
 schemes NAT_1, FINSEQ_1;

begin

reserve m for Element of NAT;
set A = NAT;

theorem Th1:
  for p being FinSequence of the Instructions of SCM+FSA holds dom
  Load p = { m: m < len p}
proof
  let p be FinSequence of the Instructions of SCM+FSA;
A1: dom Load p = { m -' 1: m in dom p} by SCMFSA_7:def 1;
  now
    let x be set;
    assume
A2: x in dom Load p;
    then consider k being Element of NAT such that
A3: x = k -' 1 and
    k in dom p by A1;
    k -' 1 < len p by A2,A3,SCMFSA_7:29;
    hence x in {m: m < len p} by A3;
  end;
  then
A4: dom Load p c= {m: m < len p} by TARSKI:def 3;
  now
    let x be set;
    assume
    x in {m: m < len p};
    then ex k being Element of NAT st x = k & k < len p;
    hence x in dom Load p by SCMFSA_7:29;
  end;
  then {m: m < len p} c= dom Load p by TARSKI:def 3;
  hence thesis by A4,XBOOLE_0:def 10;
end;

theorem Th2:
  for p being FinSequence of the Instructions of SCM+FSA holds rng
  Load p = rng p
proof
  let p be FinSequence of the Instructions of SCM+FSA;
A1: dom Load p = {m -' 1: m in dom p} by SCMFSA_7:def 1;
  now
    let y be set;
    assume
    y in rng p;
    then consider x being set such that
A2: x in dom p and
A3: y = p.x by FUNCT_1:def 5;
    reconsider x as Element of NAT by A2;
    dom p = Seg len p by FINSEQ_1:def 3;
    then dom p = {m : 1 <= m & m <= len p};
    then ex m being Element of NAT st x = m & 1 <= m & m <= len p by A2;
    then
A4: x -' 1 + 1 = x - 1 + 1 by XREAL_1:235
      .= x;
A5:  (x -' 1) in dom Load p by A1,A2;
    then (Load p). (x -' 1) = p/.(x -' 1 + 1) by SCMFSA_7:def 1
      .= y by A2,A3,A4,PARTFUN1:def 8;
    hence ex x being set st x in dom Load p & y = (Load p).x by A5;
  end;
  then
A6: rng p c= rng Load p by FUNCT_1:19;
  now
    let y be set;
    assume
    y in rng Load p;
    then consider x being set such that
A7: x in dom Load p and
A8: y = (Load p).x by FUNCT_1:def 5;
    consider m being Element of NAT such that
A9: x = m -' 1 and
    m in dom p by A1,A7;
A10: m -' 1 + 1 in dom p by A7,A9,SCMFSA_7:26;
    then p.(m -' 1 + 1) = p/.(m -' 1 + 1) by PARTFUN1:def 8
      .= y by A7,A8,A9,SCMFSA_7:def 1;
    hence ex x being set st x in dom p & y = p.x by A10;
  end;
  then rng Load p c= rng p by FUNCT_1:19;
  hence thesis by A6,XBOOLE_0:def 10;
end;

registration
  let p be FinSequence of the Instructions of SCM+FSA;
  cluster Load p -> initial NAT-defined;
  coherence
  proof
A1: dom Load p = {m: m < len p} by Th1;
A2: now
      let k,n be Nat;
      assume that
A3:   n in dom Load p and
A4:   k < n;
      n in NAT by ORDINAL1:def 13;
      then n < len p by A3,SCMFSA_7:29;
      then k in NAT & k < len p by A4,ORDINAL1:def 13,XXREAL_0:2;
      hence k in dom Load p by A1;
    end;
    now
      let x be set;
      assume
      x in dom Load p;
      then ex m st m = x & m < len p by A1;
      hence x in NAT;
    end;
    then dom Load p c= NAT by TARSKI:def 3;
    hence thesis by A2,RELAT_1:def 18,AFINSQ_1:def 13;
  end;
end;

theorem
  for i being Instruction of SCM+FSA holds Load <* i *> = 0 .-->
  i
proof
  let i be Instruction of SCM+FSA;
A1: len <* i *> = 1 by FINSEQ_1:56;
A2: dom Load <* i *> = {m: m < len <* i *>} by Th1;
  now
    let x be set;
    assume
    x in { 0};
    then x = 0 by TARSKI:def 1;
    hence x in dom Load <* i *> by A2;
  end;
  then
A3: { 0} c= dom Load <* i *> by TARSKI:def 3;
A4: now
    let x be set;
    assume
A5: x in { 0};
    then
A6: x = 0 by TARSKI:def 1;
    hence (Load <* i *>).x = <* i *>/.(0 + 1) by A3,A5,SCMFSA_7:def 1
      .= <* i *>.1 by A1,FINSEQ_4:24
      .= i by FINSEQ_1:57
      .= ( 0 .--> i).x by A6,FUNCOP_1:87;
  end;
  now
    let x be set;
    assume
    x in dom Load <* i *>;
    then ex m being Element of NAT st x = m & m < 0 + len <* i *> by A2;
    then x = 0 by A1,NAT_1:13;
    hence x in { 0} by TARSKI:def 1;
  end;
  then dom Load <* i *> c= { 0} by TARSKI:def 3;
  then dom ( 0 .--> i) = { 0} & dom Load <* i *> = { 0} by A3
,FUNCOP_1:19,XBOOLE_0:def 10;
  hence thesis by A4,FUNCT_1:9;
end;

theorem Th4:
  for i being Instruction of SCM+FSA holds dom Macro i = {  0
  ,  1 }
proof
  let i be Instruction of SCM+FSA;
  for x be set holds x in dom Macro i iff x = 0 or x = 1 by
SCMFSA6B:32;
  hence thesis by TARSKI:def 2;
end;

theorem Th5:
  for i being Instruction of SCM+FSA holds Macro i = Load <* i,halt
  SCM+FSA *>
proof
  let i be Instruction of SCM+FSA;
A1: dom Load <* i,halt SCM+FSA *> = {m -' 1: m in dom <* i,halt SCM+FSA *>}
  by SCMFSA_7:def 1;
A2: dom Macro i = { 0, 1} by Th4;
A3: dom <* i,halt SCM+FSA *> = Seg len <* i,halt SCM+FSA *> by FINSEQ_1:def 3
    .= {1,2} by FINSEQ_1:4,61;
  then
A4: 2 in dom <* i,halt SCM+FSA *> by TARSKI:def 2;
A5: 1 in dom <* i,halt SCM+FSA *> by A3,TARSKI:def 2;
  now
    let x be set;
    assume
    x in { 0, 1};
    then x = 0 or x =  1 by TARSKI:def 2;
    then x = (0 + 1 -' 1) or x =  (1 + 1 -' 1) by NAT_D:34;
    hence x in dom Load <* i,halt SCM+FSA *> by A1,A5,A4;
  end;
  then
A6: { 0, 1} c= dom Load <* i,halt SCM+FSA *> by TARSKI:def 3;
A7: now
    let x be set;
    assume
A8: x in { 0, 1};
    per cases by A8,TARSKI:def 2;
    suppose
A9:   x = 0;
      hence (Load <* i,halt SCM+FSA *>).x = <* i,halt SCM+FSA *>/.(0 + 1) by A6
,A8,SCMFSA_7:def 1
        .= <* i,halt SCM+FSA *>.1 by A5,PARTFUN1:def 8
        .= (<* i *> ^ <* halt SCM+FSA *>).1
        .= i by FINSEQ_1:58
        .= (Macro i).x by A9,SCMFSA6B:33;
    end;
    suppose
A10:  x =  1;
      hence (Load <* i,halt SCM+FSA *>).x = <* i,halt SCM+FSA *>/.(1 + 1) by A6
,A8,SCMFSA_7:def 1
        .= <* i,halt SCM+FSA *>.2 by A4,PARTFUN1:def 8
        .= (<* i *> ^ <* halt SCM+FSA *>).(1+1)
        .= (<* i *> ^ <* halt SCM+FSA *>).(len <* i *> + 1) by FINSEQ_1:57
        .= halt SCM+FSA by FINSEQ_1:59
        .= (Macro i).x by A10,SCMFSA6B:33;
    end;
  end;
  now
    let x be set;
    assume
    x in dom Load <* i,halt SCM+FSA *>;
    then ex m being Element of NAT
     st x = m -' 1 & m in dom <* i, halt SCM+FSA
    *> by A1;
    then x = (0 + 1 -' 1) or x =  (1 + 1 -' 1) by A3,TARSKI:def 2;
    then x = 0 or x = 1 by NAT_D:34;
    hence x in { 0, 1} by TARSKI:def 2;
  end;
  then dom Load <* i,halt SCM+FSA *> c= { 0, 1} by TARSKI:def 3;
  then dom Load <* i,halt SCM+FSA *> = { 0, 1} by A6,
XBOOLE_0:def 10;
  hence thesis by A2,A7,FUNCT_1:9;
end;

theorem Th6:
  for i being Instruction of SCM+FSA holds card Macro i = 2
proof
  let i be Instruction of SCM+FSA;
  thus card Macro i = card Load <* i,halt SCM+FSA *> by Th5
    .= len <* i,halt SCM+FSA *> by SCMFSA_7:25
    .= 2 by FINSEQ_1:61;
end;

theorem
  for i being Instruction of SCM+FSA holds (i = halt SCM+FSA implies (
  Directed Macro i). 0 = goto  2) & (i <> halt SCM+FSA implies (
  Directed Macro i). 0 = i)
proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  let i be Instruction of SCM+FSA;
A2: (Macro i). 0 = i by SCMFSA6B:33;
   0 in { 0, 1} by TARSKI:def 2;
  then
A3:  0 in dom Macro i by Th4;
A4: card Macro i = 2 by Th6;
  hereby
A5: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
    assume
A6: i = halt SCM+FSA;
    dom (halt SCM+FSA .--> goto  2) = {halt SCM+FSA} by FUNCOP_1:19;
    then
A7: i in dom (halt SCM+FSA .--> goto  2) by A6,TARSKI:def 1;
    rng Macro i c= the Instructions of SCM+FSA by AMI_1:118;
    hence
    (Directed Macro i). 0 = (((id the Instructions of SCM+FSA) +* (
    halt SCM+FSA, goto  2))*Macro i). 0 by A4,FUNCT_7:118
      .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
     2))*Macro i). 0 by A5,FUNCT_7:def 3
      .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
    2)).i by A3,A2,FUNCT_1:23
      .= (halt SCM+FSA .--> goto  2).i by A7,FUNCT_4:14
      .= goto  2 by A6,FUNCOP_1:87;
  end;
A8: dom (halt SCM+FSA .--> goto  2) = {halt SCM+FSA} by FUNCOP_1:19;
  assume
  i <> halt SCM+FSA;
  then
A9: not i in dom (halt SCM+FSA .--> goto  2) by A8,TARSKI:def 1;
  rng Macro i c= the Instructions of SCM+FSA by AMI_1:118;
  hence (Directed Macro i). 0 = (((id the Instructions of SCM+FSA) +* (
  halt SCM+FSA, goto  2))* Macro i). 0 by A4,FUNCT_7:118
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
  2))* Macro i). 0 by A1,FUNCT_7:def 3
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto  2
  )).i by A3,A2,FUNCT_1:23
    .= (id the Instructions of SCM+FSA).i by A9,FUNCT_4:12
    .= i by FUNCT_1:35;
end;

theorem
  for i being Instruction of SCM+FSA holds (Directed Macro i). 1 =
  goto  2
proof
  let i be Instruction of SCM+FSA;
A1: (Macro i). 1 = halt SCM+FSA by SCMFSA6B:33;
   1 in { 0, 1} by TARSKI:def 2;
  then
A2:  1 in dom Macro i by Th4;
  dom (halt SCM+FSA .--> goto  2 ) = {halt SCM+FSA} by FUNCOP_1:19;
  then
A3: halt SCM+FSA in dom (halt SCM+FSA .--> goto  2) by TARSKI:def 1;
A4: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  card Macro i = 2 & rng Macro i c= the Instructions of SCM+FSA by Th6,
AMI_1:118;
  hence (Directed Macro i). 1 = (((id the Instructions of SCM+FSA) +* (
  halt SCM+FSA,goto  2))* Macro i). 1 by FUNCT_7:118
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
  2))* Macro i). 1 by A4,FUNCT_7:def 3
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto  2
  )). halt SCM+FSA by A2,A1,FUNCT_1:23
    .= (halt SCM+FSA .--> goto  2).halt SCM+FSA by A3,FUNCT_4:14
    .= goto  2 by FUNCOP_1:87;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> initial NAT-defined;
  coherence
  proof
    a := k = Load (aSeq(a,k) ^ <* halt SCM+FSA *>) by SCMFSA_7:33;
    hence thesis;
  end;
end;

Lm1: for s being State of SCM+FSA st IC s = 0 for a being Int-Location,
k being Integer st a := k c= s holds ProgramPart s halts_on s
proof
  let s be State of SCM+FSA;
  assume
A1: IC s = 0;
  let a be Int-Location, k be Integer;
  assume
A2: a := k c= s;
  per cases;
  suppose
A3: k > 0;
    then consider k1 being Element of NAT such that
A4: k1 + 1 = k and

A5: a := k = Load (<* a := intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0)) ^
    <* halt SCM+FSA *>) by SCMFSA_7:def 2;

A6: len (<* a := intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0))) = len <* a :=
    intloc 0 *> + len (k1 |-> AddTo(a,intloc 0)) by FINSEQ_1:35

      .= 1 + len (k1 |-> AddTo(a,intloc 0)) by FINSEQ_1:56
      .= k by A4,FINSEQ_1:def 18;

    set f = <* a:=intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0)) ^ <* halt SCM+FSA
    *>;

A7: f.1 = (<* a := intloc 0 *> ^ ((k1 |-> AddTo(a,intloc 0)) ^ <*halt
    SCM+FSA*>)).1 by FINSEQ_1:45

      .= a := intloc 0 by FINSEQ_1:58;
    reconsider k as Element of NAT by A3,INT_1:16;

A8: len f = len (<* a := intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0))) + len
    <* halt SCM+FSA *> by FINSEQ_1:35

      .= k + 1 by A6,FINSEQ_1:56;
    then
A9: dom f = Seg (k + 1) by FINSEQ_1:def 3;
A10: now
      let i be Element of NAT;
      assume that
      0 <= i and
A11:  i <= k;
      0 + 1 <= i + 1 & i + 1 <= k + 1 by A11,XREAL_1:8;
      hence i + 1 in dom f by A9;
A12:  dom Load f = {m: m < len f} by Th1;
      i < k + 1 by A11,NAT_1:13;
      hence  i in dom Load f by A8,A12;
    end;
A13: now
      let i be Element of NAT;
      assume that
      0 <= i and
A14:  i <= k;
A15:   i in dom Load f by A10,A14;
      hence s. i = (Load f). i by A2,A5,GRFUNC_1:8
        .= f/.(i+1) by A15,SCMFSA_7:def 1
        .= f.(i+1) by A10,A14,PARTFUN1:def 8;
    end;
    then
A16: s. 0 = f.(0 + 1)
      .= a := intloc 0 by A7;
A17: now
      let n be Element of NAT;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
      assume
      n = 0;
      hence
A18:  Comput(ProgramPart(s),s,n) = s by AMI_1:13;

      hence
A19:  CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s,n
)) = a:= intloc 0
 by A1,A16,AMI_1:def 16,Y;
      thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
      Comput(ProgramPart(s),s,n)) by AMI_1:14
        .= Exec(a:= intloc 0,s) by A18,A19,AMI_1:def 18;
    end;
A20: now
      let i be Element of NAT;
      assume that
A21:  1 < i and
A22:  i <= k;
A23:  1 <= i - 1 by A21,INT_1:79;
      then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
      i - 1 <= k - 1 by A22,XREAL_1:11;
      then
A24:  i1 in Seg k1 by A4,A23;
A25:  len <* a := intloc 0 *> = 1 by FINSEQ_1:56;

      dom (<* a := intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0))) = Seg k by A6,
FINSEQ_1:def 3;

      then
      i in dom (<* a := intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0))) by A21,A22;

      hence f.i = (<* a:= intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0))).i by
FINSEQ_1:def 7

        .= (k1 |-> AddTo(a,intloc 0)).(i - 1) by A6,A21,A22,A25,FINSEQ_1:37
        .= AddTo(a,intloc 0) by A24,FUNCOP_1:13;
    end;
A26: now
      let i be Element of NAT;
      assume that
A27:  0 < i and
A28:  i < k;
A29:  0 + 1 < i + 1 & i + 1 <= k by A27,A28,NAT_1:13,XREAL_1:8;
      thus s. i = f.(i+1) by A13,A28
        .= AddTo(a,intloc 0) by A20,A29;
    end;

A30: for i being Element of NAT st i <= k holds IC Comput(ProgramPart(s),s,i) =
     i

    proof

      defpred P[Nat] means $1 <= k implies IC Comput(ProgramPart(s),s,$1) =
       $1;

      let i be Element of NAT;
      assume
A31:  i <= k;
A32:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A33:    P[n];
        assume
A34:    n+1 <= k;
        then
A35:    n < k by NAT_1:13;
        per cases;
        suppose
A36:      n=0;
          hence IC Comput(ProgramPart(s),s,n+1) = IC Exec(a:= intloc 0,s) by
A17
            .= Exec(a:= intloc 0,s).IC SCM+FSA by AMI_1:def 15
            .= succ  n by A1,A36,SCMFSA_2:89
            .=  (n+1) by NAT_1:39;
        end;
        suppose
A37:      n>0;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
          n + 0 <= n + 1 by XREAL_1:9;

          then
A38:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). n by A33,A34,
AMI_1:def 16,XXREAL_0:2,Y

            .= s. n by AMI_1:54
            .= AddTo(a,intloc 0) by A26,A35,A37;
T: ProgramPart s = ProgramPart Comput(
ProgramPart(s),s,n)
by AMI_1:144;
A39:      Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,n)) by AMI_1:14

            .= Exec(AddTo(a,intloc 0), Comput(ProgramPart(s),s,n)) by A38,AMI_1
:def 18,T;

          thus IC Comput(ProgramPart(s),s,n+1) = Comput(ProgramPart(s),s,n+1).
IC SCM+FSA by
AMI_1:def 15

            .= succ IC Comput(ProgramPart(s),s,n) by A39,SCMFSA_2:90
            .=  (n+1) by A33,A34,NAT_1:13,39;
        end;
      end;
A40:  P[0] by A1,AMI_1:13;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A40,A32);
      hence thesis by A31;
    end;

    f.(k + 1) = <* halt SCM+FSA *>.(k + 1 - k) by A6,A8,FINSEQ_1:37,XREAL_1:31

      .= halt SCM+FSA by FINSEQ_1:def 8;
    then
A41: s. k = halt SCM+FSA by A13;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:144;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
    CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k))
     = ( Comput(ProgramPart(s),s,k)).IC Comput(ProgramPart(s),s,k)
    by AMI_1:def 16,Y,TX

      .= ( Comput(ProgramPart(s),s,k)). k by A30
      .= halt SCM+FSA by A41,AMI_1:54;
    hence thesis by AMI_1:146;
  end;
  suppose
A42: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A43: k1 + k = 1 and

A44: a:=k = Load (<*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) ^ <*
    halt SCM+FSA*>) by A42,SCMFSA_7:def 2;

A45: len (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) = len<*a:=intloc 0*>
    + len(k1|->SubFrom(a,intloc 0)) by FINSEQ_1:35

      .= 1 + len(k1|->SubFrom(a,intloc 0)) by FINSEQ_1:56
      .= mk+1+1 by A43,FINSEQ_1:def 18;
    set f = <*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) ^ <*halt SCM+FSA*>;

A46: f.1 = (<*a:=intloc 0*>^((k1|->SubFrom(a,intloc 0))^<*halt SCM+FSA*>))
    .1 by FINSEQ_1:45

      .= a := intloc 0 by FINSEQ_1:58;

A47: len f = len(<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0)))+len<*halt
    SCM+FSA *> by FINSEQ_1:35

      .= mk+1+1 + 1 by A45,FINSEQ_1:56;
    then
A48: dom f = Seg (mk+1+1 + 1) by FINSEQ_1:def 3;
A49: now
      let i be Element of NAT;
      assume that
      0 <= i and
A50:  i <= mk+1+1;
      0 + 1 <= i + 1 & i + 1 <= mk+1+1 + 1 by A50,XREAL_1:8;
      hence i + 1 in dom f by A48;
A51:  dom Load f = {m: m < len f} by Th1;
      i < mk+1+1 + 1 by A50,NAT_1:13;
      hence  i in dom Load f by A47,A51;
    end;
A52: now
      let i be Element of NAT;
      assume that
      0 <= i and
A53:  i <= mk+1+1;
A54:   i in dom Load f by A49,A53;
      hence s. i = (Load f). i by A2,A44,GRFUNC_1:8
        .= f/.(i+1) by A54,SCMFSA_7:def 1
        .= f.(i+1) by A49,A53,PARTFUN1:def 8;
    end;
    then
A55: s. 0 = f.(0 + 1)
      .= a := intloc 0 by A46;
A56: now
      let n be Element of NAT;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
      assume
      n = 0;
      hence
A57:  Comput(ProgramPart(s),s,n) = s by AMI_1:13;

      hence
A58:  CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s,n
))
 = a:= intloc 0 by A1,A55,AMI_1:def 16,Y;
      thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
      Comput(ProgramPart(s),s,n)) by AMI_1:14
        .= Exec(a:= intloc 0,s) by A57,A58,AMI_1:def 18;
    end;
A59: now
A60:  len <*a:= intloc 0*> = 1 by FINSEQ_1:56;
      let i be Element of NAT;
      assume that
A61:  1 < i and
A62:  i <= mk+1+1;
A63:  i - 1 <= mk+1+1 - 1 by A62,XREAL_1:11;
A64:  1 - 1 < i - 1 by A61,XREAL_1:11;
      then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
      1 - 1 + 1 <= i - 1 by A64,INT_1:20;
      then
A65:  i1 in Seg k1 by A43,A63;

      dom (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) = Seg (mk+1+1) by A45,
FINSEQ_1:def 3;

      then i in dom (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) by A61,A62;

      hence f.i = (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))).i by
FINSEQ_1:def 7

        .= (k1|->SubFrom(a,intloc 0)).(i - 1) by A45,A61,A62,A60,FINSEQ_1:37
        .= SubFrom(a,intloc 0) by A65,FUNCOP_1:13;
    end;
A66: now
      let i be Element of NAT;
      assume that
A67:  0 < i and
A68:  i < mk+1+1;
A69:  0 + 1 < i + 1 & i + 1 <= mk+1+1 by A67,A68,NAT_1:13,XREAL_1:8;
      thus s. i = f.(i+1) by A52,A68
        .=SubFrom(a,intloc 0) by A59,A69;
    end;

A70: for i being Element of NAT st i <= mk+1+1 holds IC Comput(ProgramPart(s),s
,i) =
     i

    proof

      defpred P[Nat] means $1<=mk+1+1 implies IC Comput(ProgramPart(s),s,$1)=
       $1;

      let i be Element of NAT;
      assume
A71:  i <= mk+1+1;
A72:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A73:    P[n];
        assume
A74:    n+1 <= mk+1+1;
        then
A75:    n < mk+1+1 by NAT_1:13;
        per cases;
        suppose
A76:      n=0;
          hence IC Comput(ProgramPart(s),s,n+1) = IC Exec(a:= intloc 0,s) by
A56
            .= Exec(a:= intloc 0,s).IC SCM+FSA by AMI_1:def 15
            .= succ  n by A1,A76,SCMFSA_2:89
            .=  (n+1) by NAT_1:39;
        end;
        suppose
A77:      n>0;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
          n + 0 <= n + 1 by XREAL_1:9;

          then
A78:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). n by A73,A74,
AMI_1:def 16,XXREAL_0:2,Y

            .= s. n by AMI_1:54
            .= SubFrom(a,intloc 0) by A66,A75,A77;
T: ProgramPart s = ProgramPart Comput(
ProgramPart(s),s,n)
by AMI_1:144;
A79:      Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,n)) by AMI_1:14

            .= Exec(SubFrom(a,intloc 0), Comput(ProgramPart(s),s,n)) by A78,
AMI_1:def 18,T;

          thus IC Comput(ProgramPart(s),s,n+1) = Comput(ProgramPart(s),s,n+1).
IC SCM+FSA by
AMI_1:def 15

            .= succ IC Comput(ProgramPart(s),s,n) by A79,SCMFSA_2:91
            .=  (n+1) by A73,A74,NAT_1:13,39;
        end;
      end;
A80:  P[0] by A1,AMI_1:13;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A80,A72);
      hence thesis by A71;
    end;

    f.(mk+1+1+1) = <*halt SCM+FSA*>.(mk+1+1+1-(mk+1+1)) by A45,A47,FINSEQ_1:37
,XREAL_1:31

      .= halt SCM+FSA by FINSEQ_1:def 8;
    then
A81: s. (mk+1+1) = halt SCM+FSA by A52;

Y:  (ProgramPart Comput(ProgramPart(s),s,mk+1+1))/.IC Comput(ProgramPart(s),s,
mk+1+1)
 = Comput(ProgramPart(s),s,mk+1+1).IC Comput(ProgramPart(s),s,mk+1+1) by AMI_1:
150;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,mk+1+1)
by AMI_1:144;
   CurInstr(ProgramPart s,Comput(ProgramPart(s),s,mk+1+1))
    = ( Comput(ProgramPart(s),s,mk+1+1)).IC
    Comput(ProgramPart(s),s,mk+1+1) by AMI_1:def 16,Y,TX

      .= ( Comput(ProgramPart(s),s,mk+1+1)). (mk+1+1) by A70
      .= halt SCM+FSA by A81,AMI_1:54;
    hence thesis by AMI_1:146;
  end;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> parahalting;
  correctness
  proof
    now
A1:   IC SCM+FSA in dom (a := k +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
      let s be State of SCM+FSA;
      assume
A2:   a := k +* Start-At( 0,SCM+FSA) c= s;
      IC s = s.IC SCM+FSA by AMI_1:def 15
        .= (a := k +* Start-At( 0,SCM+FSA)).IC SCM+FSA
         by A2,A1,GRFUNC_1:8
        .= 0 by SF_MASTR:66;
      hence ProgramPart s halts_on s by A2,Lm1,SCMFSA6B:5;
    end;
    then a := k +* Start-At( 0,SCM+FSA) is halting by AMI_1:def 26;
    hence thesis by SCMFSA6B:def 3;
  end;
end;

theorem
  for s being State of SCM+FSA for a being read-write Int-Location, k
  being Integer holds IExec(a := k,s).a = k & (for b being read-write
  Int-Location st b <> a holds IExec(a := k,s).b = s.b) & for f being
  FinSeq-Location holds IExec(a := k,s).f = s.f
proof
  let s be State of SCM+FSA;
  let a be read-write Int-Location;
  let k be Integer;
  set s1 = s +* Initialized (a := k);
A1: IExec(a := k,s) = Result(ProgramPart(s1),s1) +* s | A by SCMFSA6B:def 1;
  intloc 0 in dom Initialized (a := k) by SCMFSA6A:45;
  then
A2: s1.intloc 0 = (Initialized (a := k)).intloc 0 by FUNCT_4:14
    .= 1 by SCMFSA6A:46;
  IC SCM+FSA in dom Initialized (a := k) by SCMFSA6A:24;
  then s1.IC SCM+FSA = (Initialized (a := k)).IC SCM+FSA by FUNCT_4:14
    .= 0 by SCMFSA6A:46;
  then
A3: IC s1 = 0 by AMI_1:def 15;
  Initialized (a := k) c= s1 & a := k c= Initialized (a := k) by FUNCT_4:26
,SCMFSA6A:26;
  then
A4: a := k c= s1 by XBOOLE_1:1;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then not a in dom (s | A) by RELAT_1:90;
  hence IExec(a := k,s).a = (Result(ProgramPart(s1),s1)).a by A1,FUNCT_4:12
    .= k by A3,A2,A4,SCMFSA_7:38;
  hereby
    let b be read-write Int-Location;
    assume
A6: b <> a;
A7: not b in dom Initialized (a := k) by SCMFSA6A:48;
    not b in A by SCMFSA_2:84;
    then not b in dom s /\ A by XBOOLE_0:def 4;
    then not b in dom (s | A) by RELAT_1:90;
    hence IExec(a := k,s).b = (Result(ProgramPart(s1),s1)).b by A1,FUNCT_4:12
      .= s1.b by A3,A2,A4,A6,SCMFSA_7:38
      .= s.b by A7,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
A9: not f in dom Initialized (a := k) by SCMFSA6A:49;
  not f in A by SCMFSA_2:85;
  then not f in dom s /\ A by XBOOLE_0:def 4;
  then not f in dom (s | A) by RELAT_1:90;
  hence IExec(a := k,s).f = (Result(ProgramPart(s1),s1)).f by A1,FUNCT_4:12
    .= s1.f by A3,A2,A4,SCMFSA_7:38
    .= s.f by A9,FUNCT_4:12;
end;

Lm2: for p1,p2,p3,p4 being FinSequence holds p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3
^ p4)

proof
  let p1,p2,p3,p4 be FinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4 by FINSEQ_1:45
    .= p1 ^ (p2 ^ p3 ^ p4) by FINSEQ_1:45;
end;

Lm3: for p1,p2,p3 being FinSequence holds len p1 + len p2 + len p3 = len (p1 ^
p2 ^ p3) & len p1 + len p2 + len p3 = len (p1 ^ (p2 ^ p3)) & len p1 + (len p2 +
len p3) = len (p1 ^ (p2 ^ p3)) & len p1 + (len p2 + len p3) = len (p1 ^ p2 ^ p3
)

proof
  let p1,p2,p3 be FinSequence;
  thus
A1: len p1 + len p2 + len p3 = len (p1 ^ p2) + len p3 by FINSEQ_1:35
    .= len (p1 ^ p2 ^ p3) by FINSEQ_1:35;
  hence len p1 + len p2 + len p3 = len (p1 ^ (p2 ^ p3)) by FINSEQ_1:45;
  thus len p1 + (len p2 + len p3) = len (p1 ^ (p2 ^ p3)) by A1,FINSEQ_1:45;
  thus thesis by A1;
end;

Lm4: for s being State of SCM+FSA st IC s = 0 & s.intloc 0 = 1 for f
being FinSeq-Location, p being FinSequence of INT st (f := p) c= s
 holds ProgramPart s halts_on s &
  (Result(ProgramPart(s),s)).f = p & (for b being Int-Location st b <> intloc 1
& b <>
intloc 2 holds (Result(ProgramPart(s),s)).b = s.b) & for g being
FinSeq-Location st g <> f
holds (Result(ProgramPart(s),s)).g = s.g

proof
  intloc 0 <> intloc 1 & intloc 0 <> intloc 2 by AMI_3:52;

  then reconsider a1 = intloc 1,a2 = intloc 2 as read-write Int-Location by
SF_MASTR:def 5;

  set D = the Instructions of SCM+FSA;
  set O = intloc 0;
  let s be State of SCM+FSA such that
A1: IC s = 0 and
A2: s.O = 1;
  let f be FinSeq-Location;
  let p be FinSequence of INT;

  set q = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *> ^ aSeq(f,p) ^ <* halt
  SCM+FSA *>;

  set q0 = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *>;
A3: (f := p) = Load q by SCMFSA_7:def 5;
  assume
A4: (f := p) c= s;
A5: now
    let i be Element of NAT;
    assume
A6:  i in dom Load q;
    then s. i = (Load q). i by A4,A3,GRFUNC_1:8;
    then
A7: s. i = q/.(i + 1) by A6,SCMFSA_7:def 1;
    i + 1 in dom q by A6,SCMFSA_7:26;
    hence s. i = q.(i + 1) by A7,PARTFUN1:def 8;
  end;
A8: now
    let i,k be Element of NAT;
    assume
    i < len q;
    then
A9:  i in dom Load q by SCMFSA_7:29;
    thus ( Comput(ProgramPart(s),s,k)). i = s. i by AMI_1:54
      .= q.(i + 1) by A5,A9;
  end;
A10: now
    let k be Element of NAT;
    assume
A11:  k in dom Load q;
    then
A12: k + 1 in dom q by SCMFSA_7:26;
    thus (Load q). k = q/.(k+1) by A11,SCMFSA_7:def 1
      .= q.(k+1) by A12,PARTFUN1:def 8;
  end;
  consider pp being FinSequence of D* such that
A13: len pp = len p and

A14: for k being Element of NAT st 1 <= k & k <= len p holds ex i being
  Integer st i = p.k & pp.k = (aSeq(a1,k) ^ aSeq(a2,i) ^ <* (f,a1):= a2 *>) and
A15: aSeq(f,p) = FlattenSeq pp by SCMFSA_7:def 4;

  defpred P[FinSequence] means $1 c= pp implies (ex pp0 being FinSequence of D

* st (pp0 = $1 & (for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
  holds IC Comput(ProgramPart(s),s,i) =  i) & ((Comput(ProgramPart(s),s,len (q0
^ FlattenSeq
  pp0)).f) | Seg len pp0 = p | Seg len pp0) & len (Comput(ProgramPart(s),s,len
(q0 ^
  FlattenSeq pp0)).f) = len p & (for b being Int-Location st b <> a1 & b <> a2
  holds Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).b = s.b) & (for g
being

FinSeq-Location st g <> f holds Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq
pp0)).g = s.
  g)));

A16: dom Load q = {m -' 1: m in dom q} by SCMFSA_7:def 1;
A17: a1 <> a2 by AMI_3:52;
A18: for r being FinSequence, x being set st P[r] holds P[r ^ <* x *>]
  proof
    let r be FinSequence, x be set;
    assume
A19: P[r];
    set r1 = len r + 1;
    len (r ^ <* x *>) = r1 by FINSEQ_2:19;
    then r1 in Seg len (r ^ <* x *>) by FINSEQ_1:6;
    then
A20: r1 in dom (r ^ <* x *>) by FINSEQ_1:def 3;
A21: 1 <= len <* (f,a1):=a2 *> by FINSEQ_1:57;
    assume
A22: r ^ <* x *> c= pp;
    then
A23: dom (r ^ <* x *>) c= dom pp by GRFUNC_1:8;
    then r1 in dom pp by A20;
    then
A24: r1 in Seg len pp by FINSEQ_1:def 3;
    then 1 <= r1 & r1 <= len p by A13,FINSEQ_1:3;
    then consider pr1 being Integer such that
A25: pr1 = p.r1 and
A26: pp.r1 = aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1):=a2 *> by A14;
    r c= r ^ <* x *> by FINSEQ_6:12;
    then consider pp0 being FinSequence of D* such that
A27: pp0 = r and

A28: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
    holds IC Comput(ProgramPart(s),s,i) =  i and

A29: (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0 = p |
    Seg len pp0 and
A30: len (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).f) = len p and

A31: for b being Int-Location st b <> a1 & b <> a2 holds Comput(ProgramPart(s
    ),s
    ,len (q0 ^ FlattenSeq pp0)).b = s.b and

A32: for h being FinSeq-Location st h <> f holds Comput(ProgramPart(s),s,len (
q0
    ^ FlattenSeq pp0)).h = s.h by A19,A22,XBOOLE_1:1;

A33: x = (r ^ <* x *>).r1 by FINSEQ_1:59
      .= pp.r1 by A22,A20,GRFUNC_1:8;
    then x in D* by A20,A23,FINSEQ_2:13;
    then <* x *> is FinSequence of D* by FINSEQ_1:95;
    then reconsider pp1 = pp0 ^ <* x *> as FinSequence of D* by FINSEQ_1:96;
    take pp1;
    thus pp1 = r ^ <* x *> by A27;
    reconsider x as Element of D* by A20,A23,A33,FINSEQ_2:13;
A34: FlattenSeq pp1 = FlattenSeq pp0 ^ FlattenSeq <* x *> by PRE_POLY:3
      .= FlattenSeq pp0 ^ x by PRE_POLY:1;
    set c2 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1));
    set c1 = len (q0 ^ FlattenSeq pp0);
A35: 1 <= c2 + len aSeq(a2,pr1) + 1 by NAT_1:11;

A36: x = aSeq(a1,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1):=a2 *>) by A26,A33,FINSEQ_1:45
;

    then len q0 + len FlattenSeq pp1 = len q0 + len (FlattenSeq pp0 ^ aSeq(a1
    ,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1):=a2 *>)) by A34,FINSEQ_1:45

      .= len (q0 ^ (FlattenSeq pp0 ^ aSeq(a1,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1)
    :=a2 *>))) by FINSEQ_1:35

      .= len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1)
    :=a2 *>)) by Lm2

      .= c2 + len (aSeq(a2,pr1) ^ <* (f,a1):=a2 *>) by FINSEQ_1:35
      .= c2 + (len aSeq(a2,pr1) + len <* (f,a1):=a2 *>) by FINSEQ_1:35;

    then
A37: len q0 + len FlattenSeq pp1 = c2 + (len aSeq(a2,pr1) + 1) by FINSEQ_1:56

      .= c2 + len aSeq(a2,pr1) + 1;

    then
A38: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(a2,pr1) + 1 by FINSEQ_1:35;

    then
A39: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(a2,pr1) by NAT_1:13;
A40: FlattenSeq pp1 c= FlattenSeq pp by A22,A27,PRE_POLY:6;
A41: now
      let p be FinSequence;
      assume
      p c= x;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp0 ^ x by FINSEQ_6:15;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp by A40,A34,XBOOLE_1:1;

      then q0 ^ (FlattenSeq pp0 ^ p) c= q0 ^ FlattenSeq pp by FINSEQ_6:15;

      then
A42:  q0 ^ FlattenSeq pp0 ^ p c= q0 ^ FlattenSeq pp by FINSEQ_1:45;
      q0 ^ FlattenSeq pp c= q by A15,FINSEQ_6:12;
      hence q0 ^ FlattenSeq pp0 ^ p c= q by A42,XBOOLE_1:1;
    end;
A43: now
      let c be Element of NAT;
      assume
A44:  c in dom aSeq(a2,pr1);

      then
A45:  c2 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,pr1 ))
      by FINSEQ_1:41;

      then c2 + c >= 1 by FINSEQ_3:27;
      then
A46:  c2 + c -' 1 + 1 = c2 + c - 1 + 1 by XREAL_1:235
        .= c2 + c;

      q0 ^ FlattenSeq pp0 ^ (aSeq(a1,r1) ^ aSeq(a2,pr1)) c= q by A26,A33,A41,
FINSEQ_6:12;

      then
A47:  q0 ^FlattenSeq pp0^aSeq(a1,r1) ^ aSeq(a2,pr1) c= q by FINSEQ_1:45;

      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,pr1)) c= dom q by
GRFUNC_1:8;

      then
A48:   (c2 + c -' 1) in dom Load q by A16,A45;

      thus aSeq(a2,pr1).c = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,pr1))
      .(c2 + c) by A44,FINSEQ_1:def 7

        .= q.(c2 + c) by A45,A47,GRFUNC_1:8
        .= (Load q). (c2 + c -' 1) by A10,A48,A46
        .= s. (c2 + c -' 1) by A4,A3,A48,GRFUNC_1:8
        .= Comput(ProgramPart(s),s,c2). (c2 + c -' 1) by AMI_1:54;
    end;
    len pp1 <= len pp by A22,A27,FINSEQ_1:84;
    then
A49: Seg len pp1 c= Seg len p by A13,FINSEQ_1:7;
    then Seg len pp1 c= dom p by FINSEQ_1:def 3;
    then
A50: dom (p | Seg len pp1) = Seg len pp1 by RELAT_1:91;

    len <* (f,a1):=a2 *> <= len (aSeq(a1,r1) ^ aSeq(a2,pr1)) + len <* (f
    ,a1):=a2 *> by NAT_1:12;

    then len <* (f,a1):=a2 *> <= len (aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1)
    :=a2 *>) by FINSEQ_1:35;

    then
A51: 1 <= len x by A26,A33,FINSEQ_1:57;
    set c3 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,pr1));
A52: c3 = c2 + len aSeq(a2,pr1) by FINSEQ_1:35;

A53: for c being Element of NAT st c in dom aSeq(a1,r1) holds aSeq(a1,r1).
    c = Comput(ProgramPart(s),s,c1). (c1 + c -' 1)

    proof
      let c be Element of NAT;
      assume
A54:  c in dom aSeq(a1,r1);

      then
A55:  c1 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1)) by FINSEQ_1:41;

      then c1 + c >= 1 by FINSEQ_3:27;
      then
A56:  c1 + c -' 1 = c1 + c - 1 by XREAL_1:235;
A57:  q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) c= q by A36,A41,FINSEQ_6:12;
      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1)) c= dom q by GRFUNC_1:8;
      then
A58:   (c1 + c -' 1) in dom Load q by A16,A55;

      thus aSeq(a1,r1).c = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1)).(c1 + c) by A54,
FINSEQ_1:def 7

        .= q.(c1 + c -' 1 + 1) by A57,A55,A56,GRFUNC_1:8
        .= (Load q). (c1 + c -' 1) by A10,A58
        .= s. (c1 + c -' 1) by A4,A3,A58,GRFUNC_1:8
        .= Comput(ProgramPart(s),s,c1). (c1 + c -' 1) by AMI_1:54;
    end;
A59: q0 ^ FlattenSeq pp1 = q0 ^ FlattenSeq pp0 ^ x by A34,FINSEQ_1:45;
    then len (q0 ^ FlattenSeq pp1) <= len q by A41,FINSEQ_1:84;
    then
A60: c2 + len aSeq(a2,pr1) < len q by A38,NAT_1:13;

A61: Comput(ProgramPart(s),s,c1).O = 1 & IC Comput(ProgramPart(s),s,c1) =  c1
by A2,A28,A31;

A62: now
      let i be Element of NAT;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c1)
by AMI_1:144;
      assume
      i <= len aSeq(a1,r1);

      hence  (c1 + i) = IC Comput(ProgramPart(s),
Comput(ProgramPart(s),s,c1),i) by A53,A61,
SCMFSA_7:36,T

        .= IC Comput(ProgramPart(s),s,c1 + i) by AMI_1:51;
    end;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,
c1)
by AMI_1:144;
A63: c2 = c1 + len aSeq(a1,r1) by FINSEQ_1:35;

    then
A64: Comput(ProgramPart(s),s,c2)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,c1),len aSeq(a1,r1)) by
AMI_1:51;

    then
A65: Comput(ProgramPart(s),s,c2).O = 1 by A53,A61,SCMFSA_7:36,T;
A66: IC Comput(ProgramPart(s),s,c2) =  c2 by A63,A64,A53,A61,SCMFSA_7:36,T;
A67: now
      let i be Element of NAT;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
      assume
      i <= len aSeq(a2,pr1);

      hence
       (c2 + i) = IC Comput(ProgramPart(s),Comput(
ProgramPart(s),s,c2),i) by A43,A65,A66,
SCMFSA_7:36,T

        .= IC Comput(ProgramPart(s),s,c2+i) by AMI_1:51;
    end;

A68: for i being Element of NAT st i < len (q0 ^ FlattenSeq pp1) holds IC
    Comput(ProgramPart(s),s,i) =  i

    proof
      let i be Element of NAT;
      assume
A69:  i < len (q0 ^ FlattenSeq pp1);
A70:  now
A71:    i < len q0 + len FlattenSeq pp1 by A69,FINSEQ_1:35;
        assume
A72:    not i <= c1;
        assume
        not (c1 + 1 <= i & i <= c2);

        hence c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1) by A37,A72,A71,NAT_1:13;

      end;
      per cases by A70;
      suppose
        i <= len (q0 ^ FlattenSeq pp0);
        hence thesis by A28;
      end;
      suppose
A73:    c1 + 1 <= i & i <= c2;
        then c1 + 1 - c1 <= i - c1 by XREAL_1:11;
        then reconsider ii = i - c1 as Element of NAT by INT_1:16;
        i - c1 <= c2 - c1 by A73,XREAL_1:11;
        hence  i = IC Comput(ProgramPart(s),s,c1+ii)by A63,A62
          .= IC Comput(ProgramPart(s),s,i);
      end;
      suppose
A74:    c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1);
        then c2 + 1 - c2 <= i - c2 by XREAL_1:11;
        then reconsider ii = i - c2 as Element of NAT by INT_1:16;
        i - c2 <= c2 + len aSeq(a2,pr1) - c2 by A74,XREAL_1:11;
        hence  i = IC Comput(ProgramPart(s),s,c2+ii)by A67
          .= IC Comput(ProgramPart(s),s,i);
      end;
    end;

S: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
A75: Comput(ProgramPart(s),s,c3).f = Comput(ProgramPart(s),s,c2 + len aSeq(a2,
pr1)).f by
FINSEQ_1:35

      .= Comput(ProgramPart(s),Comput(ProgramPart(s),
s,c2),len aSeq(a2,pr1)).f by AMI_1:51
      .= Comput(ProgramPart(s),s,c2).f by A43,A65,A66,SCMFSA_7:36,S
      .= Comput(ProgramPart(s),s,c1).f by A64,A53,A61,SCMFSA_7:36,T;
A76: c3 = c1 + len aSeq(a1,r1) + len aSeq(a2,pr1) by A63,FINSEQ_1:35;

Y:  (ProgramPart Comput(ProgramPart(s),s,c3))/.IC Comput(ProgramPart(s),s,c3)
 = Comput(ProgramPart(s),s,c3).IC Comput(ProgramPart(s),s,c3) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),Comput(ProgramPart(s),s,c3
))
     = Comput(ProgramPart(s),s,c3).IC Comput(ProgramPart(s),s,c3)
    by AMI_1:def 16,Y

      .= Comput(ProgramPart(s),s,c3). c3 by A52,A68,A39
      .= q.(c3 + 1) by A8,A52,A60

      .= (q0 ^ FlattenSeq pp1).(c3 + 1) by A59,A52,A41,A38,A35,FINSEQ_4:98;

    then CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),Comput(ProgramPart(s)
,s,c3))
     = (q0 ^ FlattenSeq pp0 ^ x).(c3 + len <*
    (f,a1):=a2 *>) by A59,FINSEQ_1:57

      .= (q0 ^ FlattenSeq pp0 ^ x).(c1 + (len aSeq(a1,r1) + (len aSeq(a2,pr1
    ) + len <* (f,a1):=a2 *>))) by A76;

    then
A77: CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),Comput(ProgramPart(s),s,
c3))
 = (q0 ^ FlattenSeq pp0 ^ x).(c1 + len x)
    by A26,A33,Lm3

      .= (aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1):=a2 *>). len (aSeq(a1,r1) ^
    aSeq(a2,pr1) ^ <* (f,a1):=a2 *>) by A26,A33,A51,FINSEQ_1:86

      .= (aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1):=a2 *>). (len (aSeq(a1,r1)
    ^ aSeq(a2,pr1)) + len <* (f,a1):=a2 *>) by FINSEQ_1:35

      .= <* (f,a1):=a2 *>.len <* (f,a1):=a2 *> by A21,FINSEQ_1:86
      .= <* (f,a1):=a2 *>.1 by FINSEQ_1:57
      .= (f,a1):=a2 by FINSEQ_1:57;
X: ProgramPart s = ProgramPart Comput(ProgramPart(s
),s,c3)
by AMI_1:144;
A78: Comput(ProgramPart(s),s,c3+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,c3)) by AMI_1:14
      .= Exec((f,a1):=a2, Comput(ProgramPart(s),s,c3)) by A77,AMI_1:def 18,X;

    then
A79: IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)) = Exec((f,a1):=a2,
    Comput(ProgramPart(s),s,c3)).IC SCM+FSA by A52,A38,AMI_1:def 15

      .= succ IC Comput(ProgramPart(s),s,c3) by SCMFSA_2:99
      .= succ  c3 by A52,A68,A39
      .=  len (q0 ^ FlattenSeq pp1) by A52,A38,NAT_1:39;

    thus for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp1) holds IC
    Comput(ProgramPart(s),s,i) =  i

    proof
      let i be Element of NAT;
      assume
A80:  i <= len (q0 ^ FlattenSeq pp1);
      per cases by A80,XXREAL_0:1;
      suppose
        i < len (q0 ^ FlattenSeq pp1);
        hence thesis by A68;
      end;
      suppose
        i = len (q0 ^ FlattenSeq pp1);
        hence thesis by A79;
      end;
    end;
    consider ki being Element of NAT such that
A81: ki = abs( Comput(ProgramPart(s),s,c3).a1) and

A82: Exec((f,a1):=a2, Comput(ProgramPart(s),s,c3)).f = Comput(ProgramPart(s),s,
c3).f +*(
    ki, Comput(ProgramPart(s),s,c3).a2) by SCMFSA_2:99;

S: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
A83: ki = abs( Comput(ProgramPart(s),s,c2 + len aSeq(a2,pr1)).a1 ) by A81,
FINSEQ_1:35

      .= abs( Comput(ProgramPart(s),Comput(
ProgramPart(s),s,c2),len aSeq(a2,pr1)).a1 ) by AMI_1:51

      .= abs( Comput(ProgramPart(s),s,c2).a1 )
      by A17,A43,A65,A66,SCMFSA_7:36,S
      .= abs( r1 ) by A64,A53,A61,SCMFSA_7:36,T
      .= r1 by ABSVALUE:def 1;

X: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
A84: Comput(ProgramPart(s),s,c3).a2 = Comput(ProgramPart(s),s,c2 + len aSeq(a2,
pr1)).a2 by
FINSEQ_1:35

      .= Comput(ProgramPart(s),Comput(ProgramPart(s),
s,c2),len aSeq(a2,pr1)).a2 by AMI_1:51
      .= p.r1 by A25,A43,A65,A66,SCMFSA_7:36,X;

A85: Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)) = Exec((f,a1):=a2,
    Comput(ProgramPart(s),s,c3)) by A38,A78,FINSEQ_1:35;

    for i being Element of NAT st i in Seg len pp1 holds ((Comput(ProgramPart(s
    ),s
    ,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1).i = (p | Seg len pp1).i

    proof
A86:  r1 in dom ( Comput(ProgramPart(s),s,c1).f) by A13,A30,A24,FINSEQ_1:def 3;
      let i be Element of NAT;
      assume
A87:  i in Seg len pp1;
      then
A88:  i <= len pp1 by FINSEQ_1:3;
      per cases;
      suppose
A89:    i = len pp1;
        then
A90:    i = len pp0 + 1 by FINSEQ_2:19;

        hence
        ((Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1).
i =
        ( Comput(ProgramPart(s),s,c1).f +*(r1,p.r1)).i by A85,A82,A83,A84,A75,
A89,
FINSEQ_1:6,FUNCT_1:72

          .= p.r1 by A27,A86,A90,FUNCT_7:33
          .= (p | Seg len pp1).i by A27,A89,A90,FINSEQ_1:6,FUNCT_1:72;
      end;
      suppose
A91:    i <> len pp1;
        then i < len pp1 by A88,XXREAL_0:1;
        then i < len pp0 + 1 by FINSEQ_2:19;
        then
A92:    i <= len pp0 by NAT_1:13;
        1 <= i by A87,FINSEQ_1:3;
        then
A93:    i in Seg len pp0 by A92;
A94:    i <> r1 by A27,A91,FINSEQ_2:19;

        ((Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1).
i =

( Comput(ProgramPart(s),s,c1).f +*(r1,p.r1)).i by A85,A82,A83,A84,A75,A87,
FUNCT_1:72

          .= Comput(ProgramPart(s),s,c1).f.i by A94,FUNCT_7:34;

        hence
        ((Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1).
i =
        (p | Seg len pp0).i by A29,A93,FUNCT_1:72

          .= p.i by A93,FUNCT_1:72
          .= (p | Seg len pp1).i by A87,FUNCT_1:72;
      end;
    end;

    then
A95: for i being set st i in Seg len pp1 holds ((Comput(ProgramPart(s),s,len (
q0 ^
    FlattenSeq pp1)).f) | Seg len pp1).i = (p | Seg len pp1).i;

A96: dom ( Comput(ProgramPart(s),s,c1).f +*(r1,p.r1)) = dom ( Comput(
ProgramPart(s),s,c1).f)
    by FUNCT_7:32;

    then dom (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)).f) = Seg len p
by A30
,A52,A38,A78,A82,A83,A84,A75,FINSEQ_1:def 3;

    then dom ((Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)).f) | Seg len
pp1 ) =
    Seg len pp1 by A49,RELAT_1:91;

    hence (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1
= p | Seg
    len pp1 by A50,A95,FUNCT_1:9;

    len ( Comput(ProgramPart(s),s,c1).f +*(r1,p.r1)) = len ( Comput(ProgramPart
(s),s,c1).f)
    by A96,FINSEQ_3:31;

    hence len (Comput(ProgramPart(s),s,len (q0^FlattenSeq pp1)).f) = len p by
A30,A38,A78
,A82,A83,A84,A75,FINSEQ_1:35;

    hereby
      let b be Int-Location;
      assume that
A97:  b <> a1 and
A98:  b <> a2;

S: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
      thus Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)).b = Comput(
ProgramPart(s),s,c2 + len
      aSeq(a2,pr1)).b by A52,A38,A78,SCMFSA_2:99

        .= Comput(ProgramPart(s),Comput(ProgramPart(s
),s,c2),len aSeq(a2,pr1)).b by AMI_1:51
        .= Comput(ProgramPart(s),s,c2).b by A43,A65,A66,A98,SCMFSA_7:36,S
        .= Comput(ProgramPart(s),s,c1).b by A64,A53,A61,A97,SCMFSA_7:36,T
        .= s.b by A31,A97,A98;
    end;
    hereby
      let h be FinSeq-Location;
S: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
      assume
A99:  h <> f;

      hence
      Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)).h = Comput(ProgramPart
(s),s,c2 + len
      aSeq(a2,pr1)).h by A52,A38,A78,SCMFSA_2:99

        .= Comput(ProgramPart(s),Comput(ProgramPart(s
),s,c2),len aSeq(a2,pr1)).h by AMI_1:51
        .= Comput(ProgramPart(s),s,c2).h by A43,A65,A66,SCMFSA_7:36,S
        .= Comput(ProgramPart(s),s,c1).h by A64,A53,A61,SCMFSA_7:36,T
        .= s.h by A32,A99;
    end;
  end;
  set k = len aSeq(a1,len p);
A100: len q0 = k + 1 by FINSEQ_2:19;

A101: q = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *> ^ (aSeq(f,p) ^ <* halt
  SCM+FSA *>) by FINSEQ_1:45;

  then q = aSeq(a1,len p) ^ (<* f :=<0,...,0> a1 *> ^ (aSeq(f,p) ^ <* halt
  SCM+FSA *>)) by FINSEQ_1:45;

  then Load aSeq(a1,len p) c= (f := p) by A3,SCMFSA_7:31;
  then
A102: Load aSeq(a1,len p) c= s by A4,XBOOLE_1:1;
A103: P[{}]
  proof
A104: now
      let i be Element of NAT such that
A105: i < len q0;
      i < len q0 implies i <= len aSeq(a1,len p) by A100,NAT_1:13;
      hence IC Comput(ProgramPart(s),s,i) =  i by A1,A2,A102,A105,SCMFSA_7:37;
    end;

    len q = len q0 + len (aSeq(f,p) ^ <* halt SCM+FSA *>) by A101,FINSEQ_1:35;

    then len q0 <= len q by NAT_1:11;
    then
A106: k < len q by A100,NAT_1:13;
    assume
    {} c= pp;
     reconsider sD = <*>(D*) as FinSequence of D*;
    take sD;
A107: q0 ^ FlattenSeq <*>(D*) = q0 ^ <*>D by PRE_POLY:2
      .= q0 by FINSEQ_1:47;
    thus sD = {};
    consider ki being Element of NAT such that
A108: ki = abs( Comput(ProgramPart(s),s,k).a1) and

A109: Exec(f:=<0,...,0>a1, Comput(ProgramPart(s),s,k)).f = ki |-> 0 by SCMFSA_2
:101;

A110: 1 <= len q0 by A100,NAT_1:11;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
    k < len q0 by A100,NAT_1:13;
    then
A111: IC Comput(ProgramPart(s),s,k) =  k by A104;

    then
A112: CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s),s,k
))
 = ( Comput(ProgramPart(s),s,k)). k by AMI_1:def 16,Y

      .= q.len q0 by A100,A8,A106
      .= q0.len q0 by A101,A110,FINSEQ_1:85
      .= f:=<0,...,0>a1 by A100,FINSEQ_1:59;
T: ProgramPart s = ProgramPart Comput(
ProgramPart(s),s,k)
by AMI_1:144;
A113: Comput(ProgramPart(s),s,len q0) = Following(ProgramPart s,
Comput(ProgramPart(s),s,k)) by A100,AMI_1:14
      .= Exec(f:=<0,...,0>a1, Comput(ProgramPart(s),s,k))
      by A112,AMI_1:def 18,T;

A114: IC Comput(ProgramPart(s),s,len q0) = Comput(ProgramPart(s),s,len q0).IC
SCM+FSA by
AMI_1:def 15

      .= succ IC Comput(ProgramPart(s),s,k) by A113,SCMFSA_2:101
      .=  len q0 by A100,A111,NAT_1:39;
    now
      let i be Element of NAT;
      assume
      i <= len q0;
      then i < len q0 or i = len q0 by XXREAL_0:1;
      hence IC Comput(ProgramPart(s),s,i) =  i by A104,A114;
    end;

    hence for i being Element of NAT st i <= len (q0 ^ FlattenSeq sD)
    holds IC Comput(ProgramPart(s),s,i) =  i by A107;
  (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq sD)).f) | Seg 0 = p | Seg len
sD;
    hence
    (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq sD)).f)|Seg len sD = p
    | Seg len sD;
    ki = abs( len p ) by A1,A2,A102,A108,SCMFSA_7:37
      .= len p by ABSVALUE:def 1;

    hence len (Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq sD)).f) = len p by
A107,A113
,A109,FINSEQ_1:def 18;

    now
      let b be Int-Location such that
A115: b <> a1 and
      b <> a2;
      thus Comput(ProgramPart(s),s,len q0).b = Comput(ProgramPart(s),s,k).b by
A113,SCMFSA_2:101
        .= s.b by A1,A2,A102,A115,SCMFSA_7:37;
    end;

    hence
    for b being Int-Location st b <> a1 & b <> a2 holds Comput(ProgramPart(s),s
,len
    (q0 ^ FlattenSeq sD)).b = s.b by A107;

    now
      let g be FinSeq-Location;
      assume
      g <> f;

      hence Comput(ProgramPart(s),s,len q0).g = Comput(ProgramPart(s),s,k).g by
A113,SCMFSA_2:101

        .= s.g by A1,A2,A102,SCMFSA_7:37;
    end;
    hence thesis by A107;
  end;
  for r being FinSequence holds P[r] from FINSEQ_1:sch 3(A103,A18);
  then consider pp0 being FinSequence of D* such that
A116: pp0 = pp and

A117: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0) holds
  IC Comput(ProgramPart(s),s,i) =  i and

A118: ( Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0 = p
|
  Seg len pp0 and
A119: len ( Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).f) = len p and

A120: ( for b being Int-Location st b <> a1 & b <> a2 holds Comput(ProgramPart(
  s),
  s,len (q0 ^ FlattenSeq pp0)).b = s.b)& for g being FinSeq-Location st g <> f
  holds Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).g = s.g;

A121: dom p = Seg len pp0 by A13,A116,FINSEQ_1:def 3;
  len q = len (q0 ^ FlattenSeq pp) + 1 by A15,FINSEQ_2:19;
  then
A122: len (q0 ^ FlattenSeq pp) < len q by NAT_1:13;

TX: ProgramPart s =
ProgramPart Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp))
by AMI_1:144;
Y:  (ProgramPart Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)))/.
IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp))
 = Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)).
 IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)) by AMI_1:150;
  IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)) =  len (q0 ^
  FlattenSeq pp) by A116,A117;

  then
A123: CurInstr(ProgramPart(s),
        Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)))
 = (Comput(ProgramPart(s),s,len
  (q0 ^ FlattenSeq pp))).  len (q0 ^ FlattenSeq pp) by AMI_1:def 16,Y,TX

    .= q.(len (q0 ^ FlattenSeq pp) + 1) by A8,A122
    .= halt SCM+FSA by A15,FINSEQ_1:59;
  hence ProgramPart s halts_on s by AMI_1:146,TX;

  then
A124: Comput(ProgramPart(s),s,len (q0^FlattenSeq pp)) = Result(ProgramPart(s),s
) by A123,AMI_1:
def 22;

  dom ( Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp0)).f) = Seg len pp0 by
A13,A116
,A119,FINSEQ_1:def 3;

  then (Result(ProgramPart(s),s)).f = p | Seg len pp0 by A116,A118,A124,RELAT_1
:97;
  hence (Result(ProgramPart(s),s)).f = p by A121,RELAT_1:97;
  thus thesis by A116,A120,A124;
end;

Lm5: for s being State of SCM+FSA, c0 being Element of NAT st IC s =  c0
for a being Int-Location, k being Integer st (for c being Element of NAT st c <
len aSeq(a,k) holds aSeq(a,k).(c + 1) = s. (c0 + c)) holds for i being
Element of NAT st i <= len aSeq(a,k) holds IC Comput(ProgramPart(s),s,i) =  (c0
+ i
)

proof
  let s be State of SCM+FSA;
  let c0 be Element of NAT;
  assume
A1: IC s =  c0;
  let a be Int-Location;
  let k be Integer;
  assume

A2: for c being Element of NAT st c < len aSeq(a,k) holds aSeq(a,k).(c +
  1) = s. (c0 + c);

  per cases;
  suppose
A3: k > 0;
    then reconsider k9= k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A4: k1 + 1 = k9 and

A5: aSeq(a,k9) = <*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) by A3,
SCMFSA_7:def 3;

    defpred Q[Nat] means $1 <= k9 implies IC Comput(ProgramPart(s),s,$1) =
     (c0 + $1);

A6: len aSeq(a,k9) = len <*a:=intloc 0*> + len (k1|->AddTo(a,intloc 0)) by A5,
FINSEQ_1:35

      .= 1 + len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:56
      .= k9 by A4,FINSEQ_1:def 18;

    for i being Element of NAT st i <= len aSeq(a,k9) holds IC Comput(
ProgramPart(s),s,i) =  (c0 + i)

    proof
A7:   now
        let i be Element of NAT;
        assume that
A8:     1 < i and
A9:     i <= k9;
A10:    1 <= i - 1 by A8,INT_1:79;
        then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
        i - 1 <= k9 - 1 by A9,XREAL_1:11;
        then
A11:    i1 in Seg k1 by A4,A10;
        len <* a:= intloc 0 *> = 1 by FINSEQ_1:56;

        hence aSeq(a,k9).i = (k1 |-> AddTo(a,intloc 0)).(i - 1) by A5,A6,A8,A9,
FINSEQ_1:37

          .= AddTo(a,intloc 0) by A11,FUNCOP_1:13;
      end;
A12:  now
        let i be Element of NAT;
        assume that
A13:    0 < i and
A14:    i < k9;
A15:    0 + 1 < i + 1 & i + 1 <= k9 by A13,A14,NAT_1:13,XREAL_1:8;
        thus s. (c0 + i) = aSeq(a,k9).(i+1) by A2,A6,A14
          .=AddTo(a,intloc 0) by A7,A15;
      end;
A16:  s. (c0 + 0) = aSeq(a,k9).(0 + 1) by A2,A3,A6
        .= a:= intloc 0 by A5,FINSEQ_1:58;
A17:  now
        let n be Element of NAT;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
        assume
        n = 0;
        hence
A18:    Comput(ProgramPart(s),s,n) = s by AMI_1:13;

        hence
A19:    CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s
,n))
 = a:= intloc 0 by A1,A16,AMI_1:def 16,Y;
        thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
        Comput(ProgramPart(s),s,n)) by AMI_1:14
          .= Exec(a:= intloc 0,s) by A18,A19,AMI_1:def 18;
      end;
A20:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A21:    Q[n];
        assume
A22:    n + 1 <= k9;
        per cases;
        suppose
A23:      n = 0;
          hence IC Comput(ProgramPart(s),s,n+1) = IC Exec(a:= intloc 0,s) by
A17
            .= Exec(a:= intloc 0,s).IC SCM+FSA by AMI_1:def 15
            .= succ  (c0 + n) by A1,A23,SCMFSA_2:89
            .=  (c0 + n + 1) by NAT_1:39
            .=  (c0 + (n + 1));
        end;
        suppose
A24:      n > 0;
A25:      n < k9 by A22,NAT_1:13;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
A26:      n + 0 <= n + 1 by XREAL_1:9;

          then
A27:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). (c0 + n)
          by A21,A22,AMI_1:def 16,XXREAL_0:2,Y

            .= s. (c0 + n) by AMI_1:54
            .= AddTo(a,intloc 0) by A12,A24,A25;
T: ProgramPart s = ProgramPart Comput(
ProgramPart(s),s,n)
by AMI_1:144;
A28:      Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,n)) by AMI_1:14

            .= Exec(AddTo(a,intloc 0), Comput(ProgramPart(s),s,n)) by A27,AMI_1
:def 18,T;

          thus IC Comput(ProgramPart(s),s,n+1) = Comput(ProgramPart(s),s,n+1).
IC SCM+FSA by
AMI_1:def 15

            .= succ IC Comput(ProgramPart(s),s,n) by A28,SCMFSA_2:90
            .=  (c0 + n + 1) by A21,A22,A26,NAT_1:39,XXREAL_0:2
            .=  (c0 + (n + 1));
        end;
      end;
      let i be Element of NAT;
      assume
A29:  i <= len aSeq(a,k9);
A30:  Q[0] by A1,AMI_1:13;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A30,A20);
      hence thesis by A6,A29;
    end;
    hence thesis;
  end;
  suppose
A31: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:16;

    defpred Q[Nat] means $1 <= mk+1+1 implies IC Comput(ProgramPart(s),s,$1)
    =  (c0 + $1);

    consider k1 being Element of NAT such that
A32: k1 + k = 1 and

A33: aSeq(a,k) = <*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) by A31,
SCMFSA_7:def 3;

A34: len aSeq(a,k) = len <* a:=intloc 0 *> + len (k1|->SubFrom(a,intloc 0)
    ) by A33,FINSEQ_1:35

      .= 1 + len (k1|->SubFrom(a,intloc 0)) by FINSEQ_1:56
      .= mk+1+1 by A32,FINSEQ_1:def 18;

    for i being Element of NAT st i <= len aSeq(a,k) holds IC Comput(
ProgramPart(s),s,i) =  (c0 + i)

    proof
A35:  now
        let i be Element of NAT;
        assume that
A36:    1 < i and
A37:    i <= mk+1+1;
A38:    i - 1 <= mk+1+1 - 1 by A37,XREAL_1:11;
A39:    1 - 1 < i - 1 by A36,XREAL_1:11;
        then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
        1 - 1 + 1 <= i - 1 by A39,INT_1:20;
        then
A40:    i1 in Seg k1 by A32,A38;
        len <* a:= intloc 0 *> = 1 by FINSEQ_1:56;

        hence aSeq(a,k).i = (k1|->SubFrom(a,intloc 0)).(i - 1) by A33,A34,A36
,A37,FINSEQ_1:37

          .= SubFrom(a,intloc 0) by A40,FUNCOP_1:13;
      end;
A41:  now
        let i be Element of NAT;
        assume that
A42:    0 < i and
A43:    i < mk+1+1;
A44:    0 + 1 < i + 1 & i + 1 <= mk+1+1 by A42,A43,NAT_1:13,XREAL_1:8;
        thus s. (c0 + i) = aSeq(a,k).(i+1) by A2,A34,A43
          .=SubFrom(a,intloc 0) by A35,A44;
      end;
A45:  s. (c0 + 0) = aSeq(a,k).(0+1) by A2,A34
        .= a:= intloc 0 by A33,FINSEQ_1:58;

A46:  for n being Element of NAT st n = 0 holds Comput(ProgramPart(s),s,n) = s
&

CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s,n)) = a
:= intloc 0 &
Comput(ProgramPart(s),s,n+1) = Exec(a:= intloc
      0,s)

      proof
        let n be Element of NAT;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
        assume
        n = 0;
        hence
A47:    Comput(ProgramPart(s),s,n) = s by AMI_1:13;

        hence
A48:    CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s),s
,n))
 = a:= intloc 0 by A1,A45,AMI_1:def 16,Y;
        thus Comput(ProgramPart(s),s,n+1) = Following(ProgramPart s,
        Comput(ProgramPart(s),s,n)) by AMI_1:14
          .= Exec(a:= intloc 0,s) by A47,A48,AMI_1:def 18;
      end;
A49:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A50:    Q[n];
        assume
A51:    n + 1 <= mk+1+1;
        per cases;
        suppose
A52:      n = 0;
          hence IC Comput(ProgramPart(s),s,n+1) = IC Exec(a:= intloc 0,s) by
A46
            .= Exec(a:= intloc 0,s).IC SCM+FSA by AMI_1:def 15
            .= succ  (c0 + n) by A1,A52,SCMFSA_2:89
            .=  (c0 + n + 1) by NAT_1:39
            .=  (c0 + (n + 1));
        end;
        suppose
A53:      n > 0;
A54:      n < mk+1+1 by A51,NAT_1:13;
Y:  (ProgramPart Comput(ProgramPart(s),s,n))/.IC Comput(ProgramPart(s),s,n)
 = Comput(ProgramPart(s),s,n).IC Comput(ProgramPart(s),s,n) by AMI_1:150;
A55:      n + 0 <= n + 1 by XREAL_1:9;

          then
A56:      CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n))
 = ( Comput(ProgramPart(s),s,n)). (c0 + n)
          by A50,A51,AMI_1:def 16,XXREAL_0:2,Y

            .= s. (c0 + n) by AMI_1:54
            .= SubFrom(a,intloc 0) by A41,A53,A54;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,n)
by AMI_1:144;
A57:      Comput(ProgramPart(s),s,n+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,n))
 by AMI_1:14

            .= Exec(SubFrom(a,intloc 0), Comput(ProgramPart(s),s,n)) by A56,
AMI_1:def 18,T;

          thus IC Comput(ProgramPart(s),s,n+1) = Comput(ProgramPart(s),s,n+1).
IC SCM+FSA by
AMI_1:def 15

            .= succ IC Comput(ProgramPart(s),s,n) by A57,SCMFSA_2:91
            .=  (c0 + n + 1) by A50,A51,A55,NAT_1:39,XXREAL_0:2
            .=  (c0 + (n + 1));
        end;
      end;
      let i be Element of NAT;
      assume
A58:  i <= len aSeq(a,k);
A59:  Q[0] by A1,AMI_1:13;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A59,A49);
      hence thesis by A34,A58;
    end;
    hence thesis;
  end;
end;

Lm6: for s being State of SCM+FSA st IC s = 0 for a being Int-Location,
k being Integer st Load aSeq(a,k) c= s holds for i being Element of NAT st i <=
len aSeq(a,k) holds IC Comput(ProgramPart(s),s,i) =  i
proof
  let s be State of SCM+FSA;
  assume
A1: IC s = 0;
  let a be Int-Location;
  let k be Integer;
  assume
A2: Load aSeq(a,k) c= s;
A3: now
    let c be Element of NAT;
    assume
    c < len aSeq(a,k);
    then
A4:  c in dom Load aSeq(a,k) by SCMFSA_7:29;
    then
A5: c + 1 in dom aSeq(a,k) by SCMFSA_7:26;
    s. c = (Load aSeq(a,k)). c by A2,A4,GRFUNC_1:8
      .= (aSeq(a,k))/.(c + 1) by A4,SCMFSA_7:def 1;
    hence s. (0 + c) = aSeq(a,k).(c + 1) by A5,PARTFUN1:def 8;
  end;
  let i be Element of NAT;
  assume
  i <= len aSeq(a,k);
  then IC Comput(ProgramPart(s),s,i) =  (0 + i) by A1,A3,Lm5;
  hence thesis;
end;

Lm7: for s being State of SCM+FSA st IC s = 0 for f being
FinSeq-Location, p being FinSequence of INT st (f := p) c= s
 holds ProgramPart s halts_on s
proof
  set a2 = intloc 2;
  set a1 = intloc 1;
  let s be State of SCM+FSA;
  set D = the Instructions of SCM+FSA;
  assume
A1: IC s = 0;
  let f be FinSeq-Location;
  let p be FinSequence of INT;

  set q = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *> ^ aSeq(f,p) ^ <* halt
  SCM+FSA *>;

  set q0 = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *>;
A2: (f := p) = Load q by SCMFSA_7:def 5;
  assume
A3: (f := p) c= s;
A4: now
    let i be Element of NAT;
    assume
A5:  i in dom Load q;
    then s. i = (Load q). i by A3,A2,GRFUNC_1:8;
    then
A6: s. i = q/.(i + 1) by A5,SCMFSA_7:def 1;
    i + 1 in dom q by A5,SCMFSA_7:26;
    hence s. i = q.(i + 1) by A6,PARTFUN1:def 8;
  end;
A7: now
    let i,k be Element of NAT;
    assume
    i < len q;
    then
A8:  i in dom Load q by SCMFSA_7:29;
    thus ( Comput(ProgramPart(s),s,k)). i = s. i by AMI_1:54
      .= q.(i + 1) by A4,A8;
  end;
  consider pp being FinSequence of D* such that

A9: len pp = len p & for k being Element of NAT st 1 <= k & k <= len p

holds ex i being Integer st i = p.k & pp.k = (aSeq(a1,k) ^ aSeq(a2,i) ^ <* (f,
  a1):= a2 *>) and
A10: aSeq(f,p) = FlattenSeq pp by SCMFSA_7:def 4;
  len q = len (q0 ^ FlattenSeq pp) + 1 by A10,FINSEQ_2:19;
  then
A11: len (q0 ^ FlattenSeq pp) < len q by NAT_1:13;

  defpred P[FinSequence] means $1 c= pp implies ex pp0 being FinSequence of D*
  st (pp0 = $1 & for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
  holds IC Comput(ProgramPart(s),s,i) =  i);

A12: now
    let k be Element of NAT;
    assume
A13:  k in dom Load q;
    then
A14: k + 1 in dom q by SCMFSA_7:26;
    thus (Load q). k = q/.(k + 1) by A13,SCMFSA_7:def 1
      .= q.(k + 1) by A14,PARTFUN1:def 8;
  end;
A15: for r being FinSequence, x being set st P[r] holds P[r ^ <* x *>]
  proof
    let r be FinSequence;
    let x be set;
    assume
A16: P[r];
    set r1 = len r + 1;
    len (r ^ <* x *>) = r1 by FINSEQ_2:19;
    then r1 in Seg len (r ^ <* x *>) by FINSEQ_1:6;
    then
A17: r1 in dom (r ^ <* x *>) by FINSEQ_1:def 3;
    assume
A18: r ^ <* x *> c= pp;
    then
A19: dom (r ^ <* x *>) c= dom pp by GRFUNC_1:8;
    then r1 in dom pp by A17;
    then r1 in Seg len pp by FINSEQ_1:def 3;
    then 1 <= r1 & r1 <= len pp by FINSEQ_1:3;
    then consider pr1 being Integer such that
    pr1 = p.r1 and
A20: pp.r1 = aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1):=a2 *> by A9;
    r c= r ^ <* x *> by FINSEQ_6:12;
    then consider pp0 being FinSequence of D* such that
A21: pp0 = r and

A22: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
    holds IC Comput(ProgramPart(s),s,i) =  i by A16,A18,XBOOLE_1:1;

A23: x = (r ^ <* x *>).r1 by FINSEQ_1:59
      .= pp.r1 by A18,A17,GRFUNC_1:8;
    then x in D* by A17,A19,FINSEQ_2:13;
    then <* x *> is FinSequence of D* by FINSEQ_1:95;
    then reconsider pp1 = pp0 ^ <* x *> as FinSequence of D* by FINSEQ_1:96;
    take pp1;
    thus pp1 = r ^ <* x *> by A21;
    reconsider x as Element of D* by A17,A19,A23,FINSEQ_2:13;
A24: FlattenSeq pp1 = FlattenSeq pp0 ^ FlattenSeq <* x *> by PRE_POLY:3
      .= FlattenSeq pp0 ^ x by PRE_POLY:1;
    set c2 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1));
    set c1 = len (q0 ^ FlattenSeq pp0);
A25: 1 <= c2 + len aSeq(a2,pr1) + 1 by NAT_1:11;

A26: x = aSeq(a1,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1):=a2 *>) by A20,A23,FINSEQ_1:45
;

    then
A27: len q0 + len FlattenSeq pp1 = len q0 + len (FlattenSeq pp0 ^ aSeq(a1,
    r1) ^ (aSeq(a2,pr1) ^ <* (f,a1):=a2 *>)) by A24,FINSEQ_1:45

      .= len (q0 ^ (FlattenSeq pp0 ^ aSeq(a1,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1)
    :=a2 *>))) by FINSEQ_1:35

      .= len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ (aSeq(a2,pr1) ^ <* (f,a1)
    :=a2 *>)) by Lm2

      .= c2 + len (aSeq(a2,pr1) ^ <* (f,a1):=a2 *>) by FINSEQ_1:35
      .= c2 + (len aSeq(a2,pr1) + len <* (f,a1):=a2 *>) by FINSEQ_1:35
      .= c2 + (len aSeq(a2,pr1) + 1) by FINSEQ_1:56
      .= c2 + len aSeq(a2,pr1) + 1;

    then
A28: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(a2,pr1) + 1 by FINSEQ_1:35;

    then
A29: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(a2,pr1) by NAT_1:13;
A30: FlattenSeq pp1 c= FlattenSeq pp by A18,A21,PRE_POLY:6;
A31: now
      let p be FinSequence;
      assume
      p c= x;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp0 ^ x by FINSEQ_6:15;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp by A30,A24,XBOOLE_1:1;
      then q0 ^ (FlattenSeq pp0 ^ p) c= q0 ^ FlattenSeq pp by FINSEQ_6:15;
      then
A32:  q0 ^ FlattenSeq pp0 ^ p c= q0 ^ FlattenSeq pp by FINSEQ_1:45;
      q0 ^ FlattenSeq pp c= q by A10,FINSEQ_6:12;
      hence q0 ^ FlattenSeq pp0 ^ p c= q by A32,XBOOLE_1:1;
    end;

A33: IC Comput(ProgramPart(s),s,c1) =  c1 & for c being Element of NAT st c <

len aSeq(a1,r1) holds aSeq(a1,r1).(c + 1) = Comput(ProgramPart(s),s,c1). (c1 +
c)

    proof
      thus IC Comput(ProgramPart(s),s,c1) =  c1 by A22;
      let c be Element of NAT;
      assume
      c < len aSeq(a1,r1);
      then 1 <= c + 1 & c + 1 <= len aSeq(a1,r1) by NAT_1:11,13;
      then
A34:  c + 1 in dom aSeq(a1,r1) by FINSEQ_3:27;

      then
A35:  c1 + (c + 1) in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1)) by FINSEQ_1:41;

A36:  q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) c= q by A26,A31,FINSEQ_6:12;
      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1)) c= dom q by GRFUNC_1:8;
      then c1 + c + 1 in dom q by A35;
      then
A37:   (c1 + c) in dom Load q by SCMFSA_7:26;

      thus aSeq(a1,r1).(c + 1) = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1)).(c1 + (c
      + 1)) by A34,FINSEQ_1:def 7

        .= q.(c1 + c + 1) by A36,A35,GRFUNC_1:8
        .= (Load q). (c1 + c) by A12,A37
        .= s. (c1 + c) by A3,A2,A37,GRFUNC_1:8
        .= Comput(ProgramPart(s),s,c1). (c1 + c) by AMI_1:54;
    end;
    set c3 = len (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,pr1));
A38: c2 = c1 + len aSeq(a1,r1) by FINSEQ_1:35;
    then
A39: c3 = c1 + len aSeq(a1,r1) + len aSeq(a2,pr1) by FINSEQ_1:35;

    len <* (f,a1):= a2 *> <= len (aSeq(a1,r1) ^ aSeq(a2,pr1)) + len <* (
    f,a1):= a2 *> by NAT_1:12;

    then len <* (f,a1):= a2 *> <= len (aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1)
    := a2 *>) by FINSEQ_1:35;

    then
A40: 1 <= len x by A20,A23,FINSEQ_1:57;
A41: 1 <= len <* (f,a1):=a2 *> by FINSEQ_1:57;
A42: q0 ^ FlattenSeq pp1 = q0 ^ FlattenSeq pp0 ^ x by A24,FINSEQ_1:45;
    then len (q0 ^ FlattenSeq pp1) <= len q by A31,FINSEQ_1:84;
    then
A43: c2 + len aSeq(a2,pr1) < len q by A28,NAT_1:13;
A44: c3 = c2 + len aSeq(a2,pr1) by FINSEQ_1:35;

T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,
c1)
by AMI_1:144;
A45: Comput(ProgramPart(s),s,c2)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,c1),len aSeq(a1,r1)) by A38,
AMI_1:51;

A46: IC Comput(ProgramPart(s),s,c2) =  c2 & for c being Element of NAT st c <

len aSeq(a2,pr1) holds aSeq(a2,pr1).(c + 1) = Comput(ProgramPart(s),s,c2). (c2
+ c)

    proof
      thus IC Comput(ProgramPart(s),s,c2) =  c2 by A38,A45,A33,Lm5,T;
      let c be Element of NAT;
      assume
      c < len aSeq(a2,pr1);
      then 1 <= c + 1 & c + 1 <= len aSeq(a2,pr1) by NAT_1:11,13;
      then
A47:  c + 1 in dom aSeq(a2,pr1) by FINSEQ_3:27;

      then
A48:  c2 + (c + 1) in dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,
      pr1)) by FINSEQ_1:41;

      q0 ^ FlattenSeq pp0 ^ (aSeq(a1,r1) ^ aSeq(a2,pr1)) c= q by A20,A23,A31,
FINSEQ_6:12;

      then
A49:  q0 ^FlattenSeq pp0^aSeq(a1,r1) ^ aSeq(a2,pr1) c= q by FINSEQ_1:45;

      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2,pr1)) c= dom q by
GRFUNC_1:8;

      then c2 + c + 1 in dom q by A48;
      then
A50:   (c2 + c) in dom Load q by SCMFSA_7:26;

      thus aSeq(a2,pr1).(c + 1) = (q0 ^ FlattenSeq pp0 ^ aSeq(a1,r1) ^ aSeq(a2
      ,pr1)).(c2 + (c + 1)) by A47,FINSEQ_1:def 7

        .= q.(c2 + c + 1) by A48,A49,GRFUNC_1:8
        .= (Load q). (c2 + c) by A12,A50
        .= s. (c2 + c) by A3,A2,A50,GRFUNC_1:8
        .= Comput(ProgramPart(s),s,c2). (c2 + c) by AMI_1:54;
    end;
A51: now
      let i be Element of NAT;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c2)
by AMI_1:144;
      assume
      i <= len aSeq(a2,pr1);

      hence  (c2 + i) = IC Comput(ProgramPart(s),
Comput(ProgramPart(s),s,c2),i) by A46,Lm5,T

        .= IC Comput(ProgramPart(s),s,c2+i) by AMI_1:51;
    end;
A52: now
      let i be Element of NAT;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c1)
by AMI_1:144;
      assume
      i <= len aSeq(a1,r1);

      hence  (c1 + i) = IC Comput(ProgramPart(s),
Comput(ProgramPart(s),s,c1),i) by A33,Lm5,T

        .= IC Comput(ProgramPart(s),s,c1 + i) by AMI_1:51;
    end;

A53: for i being Element of NAT st i < len (q0 ^ FlattenSeq pp1) holds IC
    Comput(ProgramPart(s),s,i) =  i

    proof
      let i be Element of NAT;
      assume
A54:  i < len (q0 ^ FlattenSeq pp1);
A55:  now
A56:    i < len q0 + len FlattenSeq pp1 by A54,FINSEQ_1:35;
        assume
A57:    not i <= c1;
        assume
        not (c1 + 1 <= i & i <= c2);

        hence c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1) by A27,A57,A56,NAT_1:13;

      end;
      per cases by A55;
      suppose
        i <= len (q0 ^ FlattenSeq pp0);
        hence thesis by A22;
      end;
      suppose
A58:    c1 + 1 <= i & i <= c2;
        then c1 + 1 - c1 <= i - c1 by XREAL_1:11;
        then reconsider ii = i - c1 as Element of NAT by INT_1:16;
        i - c1 <= c2 - c1 by A58,XREAL_1:11;
        then  i = IC Comput(ProgramPart(s),s,c1+ii)by A38,A52;
        hence thesis;
      end;
      suppose
A59:    c2 + 1 <= i & i <= c2 + len aSeq(a2,pr1);
        then c2 + 1 - c2 <= i - c2 by XREAL_1:11;
        then reconsider ii = i - c2 as Element of NAT by INT_1:16;
        i - c2 <= c2 + len aSeq(a2,pr1) - c2 by A59,XREAL_1:11;
        hence  i = IC Comput(ProgramPart(s),s,c2+ii)by A51
          .= IC Comput(ProgramPart(s),s,i);
      end;
    end;

Y:  (ProgramPart Comput(ProgramPart(s),s,c3))/.IC Comput(ProgramPart(s),s,c3)
 = Comput(ProgramPart(s),s,c3).IC Comput(ProgramPart(s),s,c3) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),Comput(ProgramPart(s),s,c3
))
     = Comput(ProgramPart(s),s,c3).IC Comput(ProgramPart(s),s,c3)
    by AMI_1:def 16,Y

      .= Comput(ProgramPart(s),s,c3). c3 by A44,A53,A29
      .= q.(c3 + 1) by A7,A44,A43

      .= (q0 ^ FlattenSeq pp0 ^ x).(c3 + 1) by A42,A44,A31,A28,A25,FINSEQ_4:98

      .= (q0 ^ FlattenSeq pp0 ^ x).(c1 + len aSeq(a1,r1) + len aSeq(a2,pr1)
    + len <* (f,a1):=a2 *>) by A39,FINSEQ_1:57

      .= (q0 ^ FlattenSeq pp0 ^ x).(c1 + (len aSeq(a1,r1) + (len aSeq(a2,pr1
    ) + len <* (f,a1):=a2 *>)))

      .= (q0 ^ FlattenSeq pp0 ^ x).(c1 + len x) by A20,A23,Lm3
      .= x.len x by A40,FINSEQ_1:86;

    then
A60: CurInstr(ProgramPart Comput(ProgramPart(s),s,c3),Comput(ProgramPart(s),s,
c3))
 = (aSeq(a1,r1) ^ aSeq(a2,pr1) ^ <* (f,a1)

:=a2 *>). (len (aSeq(a1,r1) ^ aSeq(a2,pr1)) + len <* (f,a1):= a2 *>) by A20,A23
,FINSEQ_1:35

      .= <* (f,a1):=a2 *>.len <* (f,a1):=a2 *> by A41,FINSEQ_1:86
      .= <* (f,a1):=a2 *>.1 by FINSEQ_1:57
      .= (f,a1):=a2 by FINSEQ_1:57;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,c3)
by AMI_1:144;
    Comput(ProgramPart(s),s,c3+1) =
    Following(ProgramPart s,Comput(ProgramPart(s),s,
c3))
     by AMI_1:14
      .= Exec((f,a1):=a2, Comput(ProgramPart(s),s,c3)) by A60,AMI_1:def 18,T;

    then
A61: IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp1)) = Exec((f,a1):=a2,
    Comput(ProgramPart(s),s,c3)).IC SCM+FSA by A44,A28,AMI_1:def 15

      .= succ IC Comput(ProgramPart(s),s,c3) by SCMFSA_2:99
      .= succ  c3 by A44,A53,A29;

    thus for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp1) holds IC
    Comput(ProgramPart(s),s,i) =  i

    proof
      let i be Element of NAT;
      assume
A62:  i <= len (q0 ^ FlattenSeq pp1);
      per cases by A62,XXREAL_0:1;
      suppose
        i < len (q0 ^ FlattenSeq pp1);
        hence thesis by A53;
      end;
      suppose
        i = len (q0 ^ FlattenSeq pp1);
        hence thesis by A44,A28,A61,NAT_1:39;
      end;
    end;
  end;
  set k = len aSeq(a1,len p);
A63: len q0 = k + 1 by FINSEQ_2:19;

  q = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *> ^ (aSeq(f,p) ^ <* halt
  SCM+FSA *>) by FINSEQ_1:45

    .= aSeq(a1,len p) ^ (<* f :=<0,...,0> a1 *> ^ (aSeq(f,p) ^ <* halt
  SCM+FSA *>)) by FINSEQ_1:45;

  then
A64: Load aSeq(a1,len p) c= (f := p) by A2,SCMFSA_7:31;
A65: P[{}]
  proof
    assume
    {} c= pp;
    take <*>(D*);
    thus <*>(D*) = {};
A66: 1 <= len q0 by A63,NAT_1:11;

A67: q = aSeq(a1,len p) ^ <* f :=<0,...,0> a1 *> ^ (aSeq(f,p) ^ <* halt
    SCM+FSA *>) by FINSEQ_1:45;

    then len q = len q0 + len ((aSeq(f,p) ^ <* halt SCM+FSA *>)) by FINSEQ_1:35
;

    then len q0 <= len q by NAT_1:11;
    then
A68: k < len q by A63,NAT_1:13;
A69: now
      let i be Element of NAT such that
A70:  i < len q0;
      i < len q0 implies i <= len aSeq(a1,len p) by A63,NAT_1:13;

      hence IC Comput(ProgramPart(s),s,i) =  i by A1,A3,A64,A70,Lm6,XBOOLE_1:1;

    end;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
    k < len q0 by A63,NAT_1:13;
    then
A71: IC Comput(ProgramPart(s),s,k) =  k by A69;

    then
A72: CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s),s,k)
)
 = ( Comput(ProgramPart(s),s,k)). k by AMI_1:def 16,Y

      .= q.len q0 by A63,A7,A68
      .= q0.len q0 by A67,A66,FINSEQ_1:85
      .= f:=<0,...,0>a1 by A63,FINSEQ_1:59;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:144;
A73: Comput(ProgramPart(s),s,len q0) =
Following(ProgramPart s,Comput(ProgramPart(s),s,k))
 by A63,AMI_1:14
      .= Exec(f:=<0,...,0>a1, Comput(ProgramPart(s),s,k))
      by A72,AMI_1:def 18,T;

A74: IC Comput(ProgramPart(s),s,len q0) = Comput(ProgramPart(s),s,len q0).IC
SCM+FSA by
AMI_1:def 15

      .= succ IC Comput(ProgramPart(s),s,k) by A73,SCMFSA_2:101
      .=  len q0 by A63,A71,NAT_1:39;
A75: now
      let i be Element of NAT;
      assume
      i <= len q0;
      then i < len q0 or i = len q0 by XXREAL_0:1;
      hence IC Comput(ProgramPart(s),s,i) =  i by A69,A74;
    end;
    q0 ^ FlattenSeq <*>(D*) = q0 ^ <*>D by PRE_POLY:2
      .= q0 by FINSEQ_1:47;
    hence thesis by A75;
  end;
Y:  (ProgramPart Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)))/.
IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp))
 = Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)).
 IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)) by AMI_1:150;
TX: ProgramPart s =
 ProgramPart Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp))
by AMI_1:144;
  for r being FinSequence holds P[r] from FINSEQ_1:sch 3(A65,A15);

  then ex pp0 being FinSequence of D* st pp0 = pp & for i being Element of NAT
  st i <= len (q0 ^ FlattenSeq pp0) holds IC Comput(ProgramPart(s),s,i) =  i;

  then IC Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)) =  len (q0 ^
  FlattenSeq pp);

  then CurInstr(ProgramPart s,
      Comput(ProgramPart(s),s,len (q0 ^ FlattenSeq pp)))
   = ( Comput(ProgramPart(s),s,len
  (q0 ^ FlattenSeq pp)).  len (q0 ^ FlattenSeq pp)) by AMI_1:def 16,Y,TX

    .= q.(len (q0 ^ FlattenSeq pp) + 1) by A7,A11
    .= halt SCM+FSA by A10,FINSEQ_1:59;
  hence thesis by AMI_1:146;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> initial NAT-defined;
  coherence
  proof
    f := p = Load (aSeq(intloc 1,len p) ^ <* f :=<0,...,0> intloc 1 *> ^
    aSeq(f,p) ^ <* halt SCM+FSA *> ) by SCMFSA_7:def 5;
    hence thesis;
  end;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> parahalting;
  correctness
  proof
    now
A1:   IC SCM+FSA in dom ((f := p) +* Start-At( 0,SCM+FSA))
 by SF_MASTR:65;
      let s be State of SCM+FSA;
      assume
A2:   (f := p) +* Start-At( 0,SCM+FSA) c= s;
      IC s = s.IC SCM+FSA by AMI_1:def 15
        .= ((f := p) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
         by A2,A1,GRFUNC_1:8
        .= 0 by SF_MASTR:66;
      hence ProgramPart s halts_on s by A2,Lm7,SCMFSA6B:5;
    end;
    then (f := p) +* Start-At( 0,SCM+FSA) is halting by AMI_1:def 26;
    hence thesis by SCMFSA6B:def 3;
  end;
end;

theorem
  for s being State of SCM+FSA, f being FinSeq-Location, p being
  FinSequence of INT holds IExec(f := p,s).f = p & (for a being read-write
Int-Location st a <> intloc 1 & a <> intloc 2 holds IExec(f := p,s).a = s.a) &
  for g being FinSeq-Location st g <> f holds IExec(f := p,s).g = s.g
proof
  let s be State of SCM+FSA;
  let f be FinSeq-Location;
  let p be FinSequence of INT;
A1: IExec((f := p),s) = Result(ProgramPart(s+*Initialized(f:=p)),s+*Initialized
(f:=p)) +* s | A by SCMFSA6B:def 1
;
  intloc 0 in dom Initialized (f := p) by SCMFSA6A:45;
  then
A2: (s+*Initialized(f:=p)).intloc 0 = (Initialized (f := p)).intloc 0 by
FUNCT_4:14
    .= 1 by SCMFSA6A:46;
  IC SCM+FSA in dom Initialized (f := p) by SCMFSA6A:24;
  then
  (s+*Initialized(f:=p)).IC SCM+FSA = (Initialized (f := p)).IC SCM+FSA by
FUNCT_4:14
    .= 0 by SCMFSA6A:46;
  then
A3: IC (s+*Initialized(f:=p)) = 0 by AMI_1:def 15;
  Initialized (f := p) c= s+*Initialized(f:=p) & (f := p) c= Initialized (
  f := p) by FUNCT_4:26,SCMFSA6A:26;
  then
A4: (f := p) c= s+*Initialized(f:=p) by XBOOLE_1:1;
  not f in A by SCMFSA_2:85;
  then not f in dom s /\ A by XBOOLE_0:def 4;
  then not f in dom (s | A) by RELAT_1:90;
  hence IExec((f := p),s).f = (Result(ProgramPart(s+*Initialized(f:=p)),s+*
Initialized(f:=p))).f by A1,FUNCT_4:12
    .= p by A3,A2,A4,Lm4;
  hereby
    let a be read-write Int-Location;
    assume
A6: a <> intloc 1 & a <> intloc 2;
A7: not a in dom Initialized (f := p) by SCMFSA6A:48;
    not a in A by SCMFSA_2:84;
    then not a in dom s /\ A by XBOOLE_0:def 4;
    then not a in dom (s | A) by RELAT_1:90;
    hence IExec((f := p),s).a = (Result(ProgramPart(s+*Initialized(f:=p)),s+*
Initialized(f:=p))).a by A1,
FUNCT_4:12
      .= (s+*Initialized(f:=p)).a by A3,A2,A4,A6,Lm4
      .= s.a by A7,FUNCT_4:12;
  end;
  let g be FinSeq-Location;
  assume
A9: g <> f;
A10: not g in dom Initialized (f := p) by SCMFSA6A:49;
  not g in A by SCMFSA_2:85;
  then not g in dom s /\ A by XBOOLE_0:def 4;
  then not g in dom (s | A) by RELAT_1:90;
  hence IExec((f := p),s).g = (Result(ProgramPart(s+*Initialized(f:=p)),s+*
Initialized(f:=p))).g by A1,FUNCT_4:12
    .= (s+*Initialized(f:=p)).g by A3,A2,A4,A9,Lm4
    .= s.g by A10,FUNCT_4:12;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i does_not_refer a means
  for b being Int-Location for l being
Element of NAT for f being FinSeq-Location holds b := a <> i &
  AddTo(b,a) <> i & SubFrom(b,a) <> i & MultBy(b,a) <> i & Divide(b,a) <> i &
Divide(a,b) <> i & a =0_goto l <> i & a >0_goto l <> i & b :=(f,a) <> i & (f,b)
  := a <> i & (f,a):= b <> i & f :=<0,...,0> a <> i;
end;

definition
  let I be preProgram of SCM+FSA;
  let a be Int-Location;
  pred I does_not_refer a means
  for i being Instruction of SCM+FSA st i in rng
  I holds i does_not_refer a;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i does_not_destroy a means
  :Def3:
  for b being Int-Location for f being
  FinSeq-Location holds a := b <> i & AddTo(a,b) <> i & SubFrom(a,b) <> i &
  MultBy(a,b) <> i & Divide(a,b) <> i & Divide(b,a) <> i & a :=(f,b) <> i & a
  :=len f <> i;
end;

definition
  let I be FinPartState of SCM+FSA;
  let a be Int-Location;
  pred I does_not_destroy a means
  :Def4:
  for i being Instruction of SCM+FSA st
  i in rng I holds i does_not_destroy a;
end;

definition
  let I be FinPartState of SCM+FSA;
  attr I is good means
  :Def5:
  I does_not_destroy intloc 0;
end;

registration
  cluster halt-free good Program of SCM+FSA;
  existence
  proof
    set I = Load (<*>(the Instructions of SCM+FSA));
A1: card I = len <*>(the Instructions of SCM+FSA) by SCMFSA_7:25
      .= 0;
    now
      let i be Instruction of SCM+FSA;
      assume that
A2:   i in rng I and
      not i does_not_destroy intloc 0;
      consider x being set such that
A3:   x in dom I and
      I.x = i by A2,FUNCT_1:def 5;
      dom I c= A by RELAT_1:def 18;
      then reconsider x as Element of NAT by A3;
      reconsider k = x as Element of NAT;
      x =  k;
      hence contradiction by A1,A3,AFINSQ_1:70;
    end;
    then I does_not_destroy intloc 0 by Def4;
    then
A4: I is good by Def5;
    now
      assume
      halt SCM+FSA in rng I;
      then consider x being set such that
A5:   x in dom I and
      I.x = halt SCM+FSA by FUNCT_1:def 5;
      dom I c= A by RELAT_1:def 18;
      then reconsider x as Element of NAT by A5;
      reconsider k = x as Element of NAT;
      x =  k;
      hence contradiction by A1,A5,AFINSQ_1:70;
    end;
    then I is halt-free by AMI_1:def 12;
    hence thesis by A4;
  end;
end;

theorem Th11:
  for a being Int-Location holds halt SCM+FSA does_not_destroy a
proof
  let a be Int-Location;
  for b be Int-Location for l be Element of NAT for f be
  FinSeq-Location holds a := b <> halt SCM+FSA & AddTo(a,b) <> halt SCM+FSA &
  SubFrom(a,b) <> halt SCM+FSA & MultBy(a,b) <> halt SCM+FSA & Divide(a,b) <>
  halt SCM+FSA & Divide(b,a) <> halt SCM+FSA & a :=(f,b) <> halt SCM+FSA & a
  :=len f <> halt SCM+FSA by SCMFSA_2:42,43,44,45,46,50,52,124;
  hence thesis by Def3;
end;

theorem Th12:
  for a,b,c being Int-Location holds a <> b implies b := c
  does_not_destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
    thus a := e <> b := c by A1,SF_MASTR:5;
A2: InsCode (b := c) = 1 by SCMFSA_2:42;
    hence AddTo(a,e) <> b := c by SCMFSA_2:43;
    thus SubFrom(a,e) <> b := c by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> b := c by A2,SCMFSA_2:45;
    thus Divide(a,e) <> b := c & Divide(e,a) <> b := c by A2,SCMFSA_2:46;
    thus a :=(f,e) <> b := c by A2,SCMFSA_2:50;
    thus a :=len f <> b := c by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem Th13:
  for a,b,c being Int-Location holds a <> b implies AddTo(b,c)
  does_not_destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode AddTo(b,c) = 2 by SCMFSA_2:43;
    hence a := e <> AddTo(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> AddTo(b,c) by A1,SF_MASTR:6;
    thus SubFrom(a,e) <> AddTo(b,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> AddTo(b,c) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> AddTo(b,c) & Divide(e,a) <> AddTo(b,c) by A2,
SCMFSA_2:46;
    thus a :=(f,e) <> AddTo(b,c) by A2,SCMFSA_2:50;
    thus a :=len f <> AddTo(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem Th14:
  for a,b,c being Int-Location holds a <> b implies SubFrom(b,c)
  does_not_destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode SubFrom(b,c) = 3 by SCMFSA_2:44;
    hence a := e <> SubFrom(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> SubFrom(b,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> SubFrom(b,c) by A1,SF_MASTR:7;
    thus MultBy(a,e) <> SubFrom(b,c) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> SubFrom(b,c) & Divide(e,a) <> SubFrom(b,c) by A2,
SCMFSA_2:46;
    thus a :=(f,e) <> SubFrom(b,c) by A2,SCMFSA_2:50;
    thus a :=len f <> SubFrom(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location holds a <> b implies MultBy(b,c)
  does_not_destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode MultBy(b,c) = 4 by SCMFSA_2:45;
    hence a := e <> MultBy(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> MultBy(b,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> MultBy(b,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> MultBy(b,c) by A1,SF_MASTR:8;
    thus Divide(a,e) <> MultBy(b,c) & Divide(e,a) <> MultBy(b,c) by A2,
SCMFSA_2:46;
    thus a :=(f,e) <> MultBy(b,c) by A2,SCMFSA_2:50;
    thus a :=len f <> MultBy(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location holds a <> b & a <> c implies Divide(b,c)
  does_not_destroy a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b & a <> c;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let h be FinSeq-Location;
A2: InsCode Divide(b,c) = 5 by SCMFSA_2:46;
    hence a := e <> Divide(b,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> Divide(b,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> Divide(b,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> Divide(b,c) by A2,SCMFSA_2:45;
    thus Divide(e,a) <> Divide(b,c) & Divide(a,e) <> Divide(b,c) by A1,
SF_MASTR:9;
    thus a := (h,e) <> Divide(b,c) by A2,SCMFSA_2:50;
    thus a :=len h <> Divide(b,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a being Int-Location, l being Element of NAT
  holds goto l does_not_destroy a
proof
  let a be Int-Location;
  let l be Element of NAT;
  now
    let b be Int-Location;
    let r be Element of NAT;
    let f be FinSeq-Location;
A1: InsCode goto l = 6 by SCMFSA_2:47;
    hence a := b <> goto l by SCMFSA_2:42;
    thus AddTo(a,b) <> goto l by A1,SCMFSA_2:43;
    thus SubFrom(a,b) <> goto l by A1,SCMFSA_2:44;
    thus MultBy(a,b) <> goto l by A1,SCMFSA_2:45;
    thus Divide(a,b) <> goto l & Divide(b,a) <> goto l by A1,SCMFSA_2:46;
    thus a :=(f,b) <> goto l by A1,SCMFSA_2:50;
    thus a :=len f <> goto l by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, l being Element of NAT
  holds b =0_goto l does_not_destroy a
proof
  let a,b be Int-Location;
  let l be Element of NAT;
  now
    let e be Int-Location;
    let f be FinSeq-Location;
A1: InsCode (b =0_goto l) = 7 by SCMFSA_2:48;
    hence a := e <> b =0_goto l by SCMFSA_2:42;
    thus AddTo(a,e) <> b =0_goto l by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> b =0_goto l by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> b =0_goto l by A1,SCMFSA_2:45;
    thus Divide(a,e) <> b =0_goto l & Divide(e,a) <> b =0_goto l by A1,
SCMFSA_2:46;
    thus a :=(f,e) <> b =0_goto l by A1,SCMFSA_2:50;
    thus a :=len f <> b =0_goto l by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, l being Element of NAT
  holds b >0_goto l does_not_destroy a
proof
  let a,b be Int-Location;
  let l be Element of NAT;
  now
    let e be Int-Location;
    let f be FinSeq-Location;
A1: InsCode (b >0_goto l) = 8 by SCMFSA_2:49;
    hence a := e <> b >0_goto l by SCMFSA_2:42;
    thus AddTo(a,e) <> b >0_goto l by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> b >0_goto l by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> b >0_goto l by A1,SCMFSA_2:45;
    thus Divide(a,e) <> b >0_goto l & Divide(e,a) <> b >0_goto l by A1,
SCMFSA_2:46;
    thus a :=(f,e) <> b >0_goto l by A1,SCMFSA_2:50;
    thus a :=len f <> b >0_goto l by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location, f being FinSeq-Location holds a <> b
  implies b := (f,c) does_not_destroy a
proof
  let a,b,c be Int-Location;
  let f be FinSeq-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let h be FinSeq-Location;
A2: InsCode (b := (f,c)) = 9 by SCMFSA_2:50;
    hence a := e <> b := (f,c) by SCMFSA_2:42;
    thus AddTo(a,e) <> b := (f,c) by A2,SCMFSA_2:43;
    thus SubFrom(a,e) <> b := (f,c) by A2,SCMFSA_2:44;
    thus MultBy(a,e) <> b := (f,c) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> b := (f,c) & Divide(e,a) <> b := (f,c) by A2,
SCMFSA_2:46;
    thus a := (h,e) <> b := (f,c) by A1,SF_MASTR:13;
    thus a :=len h <> b := (f,c) by A2,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b,c being Int-Location, f being FinSeq-Location holds (f,c):= b
  does_not_destroy a
proof
  let a,b,c be Int-Location;
  let f be FinSeq-Location;
  now
    let e be Int-Location;
    let h be FinSeq-Location;
A1: InsCode ((f,c) := b) = 10 by SCMFSA_2:51;
    hence a := e <> (f,c) := b by SCMFSA_2:42;
    thus AddTo(a,e) <> (f,c) := b by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> (f,c) := b by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> (f,c) := b by A1,SCMFSA_2:45;
    thus Divide(e,a) <> (f,c) := b & Divide(a,e) <> (f,c) := b by A1,
SCMFSA_2:46;
    thus a := (h,e) <> (f,c) := b by A1,SCMFSA_2:50;
    thus a :=len h <> (f,c) := b by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, f being FinSeq-Location holds a <> b
  implies b :=len f does_not_destroy a
proof
  let a,b be Int-Location;
  let f be FinSeq-Location;
  assume
A1: a <> b;
  now
    let c be Int-Location;
    let g be FinSeq-Location;
A2: InsCode (b :=len f) = 11 by SCMFSA_2:52;
    hence a := c <> b :=len f by SCMFSA_2:42;
    thus AddTo(a,c) <> b :=len f by A2,SCMFSA_2:43;
    thus SubFrom(a,c) <> b :=len f by A2,SCMFSA_2:44;
    thus MultBy(a,c) <> b :=len f by A2,SCMFSA_2:45;
    thus Divide(a,c) <> b :=len f & Divide(c,a) <> b :=len f by A2,SCMFSA_2:46;
    thus a :=(g,c) <> b :=len f by A2,SCMFSA_2:50;
    thus a :=len g <> b :=len f by A1,SF_MASTR:15;
  end;
  hence thesis by Def3;
end;

theorem
  for a,b being Int-Location, f being FinSeq-Location holds f
  :=<0,...,0> b does_not_destroy a
proof
  let a,b be Int-Location;
  let f be FinSeq-Location;
  now
    let e be Int-Location;
    let h be FinSeq-Location;
A1: InsCode (f :=<0,...,0> b) = 12 by SCMFSA_2:53;
    hence a := e <> f :=<0,...,0> b by SCMFSA_2:42;
    thus AddTo(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:43;
    thus SubFrom(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:44;
    thus MultBy(a,e) <> f :=<0,...,0> b by A1,SCMFSA_2:45;
    thus Divide(a,e) <> f :=<0,...,0> b & Divide(e,a) <> f :=<0,...,0> b by A1,
SCMFSA_2:46;
    thus a :=(h,e) <> f :=<0,...,0> b by A1,SCMFSA_2:50;
    thus a :=len h <> f :=<0,...,0> b by A1,SCMFSA_2:52;
  end;
  hence thesis by Def3;
end;

definition
  canceled;
  let I be FinPartState of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_on s means
  :Def7:
  for k being Element of NAT holds IC
  Comput(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,
SCM+FSA)),k) in dom I;
  pred I is_halting_on s means
  :Def8:
  ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (I +* Start-At( 0,SCM+FSA));
end;

theorem Th24:
  for I being Program of SCM+FSA holds I is paraclosed iff for s
  being State of SCM+FSA holds I is_closed_on s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is paraclosed;
    let s be State of SCM+FSA;
    I +* Start-At( 0,SCM+FSA) c= s +* (I +* Start-At( 0,SCM+FSA))
     by FUNCT_4:26;
    then for k being Element of NAT holds IC Comput(ProgramPart(s +* (I +*
Start-At(
     0,SCM+FSA))),s +* (I +* Start-At(
     0,SCM+FSA)),k) in dom I by A1,SCMFSA6B:def 2;
    hence I is_closed_on s by Def7;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_closed_on s;
  now
    let s be State of SCM+FSA;
    let k be Element of NAT;
    assume
    I +* Start-At( 0,SCM+FSA) c= s;
    then
A3: s = s +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
    I is_closed_on s by A2;
    hence IC Comput(ProgramPart(s),s,k) in dom I by A3,Def7;
  end;
  hence thesis by SCMFSA6B:def 2;
end;

theorem
  for I being Program of SCM+FSA holds I is parahalting iff for s being
  State of SCM+FSA holds I is_halting_on s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is parahalting;
    let s be State of SCM+FSA;
    I +* Start-At( 0,SCM+FSA) c= s +* (I +* Start-At( 0,SCM+FSA))
     & I +*
    Start-At( 0,SCM+FSA) is halting by A1,FUNCT_4:26,SCMFSA6B:def 3;
    then ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (I +* Start-At( 0,SCM+FSA)) by AMI_1:def 26;
    hence I is_halting_on s by Def8;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_halting_on s;
  now
    let s be State of SCM+FSA;
    assume
    I +* Start-At( 0,SCM+FSA) c= s;
    then
A3: s = s +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
    I is_halting_on s by A2;
    hence ProgramPart s halts_on s by A3,Def8;
  end;
  then I +* Start-At( 0,SCM+FSA) is halting by AMI_1:def 26;
  hence thesis by SCMFSA6B:def 3;
end;

theorem Th26:
  for i being Instruction of SCM+FSA, a being Int-Location, s
  being State of SCM+FSA holds i does_not_destroy a implies Exec(i,s).a = s.a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  let s be State of SCM+FSA;
  assume
A1: i does_not_destroy a;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by AMI_1:def 8;
  end;
  suppose
    InsCode i = 1;
    then consider da,db being Int-Location such that
A5: i = da := db by SCMFSA_2:54;
    da <> a by A1,A5,Def3;
    hence thesis by A5,SCMFSA_2:89;
  end;
  suppose
    InsCode i = 2;
    then consider da, db being Int-Location such that
A6: i = AddTo(da,db) by SCMFSA_2:55;
    da <> a by A1,A6,Def3;
    hence thesis by A6,SCMFSA_2:90;
  end;
  suppose
    InsCode i = 3;
    then consider da, db being Int-Location such that
A7: i = SubFrom(da, db) by SCMFSA_2:56;
    da <> a by A1,A7,Def3;
    hence thesis by A7,SCMFSA_2:91;
  end;
  suppose
    InsCode i = 4;
    then consider da, db being Int-Location such that
A8: i = MultBy(da,db) by SCMFSA_2:57;
    da <> a by A1,A8,Def3;
    hence thesis by A8,SCMFSA_2:92;
  end;
  suppose
    InsCode i = 5;
    then consider da, db being Int-Location such that
A9: i = Divide(da, db) by SCMFSA_2:58;
    da <> a & db <> a by A1,A9,Def3;
    hence thesis by A9,SCMFSA_2:93;
  end;
  suppose
    InsCode i = 6;
    then ex loc being Element of NAT st i = goto loc by
SCMFSA_2:59;
    hence thesis by SCMFSA_2:95;
  end;
  suppose
    InsCode i = 7;
    then
    ex loc being Element of NAT, da being Int-Location st
    i = da=0_goto loc by SCMFSA_2:60;
    hence thesis by SCMFSA_2:96;
  end;
  suppose
    InsCode i = 8;
    then
    ex loc being Element of NAT, da being Int-Location st
    i = da>0_goto loc by SCMFSA_2:61;
    hence thesis by SCMFSA_2:97;
  end;
  suppose
    InsCode i = 9;
    then consider db, da being Int-Location, g being FinSeq-Location such that
A10: i = da := (g,db) by SCMFSA_2:62;
    da <> a by A1,A10,Def3;
    hence thesis by A10,SCMFSA_2:98;
  end;
  suppose
    InsCode i = 10;
    then ex db, da being Int-Location, g being FinSeq-Location st i = (g,db):=
    da by SCMFSA_2:63;
    hence thesis by SCMFSA_2:99;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, g being FinSeq-Location such that
A11: i = da :=len g by SCMFSA_2:64;
    da <> a by A1,A11,Def3;
    hence thesis by A11,SCMFSA_2:100;
  end;
  suppose
    InsCode i = 12;
    then
    ex da being Int-Location, g being FinSeq-Location st i = g :=<0,...,0>
    da by SCMFSA_2:65;
    hence thesis by SCMFSA_2:101;
  end;
end;

theorem Th27:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_destroy a & I is_closed_on s holds for k being
  Element of NAT holds Comput(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s
+* (I +* Start-At( 0,SCM+FSA)),k).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
  defpred P[Nat] means
   Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA)
),$1).a
  = s.a;
  dom I misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
  then
  I +* Start-At( 0,SCM+FSA) c= s+*(I+*Start-At( 0,SCM+FSA))
   & I c= I +* Start-At(
   0,SCM+FSA) by FUNCT_4:26,33;
  then
A2: I c= s+*(I+*Start-At( 0,SCM+FSA)) by XBOOLE_1:1;
  assume
A3: I is_closed_on s;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    set l = IC Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At
( 0,SCM+FSA)),k);
A6: l in dom I by A3,Def7;
    then (s+*(I+*Start-At( 0,SCM+FSA))).l = I.l by A2,GRFUNC_1:8;
    then (s+*(I+*Start-At( 0,SCM+FSA))).l in rng I by A6,FUNCT_1:def 5;
    then
A7: (s+*(I+*Start-At( 0,SCM+FSA))).l does_not_destroy a by A1,Def4;
Y:  (ProgramPart Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*
Start-At( 0,SCM+FSA)),k))/.
IC Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA)
),k)
 = Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA)
),k).
 IC Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA
)),k) by AMI_1:150;
T: ProgramPart ((s+*(I+*Start-At( 0,SCM+FSA)))) =
ProgramPart Comput(ProgramPart((s+*(I+*Start-At( 0,SCM+FSA)))),
(s+*(I+*Start-At( 0,SCM+FSA))),k)
by AMI_1:144;
    Comput(ProgramPart((s+*(I+*Start-At( 0,SCM+FSA)))),(s+*(I+*Start-At( 0,
SCM+FSA))),k + 1).a =
     (Following(ProgramPart ((s+*(I+*Start-At( 0,SCM+FSA)))),
     Comput(ProgramPart((s+*(I+*Start-At( 0,SCM+FSA)))),(s+*(I+*Start-At( 0,
SCM+FSA))),k))).a
      by AMI_1:14
      .= Exec(CurInstr(
       ProgramPart Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*
Start-At( 0,SCM+FSA)),k),
          Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,
SCM+FSA)),k)),
       Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,
SCM+FSA)),k)).a by AMI_1:def 18,T
      .= Exec(Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At(
0,SCM+FSA)),k).l,
       Comput(ProgramPart(s+*(I
    +*Start-At( 0,SCM+FSA))),s+*(I
    +*Start-At( 0,SCM+FSA)),k)).a by AMI_1:def 16,Y
      .= Exec( (s+*(I+*Start-At( 0,SCM+FSA))).l,
       Comput(ProgramPart(s+*(I+*Start-At(
     0,SCM+FSA))),s+*(I+*Start-At(
     0,SCM+FSA)),k)).a by AMI_1:54
      .= s.a by A5,A7,Th26;
    hence P[k+1];
  end;
A8: not a in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  Comput(ProgramPart(s+*(I+*Start-At( 0,SCM+FSA))),s+*(I+*Start-At( 0,SCM+FSA))
,0).a =
   (s+*(I+*Start-At( 0,SCM+FSA)))
  .a by AMI_1:13
    .= s.a by A8,FUNCT_4:12;
  then
A9: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A9, A4);
end;

registration
  cluster Stop SCM+FSA -> parahalting good;
  coherence
   proof
    thus Stop SCM+FSA is parahalting
proof
  now
    dom Stop SCM+FSA misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
    then
A1: Stop SCM+FSA c= Stop SCM+FSA +* Start-At( 0,SCM+FSA) by FUNCT_4:33;

A2: dom Stop SCM+FSA c= dom (Stop SCM+FSA +* Start-At( 0,SCM+FSA))
 by FUNCT_4:11;
A3:  0 in dom Stop SCM+FSA by AFINSQ_1:69;
A4: IC SCM+FSA in dom (Stop SCM+FSA +* Start-At( 0,SCM+FSA))
 by SF_MASTR:65;
    let s be State of SCM+FSA;
    assume
A5: Stop SCM+FSA +* Start-At( 0,SCM+FSA) c= s;
Z:  (ProgramPart s)/.IC s
 = s.IC s by AMI_1:150;
u: Comput(ProgramPart(s),s,0) =
  s by AMI_1:13;
    CurInstr(ProgramPart s,Comput(ProgramPart(s),s,0))
     = CurInstr(ProgramPart s,s) by u
      .= s.IC s by AMI_1:def 16,Z
      .= s.(s.IC SCM+FSA) by AMI_1:def 15

      .= s.((Stop SCM+FSA +* Start-At( 0,SCM+FSA)).IC SCM+FSA)
       by A5,A4,GRFUNC_1:8

      .= s. 0 by SF_MASTR:66
      .= (Stop SCM+FSA +* Start-At( 0,SCM+FSA)). 0
       by A5,A2,A3,GRFUNC_1:8
      .= (Stop SCM+FSA). 0 by A1,A3,GRFUNC_1:8
      .= halt SCM+FSA by AFINSQ_1:38;
    hence ProgramPart s halts_on s by AMI_1:146;
  end;
  then Stop SCM+FSA +* Start-At( 0,SCM+FSA) is halting by AMI_1:def 26;
  hence thesis by SCMFSA6B:def 3;
end;
   thus Stop SCM+FSA does_not_destroy intloc 0
proof
  now
    let i be Instruction of SCM+FSA;
A1: rng Stop SCM+FSA = {halt SCM+FSA} by AFINSQ_1:36;
    assume
    i in rng Stop SCM+FSA;
    then i = halt SCM+FSA by A1,TARSKI:def 1;
    hence i does_not_destroy intloc 0 by Th11;
  end;
  hence thesis by Def4;
end;
   end;
end;

registration
  cluster parahalting good Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster paraclosed good -> keeping_0 Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed good;
    then
A2: I does_not_destroy intloc 0 by Def5;
    now
      let s be State of SCM+FSA;
      assume
      I +* Start-At( 0,SCM+FSA) c= s;
      then
A3:   s +* (I +* Start-At( 0,SCM+FSA)) = s by FUNCT_4:79;
      let k be Element of NAT;
      I is_closed_on s by A1,Th24;
      hence Comput(ProgramPart(s),s,k).intloc 0 = s.intloc 0 by A2,A3,Th27;
    end;
    hence thesis by SCMFSA6B:def 4;
  end;
end;

canceled;

theorem Th29:
  for a being Int-Location, k being Integer holds rng aSeq(a,k) c=
  {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
proof
  let a be Int-Location;
  let k be Integer;
  now
    let x be set;
    assume
A1: x in rng aSeq(a,k);
    per cases;
    suppose
A2:   k > 0 & k = 0 + 1;
      then
      ex k1 being Element of NAT st k1 + 1 = k & aSeq(a,k) = <* a := intloc
      0 *> ^ (k1 |-> AddTo(a,intloc 0)) by SCMFSA_7:def 3;
      then aSeq(a,k) = <* a := intloc 0 *> ^ {} by A2
        .= <* a := intloc 0 *> by FINSEQ_1:47;
      then rng aSeq(a,k) = {a := intloc 0} by FINSEQ_1:55;
      then x = a := intloc 0 by A1,TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
    suppose
A3:   k > 0 & k <> 1;
      then consider k1 being Element of NAT such that
A4:   k1 + 1 = k and
A5:   aSeq(a,k) = <* a := intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0)) by
SCMFSA_7:def 3;
A6:   k1 <> 0 by A3,A4;
      rng aSeq(a,k) = rng <* a := intloc 0 *> \/ rng (k1 |-> AddTo(a,
      intloc 0)) by A5,FINSEQ_1:44
        .= {a := intloc 0} \/ rng (Seg k1 --> AddTo(a,intloc 0)) by FINSEQ_1:55
        .= {a := intloc 0} \/ {AddTo(a,intloc 0)} by A6,FUNCOP_1:14;
      then x in {a := intloc 0} or x in {AddTo(a,intloc 0)} by A1,
XBOOLE_0:def 3;
      then x = a := intloc 0 or x = AddTo(a,intloc 0) by TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
    suppose
A7:   not k > 0;
      then consider k1 being Element of NAT such that
A8:   k1 + k = 1 and
A9:   aSeq(a,k) = <* a := intloc 0 *> ^ (k1 |-> SubFrom(a,intloc 0))
      by SCMFSA_7:def 3;
A10:  k1 <> 0 by A7,A8;
      rng aSeq(a,k) = rng <* a := intloc 0 *> \/ rng (k1 |-> SubFrom(a,
      intloc 0)) by A9,FINSEQ_1:44
        .= {a := intloc 0} \/ rng (Seg k1 --> SubFrom(a,intloc 0)) by
FINSEQ_1:55
        .= {a := intloc 0} \/ {SubFrom(a,intloc 0)} by A10,FUNCOP_1:14;
      then x in {a := intloc 0} or x in {SubFrom(a,intloc 0)} by A1,
XBOOLE_0:def 3;
      then x = a := intloc 0 or x = SubFrom(a,intloc 0) by TARSKI:def 1;
      hence x in {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)} by
ENUMSET1:def 1;
    end;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th30:
  for a being Int-Location, k being Integer holds rng (a := k) c=
  {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
proof
  let a be Int-Location;
  let k be Integer;
  now
    let x be set;
A1: rng aSeq(a,k) c= {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0 )
    } by Th29;
    a := k = Load (aSeq(a,k) ^ <* halt SCM+FSA *>) by SCMFSA_7:33;
    then
A2: rng (a := k) = rng (aSeq(a,k) ^ <* halt SCM+FSA *>) by Th2
      .= rng aSeq(a,k) \/ rng <* halt SCM+FSA *> by FINSEQ_1:44
      .= rng aSeq(a,k) \/ {halt SCM+FSA} by FINSEQ_1:55;
    assume
    x in rng (a := k);
    then x in rng aSeq(a,k) or x in {halt SCM+FSA} by A2,XBOOLE_0:def 3;
    then
    x = a := intloc 0 or x = AddTo(a,intloc 0) or x = SubFrom(a,intloc 0)
    or x = halt SCM+FSA by A1,ENUMSET1:def 1,TARSKI:def 1;
    hence
    x in {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0
    )} by ENUMSET1:def 2;
  end;
  hence thesis by TARSKI:def 3;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> good;
  correctness
  proof
    now
      let i be Instruction of SCM+FSA;
A1:   rng (a := k) c= {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),
      SubFrom(a,intloc 0)} by Th30;
      assume
A2:   i in rng (a := k);
      per cases by A2,A1,ENUMSET1:def 2;
      suppose
        i = halt SCM+FSA;
        hence i does_not_destroy intloc 0 by Th11;
      end;
      suppose
        i = a := intloc 0;
        hence i does_not_destroy intloc 0 by Th12;
      end;
      suppose
        i = AddTo(a,intloc 0);
        hence i does_not_destroy intloc 0 by Th13;
      end;
      suppose
        i = SubFrom(a,intloc 0);
        hence i does_not_destroy intloc 0 by Th14;
      end;
    end;
    then a := k does_not_destroy intloc 0 by Def4;
    hence thesis by Def5;
  end;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> keeping_0;
  correctness;
end;

