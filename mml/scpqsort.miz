:: Quick Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, SCMPDS_4, SCMFSA6A, SCMFSA8A, SCMFSA_7,
      INT_1, SCMFSA8B, CARD_1, SCMPDS_5, FUNCT_1, UNIALG_2, SCMFSA7B, SCMFSA6B,
      FUNCT_4, SCMPDS_3, RELAT_1, AMI_2, SCMFSA_9, ARYTM_1, RELOC, SCM_1,
      FUNCT_7, BOOLE, FUNCOP_1, CARD_3, SCMPDS_8, FINSEQ_1, RFUNCT_2, RFINSEQ,
      FUNCT_2, SCPISORT, SCMP_GCD, SCPQSORT, NAT_1;
 notations TARSKI, XBOOLE_0, FUNCT_2, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0,
      RELAT_1, FUNCT_1, FUNCT_4, RECDEF_1, INT_1, NAT_1, NAT_D, AMI_1, AMI_2,
      AMI_3, AMI_5, FUNCT_7, SCMPDS_2, SCMPDS_3, CARD_1, SCMPDS_4, SCM_1,
      SCMPDS_5, SCMPDS_6, SCMP_GCD, CARD_3, FINSEQ_1, SCMPDS_8, SFMASTR3,
      RFINSEQ, SCPISORT;
 constructors XXREAL_0, NAT_1, RAT_1, RECDEF_1, RFINSEQ, SCM_1, AMI_5,
      SFMASTR3, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT,
      WSIERP_1, SCMPDS_1, MESFUNC1, NAT_D;
 registrations AMI_1, INT_1, FUNCT_1, RELSET_1, FINSEQ_1, SCMPDS_2, SCMFSA_4,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMPDS_8, WSIERP_1, FRAENKEL, XREAL_0,
      NUMBERS, SETFAM_1, XXREAL_0, CARD_3;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMPDS_2, SCMP_GCD;
 theorems AMI_1, AMI_3, NAT_1, REAL_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2,
      FUNCT_7, GRFUNC_1, SCM_1, SCMFSA6B, SCMPDS_4, SCMPDS_5, REAL_2, SCMPDS_6,
      SCMP_GCD, SCMPDS_7, SCMPDS_8, FINSEQ_1, SFMASTR3, FINSEQ_2, RFINSEQ,
      FUNCT_2, FINSEQ_3, RELAT_1, SCPISORT, XBOOLE_0, XBOOLE_1, XREAL_1, AMI_5,
      XXREAL_0;
 schemes NAT_1, SCMPDS_8;

begin :: The Several Properties of "while" Program and Finite Sequence

reserve x for Int_position,
        n,p0 for Element of NAT;

Lm1:
 for s being State of SCMPDS, I,J being shiftable Program-block,
 n being Element of NAT
 holds I ';' Goto n ';' J is shiftable
proof
  let s be State of SCMPDS, I,J be shiftable Program-block,n be Element of NAT;
        I ';' Goto n ';' J = I ';' Load (goto n) ';' J by SCMPDS_6:def 1;
   hence thesis;
end;

registration
   let I,J be shiftable Program-block,
   a be Int_position,k1 be Integer;
   cluster if>0(a,k1,I,J) -> shiftable;
   correctness
   proof
    set i = (a,k1)<=0_goto (card I + 2),
        G =Goto (card J+1);
    reconsider IJ=I ';' G ';' J as shiftable Program-block by Lm1;
         if>0(a,k1,I,J) = i ';' I ';' G ';' J by SCMPDS_6:def 5
     .=i ';' (I ';' G) ';' J by SCMPDS_4:50
     .=i ';' IJ by SCMPDS_4:50
     .=Load i ';' IJ by SCMPDS_4:def 4;
    hence thesis;
  end;
end;

theorem Th1:     :: see SCMPDS_6:87
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 J being shiftable Program-block,a ,b be Int_position,k1 being Integer
 st s.DataLoc(s.a,k1) > 0 & I is_closed_on s & I is_halting_on s
 holds IExec(if>0(a,k1,I,J),s).b = IExec(I,s).b
proof
    let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
    J be shiftable Program-block,a,b be Int_position,k1 be Integer;
    assume s.DataLoc(s.a,k1)>0 & I is_closed_on s & I is_halting_on s;
then A1:  IExec(if>0(a,k1,I,J),s) =
     IExec(I,s) +* Start-At inspos (card I + card J + 2) by SCMPDS_6:84;
         not b in dom Start-At inspos (card I + card J + 2) by SCMPDS_4:59;
    hence IExec(if>0(a,k1,I,J),s).b = IExec(I,s).b by A1,FUNCT_4:12;
end;

set A = the Instruction-Locations of SCMPDS,
    D = SCM-Data-Loc;

Lm2:
 for a be Int_position,i be Integer,I be Program-block holds
   while>0(a,i,I)= ((a,i)<=0_goto (card I +2)) ';' (I ';'
   goto -(card I+1))
proof
   let a be Int_position,i be Integer,I be Program-block;
   set i1=(a,i)<=0_goto (card I +2),
       i2=goto -(card I+1);
   thus while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
       .= i1 ';' (I ';' i2) by SCMPDS_4:51;
end;

Lm3:
 for I being Program-block,a being Int_position,i being Integer
 holds Shift(I,1) c= while>0(a,i,I)
proof
  let I be Program-block,a be Int_position,i be Integer;
   set i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);
A1: card Load i1=1 by SCMPDS_5:6;
         while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
     .= i1 ';' I ';' Load i2 by SCMPDS_4:def 5
     .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
    hence thesis by A1,SCMPDS_7:16;
end;

theorem Th2:
 for s,sm be State of SCMPDS,I be No-StopCode shiftable Program-block,
 a be Int_position,i be Integer, m be Element of NAT
 st card I>0 & I is_closed_on s &
 I is_halting_on s & s.DataLoc(s.a,i) > 0 &
 m=LifeSpan (s +* Initialized stop I)+2 &
 sm=(Computation(s +* Initialized stop while>0(a,i,I))).m holds
 sm | SCM-Data-Loc =IExec(I,s)|SCM-Data-Loc &
 sm +*Initialized stop while>0(a,i,I)=sm
proof
    let s,sm be State of SCMPDS,I be No-StopCode shiftable Program-block,
    a be Int_position,i be Integer,m be Element of NAT;
     set b=DataLoc(s.a,i);
   set WH =while>0(a,i,I),
       iWH=Initialized stop WH,
       IsI=Initialized stop I;
   set i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);
   set s2 = s +* IsI,
       s3 = s +* iWH,
       s4 = (Computation s3).1;

    assume A1: card I>0 & I is_closed_on s & I is_halting_on s & s.b > 0 &
       m=LifeSpan s2+2 & sm=(Computation(s +* iWH)).m;

A2:   IsI c= s2 by FUNCT_4:26;
A3:   s2 is halting by A1,SCMPDS_6:def 3;
      then s2 +* IsI is halting by A2,FUNCT_4:79;
then A4:   I is_halting_on s2 by SCMPDS_6:def 3;
A5:   I is_closed_on s2 by A1,SCMPDS_6:38;
A6:   IC s3 =inspos 0 by SCMPDS_6:21;
           WH = i1 ';' (I ';' i2) by Lm2;
then A7:   CurInstr s3 = i1 by SCMPDS_6:22;
A8:   (Computation s3).(0 + 1) = Following (Computation s3).0 by AMI_1:def 19
      .= Following s3 by AMI_1:def 19
      .= Exec(i1,s3) by A7,AMI_1:def 18;
      A9: s3.DataLoc(s3.a,i)= s3.b by SCMPDS_5:19
      .= s.b by SCMPDS_5:19;
A10:   IC s4 = s4.IC SCMPDS by AMI_1:def 15
      .= Next IC s3 by A1,A8,A9,SCMPDS_2:68
      .= inspos(0+1) by A6,SCMPDS_4:70;
           s2,s3 equal_outside A by SCMPDS_4:36;
then A11:   s2 | D = s3 | D by SCMPDS_4:24;
           now let x;
          thus s2.x = s3.x by A11,SCMPDS_4:23
          .= s4.x by A8,SCMPDS_2:68;
      end;
then A12:   s2 | D = s4 | D by SCMPDS_4:23;
      set m2=LifeSpan s2,
          s5=(Computation s4).m2,
          l1=inspos (card I + 1);

A13:   dom (s | A) = A by SCMPDS_6:1;
           card I + 1 < card I + 2 by XREAL_1:8;
then A14:   l1 in dom WH by SCMPDS_8:18;
A15:   WH c= iWH by SCMPDS_6:17;
           iWH c= s3 by FUNCT_4:26;
then A16:   WH c= s3 by A15,XBOOLE_1:1;
           Shift(I,1) c= WH by Lm3;
      then Shift(I,1) c= s3 by A16,XBOOLE_1:1;
then A17:   Shift(I,1) c= s4 by AMI_3:38;
then (Computation s2).m2 | D = s5 | D by A1,A2,A4,A5,A10,A12,SCMPDS_7:36;
then A18:   s5|D =(Result s2)|D by A3,SCMFSA6B:16
      .= (Result s2 +* s | A)|D by A13,FUNCT_4:76,AMI_5:33
      .=IExec(I,s)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set s6=(Computation s3).m3;
A19:     IC s5=l1 by A1,A2,A4,A5,A10,A12,A17,SCMPDS_7:36;
A20:     s6=s5 by AMI_1:51;
then A21:     CurInstr s6=s5.l1 by A19,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s3.l1 by AMI_1:54
        .=WH.l1 by A14,A16,GRFUNC_1:8
        .=i2 by SCMPDS_8:19;
        set s7=(Computation s3).(m3+ 1);
A22:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A21,AMI_1:def 18;
A23:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,0-(card I+1)) by A22,SCMPDS_2:66
       .=inspos 0 by A19,A20,SCMPDS_7:1;
           now let x;
        thus sm.x=s6.x by A1,A22,SCMPDS_2:66
             .=s5.x by AMI_1:51;
      end;
      hence sm | D =IExec(I,s)|D by A18,SCMPDS_4:23;
      thus sm +* iWH=sm by A1,A23,SCMPDS_7:37;
end;

theorem Th3:
 for s be State of SCMPDS,I be Program-block st
 for t be State of SCMPDS st
  t | SCM-Data-Loc =s | SCM-Data-Loc holds I is_halting_on t
  holds I is_closed_on s
proof
    let s be State of SCMPDS,I be Program-block;
    assume A1: for t be State of SCMPDS st t | D =s | D
               holds I is_halting_on t;
    set pI=stop I,
        II=Initialized pI,
        sI=s +* II;
     defpred X[Element of NAT] means not IC (Computation sI).$1 in dom pI;
    assume not I is_closed_on s;
then A2:  ex k be Element of NAT st X[k] by SCMPDS_6:def 2;
    consider n such that
A3:  X[n] and
A4:  for m be Element of NAT st X[m] holds n <= m from NAT_1:sch 5(A2);
A5:  not Next IC (Computation sI).n in dom pI by A3,SCMPDS_4:71;
   set s2 = (Computation sI).n,
       Ig = ((IC s2,Next IC s2) --> (goto 1, goto -1)),
       s0 = sI +* Ig,
       s1 = s2 +* Ig,
       t1= sI +* (IC s2,goto 1),
       t2= t1 +* (Next IC s2,goto -1),
       t3= s2 +* (IC s2,goto 1),
       t4= t3 +* (Next IC s2,goto -1),
       IL=the Instruction-Locations of SCMPDS;
   set IAt = pI +* Start-At inspos 0;
            dom stop(I) misses dom Start-At inspos 0 by SCMPDS_4:54;
then A6:  pI c= IAt by FUNCT_4:33;
A7:  II = IAt by SCMPDS_4:def 2;
          (IAt) | IL = pI by SCMPDS_4:58;
then A8: dom stop (I) = dom(IAt) /\ IL by RELAT_1:90;
then A9: not IC s2 in dom IAt by A3,XBOOLE_0:def 3;
A10: not Next IC s2 in dom IAt by A5,A8,XBOOLE_0:def 3;
A11:  II c= sI by FUNCT_4:26;
     then IAt c= t1 by A7,A9,FUNCT_7:91;
     then IAt c= t2 by A10,FUNCT_7:91;
then A12: IAt c= s0 by SCMPDS_4:69;
A13: sI,t1 equal_outside IL by FUNCT_7:93;
          t1,t2 equal_outside IL by FUNCT_7:93;
     then sI,t2 equal_outside IL by A13,FUNCT_7:29;
     then A14: sI,s0 equal_outside IL by SCMPDS_4:69;
then A15: s0,sI equal_outside IL by FUNCT_7:28;
A16:  for a be Int_position holds s.a = sI.a by SCMPDS_5:19;
          s0 | D = sI | D by A14,SCMPDS_4:24
     .= s | D by A16,SCMPDS_4:23;
     then I is_halting_on s0 by A1;
then A17:  s0 +* II is halting by SCMPDS_6:def 3;
     A18: s0 +* II=s0 by A7,A12,FUNCT_4:79;
A19: stop I c= s0 by A6,A12,XBOOLE_1:1;
A20: stop I c= sI by A6,A7,A11,XBOOLE_1:1;
          for m be Element of NAT st m < n
          holds IC((Computation sI).m) in dom pI by A4;
then A21: (Computation s0).n,s2 equal_outside IL by A15,A19,A20,SCMPDS_4:67;
A22: s2,t3 equal_outside IL by FUNCT_7:93;
          t3,t4 equal_outside IL by FUNCT_7:93;
     then s2,t4 equal_outside IL by A22,FUNCT_7:29;
     then s2,s1 equal_outside IL by SCMPDS_4:69;
then A23: (Computation s0).n, s1 equal_outside IL by A21,FUNCT_7:29;
           sI | IL = s2 | IL by SCMFSA6B:17;
      then t1 | IL = t3 | IL by FUNCT_7:95;
      then t2 | IL = t4 | IL by FUNCT_7:95;
      then s0 | IL = t4 | IL by SCMPDS_4:69;
then s0 | IL = s1 | IL by SCMPDS_4:69;
     then (Computation s0).n | IL = s1 | IL by SCMFSA6B:17;
then A24: (Computation s0).n = s1 by A23,FUNCT_7:92;
          s1 is not halting by SCMPDS_4:66;
     hence contradiction by A17,A18,A24,SCM_1:27;
end;

theorem Th4:
   for i1,i2,i3,i4 be Instruction of SCMPDS holds
   card (i1 ';' i2 ';' i3 ';' i4)=4
proof
   let x1,x2,x3,x4 be Instruction of SCMPDS;
   thus card (x1 ';' x2 ';' x3 ';' x4)=card (x1 ';' x2 ';' x3)+1 by SCMP_GCD:8
  .=card (x1 ';' x2 )+1+1 by SCMP_GCD:8
  .=2+1+1 by SCMP_GCD:9
  .=4;
end;

theorem Th5:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a,x,y be Int_position, i,c be Integer st card I > 0 &
  s.x >= c+s.DataLoc(s.a,i) &
   (for t be State of SCMPDS st t.x >= c+t.DataLoc(s.a,i) & t.y=s.y &
     t.a=s.a & t.DataLoc(s.a,i) > 0 holds
     IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
     IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
     IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i) & IExec(I,t).y=t.y)
   holds
     while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
   (s.DataLoc(s.a,i) > 0 implies
       IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
   let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
   a,x1,y1 be Int_position, i,c be Integer;
   set b=DataLoc(s.a,i);
   assume A1: card I > 0;
   assume A2: s.x1 >= c+s.b;
   assume A3: for t be State of SCMPDS st t.x1 >= c+t.b & t.y1=s.y1 &
    t.a=s.a & t.b > 0 holds
    IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).b < t.b & IExec(I,t).x1 >= c+IExec(I,t).b &
    IExec(I,t).y1=t.y1;
A4: for x st x in {x1} holds
       s.x >= c+s.b by A2,TARSKI:def 1;
      now
       let t be State of SCMPDS;
       assume A5: (for x st x in {x1} holds t.x >= c+t.b) &
         (for x st x in {y1} holds t.x=s.x) & t.a=s.a & t.b > 0;
                x1 in {x1} by TARSKI:def 1;
       then A6: t.x1 >= c+t.b by A5;
                y1 in {y1} by TARSKI:def 1;
       then A7: t.y1=s.y1 by A5;
       hence IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
              IExec(I,t).b < t.b by A3,A5,A6;
       hereby
           let x;
           assume A8: x in {x1};
                 IExec(I,t).x1 >= c+IExec(I,t).b by A3,A5,A6,A7;
           hence IExec(I,t).x >= c+IExec(I,t).b by A8,TARSKI:def 1;
       end;
       hereby
           let x;
           assume A9: x in {y1};
            hence IExec(I,t).x=IExec(I,t).y1 by TARSKI:def 1
                 .=t.y1 by A3,A5,A6,A7
                 .=t.x by A9,TARSKI:def 1;
       end;
    end;
    hence thesis by A1,A4,SCMPDS_8:27;
end;

theorem Th6:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a,x,y be Int_position, i,c be Integer st card I > 0 & s.x >= c &
   (for t be State of SCMPDS st t.x >= c & t.y=s.y &
     t.a=s.a & t.DataLoc(s.a,i) > 0 holds
     IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
     IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
     IExec(I,t).x >= c & IExec(I,t).y=t.y)
   holds
   while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
   ( s.DataLoc(s.a,i) > 0 implies
   IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a,x,y be Int_position, i,c be Integer;
   set b=DataLoc(s.a,i);

   assume A1: card I > 0;
   assume A2: s.x >= c;
   assume A3: for t be State of SCMPDS st t.x >= c & t.y=s.y &
     t.a=s.a & t.b > 0
 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
     IExec(I,t).b < t.b & IExec(I,t).x >= c & IExec(I,t).y=t.y;

     defpred P[set] means ex t be State of SCMPDS st
     t=$1 & t.x >= c & t.y=s.y;

    consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4:  for s be State of SCMPDS holds
       (s.b <= 0 implies f.s =0) & (s.b > 0 implies f.s=s.b)
     by SCMPDS_8:5;
     deffunc F(State of SCMPDS) = f.$1;
A5:  for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
     proof
       let t be State of SCMPDS;
       thus F(Dstate t)=0 implies t.b <= 0
       proof
         assume A6: F(Dstate t)=0;
         assume t.b > 0;
    then (Dstate t).b > 0 by SCMPDS_8:4;
         hence contradiction by A4,A6;
       end;
       assume t.b <= 0;
        then (Dstate t).b <= 0 by SCMPDS_8:4;
        hence thesis by A4;
     end;
then A7: for t be State of SCMPDS st
    P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
A8: P[Dstate s]
    proof
       take t=Dstate s;
       thus t=Dstate s;
      thus t.x >= c by A2,SCMPDS_8:4;
      thus t.y=s.y by SCMPDS_8:4;
    end;
A9: now
         let t be State of SCMPDS;
         assume A10:P[Dstate t] & t.a=s.a & t.b > 0;
         then consider v be State of SCMPDS such that
     A11: v=Dstate t & v.x >= c & v.y=s.y;
     A12: t.x >= c by A11,SCMPDS_8:4;
     A13: t.y=s.y by A11,SCMPDS_8:4;
     hence IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t
        by A3,A10,A12;
        set It=IExec(I,t),
            t2=Dstate It,
            t1=Dstate t;
        thus F(t2) < F(t1)
        proof
          assume A14: F(t2) >= F(t1);
               t1.b > 0 by A10,SCMPDS_8:4;
      then A15: F(t1)=t1.b by A4
           .=t.b by SCMPDS_8:4;
           then It.b > 0 by A5,A10,A14;
           then t2.b > 0 by SCMPDS_8:4;
           then F(t2)=t2.b by A4
           .=It.b by SCMPDS_8:4;
           hence contradiction by A3,A10,A12,A13,A14,A15;
       end;
        thus P[Dstate It]
        proof
            take v=Dstate It;
            thus v=Dstate It;
                 It.x >= c by A3,A10,A12,A13;
          hence v.x >= c by SCMPDS_8:4;
                   It.y=t.y by A3,A10,A12,A13;
          hence v.y=s.y by A13,SCMPDS_8:4;
        end;
    end;
         (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s &
    while>0(a,i,I) is_halting_on s from SCMPDS_8:sch 3(A1,A7,A8,A9);
    hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;
   assume A16: s.b > 0;
         (F(s)=F(s) or P[s]) &
    IExec(while>0(a,i,I),s) = IExec(while>0(a,i,I),IExec(I,s))
    from SCMPDS_8:sch 4(A1,A16,A7,A8,A9);
    hence thesis;
end;

theorem Th7:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a,x1,x2,x3,x4 be Int_position, i,c,md be Integer st
  card I > 0 & s.x4=s.x3-c+s.x1 & md <= s.x3-c &
  (for t be State of SCMPDS st t.x4=t.x3-c+t.x1 & md <= t.x3-c &
   t.x2=s.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0 holds
     IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
     IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
     IExec(I,t).x4=IExec(I,t).x3-c+IExec(I,t).x1 &
     md <= IExec(I,t).x3-c & IExec(I,t).x2=t.x2)
   holds
    while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
    ( s.DataLoc(s.a,i) > 0 implies
     IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)) )
proof
    let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
     a,x1,x2,x3,x4 be Int_position, i,c,md be Integer;
   set b=DataLoc(s.a,i);

   assume A1: card I > 0;
   assume A2: s.x4=s.x3-c+s.x1 & md <= s.x3-c;
   assume A3: for t be State of SCMPDS st t.x4=t.x3-c+t.x1 & md <= t.x3-c &
           t.x2=s.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0 holds
           IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
           IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
           IExec(I,t).x4=IExec(I,t).x3-c+IExec(I,t).x1 &
           md <= IExec(I,t).x3-c & IExec(I,t).x2=t.x2;

     defpred P[set] means ex t be State of SCMPDS st
     t=$1 & t.x4=t.x3-c+t.x1 & md <= t.x3-c & t.x2=s.x2;

     consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4:  for s be State of SCMPDS holds
        (s.b <= 0 implies f.s =0) & (s.b > 0 implies f.s=s.b)
     by SCMPDS_8:5;
     deffunc F(State of SCMPDS) = f.$1;
A5:  for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
     proof
       let t be State of SCMPDS;
       thus F(Dstate t)=0 implies t.b <= 0
       proof
         assume A6: F(Dstate t)=0;
         assume t.b > 0;
        then (Dstate t).b > 0 by SCMPDS_8:4;
         hence contradiction by A4,A6;
       end;
       assume t.b <= 0;
        then (Dstate t).b <= 0 by SCMPDS_8:4;
        hence thesis by A4;
     end;
then A7:  for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <=
0;
A8:  P[Dstate s]
     proof
       take t=Dstate s;
       thus t=Dstate s;
              t.x4=s.x3-c+s.x1 by A2,SCMPDS_8:4;
         then t.x4=t.x3-c+s.x1 by SCMPDS_8:4;
      hence t.x4=t.x3-c+t.x1 by SCMPDS_8:4;
      thus md <= t.x3-c by A2,SCMPDS_8:4;
      thus t.x2=s.x2 by SCMPDS_8:4;
    end;
A9: now
         let t be State of SCMPDS;
         assume A10:P[Dstate t] & t.a=s.a & t.b > 0;
         then consider v be State of SCMPDS such that
     A11: v=Dstate t & v.x4=v.x3-c+v.x1 & md <= v.x3-c &
         v.x2=s.x2;
              t.x4=v.x3-c+v.x1 by A11,SCMPDS_8:4;
         then t.x4=t.x3-c+v.x1 by A11,SCMPDS_8:4;
     then A12: t.x4=t.x3-c+t.x1 by A11,SCMPDS_8:4;
     A13: md <= t.x3-c by A11,SCMPDS_8:4;
     A14: t.x2=s.x2 by A11,SCMPDS_8:4;
     hence IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t
        by A3,A10,A12,A13;
        set It=IExec(I,t),
            t2=Dstate It,
            t1=Dstate t;
        thus F(t2) < F(t1)
        proof
          assume A15: F(t2) >= F(t1);
               t1.b > 0 by A10,SCMPDS_8:4;
      then A16: F(t1)=t1.b by A4
           .=t.b by SCMPDS_8:4;
           then It.b > 0 by A5,A10,A15;
           then t2.b > 0 by SCMPDS_8:4;
           then F(t2)=t2.b by A4
           .=It.b by SCMPDS_8:4;
           hence contradiction by A3,A10,A12,A13,A14,A15,A16;
       end;
        thus P[Dstate It]
        proof
            take v=Dstate It;
            thus v=Dstate It;
                 It.x4=It.x3-c+It.x1 by A3,A10,A12,A13,A14;
            then v.x4=It.x3-c+It.x1 by SCMPDS_8:4;
            then v.x4=v.x3-c+It.x1 by SCMPDS_8:4;
         hence v.x4=v.x3-c+v.x1 by SCMPDS_8:4;
                 md <= It.x3-c by A3,A10,A12,A13,A14;
         hence md <= v.x3-c by SCMPDS_8:4;
                It.x2=t.x2 by A3,A10,A12,A13,A14;
         hence v.x2=s.x2 by A14,SCMPDS_8:4;
        end;
    end;
         (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s &
    while>0(a,i,I) is_halting_on s from SCMPDS_8:sch 3(A1,A7,A8,A9);
    hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;

  assume A17: s.b > 0;
         (F(s)=F(s) or P[s]) &
    IExec(while>0(a,i,I),s) = IExec(while>0(a,i,I),IExec(I,s))
    from SCMPDS_8:sch 4(A1,A17,A7,A8,A9);
    hence thesis;
end;

theorem Th8:
  for f being FinSequence of INT,m,k1,k,n be Element of NAT st m<=k & k <= n &
  k1=k-1 & f is_non_decreasing_on m,k1 & f is_non_decreasing_on k+1,n &
  (for i be Element of NAT st m <= i & i < k holds f.i <= f.k) &
  (for i be Element of NAT st k < i & i <= n holds f.k <= f.i)
  holds
   f is_non_decreasing_on m,n
proof
    let f be FinSequence of INT,m,k1,k,n be Element of NAT;
    assume A1: m<=k & k <= n & k1=k-1;
    assume A2: f is_non_decreasing_on m,k1;
    assume A3: f is_non_decreasing_on k+1,n;
    assume A4: for i be Element of NAT st m <= i & i < k holds f.i <= f.k;
    assume A5: for i be Element of NAT st k < i & i <= n holds f.k <= f.i;
         now
       let i,j be Element of NAT;
       assume A6: m <= i & i <= j & j <= n;
       per cases by REAL_1:def 5;
       suppose j < k;
         then j+1 <= k by INT_1:20;
         then j <= k1 by A1,XREAL_1:21;
         hence f.i <= f.j by A2,A6,SFMASTR3:def 4;
       end;
       suppose A7: j = k;
         hereby
           per cases;
           suppose i=j;
              hence f.i <= f.j;
           end;
           suppose i<>j;
              then i<j by A6,REAL_1:def 5;
            hence f.i <= f.j by A4,A6,A7;
         end;
         end;
       end;
       suppose A8: j > k;
        hereby
           per cases by REAL_1:def 5;
           suppose A9: i < k;
           A10: f.j >= f.k by A5,A6,A8;
                    f.k >= f.i by A4,A6,A9;
            hence f.i <= f.j by A10,XXREAL_0:2;
           end;
           suppose A11: i = k;
            hereby
              per cases;
              suppose i=j;
              hence f.i <= f.j;
              end;
              suppose i<>j;
                then i<j by A6,REAL_1:def 5;
                hence f.i <= f.j by A5,A6,A11;
           end;
           end;
           end;
           suppose i > k;
             then i >= k+1 by INT_1:20;
             hence f.i <= f.j by A3,A6,SFMASTR3:def 4;
       end;
       end;
   end;
   end;
   hence thesis by SFMASTR3:def 4;
end;

theorem Th9:  :: RFINSEQ:17
for f,g be FinSequence,x be set st x in dom g & f,g are_fiberwise_equipotent
 holds ex y be set st y in dom g & f.x=g.y
proof
   let f,g be FinSequence,x be set;
   assume A1:x in dom g & f,g are_fiberwise_equipotent;
   then consider P be Permutation of dom g such that
A2: f = g*P by RFINSEQ:17;
    take y=P.x;
    thus y in dom g by A1,FUNCT_2:7;
    thus f.x=g.y by A1,A2,FUNCT_2:70;
end;

theorem Th10:   ::RFINSEQ:14
 for f,g,h be FinSequence holds
   f,g are_fiberwise_equipotent iff h^f, h^g are_fiberwise_equipotent
proof
  let f,g,h be FinSequence;
  thus f,g are_fiberwise_equipotent implies h^f, h^g are_fiberwise_equipotent
  proof assume
    A1: f,g are_fiberwise_equipotent;
          now let y be set;
           card (f"{y}) = card (g"{y}) by A1,RFINSEQ:def 1;
      hence card ((h^f)"{y}) = card(g"{y}) + card(h"{y}) by FINSEQ_3:63
      .= card((h^g)"{y}) by FINSEQ_3:63;
     end;
    hence thesis by RFINSEQ:def 1;
   end; assume
  A2: h^f,h^g are_fiberwise_equipotent;
        now let x be set;
         card((h^f)"{x}) = card(f"{x})+card(h"{x}) &
    card((h^g)"{x}) = card(g"{x})+card(h"{x}) &
    card((h^f)"{x}) = card((h^g)"{x}) by A2,FINSEQ_3:63,RFINSEQ:def 1;
    hence card(f"{x}) = card(g"{x});
   end;
  hence thesis by RFINSEQ:def 1;
end;

theorem Th11:
 for f,g be FinSequence,m,n,j be Element of NAT
 st f,g are_fiberwise_equipotent &
 m<=n & n <= len f & (for i be Element of NAT st 1<=i & i<=m holds f.i=g.i) &
 (for i be Element of NAT st n<i & i<=len f holds f.i=g.i) & (m<j & j<=n)
holds ex k be Element of NAT st m<k & k<=n & f.j=g.k
proof
  let f,g be FinSequence,m,n,j be Element of NAT;
  assume A1: f,g are_fiberwise_equipotent;
  assume A2: m<=n & n <= len f;
  assume A3: for i be Element of NAT st 1<=i & i<=m holds f.i=g.i;
  assume A4: for i be Element of NAT st n<i & i<=len f holds f.i=g.i;
  assume A5: m<j & j<=n;
          n-m >= 0 by A2,XREAL_1:50;
     then reconsider m2=n-m as Element of NAT by INT_1:16;
          len f-n >= 0 by A2,XREAL_1:50;
     then reconsider m3=len f-n as Element of NAT by INT_1:16;
A6:  len f=n+m3;
A7:  len g=n+m3 by A1,RFINSEQ:16;
     consider s1,r1 be FinSequence such that
A8:  len s1 = n & len r1 = m3 & f = s1^r1 by A6,FINSEQ_2:25;
     consider s2,r2 be FinSequence such that
A9:  len s2 = n & len r2 = m3 & g = s2^r2 by A7,FINSEQ_2:25;
      len s1=m+m2 by A8;
     then consider p1,q1 be FinSequence such that
A10:  len p1 = m & len q1 = m2 & s1 = p1^q1 by FINSEQ_2:25;
      len s2=m+m2 by A9;
     then consider p2,q2 be FinSequence such that
A11:  len p2 = m & len q2 = m2 & s2 = p2^q2 by FINSEQ_2:25;
A12:  f=p1^(q1^r1) by A8,A10,FINSEQ_1:45;
A13:  g=p2^(q2^r2) by A9,A11,FINSEQ_1:45;
A14:  Seg m = dom p1 by A10,FINSEQ_1:def 3;
A15:  Seg m = dom p2 by A11,FINSEQ_1:def 3;
          now
        let i be Element of NAT;
        assume A16: i in Seg m3;
        then A17: i in dom r1 by A8,FINSEQ_1:def 3;
        A18: i in dom r2 by A9,A16,FINSEQ_1:def 3;
        A19: 1 <= i & i <= m3 by A16,FINSEQ_1:3;
        then A20: n+1 <= n+i by XREAL_1:8;
                 n < n+1 by XREAL_1:31;
            then A21: n< i+n by A20,XXREAL_0:2;
        A22: len s1+i <= len f by A6,A8,A19,XREAL_1:8;
        thus r1.i=f.(len s1+i) by A8,A17,FINSEQ_1:def 7
          .=g.(len s2+i) by A4,A8,A9,A21,A22
          .=r2.i by A9,A18,FINSEQ_1:def 7;
     end;
     then r1=r2 by A8,A9,FINSEQ_2:10;
then A23:  s1,s2 are_fiberwise_equipotent by A1,A8,A9,RFINSEQ:14;
          now
        let i be Element of NAT;
        assume A24: i in Seg m;
        then A25: 1<= i & i <= m by FINSEQ_1:3;
        thus p1.i=f.i by A12,A14,A24,FINSEQ_1:def 7
          .=g.i by A3,A25
          .=p2.i by A13,A15,A24,FINSEQ_1:def 7;
     end;
     then p1=p2 by A10,A11,FINSEQ_2:10;
then A26:  q1,q2 are_fiberwise_equipotent by A10,A11,A23,Th10;
A27:  j-len p1 > 0 by A5,A10,XREAL_1:52;
     then reconsider x=j-len p1 as Element of NAT by INT_1:16;
A28:  Seg m2 = dom q1 by A10,FINSEQ_1:def 3;
A29:  Seg m2 = dom q2 by A11,FINSEQ_1:def 3;
A30:  1+ 0<= x by A27,INT_1:20;
     A31: x <= n-len p1 by A5,XREAL_1:11;
then x in dom q2 by A10,A29,A30,FINSEQ_1:3;
     then consider y be set such that
A32:  y in dom q2 & q1.x=q2.y by A26,Th9;
     reconsider y as Element of NAT by A32;
A33:  1<=y & y<=m2 by A29,A32,FINSEQ_1:3;
     take k=len p2+y;
       A34: k>=len p2+1 by A33,XREAL_1:8;
            m+1 > m by XREAL_1:31;
     hence m<k by A11,A34,XXREAL_0:2;
            k <= m2+len p2 by A33,XREAL_1:8;
     hence k<=n by A11;
A35:  x in dom q1 by A10,A28,A30,A31,FINSEQ_1:3;
then A36:  len p1 + x in dom s1 by A10,FINSEQ_1:41;
A37:  len p2 + y in dom s2 by A11,A32,FINSEQ_1:41;
     thus f.j=s1.(len p1+x) by A8,A36,FINSEQ_1:def 7
     .=q2.y by A10,A32,A35,FINSEQ_1:def 7
     .=s2.(len p2+y) by A11,A32,FINSEQ_1:def 7
     .=g.k by A9,A37,FINSEQ_1:def 7;
end;

Lm4:
  for s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a be Int_position, i,c be Integer,f,g be FinSequence of INT,m,n,m1
 be Element of NAT st card I> 0 & s.a=c & len f=n & len g=n &
 f is_FinSequence_on s,m &
 g is_FinSequence_on IExec(while>0(a,i,I),s),m & 1=s.DataLoc(c,i) &
   m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be State of SCMPDS,f1,f2 be FinSequence of INT,k1,k2,y1,
 yn be Element of NAT
  st t.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 &
   m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
    (for j be Element of NAT st (1<=j & j<2*k1+1) holds
           IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) &
   (y1>=yn implies IExec(I,t).DataLoc(c,i)=2*k1-1 &
          (for j be Element of NAT st (1<=j & j <= n) holds
          IExec(I,t).intpos (m+j) = t.intpos (m+j))) &
   (y1<yn implies IExec(I,t).DataLoc(c,i)=2*k1+3 &
          (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
           IExec(I,t).intpos(m+j) = t.intpos (m+j)) &
     (ex ym be Element of NAT st y1 <= ym & ym <= yn &
     m+y1=IExec(I,t).intpos k2 &
        m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) &
        m+yn=IExec(I,t).intpos (k2+3) &
        (for j be Element of NAT st y1 <= j & j < ym holds
           IExec(I,t).intpos (m+j) <= IExec(I,t).intpos (m+ym)) &
        (for j be Element of NAT st ym < j & j <= yn holds
           IExec(I,t).intpos (m+j) >= IExec(I,t).intpos (m+ym)))) &
    (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m &
    len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent))
    holds
     while>0(a,i,I) is_halting_on s &
     f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
proof
   let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
   a be Int_position, i,c be Integer,f,g be FinSequence of INT,
   m,n,m1 be Element of NAT;
   set b=DataLoc(c,i);
   assume A1: card I>0 & s.a=c & len f=n & len g=n;
   assume A2: f is_FinSequence_on s,m;
   assume A3: g is_FinSequence_on IExec(while>0(a,i,I),s),m;
   assume A4: 1=s.b;
   assume A5: m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1);
   assume A6: for t be State of SCMPDS,f1,f2 be FinSequence of INT,
     k1,k2,y1,yn be Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
     m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
     holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
          (for j be Element of NAT st (1<=j & j<2*k1+1) holds
           IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) &
         (y1>=yn implies IExec(I,t).b=2*k1-1 &
            (for j be Element of NAT st (1<=j & j <= n) holds
            IExec(I,t).intpos (m+j) = t.intpos (m+j))) &
         (y1<yn implies IExec(I,t).b=2*k1+3 &
            (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
            IExec(I,t).intpos (m+j) = t.intpos (m+j)) &
          (ex ym be Element of NAT st y1 <= ym & ym <= yn &
          m+y1=IExec(I,t).intpos k2 &
         m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) &
         m+yn=IExec(I,t).intpos (k2+3) &
          (for j be Element of NAT st y1 <= j & j < ym holds
             IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) &
          (for j be Element of NAT st ym < j & j <= yn holds
              IExec(I,t).intpos(m+j) >= IExec(I,t).intpos(m+ym)))) &
     (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m &
      len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

   set WH =while>0(a,i,I),
       sWH=stop WH,
       iWH=Initialized sWH;

    defpred P[Element of NAT] means
    for t be State of SCMPDS,f1 be FinSequence of INT, k1,k2,y1,yn be
    Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
    (1 <= y1 & yn <= n or y1 >= yn) & m+y1=t.intpos k2 &
    m+yn=t.intpos(k2+1) & yn-y1<=$1 & f1 is_FinSequence_on t,m &
    len f1=n holds ex k be Element of NAT,f2 be FinSequence of INT st
    (Computation(t +*iWH)).k+*iWH=(Computation(t +*iWH)).k &
    f2 is_FinSequence_on (Computation(t +*iWH)).k,m & len f2=n &
    f1,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on y1,yn &
   (for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n) holds
   f2.j= t.intpos(m+j)) &
   (for j be Element of NAT st y1>=yn & 1<=j & j<= n
   holds f2.j= t.intpos(m+j)) &
      (for j be Element of NAT st (1<=j & j<2*k1+1) holds
      (Computation(t +*iWH)).k.intpos(m+n+j)=t.intpos(m+n+j)) &
      (Computation(t +*iWH)).k.b=t.b-2 & (Computation(t +*iWH)).k.a=c;

A7:  P[0]
     proof
         let t be State of SCMPDS,f1 be FinSequence of INT,k1,k2,y1,yn be
         Element of NAT;
         assume A8: t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
                   (1 <= y1 & yn <= n or y1 >= yn) & m+y1=t.intpos k2 &
                   m+yn=t.intpos(k2+1) & yn-y1<=0 &
                   f1 is_FinSequence_on t,m & len f1=n;
A9:     I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a by A6,A8;
A10:     y1>=yn implies IExec(I,t).b=2*k1-1 &
(for j be Element of NAT st (1<=j & j <= n)
        holds IExec(I,t).intpos (m+j) = t.intpos (m+j)) by A6,A8;
A11:     y1>=yn by A8,XREAL_1:52;
A12:     IExec(I,t).b=t.b-(1+1) by  A8,A10,XREAL_1:52;
        take k=LifeSpan (t +* Initialized stop I)+2;
        set tk=(Computation(t +* iWH)).k;
A13:     tk | D =IExec(I,t) | D by A1,A8,A9,Th2;
        consider f2 be FinSequence of INT such that
A14:     len f2=n & for i be Element of NAT st 1<=i & i <= len f2 holds
        f2.i=IExec(I,t).intpos(m+i) by SCPISORT:2;
A15:     f2 is_FinSequence_on IExec(I,t),m by A14,SCPISORT:def 1;
        take f2;
        thus tk+*iWH =tk by A1,A8,A9,Th2;
             now
         let i be Element of NAT;
         assume 1<=i & i <= len f2;
         hence f2.i=IExec(I,t).intpos(m+i) by A14
           .=tk.intpos(m+i) by A13,SCMPDS_4:23;
        end;
        hence f2 is_FinSequence_on tk,m by SCPISORT:def 1;
        thus len f2=n by A14;
        thus f1,f2 are_fiberwise_equipotent by A6,A8,A14,A15;
        thus f2 is_non_decreasing_on y1,yn by A11,SCPISORT:1;
        thus for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
        holds
         f2.j= t.intpos(m+j) by A8,XREAL_1:52;
        hereby
           let j be Element of NAT;
           assume A16: y1>=yn & 1<=j & j<= n;
           hence f2.j=IExec(I,t).intpos (m+j) by A14
           .=t.intpos(m+j) by A6,A8,A16;
        end;
        hereby
         let j be Element of NAT;
         assume A17: 1<=j & j<2*k1+1;
         thus tk.intpos(m+n+j)=IExec(I,t).intpos(m+n+j) by A13,SCMPDS_4:23
           .=t.intpos(m+n+j) by A6,A8,A17;
       end;
       thus tk.b=t.b-2 by A12,A13,SCMPDS_4:23;
       thus tk.a=c by A8,A9,A13,SCMPDS_4:23;
    end;
A18: now let k be Element of NAT;
         assume A19:P[k];
              now let t be State of SCMPDS,f1 be FinSequence of INT,
             k1,k2,y1,ym,yn be Element of NAT;
             assume A20: t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
               (1 <= y1 & yn <= n or y1 >= yn) & m+y1=t.intpos k2 &
               m+yn=t.intpos(k2+1) & yn-y1<=k+1 &
               f1 is_FinSequence_on t,m & len f1=n;
            per cases;
            suppose yn-y1<=0;
            hence ex kk be Element of NAT,f2 be FinSequence of INT st
             (Computation(t +*iWH)).kk+*iWH=(Computation(t +*iWH)).kk &
             f2 is_FinSequence_on (Computation(t +*iWH)).kk,m & len f2=n &
             f1,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on y1,yn &
             (for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
             holds
             f2.j= t.intpos(m+j)) &
             (for j be Element of NAT st y1>=yn & 1<=j & j<= n holds
             f2.j= t.intpos(m+j)) &
             (for j be Element of NAT st (1<=j & j<2*k1+1) holds
             (Computation(t +*iWH)).kk.intpos(m+n+j)=t.intpos(m+n+j)) &
             (Computation(t +*iWH)).kk.b=t.b-2 &
             (Computation(t +*iWH)).kk.a=c by A7,A20;

             end;
             suppose A21: yn-y1>0;
        then A22:    yn>y1 by REAL_2:106;
        A23:    I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a
               by A6,A20;
               set It=IExec(I,t);
        A24:    y1<yn implies It.b=2*k1+3 &
               (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n)
               holds
                  IExec(I,t).intpos (m+j) = t.intpos (m+j)) &
               (ex ym be Element of NAT st y1 <= ym & ym <= yn &
               m+y1=It.intpos k2 &
                m+ym-1=It.intpos (k2+1) & m+ym+1=It.intpos (k2+2) &
                m+yn=It.intpos (k2+3) &
               (for j be Element of NAT st y1 <= j & j < ym holds
                IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) &
               (for j be Element of NAT st ym < j & j <= yn holds
               IExec(I,t).intpos(m+j) >= IExec(I,t).intpos(m+ym))) by A6,A20;
               set m1=LifeSpan (t +* Initialized stop I)+2;
               set t1=(Computation(t +* iWH)).m1;
        A25:    t1 | D =IExec(I,t) | D & t1+*iWH =t1 by A1,A20,A23,Th2;
               consider ym be Element of NAT such that
        A26:    y1 <= ym & ym <= yn & m+y1=It.intpos k2 &
                m+ym-1=It.intpos (k2+1) & m+ym+1=It.intpos (k2+2) &
                m+yn=It.intpos (k2+3) &
               (for j be Element of NAT st y1 <= j & j < ym holds
                IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) &
               (for j be Element of NAT st ym < j & j <= yn holds
               IExec(I,t).intpos(m+j) >= IExec(I,t).intpos(m+ym)) by A21,A24,
REAL_2:106;
               set k3=m+n+2*(k1+1)+1,
                   yd=ym+1;
        A27:    t1.a=c by A20,A23,A25,SCMPDS_4:23;
        A28:    t1.b=2*k1+3 by A21,A24,A25,REAL_2:106,SCMPDS_4:23;
        A29:    t1.b=2*(k1+1)+1 by A21,A24,A25,REAL_2:106,SCMPDS_4:23;
        A30:    yd > ym by XREAL_1:31;
        then A31:    yd >= y1 by A26,XXREAL_0:2;
        then A32:    yd >= 1 by A20,A21,XXREAL_0:2,REAL_2:106;
        A33:    t1.intpos k3=m+yd by  A20,A25,SCMPDS_4:23,A26;
        A34:    t1.intpos(k3+1)=m+yn by A20,A25,A26,SCMPDS_4:23;
                   A35: ym+(1+k) >= y1+(1+k) by A26,XREAL_1:8;
                    yn <= y1+(k+1) by A20,XREAL_1:22;
               then yn <= yd+k by A35,XXREAL_0:2;
        then A36:    yn-yd<=k by XREAL_1:22;
               consider f2 be FinSequence of INT such that
        A37:    len f2=n & for i be Element of NAT st 1<=i & i <= len f2 holds
               f2.i=t1.intpos(m+i) by SCPISORT:2;
                f2 is_FinSequence_on t1,m by A37,SCPISORT:def 1;
               then consider kl be Element of NAT,f3 be FinSequence of INT
               such that
        A38:   (Computation(t1 +*iWH)).kl+*iWH=(Computation(t1 +*iWH)).kl &
              f3 is_FinSequence_on (Computation(t1 +*iWH)).kl,m & len f3=n &
              f2,f3 are_fiberwise_equipotent &
              f3 is_non_decreasing_on yd,yn &
              (for j be Element of NAT st yd<yn & (1<=j & j<yd or yn<j & j<= n)
              holds
              f3.j= t1.intpos(m+j)) &
              (for j be Element of NAT st yd>=yn & 1<=j & j<= n
              holds f3.j=t1.intpos(m+j)) &
              (for j be Element of NAT st (1<=j & j<2*(k1+1)+1) holds
             (Computation(t1 +*iWH)).kl.intpos(m+n+j)=t1.intpos(m+n+j)) &
             (Computation(t1 +*iWH)).kl.b=t1.b-2 &
             (Computation(t1 +*iWH)).kl.a=c by A19,A20,A21,A27,A29,A32,A33,A34
,A36,A37,REAL_2:106;
             set t2=(Computation(t1 +*iWH)).kl;
        A39:    ym >= 1 by A20,A21,A26,XXREAL_0:2,REAL_2:106;
            then ym-1 >= 0 by XREAL_1:50;
               then reconsider yc=ym-1 as Element of NAT by INT_1:16;
        A40:    t2.b=2*k1+1 by A28,A38;
        A41:    yc < ym by XREAL_1:148;
        then A42:    yc <= yn by A26,XXREAL_0:2;
        then A43:    yc <= n by A20,A21,XXREAL_0:2,REAL_2:106;
               set jj=2*k1+1;
        A44:    k2=m+n+jj by A20;
        A45:    jj >= 1 by NAT_1:11;
        A46:    2*k1+3=2*(k1+1)+1;
        then jj < 2*(k1+1)+1 by XREAL_1:8;
        then A47:    t2.intpos k2=t1.intpos(m+n+jj) by A38,A44,A45
               .=m+y1 by A25,A26,A44,SCMPDS_4:23;
               set jj=2*k1+2;
                    jj >= 2 by NAT_1:11;
        then A48:    jj >= 1 by XXREAL_0:2;
                jj < 2*(k1+1)+1 by A46,XREAL_1:8;
        then A49:    t2.intpos (k2+1)=t1.intpos(m+n+jj) by A20,A38,A48
               .=m+yc by A20,A25,A26,SCMPDS_4:23;
                    yc <= yn-1 by A26,XREAL_1:11;
               then A50: yc-y1 <= yn-1-y1 by XREAL_1:11;
                    yn-y1-1 <= k+1-1 by A20,XREAL_1:11;
        then yc-y1<=k by A50,XXREAL_0:2;
               then consider km be Element of NAT,f4 be FinSequence of INT
               such that
        A51:   (Computation(t2 +*iWH)).km+*iWH=(Computation(t2 +*iWH)).km &
              f4 is_FinSequence_on (Computation(t2 +*iWH)).km,m & len f4=n &
              f3,f4 are_fiberwise_equipotent &
              f4 is_non_decreasing_on y1,yc &
              (for j be Element of NAT st y1<yc & (1<=j & j<y1 or yc<j & j<= n)
              holds
              f4.j= t2.intpos(m+j)) &
              (for j be Element of NAT st y1>=yc & 1<=j & j<= n
              holds f4.j=t2.intpos(m+j)) &
              (for j be Element of NAT st (1<=j & j<2*k1+1) holds
             (Computation(t2 +*iWH)).km.intpos(m+n+j)=t2.intpos(m+n+j)) &
             (Computation(t2 +*iWH)).km.b=t2.b-2 &
             (Computation(t2 +*iWH)).km.a=c by A19,A20,A21,A38,A40,A43,A47,A49,
REAL_2:106;
             take mm=m1+(kl+km);
             set tm=(Computation(t +* iWH)).mm;
             take f4;
        A52:  tm=(Computation (t1+*iWH)).(kl+km) by A25,AMI_1:51
             .=(Computation (t2+*iWH)).km by A38,AMI_1:51;
             hence tm+*iWH =tm by A51;
             thus f4 is_FinSequence_on tm,m by A51,A52;
             thus len f4=n by A51;
                  now
                let i be Element of NAT;
                assume 1<=i & i <= len f2;
                hence f2.i=t1.intpos(m+i) by A37
                 .=IExec(I,t).intpos(m+i) by A25,SCMPDS_4:23;
             end;
             then f2 is_FinSequence_on IExec(I,t),m by SCPISORT:def 1;
             then f1,f2 are_fiberwise_equipotent by A6,A20,A37;
             then f1,f3 are_fiberwise_equipotent by A38,RFINSEQ:2;
             hence f1,f4 are_fiberwise_equipotent by A51,RFINSEQ:2;
        A53:  yc < yd by A30,A41,XXREAL_0:2;
        A54:  now
                let j be Element of NAT;
                assume A55: yd<=j & j<=yn;
              then A56: j <= n by A20,A21,XXREAL_0:2,REAL_2:106;
                  A57: yc < j by A53,A55,XXREAL_0:2;
              A58: 1<=j by A32,A55,XXREAL_0:2;
                       now
                    per cases;
                    suppose y1<yc;
                    hence f4.j=t2.intpos(m+j) by A51,A56,A57;
                    end;
                    suppose y1>=yc;
                    hence f4.j=t2.intpos(m+j) by A51,A56,A58;
                  end;
                  end;
                hence f4.j=f3.j by A38,A56,A58,SCPISORT:def 1;
            end;
                 now let i,j be Element of NAT;
               assume A59: yd <= i & i <= j & j <= yn;
              then A60:  i <= yn by XXREAL_0:2;
              A61:  yd <= j by A59,XXREAL_0:2;
              A62:  f4.i=f3.i by A54,A59,A60;
                        f4.j=f3.j by A54,A59,A61;
              hence f4.i <= f4.j by A38,A59,A62,SFMASTR3:def 4;
            end;
       then A63:  f4 is_non_decreasing_on yd,yn by SFMASTR3:def 4;
                 y1-1 >= 0 by A20,A21,REAL_2:106,XREAL_1:50;
            then reconsider y0=y1-1 as Element of NAT by INT_1:16;
       A64:  y0 <= yc by A26,XREAL_1:11;
       A65:  now let i be Element of NAT;
               assume A66:1<=i & i<=y0;
                       i-1 < i by XREAL_1:148;
                  then i-1 < y1-1 by A66,XXREAL_0:2;
               then A67:i<y1 by XREAL_1:11;
                       y1 <= n by A20,A22,XXREAL_0:2;
               then A68:i<=n by A67,XXREAL_0:2;
                    now
                   per cases;
                   suppose y1<yc;
                    hence f4.i= t2.intpos(m+i) by A51,A66,A67;
                   end;
                   suppose y1>=yc;
                    hence f4.i= t2.intpos(m+i) by A51,A66,A68;
              end;
              end;
              hence f4.i=f3.i by A38,A66,A68,SCPISORT:def 1;
            end;
       A69:  now let i be Element of NAT;
                assume A70: yc<i & i<=len f4;
           A71:  1+0 <= i by A70,INT_1:20;
                     now
                   per cases;
                   suppose y1<yc;
                    hence f4.i= t2.intpos(m+i) by A51,A70;
                   end;
                   suppose y1>=yc;
                    hence f4.i= t2.intpos(m+i) by A51,A70,A71;
              end;
              end;
              hence f4.i=f3.i by A38,A51,A70,A71,SCPISORT:def 1;
            end;
       A72:  ym <= n by A20,A21,A26,XXREAL_0:2,REAL_2:106;
       then A73:  f4.ym=f3.ym by A41,A51,A69;
                 now
               per cases;
               suppose yd<yn;
                 hence f3.ym= t1.intpos(m+ym) by A30,A38,A39;
               end;
               suppose yd>=yn;
                 hence f3.ym= t1.intpos(m+ym) by A38,A39,A72;
            end;
            end;
       then A74:  f4.ym=IExec(I,t).intpos(m+ym) by A25,A73,SCMPDS_4:23;
       A75: now let i be Element of NAT;
                assume A76:y1 <= i & i < ym;
                     y0 < y1 by XREAL_1:148;
         then A77:    y0 < i by A76,XXREAL_0:2;
                     i+1 <= ym by A76,INT_1:20;
         then i<=yc by XREAL_1:21;
                then consider j be Element of NAT such that
         A78:    y0<j & j<=yc & f4.i=f3.j by A43,A51,A64,A65,A69,A77,Th11;
         A79:    1+0 <= j by A78,INT_1:20;
         A80:    j<yd by A53,A78,XXREAL_0:2;
         A81:    j<= n by A43,A78,XXREAL_0:2;
                    A82: y1-1+1 <= j by A78,INT_1:20;
                     yc < ym by XREAL_1:148;
         then A83:    j < ym by A78,XXREAL_0:2;
                     now
                   per cases;
                   suppose yd<yn;
                   hence f3.j= t1.intpos(m+j) by A38,A79,A80;
                   end;
                   suppose yd>=yn;
                   hence f3.j= t1.intpos(m+j) by A38,A79,A81;
                end;
                end;
                then f4.i=IExec(I,t).intpos(m+j) by A25,A78,SCMPDS_4:23;
               hence f4.i <= f4.ym by A26,A74,A82,A83;
            end;
         A84:  now let i be Element of NAT;
                  assume A85: 1<=i & i<=ym;
               then A86:  i<yd by A30,XXREAL_0:2;
               A87:  i<=n by A72,A85,XXREAL_0:2;
                        now
                     per cases;
                     suppose yd<yn;
                     hence f3.i= t1.intpos(m+i) by A38,A85,A86;
                     end;
                     suppose yd>=yn;
                     hence f3.i= t1.intpos(m+i) by A38,A85,A87;
                   end;
                   end;
                   hence f3.i=f2.i by A37,A85,A87;
              end;
         A88:  now let i be Element of NAT;
                  assume A89: yn<i & i<=len f3;
                  then A90: 1+0<=i by INT_1:20;
                       now
                     per cases;
                     suppose yd<yn;
                     hence f3.i= t1.intpos(m+i) by A38,A89;
                     end;
                     suppose yd>=yn;
                     hence f3.i= t1.intpos(m+i) by A38,A89,A90;
                   end;
                   end;
                   hence f3.i=f2.i by A37,A38,A89,A90;
              end;
                   now let i be Element of NAT;
                 assume A91: ym < i & i <= yn;
           then A92:   yc < i by A41,XXREAL_0:2;
           A93:   i<=len f4 by A20,A21,A51,A91,XXREAL_0:2,REAL_2:106;
                consider j be Element of NAT such that
           A94:   ym<j & j<=yn & f3.i=f2.j by A20,A21,A26,A38,A84,A88,A91,Th11,
REAL_2:106;
           A95:   1<=j by A39,A94,XXREAL_0:2;
           A96:   j<=len f2 by A20,A21,A37,A94,XXREAL_0:2,REAL_2:106;
                      f4.i=f2.j by A69,A92,A93,A94
                .=t1.intpos(m+j) by A37,A95,A96
               .=IExec(I,t).intpos(m+j) by A25,SCMPDS_4:23;
                 hence f4.ym <= f4.i by A26,A74,A94;
            end;
            hence f4 is_non_decreasing_on y1,yn by A26,A51,A63,A75,Th8;
            thus for j be Element of NAT st y1<yn &
            (1<=j & j<y1 or yn<j & j<= n)
            holds
                  f4.j= t.intpos(m+j)
             proof
                let j be Element of NAT;
                assume A97: y1<yn & (1<=j & j<y1 or yn<j & j<= n);
              A98: 1<=j & j<y1 or yc<j & j<= n
                proof
                   per cases by A97;
                   suppose 1<=j & j<y1;
                   hence thesis;
                   end;
                   suppose yn<j & j<=n;
                    hence thesis by A42,XXREAL_0:2;
                end;
                end;
            A99: 1<=j & j<= n
                proof
                   per cases by A97;
                   suppose A100:1<=j & j<y1;
                     then j<yn by A97,XXREAL_0:2;
                     hence thesis by A20,A21,A100,XXREAL_0:2,REAL_2:106;
                   end;
                   suppose A101: yn<j & j<=n;
                     then y1 < j by A97,XXREAL_0:2;
                    hence thesis by A20,A21,A101,XXREAL_0:2,REAL_2:106;
               end;
               end;
           A102: 1<=j & j<yd or yn<j & j<= n
               proof
                   per cases by A97;
                   suppose 1<=j & j<y1;
                   hence thesis by A31,XXREAL_0:2;
                   end;
                   suppose yn<j & j<=n;
                    hence thesis;
             end;
             end;
         A103: now
                per cases;
                suppose yd<yn;
                 hence f3.j=t1.intpos(m+j) by A38,A102;
                end;
                suppose yd>=yn;
                 hence f3.j=t1.intpos(m+j) by A38,A99;
             end;
             end;
                  now
                per cases;
                suppose y1<yc;
                 hence f4.j=t2.intpos(m+j) by A51,A98;
                end;
                suppose y1>=yc;
                  hence f4.j=t2.intpos(m+j) by A51,A99;
             end;
             end;
             hence f4.j=f3.j by A38,A99,SCPISORT:def 1
                   .=IExec(I,t).intpos(m+j) by A25,A103,SCMPDS_4:23
                  .=t.intpos(m+j) by A6,A20,A97;
            end;
            thus for j be Element of NAT st y1>=yn & 1<=j & j<= n holds
                f4.j=t.intpos(m+j) by A21,REAL_2:106;
           hereby
              let j be Element of NAT;
              assume A104: 1<=j & j<2*k1+1;
                   2*k1+1 < 2*(k1+1)+1 by A46,XREAL_1:8;
          then A105: j < 2*(k1+1)+1 by A104,XXREAL_0:2;
             thus tm.intpos(m+n+j)=t2.intpos(m+n+j) by A51,A52,A104
              .=t1.intpos(m+n+j) by A38,A104,A105
              .=IExec(I,t).intpos(m+n+j) by A25,SCMPDS_4:23
              .=t.intpos(m+n+j) by A6,A20,A104;
           end;
           thus tm.b=t.b-2 by  A28,A38,A51,A52,A20;
           thus tm.a=c by A51,A52;
         end;
         end;
         hence P[k+1];
    end;
A106: for k being Element of NAT holds P[k] from NAT_1:sch 1(A7,A18);
A107: m1=m+n+2*0+1 by A5;
     ex k be Element of NAT,f2 be FinSequence of INT st
     (Computation(s +*iWH)).k+*iWH=(Computation(s +*iWH)).k &
     f2 is_FinSequence_on (Computation(s +*iWH)).k,m & len f2=n &
     f,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n &
     (for j be Element of NAT st 1<n & (1<=j & j<1 or n<j & j<= n) holds
       f2.j= s.intpos(m+j)) &
     (for j be Element of NAT st 1>=n & 1<=j & j<= n
     holds f2.j= s.intpos(m+j)) &
       (for j be Element of NAT st (1<=j & j<2*0+1) holds
     (Computation(s +*iWH)).k.intpos(m+n+j)=s.intpos(m+n+j)) &
     (Computation(s +*iWH)).k.b=s.b-2 & (Computation(s +*iWH)).k.a=c
     proof
       per cases;
       suppose n-1<=0;
         hence thesis by A1,A2,A4,A5,A106,A107;
       end;
       suppose n-1>0;
         then reconsider nn=n-1 as Element of NAT by INT_1:16;
              P[nn] by A106;
         hence thesis by A1,A2,A4,A5,A107;
     end;
     end;
     then consider k be Element of NAT,f2 be FinSequence of INT such that
A108:  (Computation(s +*iWH)).k+*iWH=(Computation(s +*iWH)).k &
     f2 is_FinSequence_on (Computation(s +*iWH)).k,m & len f2=n &
     f,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n &
     (Computation(s +*iWH)).k.b=s.b-2 &
     (Computation(s +*iWH)).k.a=c;
     set sk=(Computation(s +*iWH)).k,
         s1 = sk +* iWH,
         s2 = (Computation s1).1;
     set i1=(a,i)<=0_goto (card I+2),
         i2=goto -(card I+1);

A109: IC s1 =inspos 0 by SCMPDS_6:21;
         WH = i1 ';' (I ';' i2 ) by Lm2;
then A110: CurInstr s1 = i1 by SCMPDS_6:22;
A111: (Computation s1).(0 + 1) = Following (Computation s1).0 by AMI_1:def 19
     .= Following s1 by AMI_1:def 19
     .= Exec(i1,s1) by A110,AMI_1:def 18;
          iWH c= s1 by FUNCT_4:26;
  then sWH c= s1 by SCMPDS_4:57;
then A112:  sWH c= s2 by AMI_3:38;

A113:  card WH=card I+2 by SCMPDS_8:17;
then A114:  inspos(card I+2) in dom sWH by SCMPDS_6:25;
A115:  IC s2 = s2.IC SCMPDS by AMI_1:def 15
     .= ICplusConst(s1,(card I+2)) by A4,A108,A111,SCMPDS_2:68
     .= inspos(0+(card I+2)) by A109,SCMPDS_6:23;
          s2.inspos(card I+2) = sWH.inspos(card I+2) by A112,A114,GRFUNC_1:8
     .=halt SCMPDS by A113,SCMPDS_6:25;
then A116:  CurInstr s2 = halt SCMPDS by A115,AMI_1:def 17;
A117:  s2=(Computation(s +*iWH)).(k+1) by A108,AMI_1:51;
then A118:  s +* iWH is halting by A116,AMI_1:def 20;
then A119:  Result (s +* iWH)=s2 by A116,A117,AMI_1:def 22;
     thus WH is_halting_on s by A118,SCMPDS_6:def 3;
          now let i be Element of NAT;
        assume i in Seg n;
     then A120: 1 <= i & i <= n by FINSEQ_1:3;
     A121: IExec(WH,s)=s2 +* s | A by A119,SCMPDS_4:def 8;
         set xi=intpos (m+i);
              dom (s | A) = A by SCMPDS_6:1;
     then A122: not xi in dom (s | A) by SCMPDS_2:53;
      thus g.i=(s2 +* s | A).xi by A1,A3,A120,A121,SCPISORT:def 1
         .=s2.xi by A122,FUNCT_4:12
         .=s1.xi by A111,SCMPDS_2:68
         .=f2.i by A108,A120,SCPISORT:def 1;
     end;
     hence thesis by A1,A108,FINSEQ_2:10;
end;

Lm5:
  for s be State of SCMPDS,I be No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,m,n,m1 be Element of NAT
 st card I> 0 & s.a=c &
  1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be State of SCMPDS,f1,f2 be FinSequence of INT,
 k1,k2,y1,yn be Element of NAT
  st t.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 &
   m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
    (for j be Element of NAT st (1<=j & j<2*k1+1) holds
           IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) &
   (y1>=yn implies IExec(I,t).DataLoc(c,i)=2*k1-1 &
          (for j be Element of NAT st (1<=j & j <= n) holds
          IExec(I,t).intpos (m+j) = t.intpos (m+j))) &
   (y1<yn implies IExec(I,t).DataLoc(c,i)=2*k1+3 &
          (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
           IExec(I,t).intpos(m+j) = t.intpos (m+j)) &
     (ex ym be Element of NAT st y1 <= ym & ym <= yn &
     m+y1=IExec(I,t).intpos k2 &
        m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) &
        m+yn=IExec(I,t).intpos (k2+3) &
        (for j be Element of NAT st y1 <= j & j < ym holds
           IExec(I,t).intpos (m+j) <= IExec(I,t).intpos (m+ym)) &
        (for j be Element of NAT st ym < j & j <= yn holds
           IExec(I,t).intpos (m+j) >= IExec(I,t).intpos (m+ym)))) &
    (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m &
    len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent))
    holds
       while>0(a,i,I) is_halting_on s
proof
   let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
   a be Int_position, i,c be Integer,m,n,m1 be Element of NAT;
   set b=DataLoc(c,i);
   assume A1: card I>0 & s.a=c;
   assume A2: 1=s.b;
   assume A3: m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1);
   assume A4: for t be State of SCMPDS,f1,f2 be FinSequence of INT,
     k1,k2,y1,yn be Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
     m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
     holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
          (for j be Element of NAT st (1<=j & j<2*k1+1) holds
           IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) &
         (y1>=yn implies IExec(I,t).b=2*k1-1 &
            (for j be Element of NAT st (1<=j & j <= n) holds
            IExec(I,t).intpos (m+j) = t.intpos (m+j))) &
         (y1<yn implies IExec(I,t).b=2*k1+3 &
            (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
            IExec(I,t).intpos (m+j) = t.intpos (m+j)) &
          (ex ym be Element of NAT st y1 <= ym & ym <= yn &
          m+y1=IExec(I,t).intpos k2 &
         m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) &
         m+yn=IExec(I,t).intpos (k2+3) &
          (for j be Element of NAT st y1 <= j & j < ym holds
             IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) &
          (for j be Element of NAT st ym < j & j <= yn holds
              IExec(I,t).intpos(m+j) >= IExec(I,t).intpos(m+ym)))) &
     (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m &
      len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

     consider f be FinSequence of INT such that
A5:  len f=n & for i be Element of NAT st 1<=i & i <= len f holds
     f.i=s.intpos(m+i) by SCPISORT:2;
A6:  f is_FinSequence_on s,m by A5,SCPISORT:def 1;
     set ss=IExec(while>0(a,i,I),s);
     consider g be FinSequence of INT such that
A7:  len g=n & for i be Element of NAT st 1<=i & i <= len g holds
     g.i=ss.intpos(m+i) by SCPISORT:2;
      g is_FinSequence_on ss,m by A7,SCPISORT:def 1;
     hence thesis by A1,A2,A3,A4,A5,A6,A7,Lm4;
end;

Lm6:
  for s be State of SCMPDS,I be No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,m,n,m1 be Element of NAT st card I> 0 &
 s.a=c &
  1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be State of SCMPDS,f1,f2 be FinSequence of INT,
 k1,k2,y1,yn be Element of NAT
  st t.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 &
   m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
    (for j be Element of NAT st (1<=j & j<2*k1+1) holds
           IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) &
   (y1>=yn implies IExec(I,t).DataLoc(c,i)=2*k1-1 &
          (for j be Element of NAT st (1<=j & j <= n) holds
          IExec(I,t).intpos (m+j) = t.intpos (m+j))) &
   (y1<yn implies IExec(I,t).DataLoc(c,i)=2*k1+3 &
          (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
           IExec(I,t).intpos(m+j) = t.intpos (m+j)) &
     (ex ym be Element of NAT st y1 <= ym & ym <= yn &
     m+y1=IExec(I,t).intpos k2 &
        m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) &
        m+yn=IExec(I,t).intpos (k2+3) &
        (for j be Element of NAT st y1 <= j & j < ym holds
           IExec(I,t).intpos (m+j) <= IExec(I,t).intpos (m+ym)) &
        (for j be Element of NAT st ym < j & j <= yn holds
           IExec(I,t).intpos (m+j) >= IExec(I,t).intpos (m+ym)))) &
    (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m &
    len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent))
    holds
      while>0(a,i,I) is_halting_on s & while>0(a,i,I) is_closed_on s
proof
   let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
   a be Int_position, i,c be Integer,m,n,m1 be Element of NAT;
   set b=DataLoc(c,i);
   assume A1: card I>0;
   assume A2: s.a=c;
   assume A3: 1=s.b;
   assume A4: m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1);
   assume A5: for t be State of SCMPDS,f1,f2 be FinSequence of INT,
     k1,k2,y1,yn be Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
     m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
     holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
          (for j be Element of NAT st (1<=j & j<2*k1+1) holds
           IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) &
         (y1>=yn implies IExec(I,t).b=2*k1-1 &
            (for j be Element of NAT st (1<=j & j <= n) holds
            IExec(I,t).intpos (m+j) = t.intpos (m+j))) &
         (y1<yn implies IExec(I,t).b=2*k1+3 &
            (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
            IExec(I,t).intpos (m+j) = t.intpos (m+j)) &
          (ex ym be Element of NAT st y1 <= ym & ym <= yn &
          m+y1=IExec(I,t).intpos k2 &
         m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) &
         m+yn=IExec(I,t).intpos (k2+3) &
          (for j be Element of NAT st y1 <= j & j < ym holds
             IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) &
          (for j be Element of NAT st ym < j & j <= yn holds
              IExec(I,t).intpos(m+j) >= IExec(I,t).intpos(m+ym)))) &
     (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m &
      len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);
A6: now let v be State of SCMPDS;
      assume A7: v | D =s | D;
      then A8: v.a =c by A2,SCMPDS_4:23;
      A9: 1 =v.b by A3,A7,SCMPDS_4:23;
      A10: m+1 =v.intpos m1 by A4,A7,SCMPDS_4:23;
               m+n =v.intpos (m1+1) by A4,A7,SCMPDS_4:23;
      hence while>0(a,i,I) is_halting_on v by A1,A4,A5,A8,A9,A10,Lm5;
   end;
   hence while>0(a,i,I) is_halting_on s;
   thus while>0(a,i,I) is_closed_on s by A6,Th3;
end;

begin :: Program Partition is to split a sequence into a "smaller" and
::       a "larger" subsequence

:: a5=a7=length  a2=mid(x[1]), a3=x[2], a4=x[n], a6=save

definition
 func Partition -> Program-block equals

      ((GBP,5):=(GBP,4) ';'
      SubFrom(GBP,5,GBP,2) ';'
      (GBP,3):=(GBP,2) ';'
      AddTo(GBP,3,1)) ';'
      while>0(GBP,5,
        while>0(GBP,5,
            (GBP,7):=(GBP,5) ';' AddTo(GBP,5,-1) ';'
            (GBP,6):=(intpos 4,0) ';'
            SubFrom(GBP,6,intpos 2,0) ';'
            if>0(GBP,6, AddTo(GBP,4,-1) ';' AddTo(GBP,7,-1),
            Load (GBP,5):=0 )
        ) ';'
        while>0(GBP,7,
            (GBP,5):=(GBP,7) ';' AddTo(GBP,7,-1) ';'
            (GBP,6):=(intpos 2,0) ';'
            SubFrom(GBP,6,intpos 3,0) ';'
            if>0(GBP,6, AddTo(GBP,3,1) ';' AddTo(GBP,5,-1),
            Load (GBP,7):=0 )
        ) ';'
        if>0(GBP,5,((GBP,6):=(intpos 4,0) ';'
                    (intpos 4,0):=(intpos 3,0) ';'
                    (intpos 3,0):=(GBP,6) ';' AddTo(GBP,5,-2) ';'
                    AddTo(GBP,3,1)) ';' AddTo(GBP,4,-1)
        )
     ) ';'
     (GBP,6):=(intpos 4,0) ';'
     (intpos 4,0):=(intpos 2,0) ';'
     (intpos 2,0):=(GBP,6);
     coherence;
end;

begin :: The Construction of Quick Sort
:: a0=global, a1=stack, a2=stack depth

definition
 let n,p0 be Element of NAT;
 set pn=p0+n;
 func QuickSort(n,p0) -> Program-block equals

       ((GBP:=0) ';'
       (SBP:=1) ';'
       (SBP,pn):=(p0+1) ';'
       (SBP,pn+1):=pn) ';'
       while>0(GBP,1,
           (GBP,2):=(SBP,pn+1) ';'
           SubFrom(GBP,2,SBP,pn) ';'
           if>0(GBP,2, (GBP,2):=(SBP,pn) ';'
                  (GBP,4):=(SBP,pn+1) ';'
                  Partition ';'
                  (((SBP,pn+3):=(SBP,pn+1) ';'
                  (SBP,pn+1):=(GBP,4) ';'
                  (SBP,pn+2):=(GBP,4) ';'
                  AddTo(SBP,pn+1,-1)) ';'
                  AddTo(SBP,pn+2,1) ';'
                  AddTo(GBP,1,2)),
                  Load AddTo(GBP,1,-2)
          )
       );
       coherence;
end;

  set i1= (GBP,7):=(GBP,5),
       i2= AddTo(GBP,5,-1),
       i3= (GBP,6):=(intpos 4,0),
       i4= SubFrom(GBP,6,intpos 2,0),
       i5= AddTo(GBP,4,-1),
       i6= AddTo(GBP,7,-1),
       i7= Load (GBP,5):=0,
       IF1= if>0(GBP,6,i5 ';' i6,i7),
       WB1= i1 ';' i2 ';' i3 ';' i4 ';' IF1,
       WH1= while>0(GBP,5,WB1),
       j1= (GBP,5):=(GBP,7),
       j2= AddTo(GBP,7,-1),
       j3= (GBP,6):=(intpos 2,0),
       j4= SubFrom(GBP,6,intpos 3,0),
       j5= AddTo(GBP,3,1),
       j6= AddTo(GBP,5,-1),
       j7= Load (GBP,7):=0,
       IF2= if>0(GBP,6,j5 ';' j6, j7),
       WB2= j1 ';' j2 ';' j3 ';' j4 ';' IF2,
       WH2= while>0(GBP,7,WB2),
       k1 = (GBP,5):=(GBP,4),
       k2 = SubFrom(GBP,5,GBP,2),
       k3 = (GBP,3):=(GBP,2),
       k4 = AddTo(GBP,3,1),
       K4 = k1 ';' k2 ';' k3 ';' k4,
       k5 = (GBP,6):=(intpos 4,0),
       k6 = (intpos 4,0):=(intpos 3,0),
       k7 = (intpos 3,0):=(GBP,6),
       k8 = AddTo(GBP,5,-2),
       k9 = AddTo(GBP,3,1),
       k0 = AddTo(GBP,4,-1),
       IF3= if>0(GBP,5, k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0),
       WB3= WH1 ';' WH2 ';' IF3,
       WH3= while>0(GBP,5,WB3),
       j8 = (GBP,6):=(intpos 4,0),
       j9 = (intpos 4,0):=(intpos 2,0),
       j0 = (intpos 2,0):=(GBP,6);

 set a1=intpos 1,
       a2=intpos 2,
       a3=intpos 3,
       a4=intpos 4,
       a5=intpos 5,
       a6=intpos 6,
       a7=intpos 7;

Lm7:
  card WB1=9
proof
   thus card WB1= card (i1 ';' i2 ';' i3 ';' i4) + card IF1 by SCMPDS_4:45
      .= 4+card IF1 by Th4
      .= 4+(card (i5 ';' i6)+card i7+2) by SCMPDS_6:79
      .= 4+(2+card i7+2) by SCMP_GCD:9
      .= 4+(2+1+2) by SCMPDS_5:6
      .= 9;
end;

Lm8:
  for s being State of SCMPDS,md,me be Element of NAT st s.a2=md & s.a4=me &
  md >= 8 & me >= 8 & s.GBP=0 & s.a5 > 0 holds
  IExec(WB1,s).GBP=0 & IExec(WB1,s).a1=s.a1 &
  IExec(WB1,s).a2=s.a2 & IExec(WB1,s).a3=s.a3 &
  (for i be Element of NAT st i >= 8 holds IExec(WB1,s).intpos i=s.intpos i) &
  (s.intpos md < s.intpos me implies IExec(WB1,s).a5=s.a5-1 &
  IExec(WB1,s).a4=s.a4-1 & IExec(WB1,s).a7=s.a5-1) &
  (s.intpos md >= s.intpos me implies IExec(WB1,s).a5=0 &
  IExec(WB1,s).a4=s.a4 & IExec(WB1,s).a7=s.a5)
proof
   let s be State of SCMPDS,md,me be Element of NAT;
   set a=GBP;
   assume A1: s.a2=md & s.a4=me & md >= 8 & me >= 8 & s.a=0 & s.a5 > 0;
   set t0=Initialized s,
       t1=IExec(i1 ';' i2 ';' i3 ';' i4,s),
       t2=IExec(i1 ';' i2 ';' i3,s),
       t3=IExec(i1 ';' i2,s),
       t4=Exec(i1, t0);
A2: t0.a=0 by A1,SCMPDS_5:40;
A3: t0.a1=s.a1 by SCMPDS_5:40;
A4: t0.a2=md by A1,SCMPDS_5:40;
A5: t0.a3=s.a3 by SCMPDS_5:40;
A6: t0.a4=me by A1,SCMPDS_5:40;
A7: t0.a5=s.a5 by SCMPDS_5:40;

A8:  DataLoc(t0.a,7)=intpos (0+7) by A2,SCMP_GCD:5;
     then a<>DataLoc(t0.a,7) by AMI_3:52;
then A9: t4.a =0 by A2,SCMPDS_2:59;
          a1<>DataLoc(t0.a,7) by A8,AMI_3:52;
then A10: t4.a1 =s.a1 by A3,SCMPDS_2:59;
          a2<>DataLoc(t0.a,7) by A8,AMI_3:52;
then A11: t4.a2 =md by A4,SCMPDS_2:59;
          a3<>DataLoc(t0.a,7) by A8,AMI_3:52;
then A12: t4.a3 =s.a3 by A5,SCMPDS_2:59;
      a4<>DataLoc(t0.a,7) by A8,AMI_3:52;
then A13: t4.a4 =me by A6,SCMPDS_2:59;
          a5<>DataLoc(t0.a,7) by A8,AMI_3:52;
then A14: t4.a5 =s.a5 by A7,SCMPDS_2:59;
      DataLoc(t0.a,5)=intpos (0+5) by A2,SCMP_GCD:5;
then A15: t4.a7 =s.a5 by A7,A8,SCMPDS_2:59;
A16: now let i be Element of NAT;
        assume i>=8;
        then i > 7 by XXREAL_0:2;
    then intpos i <> DataLoc(t0.a,7) by A8,AMI_3:52;
        hence t4.intpos i=t0.intpos i by SCMPDS_2:59
          .=s.intpos i by SCMPDS_5:40;
     end;

A17:  DataLoc(t4.a,5)=intpos (0+5) by A9,SCMP_GCD:5;
then A18:  a<>DataLoc(t4.a,5) by AMI_3:52;
A19: t3.a =Exec(i2, t4).a by SCMPDS_5:47
     .=0 by A9,A18,SCMPDS_2:60;
A20:  a1<>DataLoc(t4.a,5) by A17,AMI_3:52;
A21: t3.a1 =Exec(i2, t4).a1 by SCMPDS_5:47
     .=s.a1 by A10,A20,SCMPDS_2:60;
A22:  a2<>DataLoc(t4.a,5) by A17,AMI_3:52;
A23: t3.a2 =Exec(i2, t4).a2 by SCMPDS_5:47
     .=md by A11,A22,SCMPDS_2:60;
A24:  a3<>DataLoc(t4.a,5) by A17,AMI_3:52;
A25: t3.a3 =Exec(i2, t4).a3 by SCMPDS_5:47
     .=s.a3 by A12,A24,SCMPDS_2:60;
A26:  a4<>DataLoc(t4.a,5) by A17,AMI_3:52;
A27: t3.a4 =Exec(i2, t4).a4 by SCMPDS_5:47
     .=me by A13,A26,SCMPDS_2:60;
A28: t3.a5 =Exec(i2, t4).a5 by SCMPDS_5:47
     .=t4.a5+ -1 by A17,SCMPDS_2:60
     .=s.a5-1 by A14;
A29:  a7<>DataLoc(t4.a,5) by A17,AMI_3:52;
A30: t3.a7 =Exec(i2, t4).a7 by SCMPDS_5:47
     .=s.a5 by A15,A29,SCMPDS_2:60;
A31: now let i be Element of NAT;
        assume A32:i>=8;
        then i > 5 by XXREAL_0:2;
    then A33: intpos i <> DataLoc(t4.a,5) by A17,AMI_3:52;
    thus t3.intpos i =Exec(i2, t4).intpos i by SCMPDS_5:47
          .=t4.intpos i by A33,SCMPDS_2:60
          .=s.intpos i by A16,A32;
      end;

A34:  DataLoc(t3.a,6)=intpos (0+6) by A19,SCMP_GCD:5;
then A35:  a<>DataLoc(t3.a,6) by AMI_3:52;
A36: t2.a =Exec(i3, t3).a by SCMPDS_5:46
     .=0 by A19,A35,SCMPDS_2:59;
A37:  a1<>DataLoc(t3.a,6) by A34,AMI_3:52;
A38: t2.a1 =Exec(i3, t3).a1 by SCMPDS_5:46
     .=s.a1 by A21,A37,SCMPDS_2:59;
A39:  a2<>DataLoc(t3.a,6) by A34,AMI_3:52;
A40: t2.a2 =Exec(i3, t3).a2 by SCMPDS_5:46
     .=md by A23,A39,SCMPDS_2:59;
A41:  a3<>DataLoc(t3.a,6) by A34,AMI_3:52;
A42: t2.a3 =Exec(i3, t3).a3 by SCMPDS_5:46
     .=s.a3 by A25,A41,SCMPDS_2:59;
A43:  a4<>DataLoc(t3.a,6) by A34,AMI_3:52;
A44: t2.a4 =Exec(i3, t3).a4 by SCMPDS_5:46
     .=me by A27,A43,SCMPDS_2:59;
A45:  a5<>DataLoc(t3.a,6) by A34,AMI_3:52;
A46: t2.a5 =Exec(i3, t3).a5 by SCMPDS_5:46
     .=s.a5-1 by A28,A45,SCMPDS_2:59;
A47:  DataLoc(t3.a4,0)=intpos (me+0) by A27,SCMP_GCD:5;
A48: t2.a6 =Exec(i3, t3).a6 by SCMPDS_5:46
     .=t3.intpos me by A34,A47,SCMPDS_2:59
     .=s.intpos me by A1,A31;
A49:  a7<>DataLoc(t3.a,6) by A34,AMI_3:52;
A50: t2.a7 =Exec(i3, t3).a7 by SCMPDS_5:46
     .=s.a5 by A30,A49,SCMPDS_2:59;
A51: now let i be Element of NAT;
        assume A52:i>=8;
        then i > 6 by XXREAL_0:2;
    then A53: intpos i <> DataLoc(t3.a,6) by A34,AMI_3:52;
        thus t2.intpos i=Exec(i3, t3).intpos i by SCMPDS_5:46
        .=t3.intpos i by A53,SCMPDS_2:59
        .=s.intpos i by A31,A52;
     end;

A54:  DataLoc(t2.a,6)=intpos (0+6) by A36,SCMP_GCD:5;
then A55:  a<>DataLoc(t2.a,6) by AMI_3:52;
A56: t1.a =Exec(i4, t2).a by SCMPDS_5:46
     .=0 by A36,A55,SCMPDS_2:62;
A57:  a1<>DataLoc(t2.a,6) by A54,AMI_3:52;
A58: t1.a1 =Exec(i4, t2).a1 by SCMPDS_5:46
     .=s.a1 by A38,A57,SCMPDS_2:62;
A59:  a2<>DataLoc(t2.a,6) by A54,AMI_3:52;
A60: t1.a2 =Exec(i4, t2).a2 by SCMPDS_5:46
     .=md by A40,A59,SCMPDS_2:62;
A61:  a3<>DataLoc(t2.a,6) by A54,AMI_3:52;
A62: t1.a3 =Exec(i4, t2).a3 by SCMPDS_5:46
     .=s.a3 by A42,A61,SCMPDS_2:62;
A63:  a4<>DataLoc(t2.a,6) by A54,AMI_3:52;
A64: t1.a4 =Exec(i4, t2).a4 by SCMPDS_5:46
     .=me by A44,A63,SCMPDS_2:62;
A65:  a5<>DataLoc(t2.a,6) by A54,AMI_3:52;
A66: t1.a5 =Exec(i4, t2).a5 by SCMPDS_5:46
     .=s.a5-1 by A46,A65,SCMPDS_2:62;
A67: t1.a6 =Exec(i4, t2).a6 by SCMPDS_5:46
     .=t2.a6-t2.DataLoc(t2.a2,0) by A54,SCMPDS_2:62
     .=t2.a6-t2.intpos(md+0) by A40,SCMP_GCD:5
     .=s.intpos me - s.intpos md by A1,A48,A51;
A68:  a7<>DataLoc(t2.a,6) by A54,AMI_3:52;
A69: t1.a7 =Exec(i4, t2).a7 by SCMPDS_5:46
     .=s.a5 by A50,A68,SCMPDS_2:62;
A70: now let i be Element of NAT;
        assume A71:i>=8;
        then i > 6 by XXREAL_0:2;
    then A72: intpos i <> DataLoc(t2.a,6) by A54,AMI_3:52;
        thus t1.intpos i=Exec(i4, t2).intpos i by SCMPDS_5:46
        .=t2.intpos i by A72,SCMPDS_2:62
        .=s.intpos i by A51,A71;
     end;

     set t01=Initialized t1,
         ii7= (GBP,5):=0,
         t5=Exec(i5,t01);
A73: t01.a=0 by A56,SCMPDS_5:40;
A74: t01.a1=s.a1 by A58,SCMPDS_5:40;
A75: t01.a2=s.a2 by A1,A60,SCMPDS_5:40;
A76: t01.a3=s.a3 by A62,SCMPDS_5:40;
A77: t01.a7=s.a5 by A69,SCMPDS_5:40;
A78:  DataLoc(t01.a,5)=intpos(0+5) by A73,SCMP_GCD:5;
A79:  DataLoc(t01.a,4)=intpos(0+4) by A73,SCMP_GCD:5;
     then a<>DataLoc(t01.a,4) by AMI_3:52;
then A80: t5.a=0 by A73,SCMPDS_2:60;
          a1<>DataLoc(t01.a,4) by A79,AMI_3:52;
then A81: t5.a1=s.a1 by A74,SCMPDS_2:60;
          a2<>DataLoc(t01.a,4) by A79,AMI_3:52;
then A82: t5.a2=s.a2 by A75,SCMPDS_2:60;
          a3<>DataLoc(t01.a,4) by A79,AMI_3:52;
then A83: t5.a3=s.a3 by A76,SCMPDS_2:60;
A84:  DataLoc(t5.a,7)=intpos(0+7) by A80,SCMP_GCD:5;
A85:  now
         per cases;
         suppose A86: t1.DataLoc(t1.a,6) <= 0;
         A87:  a<>DataLoc(t01.a,5) by A78,AMI_3:52;
         thus IExec(IF1,t1).a=IExec(i7,t1).a by A86,SCMPDS_6:88
              .=Exec(ii7,t01).a by SCMPDS_5:45
              .=0 by A73,A87,SCMPDS_2:58;
         A88:  a1<>DataLoc(t01.a,5) by A78,AMI_3:52;
         thus IExec(IF1,t1).a1=IExec(i7,t1).a1 by A86,SCMPDS_6:88
              .=Exec(ii7,t01).a1 by SCMPDS_5:45
              .=s.a1 by A74,A88,SCMPDS_2:58;
         A89:  a2<>DataLoc(t01.a,5) by A78,AMI_3:52;
         thus IExec(IF1,t1).a2=IExec(i7,t1).a2 by A86,SCMPDS_6:88
              .=Exec(ii7,t01).a2 by SCMPDS_5:45
              .=s.a2 by A75,A89,SCMPDS_2:58;
         A90:  a3<>DataLoc(t01.a,5) by A78,AMI_3:52;
         thus IExec(IF1,t1).a3=IExec(i7,t1).a3 by A86,SCMPDS_6:88
              .=Exec(ii7,t01).a3 by SCMPDS_5:45
              .=s.a3 by A76,A90,SCMPDS_2:58;
         hereby let i be Element of NAT;
              assume A91:i>=8;
                then i > 5 by XXREAL_0:2;
            then A92: intpos i <> DataLoc(t01.a,5) by A78,AMI_3:52;
        thus IExec(WB1,s).intpos i=IExec(IF1,t1).intpos i by SCMPDS_5:39
              .=IExec(i7,t1).intpos i by A86,SCMPDS_6:88
              .=Exec(ii7,t01).intpos i by SCMPDS_5:45
              .=t01.intpos i by A92,SCMPDS_2:58
              .=t1.intpos i by SCMPDS_5:40
              .=s.intpos i by A70,A91;
        end;

         end;
         suppose A93: t1.DataLoc(t1.a,6) > 0;
          A94: a<>DataLoc(t5.a,7) by A84,AMI_3:52;
         thus IExec(IF1,t1).a=IExec(i5 ';' i6,t1).a by A93,SCMPDS_6:87
              .=Exec(i6,t5).a by SCMPDS_5:47
              .=0 by A80,A94,SCMPDS_2:60;
          A95: a1<>DataLoc(t5.a,7) by A84,AMI_3:52;
         thus IExec(IF1,t1).a1=IExec(i5 ';' i6,t1).a1 by A93,SCMPDS_6:87
              .=Exec(i6,t5).a1 by SCMPDS_5:47
              .=s.a1 by A81,A95,SCMPDS_2:60;
         A96:  a2<>DataLoc(t5.a,7) by A84,AMI_3:52;
         thus IExec(IF1,t1).a2=IExec(i5 ';' i6,t1).a2 by A93,SCMPDS_6:87
              .=Exec(i6,t5).a2 by SCMPDS_5:47
              .=s.a2 by A82,A96,SCMPDS_2:60;
         A97:  a3<>DataLoc(t5.a,7) by A84,AMI_3:52;
         thus IExec(IF1,t1).a3=IExec(i5 ';' i6,t1).a3 by A93,SCMPDS_6:87
              .=Exec(i6,t5).a3 by SCMPDS_5:47
              .=s.a3 by A83,A97,SCMPDS_2:60;
         hereby let i be Element of NAT;
              assume A98:i>=8;
                then i > 7 by XXREAL_0:2;
            then A99: intpos i <> DataLoc(t5.a,7) by A84,AMI_3:52;
                     i > 4 by A98,XXREAL_0:2;
            then A100: intpos i<>DataLoc(t01.a,4) by A79,AMI_3:52;
        thus IExec(WB1,s).intpos i=IExec(IF1,t1).intpos i by SCMPDS_5:39
              .=IExec(i5 ';' i6,t1).intpos i by A93,SCMPDS_6:87
              .=Exec(i6,t5).intpos i by SCMPDS_5:47
              .=t5.intpos i by A99,SCMPDS_2:60
              .=t01.intpos i by A100,SCMPDS_2:60
              .=t1.intpos i by SCMPDS_5:40
              .=s.intpos i by A70,A98;
        end;
     end;
     end;
     hence IExec(WB1,s).a=0 & IExec(WB1,s).a1=s.a1 &
        IExec(WB1,s).a2=s.a2 & IExec(WB1,s).a3=s.a3 by SCMPDS_5:39;
   thus for i be Element of NAT st i >= 8
   holds IExec(WB1,s).intpos i=s.intpos i by A85;
A101:  t1.DataLoc(t1.a,6)=s.intpos me - s.intpos md by  A56,SCMP_GCD:5,A67;
A102: t01.a4=s.a4 by A1,A64,SCMPDS_5:40;
A103: t01.a5=s.a5-1 by A66,SCMPDS_5:40;
      hereby
        assume s.intpos md < s.intpos me;
         then A104: t1.DataLoc(t1.a,6) > 0 by A101,XREAL_1:52;
         A105:  a5<>DataLoc(t01.a,4) by A79,AMI_3:52;
         A106:  a5<>DataLoc(t5.a,7) by A84,AMI_3:52;
        thus IExec(WB1,s).a5=IExec(IF1,t1).a5 by SCMPDS_5:39
              .=IExec(i5 ';' i6,t1).a5 by A104,SCMPDS_6:87
              .=Exec(i6,t5).a5 by SCMPDS_5:47
              .=t5.a5 by A106,SCMPDS_2:60
               .=s.a5-1 by A103,A105,SCMPDS_2:60;
         A107:  a4<>DataLoc(t5.a,7) by A84,AMI_3:52;
        thus IExec(WB1,s).a4=IExec(IF1,t1).a4 by SCMPDS_5:39
              .=IExec(i5 ';' i6,t1).a4 by A104,SCMPDS_6:87
              .=Exec(i6,t5).a4 by SCMPDS_5:47
              .=t5.a4 by A107,SCMPDS_2:60
              .=t01.a4+-1 by A79,SCMPDS_2:60
              .=s.a4-1 by A102;
         A108:  a7<>DataLoc(t01.a,4) by A79,AMI_3:52;
        thus IExec(WB1,s).a7=IExec(IF1,t1).a7 by SCMPDS_5:39
              .=IExec(i5 ';' i6,t1).a7 by A104,SCMPDS_6:87
              .=Exec(i6,t5).a7 by SCMPDS_5:47
              .=t5.a7+ -1 by A84,SCMPDS_2:60
              .=t5.a7-1
              .=s.a5-1 by A77,A108,SCMPDS_2:60;
      end;
      hereby
        assume s.intpos md >= s.intpos me;
        then A109: t1.DataLoc(t1.a,6) <= 0 by A101,REAL_2:106;
        thus IExec(WB1,s).a5=IExec(IF1,t1).a5 by SCMPDS_5:39
              .=IExec(i7,t1).a5 by A109,SCMPDS_6:88
              .=Exec(ii7,t01).a5 by SCMPDS_5:45
              .=0 by A78,SCMPDS_2:58;
         A110:  a4<>DataLoc(t01.a,5) by A78,AMI_3:52;
        thus IExec(WB1,s).a4=IExec(IF1,t1).a4 by SCMPDS_5:39
              .=IExec(i7,t1).a4 by A109,SCMPDS_6:88
              .=Exec(ii7,t01).a4 by SCMPDS_5:45
              .=s.a4 by A102,A110,SCMPDS_2:58;
         A111:  a7<>DataLoc(t01.a,5) by A78,AMI_3:52;
         thus IExec(WB1,s).a7=IExec(IF1,t1).a7 by SCMPDS_5:39
              .=IExec(i7,t1).a7 by A109,SCMPDS_6:88
              .=Exec(ii7,t01).a7 by SCMPDS_5:45
              .=s.a5 by A77,A111,SCMPDS_2:58;
      end;
end;

Lm9:
 for s being State of SCMPDS,m4,md be Element of NAT st s.GBP=0 & s.a5 > 0
 & s.a4=m4+s.a5 & m4>=8 & s.a2=md & md >= 8 holds IExec(WH1,s).GBP=0 &
  IExec(WH1,s).a1=s.a1 & IExec(WH1,s).a5=0 &
  IExec(WH1,s).a2=s.a2 & IExec(WH1,s).a3=s.a3 &
  (for i be Element of NAT st i >= 8 holds IExec(WH1,s).intpos i=s.intpos i) &
  ex mE be Element of NAT st mE=IExec(WH1,s).a7 & IExec(WH1,s).a4=m4+mE &
  mE <= s.a5 & (for i be Element of NAT st m4+mE < i & i <=s.a4 holds
     IExec(WH1,s).intpos md < IExec(WH1,s).intpos i) &
     (mE = 0 or IExec(WH1,s).intpos md >= IExec(WH1,s).intpos(m4+mE))
proof
    let s be State of SCMPDS,m4,md be Element of NAT;
    assume A1: s.GBP=0 & s.a5 > 0 & s.a4=m4+s.a5 & m4>=8 &
           s.a2=md & md >= 8;
    set a=GBP;
    defpred P[Element of NAT] means
     for t being State of SCMPDS st
   t.a=0 & t.a5 =$1+1 & t.a4=m4+t.a5 & t.a2=md holds IExec(WH1,t).a=0 &
  IExec(WH1,t).a1=t.a1 & IExec(WH1,t).a5=0 &
  IExec(WH1,t).a2=t.a2 & IExec(WH1,t).a3=t.a3 &
 (for i be Element of NAT st i >= 8 holds IExec(WH1,t).intpos i=t.intpos i) &
 ex mE be Element of NAT st mE=IExec(WH1,t).a7 & IExec(WH1,t).a4=m4+mE &
 mE <= t.a5 &
   (for i be Element of NAT st m4+mE < i & i <=t.a4 holds
     IExec(WH1,t).intpos md < IExec(WH1,t).intpos i) &
     (mE=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+mE));
        now
       let t be State of SCMPDS;
       set b=DataLoc(t.a,5);
       assume A2: t.a=0 & t.a5 =0+1 & t.a4=m4+t.a5 & t.a2=md;
   set me=m4+1;
            me>=m4 by NAT_1:11;
then A3:    me>=8 by A1,XXREAL_0:2;
A4:    b=intpos (0+5) by A2,SCMP_GCD:5;
A5:    now let v be State of SCMPDS;
           assume A6: v.a4 >= m4+v.b & v.a2=t.a2 & v.a=t.a & v.b > 0;
               then A7: m4+v.b>m4+0 by XREAL_1:8;
               then A8: v.a4 >=m4 by A6,XXREAL_0:2;
                   v.a4 > 0 by A6,A7;
               then reconsider ME=v.a4 as Element of NAT by INT_1:16;
           A9: ME >= 8 by A1,A8,XXREAL_0:2;
           then A10: (v.intpos md < v.intpos ME implies IExec(WB1,v).a5=v.a5-1
&
               IExec(WB1,v).a4=v.a4-1 & IExec(WB1,v).a7=v.a5-1) &
               (v.intpos md >= v.intpos ME implies IExec(WB1,v).a5=0 &
               IExec(WB1,v).a4=v.a4 & IExec(WB1,v).a7=v.a5)
               by A1,A2,A4,A6,Lm8;
          thus IExec(WB1,v).a=v.a by A1,A2,A4,A6,A9,Lm8;
          thus WB1 is_closed_on v & WB1 is_halting_on v by SCMPDS_6:34,
35;
          hereby
              per cases;
              suppose A11: v.intpos md < v.intpos ME;
             hence IExec(WB1,v).b < v.b by A4,A10,XREAL_1:148;
                    m4+v.b-1=m4+IExec(WB1,v).b by A4,A10,A11;
             hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A6,A10,A11,
XREAL_1:11
;
              end;
              suppose A12:v.intpos md >= v.intpos ME;
             hence IExec(WB1,v).b < v.b by A1,A2,A4,A6,A9,Lm8;
                     m4+IExec(WB1,v).b < m4+v.b by A4,A6,A10,A12,XREAL_1:8;
              hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A6,A10,A12,
XXREAL_0:2
;
          end;
          end;
          thus IExec(WB1,v).a2=v.a2 by A1,A2,A4,A6,A9,Lm8;
        end;
       set It=IExec(WB1,t);
A13:    It.a=0 & It.a1=t.a1 & It.a2=t.a2 & It.a3=t.a3 &
       (for i be Element of NAT st i >= 8 holds It.intpos i=t.intpos i) &
       (t.intpos md < t.intpos me implies It.a5=t.a5-1 &
         It.a4=t.a4-1 & It.a7=t.a5-1) &
       (t.intpos md >= t.intpos me implies It.a5=0 &
         It.a4=t.a4 & It.a7=t.a5) by A1,A2,A3,Lm8;
then A14:  It.DataLoc(It.a,5)=0 by  SCMP_GCD:5,A2;
A15:  now let x;
           thus IExec(WH1,t).x =IExec(WH1,It).x by A2,A4,A5,Lm7,Th5
             .=It.x by A14,SCMPDS_8:23;
     end;
     hence IExec(WH1,t).a=0 by A13;
     thus IExec(WH1,t).a1=t.a1 by A13,A15;
     thus IExec(WH1,t).a5=0 by A2,A13,A15;
     thus IExec(WH1,t).a2=t.a2 by A13,A15;
     thus IExec(WH1,t).a3=t.a3 by A13,A15;
A16:  now let i be Element of NAT;
           assume A17: i >= 8;
           thus IExec(WH1,t).intpos i=It.intpos i by A15
           .=t.intpos i by A1,A2,A3,A17,Lm8;
       end;
    hence for i be Element of NAT st i >= 8
    holds IExec(WH1,t).intpos i=t.intpos i;
A18:    IExec(WH1,t).intpos me=t.intpos me by A3,A16;
       hereby
           per cases;
           suppose A19: t.intpos md < t.intpos me;
             take ME=0;
           thus IExec(WH1,t).a7=ME by A2,A13,A15,A19;
           thus IExec(WH1,t).a4=m4+ME by A2,A13,A15,A19;
             thus ME <= t.a5 by A2;
             hereby
                 let i be Element of NAT;
                 assume A20: m4+ME < i & i <=t.a4;
                 then m4+1 <= i by INT_1:20;
             then i=m4+1 by A2,A20,XXREAL_0:1;
              hence IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A1,A16
,A18,A19;
             end;
             thus
                  ME=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+ME)
;

           end;
           suppose A21: t.intpos md >= t.intpos me;
             take ME=1;
           thus IExec(WH1,t).a7=ME by A2,A13,A15,A21;
          thus IExec(WH1,t).a4=m4+ME by A2,A13,A15,A21;
            thus ME <= t.a5 by A2;
             thus for i be Element of NAT st m4+ME < i & i <=t.a4
                 holds IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A2;
             thus ME=0 or IExec(WH1,t).intpos md >=
               IExec(WH1,t).intpos (m4+ME) by A1,A16,A18,A21;
       end;
       end;
    end;
then A22: P[0];
A23: now
       let k be Element of NAT;
       assume A24:P[k];
          now
       let t be State of SCMPDS;
       set b=DataLoc(t.a,5);
       assume A25: t.a=0 & t.a5 =(k+1)+1 & t.a4=m4+t.a5 & t.a2=md;
      set me=m4+(k+1+1);
            me>=m4 by NAT_1:11;
then A26:    me>=8 by A1,XXREAL_0:2;
A27:    b=intpos (0+5) by A25,SCMP_GCD:5;
A28:    now let v be State of SCMPDS;
           assume A29: v.a4 >= m4+v.b & v.a2=t.a2 & v.a=t.a & v.b > 0;
               then A30: m4+v.b>m4+0 by XREAL_1:8;
               then A31: v.a4 >=m4 by A29,XXREAL_0:2;
                   v.a4 > 0 by A29,A30;
               then reconsider ME=v.a4 as Element of NAT by INT_1:16;
           A32: ME >= 8 by A1,A31,XXREAL_0:2;
           then A33: (v.intpos md < v.intpos ME implies IExec(WB1,v).a5=v.a5-1
&
               IExec(WB1,v).a4=v.a4-1 & IExec(WB1,v).a7=v.a5-1) &
               (v.intpos md >= v.intpos ME implies IExec(WB1,v).a5=0 &
               IExec(WB1,v).a4=v.a4 & IExec(WB1,v).a7=v.a5)
               by A1,A25,A27,A29,Lm8;
          thus IExec(WB1,v).a=v.a by A1,A25,A27,A29,A32,Lm8;
          thus WB1 is_closed_on v & WB1 is_halting_on v by SCMPDS_6:34,
35;
          hereby
              per cases;
              suppose A34:v.intpos md < v.intpos ME;
             hence IExec(WB1,v).b < v.b by A27,A33,XREAL_1:148;
                    m4+v.b-1=m4+IExec(WB1,v).b by A27,A33,A34;
             hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A29,A33,A34,
XREAL_1:11;
              end;
              suppose A35:v.intpos md >= v.intpos ME;
             hence IExec(WB1,v).b < v.b by A1,A25,A27,A29,A32,Lm8;
                     m4+IExec(WB1,v).b < m4+v.b by A27,A29,A33,A35,XREAL_1:8;
              hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A29,A33,A35,
XXREAL_0:2;
          end;
          end;
          thus IExec(WB1,v).a2=v.a2 by A1,A25,A27,A29,A32,Lm8;
        end;
       set It=IExec(WB1,t);
A36:    It.a=0 & It.a1=t.a1 & It.a2=t.a2 & It.a3=t.a3 &
       (for i be Element of NAT st i >= 8 holds It.intpos i=t.intpos i) &
       (t.intpos md < t.intpos me implies It.a5=t.a5-1 &
         It.a4=t.a4-1 & It.a7=t.a5-1) &
       (t.intpos md >= t.intpos me implies It.a5=0 &
         It.a4=t.a4 & It.a7=t.a5) by A1,A25,A26,Lm8;
then A37:  DataLoc(It.a,5)=intpos(0+5) by SCMP_GCD:5;
     per cases;
     suppose A38: t.intpos md < t.intpos me;
     A39:  It.a4=t.a4-1 by A1,A25,A26,A38,Lm8;
     A40:  It.a4=m4+It.a5 by A25,A36,A38;
     A41:  IExec(WH1,t)=IExec(WH1,It) by A25,A27,A28,Lm7,Th5;
     hence IExec(WH1,t).a=0 by A24,A25,A36,A40;
     thus IExec(WH1,t).a1=t.a1 by A24,A25,A36,A40,A41;
     thus IExec(WH1,t).a5=0 by A24,A25,A36,A40,A41;
     thus IExec(WH1,t).a2=t.a2 by A24,A25,A36,A40,A41;
     thus IExec(WH1,t).a3=t.a3 by A24,A25,A36,A40,A41;
     A42:  now let i be Element of NAT;
             assume A43: i >= 8;
             hence IExec(WH1,t).intpos i=It.intpos i by A24,A25,A36,A40,A41
              .=t.intpos i by A1,A25,A26,A43,Lm8;
          end;
       hence for i be Element of NAT st i >= 8
       holds IExec(WH1,t).intpos i=t.intpos i;
          consider mE be Element of NAT such that
      A44:  mE=IExec(WH1,It).a7 & IExec(WH1,It).a4=m4+mE & mE <= It.a5 &
           (for i be Element of NAT st m4+mE < i & i <=It.a4 holds
           IExec(WH1,It).intpos md < IExec(WH1,It).intpos i) &
           (mE=0 or IExec(WH1,It).intpos md >= IExec(WH1,It).intpos (m4+mE))
            by A24,A25,A36,A40;
            take mE;
      thus mE=IExec(WH1,t).a7 by A25,A27,A28,A44,Lm7,Th5;
      thus IExec(WH1,t).a4=m4+mE by A25,A27,A28,A44,Lm7,Th5;
                 It.a5 < t.a5 by A36,A38,XREAL_1:148;
      hence mE <= t.a5 by A44,XXREAL_0:2;
            hereby
               let i be Element of NAT;
               assume A45: m4+mE < i & i <=t.a4;
               per cases;
               suppose A46: i=t.a4;
                     IExec(WH1,t).intpos me =t.intpos me by A26,A42;
             hence IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A1,A25,A38
,A42,A46;

               end;
               suppose i<>t.a4;
                  then i < t.a4 by A45,REAL_1:def 5;
                  then i+1 <= t.a4 by INT_1:20;
                  then i <= It.a4 by A39,XREAL_1:21;
              hence IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A41,A44
,A45;
           end;
           end;
           thus mE=0 or
            IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+mE) by A41,A44;

   end;
   suppose A47: t.intpos md >= t.intpos me;
A48:    now let x;
           thus IExec(WH1,t).x =IExec(WH1,It).x by A25,A27,A28,Lm7,Th5
             .=It.x by A36,A37,A47,SCMPDS_8:23;
       end;
      hence IExec(WH1,t).a=0 by A36;
      thus IExec(WH1,t).a1=t.a1 by A36,A48;
      thus IExec(WH1,t).a5=0 by A36,A47,A48;
      thus IExec(WH1,t).a2=t.a2 by A36,A48;
      thus IExec(WH1,t).a3=t.a3 by A36,A48;
A49:    now let i be Element of NAT;
           assume A50: i >= 8;
           thus IExec(WH1,t).intpos i=It.intpos i by A48
           .=t.intpos i by A1,A25,A26,A50,Lm8;
       end;
    hence for i be Element of NAT st i >= 8
    holds IExec(WH1,t).intpos i=t.intpos i;
A51:    IExec(WH1,t).intpos me=t.intpos me by A26,A49;
       take ME=k+1+1;
       thus IExec(WH1,t).a7=ME by A25,A36,A47,A48;
       thus IExec(WH1,t).a4=m4+ME by A25,A36,A47,A48;
       thus ME <= t.a5 by A25;
       thus for i be Element of NAT st m4+ME < i & i <=t.a4 &
          not IExec(WH1,t).intpos md < IExec(WH1,t).intpos i
            holds contradiction by A25;
         thus ME=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+ME)
          by A1,A47,A49,A51;
     end;
     end;
     hence P[k+1];
    end;
A52: for k be Element of NAT holds P[k] from NAT_1:sch 1(A22,A23);
         s.a5 >=1+0 by A1,INT_1:20;
    then s.a5-1 >= 0 by XREAL_1:50;
    then reconsider m5=s.a5-1 as Element of NAT by INT_1:16;
     s.a5=m5+1;
    hence thesis by A1,A52;
end;

Lm10:
 for s being State of SCMPDS,m4,md be Element of NAT st s.GBP=0 & s.a5 > 0
 & s.a4=m4+s.a5 & m4>=8 & s.a2=md & md >= 8 holds
   WH1 is_closed_on s & WH1 is_halting_on s
proof
    let s be State of SCMPDS,m4,md be Element of NAT;
    assume A1: s.GBP=0 & s.a5 > 0 & s.a4=m4+s.a5 & m4>=8 &
           s.a2=md & md >= 8;
    set a=GBP;
    set b=DataLoc(s.a,5);
A2:  b=intpos (0+5) by A1,SCMP_GCD:5;
      now let v be State of SCMPDS;
           assume A3: v.a4 >= m4+v.b & v.a2=s.a2 & v.a=s.a & v.b > 0;
               then A4: m4+v.b>m4+0 by XREAL_1:8;
               then A5: v.a4 >=m4 by A3,XXREAL_0:2;
                   v.a4 > 0 by A3,A4;
               then reconsider ME=v.a4 as Element of NAT by INT_1:16;
           A6: ME >= 8 by A1,A5,XXREAL_0:2;
           then A7: (v.intpos md < v.intpos ME implies IExec(WB1,v).a5=v.a5-1 &
               IExec(WB1,v).a4=v.a4-1 & IExec(WB1,v).a7=v.a5-1) &
               (v.intpos md >= v.intpos ME implies IExec(WB1,v).a5=0 &
               IExec(WB1,v).a4=v.a4 & IExec(WB1,v).a7=v.a5)
               by A1,A2,A3,Lm8;
          thus IExec(WB1,v).a=v.a by A1,A2,A3,A6,Lm8;
          thus WB1 is_closed_on v & WB1 is_halting_on v by SCMPDS_6:34,
35;
          hereby
              per cases;
              suppose A8: v.intpos md < v.intpos ME;
             hence IExec(WB1,v).b < v.b by A2,A7,XREAL_1:148;
                    m4+v.b-1=m4+IExec(WB1,v).b by A2,A7,A8;
             hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A3,A7,A8,XREAL_1:11
;
              end;
              suppose A9:v.intpos md >= v.intpos ME;
             hence IExec(WB1,v).b < v.b by A1,A2,A3,A6,Lm8;
                     m4+IExec(WB1,v).b < m4+v.b by A2,A3,A7,A9,XREAL_1:8;
              hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A3,A7,A9,XXREAL_0:2
;
          end;
          end;
          thus IExec(WB1,v).a2=v.a2 by A1,A2,A3,A6,Lm8;
     end;
     hence thesis by A1,A2,Lm7,Th5;
end;

Lm11:
  card WH1=11
proof
   thus card WH1=9+2 by Lm7,SCMPDS_8:17
      .=11;
end;

Lm12:
  card WB2=9
proof
   thus card WB2= card (j1 ';' j2 ';' j3 ';' j4) + card IF2 by SCMPDS_4:45
      .= 4+card IF2 by Th4
      .= 4+(card (j5 ';' j6) +card j7+2) by SCMPDS_6:79
      .= 4+(2+card j7+2) by SCMP_GCD:9
      .= 4+(2+1+2) by SCMPDS_5:6
      .= 9;
end;

Lm13:
  card WH2=11
proof
   thus card WH2= 9+2 by Lm12,SCMPDS_8:17
      .=11;
end;

Lm14:
  for s being State of SCMPDS,md,me be Element of NAT st s.a2=md & s.a3=me &
  md >= 8 & me >= 8 & s.GBP=0 & s.a7 > 0 holds
  IExec(WB2,s).GBP=0 & IExec(WB2,s).a1=s.a1 &
  IExec(WB2,s).a2=s.a2 & IExec(WB2,s).a4=s.a4 &
  (for i be Element of NAT st i >= 8 holds IExec(WB2,s).intpos i=s.intpos i) &
  (s.intpos md > s.intpos me implies IExec(WB2,s).a7=s.a7-1 &
  IExec(WB2,s).a3=s.a3+1 & IExec(WB2,s).a5=s.a7-1) &
  (s.intpos md <= s.intpos me implies IExec(WB2,s).a7=0 &
  IExec(WB2,s).a3=s.a3 & IExec(WB2,s).a5=s.a7)
proof
   let s be State of SCMPDS,md,me be Element of NAT;
   set a=GBP;
   assume A1: s.a2=md & s.a3=me & md >= 8 & me >= 8 & s.a=0 & s.a7 > 0;
   set t0=Initialized s,
       t1=IExec(j1 ';' j2 ';' j3 ';' j4,s),
       t2=IExec(j1 ';' j2 ';' j3,s),
       t3=IExec(j1 ';' j2,s),
       t4=Exec(j1, t0);
A2: t0.a=0 by A1,SCMPDS_5:40;
A3: t0.a1=s.a1 by SCMPDS_5:40;
A4: t0.a2=md by A1,SCMPDS_5:40;
A5: t0.a4=s.a4 by SCMPDS_5:40;
A6: t0.a3=me by A1,SCMPDS_5:40;
A7: t0.a7=s.a7 by SCMPDS_5:40;

A8:  DataLoc(t0.a,5)=intpos (0+5) by A2,SCMP_GCD:5;
     then a<>DataLoc(t0.a,5) by AMI_3:52;
then A9: t4.a =0 by A2,SCMPDS_2:59;
          a1<>DataLoc(t0.a,5) by A8,AMI_3:52;
then A10: t4.a1 =s.a1 by A3,SCMPDS_2:59;
          a2<>DataLoc(t0.a,5) by A8,AMI_3:52;
then A11: t4.a2 =md by A4,SCMPDS_2:59;
          a4<>DataLoc(t0.a,5) by A8,AMI_3:52;
then A12: t4.a4 =s.a4 by A5,SCMPDS_2:59;
      a3<>DataLoc(t0.a,5) by A8,AMI_3:52;
then A13: t4.a3 =me by A6,SCMPDS_2:59;
          a7<>DataLoc(t0.a,5) by A8,AMI_3:52;
then A14: t4.a7 =s.a7 by A7,SCMPDS_2:59;
      DataLoc(t0.a,7)=intpos (0+7) by A2,SCMP_GCD:5;
then A15: t4.a5 =s.a7 by A7,A8,SCMPDS_2:59;
A16: now let i be Element of NAT;
        assume i>=8;
        then i > 5 by XXREAL_0:2;
    then intpos i <> DataLoc(t0.a,5) by A8,AMI_3:52;
        hence t4.intpos i=t0.intpos i by SCMPDS_2:59
          .=s.intpos i by SCMPDS_5:40;
     end;

A17:  DataLoc(t4.a,7)=intpos (0+7) by A9,SCMP_GCD:5;
then A18:  a<>DataLoc(t4.a,7) by AMI_3:52;
A19: t3.a =Exec(j2, t4).a by SCMPDS_5:47
     .=0 by A9,A18,SCMPDS_2:60;
A20:  a1<>DataLoc(t4.a,7) by A17,AMI_3:52;
A21: t3.a1 =Exec(j2, t4).a1 by SCMPDS_5:47
     .=s.a1 by A10,A20,SCMPDS_2:60;
A22:  a2<>DataLoc(t4.a,7) by A17,AMI_3:52;
A23: t3.a2 =Exec(j2, t4).a2 by SCMPDS_5:47
     .=md by A11,A22,SCMPDS_2:60;
A24:  a4<>DataLoc(t4.a,7) by A17,AMI_3:52;
A25: t3.a4 =Exec(j2, t4).a4 by SCMPDS_5:47
     .=s.a4 by A12,A24,SCMPDS_2:60;
A26:  a3<>DataLoc(t4.a,7) by A17,AMI_3:52;
A27: t3.a3 =Exec(j2, t4).a3 by SCMPDS_5:47
     .=me by A13,A26,SCMPDS_2:60;
A28: t3.a7 =Exec(j2, t4).a7 by SCMPDS_5:47
     .=t4.a7+ -1 by A17,SCMPDS_2:60
     .=s.a7-1 by A14;
A29:  a5<>DataLoc(t4.a,7) by A17,AMI_3:52;
A30: t3.a5 =Exec(j2, t4).a5 by SCMPDS_5:47
     .=s.a7 by A15,A29,SCMPDS_2:60;
A31: now let i be Element of NAT;
        assume A32:i>=8;
        then i > 7 by XXREAL_0:2;
    then A33: intpos i <> DataLoc(t4.a,7) by A17,AMI_3:52;
    thus t3.intpos i =Exec(j2, t4).intpos i by SCMPDS_5:47
          .=t4.intpos i by A33,SCMPDS_2:60
          .=s.intpos i by A16,A32;
      end;

A34:  DataLoc(t3.a,6)=intpos (0+6) by A19,SCMP_GCD:5;
then A35:  a<>DataLoc(t3.a,6) by AMI_3:52;
A36: t2.a =Exec(j3, t3).a by SCMPDS_5:46
     .=0 by A19,A35,SCMPDS_2:59;
A37:  a1<>DataLoc(t3.a,6) by A34,AMI_3:52;
A38: t2.a1 =Exec(j3, t3).a1 by SCMPDS_5:46
     .=s.a1 by A21,A37,SCMPDS_2:59;
A39:  a2<>DataLoc(t3.a,6) by A34,AMI_3:52;
A40: t2.a2 =Exec(j3, t3).a2 by SCMPDS_5:46
     .=md by A23,A39,SCMPDS_2:59;
A41:  a4<>DataLoc(t3.a,6) by A34,AMI_3:52;
A42: t2.a4 =Exec(j3, t3).a4 by SCMPDS_5:46
     .=s.a4 by A25,A41,SCMPDS_2:59;
A43:  a3<>DataLoc(t3.a,6) by A34,AMI_3:52;
A44: t2.a3 =Exec(j3, t3).a3 by SCMPDS_5:46
     .=me by A27,A43,SCMPDS_2:59;
A45:  a7<>DataLoc(t3.a,6) by A34,AMI_3:52;
A46: t2.a7 =Exec(j3, t3).a7 by SCMPDS_5:46
     .=s.a7-1 by A28,A45,SCMPDS_2:59;
A47:  DataLoc(t3.a2,0)=intpos (md+0) by A23,SCMP_GCD:5;
A48: t2.a6 =Exec(j3, t3).a6 by SCMPDS_5:46
     .=t3.intpos md by A34,A47,SCMPDS_2:59
     .=s.intpos md by A1,A31;
A49:  a5<>DataLoc(t3.a,6) by A34,AMI_3:52;
A50: t2.a5 =Exec(j3, t3).a5 by SCMPDS_5:46
     .=s.a7 by A30,A49,SCMPDS_2:59;
A51: now let i be Element of NAT;
        assume A52:i>=8;
        then i > 6 by XXREAL_0:2;
    then A53: intpos i <> DataLoc(t3.a,6) by A34,AMI_3:52;
        thus t2.intpos i=Exec(j3, t3).intpos i by SCMPDS_5:46
        .=t3.intpos i by A53,SCMPDS_2:59
        .=s.intpos i by A31,A52;
     end;

A54:  DataLoc(t2.a,6)=intpos (0+6) by A36,SCMP_GCD:5;
then A55:  a<>DataLoc(t2.a,6) by AMI_3:52;
A56: t1.a =Exec(j4, t2).a by SCMPDS_5:46
     .=0 by A36,A55,SCMPDS_2:62;
A57:  a1<>DataLoc(t2.a,6) by A54,AMI_3:52;
A58: t1.a1 =Exec(j4, t2).a1 by SCMPDS_5:46
     .=s.a1 by A38,A57,SCMPDS_2:62;
A59:  a2<>DataLoc(t2.a,6) by A54,AMI_3:52;
A60: t1.a2 =Exec(j4, t2).a2 by SCMPDS_5:46
     .=md by A40,A59,SCMPDS_2:62;
A61:  a4<>DataLoc(t2.a,6) by A54,AMI_3:52;
A62: t1.a4 =Exec(j4, t2).a4 by SCMPDS_5:46
     .=s.a4 by A42,A61,SCMPDS_2:62;
A63:  a3<>DataLoc(t2.a,6) by A54,AMI_3:52;
A64: t1.a3 =Exec(j4, t2).a3 by SCMPDS_5:46
     .=me by A44,A63,SCMPDS_2:62;
A65:  a7<>DataLoc(t2.a,6) by A54,AMI_3:52;
A66: t1.a7 =Exec(j4, t2).a7 by SCMPDS_5:46
     .=s.a7-1 by A46,A65,SCMPDS_2:62;
A67: t1.a6 =Exec(j4, t2).a6 by SCMPDS_5:46
     .=t2.a6-t2.DataLoc(t2.a3,0) by A54,SCMPDS_2:62
     .=t2.a6-t2.intpos(me+0) by A44,SCMP_GCD:5
     .=s.intpos md - s.intpos me by A1,A48,A51;
A68:  a5<>DataLoc(t2.a,6) by A54,AMI_3:52;
A69: t1.a5 =Exec(j4, t2).a5 by SCMPDS_5:46
     .=s.a7 by A50,A68,SCMPDS_2:62;
A70: now let i be Element of NAT;
        assume A71:i>=8;
        then i > 6 by XXREAL_0:2;
    then A72: intpos i <> DataLoc(t2.a,6) by A54,AMI_3:52;
        thus t1.intpos i=Exec(j4, t2).intpos i by SCMPDS_5:46
        .=t2.intpos i by A72,SCMPDS_2:62
        .=s.intpos i by A51,A71;
     end;

     set t01=Initialized t1,
         jj7= (GBP,7):=0,
         t5=Exec(j5,t01);
A73: t01.a=0 by A56,SCMPDS_5:40;
A74: t01.a1=s.a1 by A58,SCMPDS_5:40;
A75: t01.a2=s.a2 by A1,A60,SCMPDS_5:40;
A76: t01.a4=s.a4 by A62,SCMPDS_5:40;
A77: t01.a5=s.a7 by A69,SCMPDS_5:40;
A78:  DataLoc(t01.a,7)=intpos(0+7) by A73,SCMP_GCD:5;
A79:  DataLoc(t01.a,3)=intpos(0+3) by A73,SCMP_GCD:5;
     then a<>DataLoc(t01.a,3) by AMI_3:52;
then A80: t5.a=0 by A73,SCMPDS_2:60;
          a1<>DataLoc(t01.a,3) by A79,AMI_3:52;
then A81: t5.a1=s.a1 by A74,SCMPDS_2:60;
          a2<>DataLoc(t01.a,3) by A79,AMI_3:52;
then A82: t5.a2=s.a2 by A75,SCMPDS_2:60;
          a4<>DataLoc(t01.a,3) by A79,AMI_3:52;
then A83: t5.a4=s.a4 by A76,SCMPDS_2:60;
A84:  DataLoc(t5.a,5)=intpos(0+5) by A80,SCMP_GCD:5;

A85:  now
         per cases;
         suppose A86: t1.DataLoc(t1.a,6) <= 0;
         A87:  a<>DataLoc(t01.a,7) by A78,AMI_3:52;
         thus IExec(IF2,t1).a=IExec(j7,t1).a by A86,SCMPDS_6:88
              .=Exec(jj7,t01).a by SCMPDS_5:45
              .=0 by A73,A87,SCMPDS_2:58;
         A88:  a1<>DataLoc(t01.a,7) by A78,AMI_3:52;
         thus IExec(IF2,t1).a1=IExec(j7,t1).a1 by A86,SCMPDS_6:88
              .=Exec(jj7,t01).a1 by SCMPDS_5:45
              .=s.a1 by A74,A88,SCMPDS_2:58;
         A89:  a2<>DataLoc(t01.a,7) by A78,AMI_3:52;
         thus IExec(IF2,t1).a2=IExec(j7,t1).a2 by A86,SCMPDS_6:88
              .=Exec(jj7,t01).a2 by SCMPDS_5:45
              .=s.a2 by A75,A89,SCMPDS_2:58;
         A90:  a4<>DataLoc(t01.a,7) by A78,AMI_3:52;
         thus IExec(IF2,t1).a4=IExec(j7,t1).a4 by A86,SCMPDS_6:88
              .=Exec(jj7,t01).a4 by SCMPDS_5:45
              .=s.a4 by A76,A90,SCMPDS_2:58;
         hereby let i be Element of NAT;
              assume A91:i>=8;
                then i > 7 by XXREAL_0:2;
            then A92: intpos i <> DataLoc(t01.a,7) by A78,AMI_3:52;
        thus IExec(WB2,s).intpos i=IExec(IF2,t1).intpos i by SCMPDS_5:39
              .=IExec(j7,t1).intpos i by A86,SCMPDS_6:88
              .=Exec(jj7,t01).intpos i by SCMPDS_5:45
              .=t01.intpos i by A92,SCMPDS_2:58
              .=t1.intpos i by SCMPDS_5:40
              .=s.intpos i by A70,A91;
        end;

         end;
         suppose A93: t1.DataLoc(t1.a,6) > 0;
          A94: a<>DataLoc(t5.a,5) by A84,AMI_3:52;
         thus IExec(IF2,t1).a=IExec(j5 ';' j6,t1).a by A93,SCMPDS_6:87
              .=Exec(j6,t5).a by SCMPDS_5:47
              .=0 by A80,A94,SCMPDS_2:60;
         A95:  a1<>DataLoc(t5.a,5) by A84,AMI_3:52;
         thus IExec(IF2,t1).a1=IExec(j5 ';' j6,t1).a1 by A93,SCMPDS_6:87
              .=Exec(j6,t5).a1 by SCMPDS_5:47
              .=s.a1 by A81,A95,SCMPDS_2:60;
         A96:  a2<>DataLoc(t5.a,5) by A84,AMI_3:52;
         thus IExec(IF2,t1).a2=IExec(j5 ';' j6,t1).a2 by A93,SCMPDS_6:87
              .=Exec(j6,t5).a2 by SCMPDS_5:47
              .=s.a2 by A82,A96,SCMPDS_2:60;
         A97:  a4<>DataLoc(t5.a,5) by A84,AMI_3:52;
         thus IExec(IF2,t1).a4=IExec(j5 ';' j6,t1).a4 by A93,SCMPDS_6:87
              .=Exec(j6,t5).a4 by SCMPDS_5:47
              .=s.a4 by A83,A97,SCMPDS_2:60;
         hereby let i be Element of NAT;
              assume A98:i>=8;
                then i > 5 by XXREAL_0:2;
            then A99: intpos i <> DataLoc(t5.a,5) by A84,AMI_3:52;
                     i > 3 by A98,XXREAL_0:2;
            then A100: intpos i<>DataLoc(t01.a,3) by A79,AMI_3:52;
        thus IExec(WB2,s).intpos i=IExec(IF2,t1).intpos i by SCMPDS_5:39
              .=IExec(j5 ';' j6,t1).intpos i by A93,SCMPDS_6:87
              .=Exec(j6,t5).intpos i by SCMPDS_5:47
              .=t5.intpos i by A99,SCMPDS_2:60
              .=t01.intpos i by A100,SCMPDS_2:60
              .=t1.intpos i by SCMPDS_5:40
              .=s.intpos i by A70,A98;
        end;
     end;
     end;
     hence IExec(WB2,s).a=0 & IExec(WB2,s).a1=s.a1 &
        IExec(WB2,s).a2=s.a2 & IExec(WB2,s).a4=s.a4 by SCMPDS_5:39;
   thus for i be Element of NAT st i >= 8
   holds IExec(WB2,s).intpos i=s.intpos i by A85;
A101:  t1.DataLoc(t1.a,6)=s.intpos md - s.intpos me by  A56,SCMP_GCD:5,A67;
A102: t01.a3=s.a3 by A1,A64,SCMPDS_5:40;
A103: t01.a7=s.a7-1 by A66,SCMPDS_5:40;
      hereby
        assume s.intpos md > s.intpos me;
         then A104: t1.DataLoc(t1.a,6) > 0 by A101,XREAL_1:52;
         A105:  a7<>DataLoc(t01.a,3) by A79,AMI_3:52;
         A106:  a7<>DataLoc(t5.a,5) by A84,AMI_3:52;
        thus IExec(WB2,s).a7=IExec(IF2,t1).a7 by SCMPDS_5:39
              .=IExec(j5 ';' j6,t1).a7 by A104,SCMPDS_6:87
              .=Exec(j6,t5).a7 by SCMPDS_5:47
              .=t5.a7 by A106,SCMPDS_2:60
               .=s.a7-1 by A103,A105,SCMPDS_2:60;
         A107:  a3<>DataLoc(t5.a,5) by A84,AMI_3:52;
        thus IExec(WB2,s).a3=IExec(IF2,t1).a3 by SCMPDS_5:39
              .=IExec(j5 ';' j6,t1).a3 by A104,SCMPDS_6:87
              .=Exec(j6,t5).a3 by SCMPDS_5:47
              .=t5.a3 by A107,SCMPDS_2:60
              .=s.a3+1 by A79,A102,SCMPDS_2:60;
         A108:  a5<>DataLoc(t01.a,3) by A79,AMI_3:52;
        thus IExec(WB2,s).a5=IExec(IF2,t1).a5 by SCMPDS_5:39
              .=IExec(j5 ';' j6,t1).a5 by A104,SCMPDS_6:87
              .=Exec(j6,t5).a5 by SCMPDS_5:47
              .=t5.a5+ -1 by A84,SCMPDS_2:60
              .=t5.a5-1
              .=s.a7-1 by A77,A108,SCMPDS_2:60;
      end;
      hereby
        assume s.intpos md <= s.intpos me;
        then A109: t1.DataLoc(t1.a,6) <= 0 by A101,REAL_2:106;
        thus IExec(WB2,s).a7=IExec(IF2,t1).a7 by SCMPDS_5:39
              .=IExec(j7,t1).a7 by A109,SCMPDS_6:88
              .=Exec(jj7,t01).a7 by SCMPDS_5:45
              .=0 by A78,SCMPDS_2:58;
         A110:  a3<>DataLoc(t01.a,7) by A78,AMI_3:52;
        thus IExec(WB2,s).a3=IExec(IF2,t1).a3 by SCMPDS_5:39
              .=IExec(j7,t1).a3 by A109,SCMPDS_6:88
              .=Exec(jj7,t01).a3 by SCMPDS_5:45
              .=s.a3 by A102,A110,SCMPDS_2:58;
         A111:  a5<>DataLoc(t01.a,7) by A78,AMI_3:52;
         thus IExec(WB2,s).a5=IExec(IF2,t1).a5 by SCMPDS_5:39
              .=IExec(j7,t1).a5 by A109,SCMPDS_6:88
              .=Exec(jj7,t01).a5 by SCMPDS_5:45
              .=s.a7 by A77,A111,SCMPDS_2:58;
      end;
end;

Lm15:
 for s being State of SCMPDS,m3,md be Element of NAT st s.GBP=0 & s.a7 > 0
 & s.a3+s.a7=m3 & s.a3>=8 & s.a2=md & md >= 8 holds IExec(WH2,s).GBP=0 &
  IExec(WH2,s).a1=s.a1 & IExec(WH2,s).a7=0 &
  IExec(WH2,s).a2=s.a2 & IExec(WH2,s).a4=s.a4 &
  (for i be Element of NAT st i >= 8 holds IExec(WH2,s).intpos i=s.intpos i) &
  ex m5,mE3 be Element of NAT st m5=IExec(WH2,s).a5 & IExec(WH2,s).a3=mE3 &
  mE3+m5=m3 & m5 <= s.a7 &
  (for i be Element of NAT st s.a3 <= i & i < mE3 holds
     IExec(WH2,s).intpos md > IExec(WH2,s).intpos i) &
     (m5 = 0 or IExec(WH2,s).intpos md <= IExec(WH2,s).intpos mE3)
proof
    let s be State of SCMPDS,m3,md be Element of NAT;
    set a=GBP;
    assume A1: s.a=0 & s.a7 > 0 & s.a3+s.a7=m3 & s.a3>=8 & s.a2=md
          & md >= 8;

    defpred P[Element of NAT] means
    for t being State of SCMPDS st t.a=0 & t.a7 =$1+1 & t.a3+t.a7=m3 &
     t.a3>=8 & t.a2=md holds IExec(WH2,t).a=0 & IExec(WH2,t).a1=t.a1 &
     IExec(WH2,t).a7=0 & IExec(WH2,t).a2=t.a2 & IExec(WH2,t).a4=t.a4 &
     (for i be Element of NAT st i >= 8
     holds IExec(WH2,t).intpos i=t.intpos i) &
 ex m5,mE3 be Element of NAT st m5=IExec(WH2,t).a5 & IExec(WH2,t).a3=mE3 &
   mE3+m5=m3 & m5 <= t.a7 & (for i be Element of NAT st t.a3 <= i & i < mE3
   holds
     IExec(WH2,t).intpos md > IExec(WH2,t).intpos i) &
     (m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3);
          now
       let t be State of SCMPDS;
       set b=DataLoc(t.a,7);
       assume A2: t.a=0 & t.a7 =0+1 & t.a3+t.a7=m3 & t.a3>=8 & t.a2=md;
       then t.a3 >= 0;
       then reconsider me=t.a3 as Element of NAT by INT_1:16;
A3:    me=t.a3;
A4:    b=intpos (0+7) by A2,SCMP_GCD:5;
A5:    now let v be State of SCMPDS;
           assume A6: v.a3 >= 8 & v.a2=t.a2 & v.a=t.a & v.b > 0;
               then v.a3 > 0;
               then reconsider ME=v.a3 as Element of NAT by INT_1:16;
           A7: ME=v.a3;
           A8: (v.intpos md > v.intpos ME implies IExec(WB2,v).a7=v.a7-1 &
               IExec(WB2,v).a3=v.a3+1 & IExec(WB2,v).a5=v.a7-1) &
               (v.intpos md <= v.intpos ME implies IExec(WB2,v).a7=0 &
               IExec(WB2,v).a3=v.a3 & IExec(WB2,v).a5=v.a7)
               by A1,A2,A4,A6,Lm14;
           thus IExec(WB2,v).a=v.a by A1,A2,A4,A6,A7,Lm14;
           thus WB2 is_closed_on v & WB2 is_halting_on v by SCMPDS_6:34,
35;
           hereby
              per cases;
              suppose A9: v.intpos md > v.intpos ME;
             hence IExec(WB2,v).b < v.b by A4,A8,XREAL_1:148;
               A10: IExec(WB2,v).a3=v.a3+1 by A1,A2,A4,A6,A9,Lm14;
                        v.a3 +1 > v.a3 by XREAL_1:31;
             hence IExec(WB2,v).a3 >= 8 by A6,A10,XXREAL_0:2;
              end;
              suppose A11:v.intpos md <= v.intpos ME;
              hence IExec(WB2,v).b < v.b by A1,A2,A4,A6,Lm14;
              thus IExec(WB2,v).a3 >= 8 by A1,A2,A4,A6,A11,Lm14;
           end;
           end;
           thus IExec(WB2,v).a2=v.a2 by A1,A2,A4,A6,A7,Lm14;
        end;
       set It=IExec(WB2,t);
A12:    It.a=0 & It.a1=t.a1 & It.a2=t.a2 & It.a4=t.a4 &
       (for i be Element of NAT st i >= 8 holds It.intpos i=t.intpos i) &
       (t.intpos md > t.intpos me implies It.a7=t.a7-1 &
         It.a3=t.a3+1 & It.a5=t.a7-1) &
       (t.intpos md <= t.intpos me implies It.a7=0 &
         It.a3=t.a3 & It.a5=t.a7) by A1,A2,A3,Lm14;
then A13:  It.DataLoc(It.a,7)=0 by  SCMP_GCD:5,A2;
A14:  now let x;
           thus IExec(WH2,t).x =IExec(WH2,It).x by A2,A4,A5,Lm12,Th6
             .=It.x by A13,SCMPDS_8:23;
     end;
     hence IExec(WH2,t).a=0 by A12;
     thus IExec(WH2,t).a1=t.a1 by A12,A14;
     thus IExec(WH2,t).a7=0 by A2,A12,A14;
     thus IExec(WH2,t).a2=t.a2 by A12,A14;
     thus IExec(WH2,t).a4=t.a4 by A12,A14;
A15:  now let i be Element of NAT;
           assume A16: i >= 8;
           thus IExec(WH2,t).intpos i=It.intpos i by A14
           .=t.intpos i by A1,A2,A3,A16,Lm14;
       end;
    hence for i be Element of NAT st i >= 8
    holds IExec(WH2,t).intpos i=t.intpos i;
A17:    IExec(WH2,t).intpos me=t.intpos me by A2,A15;
       hereby
           per cases;
           suppose A18: t.intpos md > t.intpos me;
             take m5=0;
             take mE3=m3;
           thus IExec(WH2,t).a5=m5 by A2,A12,A14,A18;
           thus IExec(WH2,t).a3 =mE3 by A2,A12,A14,A18;
           thus mE3+m5=m3;
           thus m5 <= t.a7 by A2;
            hereby
                 let i be Element of NAT;
                 assume A19: t.a3 <= i & i < mE3;
                 then i <= me by A2,NAT_1:13;
             then i=t.a3 by A19,XXREAL_0:1;
             hence IExec(WH2,t).intpos md > IExec(WH2,t).intpos i by A1,A15,A17
,A18;
           end;
             thus
                  m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3;

           end;
           suppose A20: t.intpos md <= t.intpos me;
             take m5=1;
             take mE3=me;
           thus IExec(WH2,t).a5=m5 by A2,A12,A14,A20;
          thus IExec(WH2,t).a3=mE3 by A12,A14,A20;
           thus mE3+m5=m3 by A2;
           thus m5 <= t.a7 by A2;
           thus for i be Element of NAT st t.a3 <= i & i < mE3
                 holds IExec(WH2,t).intpos md > IExec(WH2,t).intpos i;
            thus m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3
               by A1,A15,A17,A20;
       end;
       end;
    end;
then A21: P[0];
A22: now
       let k be Element of NAT;
       assume A23:P[k];
          now
       let t be State of SCMPDS;
       set b=DataLoc(t.a,7);
       assume A24: t.a=0 & t.a7 =(k+1)+1 & t.a3+t.a7=m3 & t.a3>=8 & t.a2=md;
       then t.a3 >= 0;
       then reconsider me=t.a3 as Element of NAT by INT_1:16;
A25:    me=t.a3;
A26:    b=intpos (0+7) by A24,SCMP_GCD:5;
A27:    t.a7 >= 1 by A24,NAT_1:11;
A28:    t.b > 0 by A26,A27;
A29:    now let v be State of SCMPDS;
           assume A30: v.a3 >= 8 & v.a2=t.a2 & v.a=t.a & v.b > 0;
               then v.a3 > 0;
               then reconsider ME=v.a3 as Element of NAT by INT_1:16;
           A31: ME=v.a3;
           A32: (v.intpos md > v.intpos ME implies IExec(WB2,v).a7=v.a7-1 &
               IExec(WB2,v).a3=v.a3+1 & IExec(WB2,v).a5=v.a7-1) &
               (v.intpos md <= v.intpos ME implies IExec(WB2,v).a7=0 &
               IExec(WB2,v).a3=v.a3 & IExec(WB2,v).a5=v.a7)
               by A1,A24,A26,A30,Lm14;
           thus IExec(WB2,v).a=v.a by A1,A24,A26,A30,A31,Lm14;
           thus WB2 is_closed_on v & WB2 is_halting_on v by SCMPDS_6:34,
35;
           hereby
              per cases;
              suppose A33: v.intpos md > v.intpos ME;
             hence IExec(WB2,v).b < v.b by A26,A32,XREAL_1:148;
               A34: IExec(WB2,v).a3=v.a3+1 by A1,A24,A26,A30,A33,Lm14;
                        v.a3 +1 > v.a3 by XREAL_1:31;
             hence IExec(WB2,v).a3 >= 8 by A30,A34,XXREAL_0:2;
              end;
              suppose A35:v.intpos md <= v.intpos ME;
              hence IExec(WB2,v).b < v.b by A1,A24,A26,A30,Lm14;
              thus IExec(WB2,v).a3 >= 8 by A1,A24,A26,A30,A35,Lm14;
           end;
           end;
           thus IExec(WB2,v).a2=v.a2 by A1,A24,A26,A30,A31,Lm14;
        end;
       set It=IExec(WB2,t);
A36:    It.a=0 & It.a1=t.a1 & It.a2=t.a2 & It.a4=t.a4 &
       (for i be Element of NAT st i >= 8 holds It.intpos i=t.intpos i) &
       (t.intpos md > t.intpos me implies It.a7=t.a7-1 &
         It.a3=t.a3+1 & It.a5=t.a7-1) &
       (t.intpos md <= t.intpos me implies It.a7=0 &
         It.a3=t.a3 & It.a5=t.a7) by A1,A24,A25,Lm14;
then A37:  DataLoc(It.a,7)=intpos(0+7) by SCMP_GCD:5;
     per cases;
     suppose A38: t.intpos md > t.intpos me;
     then A39:  It.a7=k+1 by A24,A36;
     A40:  It.a3=t.a3+1 by A1,A24,A38,Lm14;
               t.a3 < It.a3 by A36,A38,XREAL_1:31;
     then A41:  It.a3 >= 8 by A24,XXREAL_0:2;
     A42: It.a3+It.a7=m3 by A24,A36,A39;
     A43:  IExec(WH2,t)=IExec(WH2,It) by A24,A26,A29,Lm12,Th6;
     hence IExec(WH2,t).a=0 by A23,A24,A36,A41,A42;
     thus IExec(WH2,t).a1=t.a1 by A23,A24,A36,A41,A42,A43;
     thus IExec(WH2,t).a7=0 by A23,A24,A36,A41,A42,A43;
     thus IExec(WH2,t).a2=t.a2 by A23,A24,A36,A41,A42,A43;
     thus IExec(WH2,t).a4=t.a4 by A23,A24,A36,A41,A42,A43;
     A44:  now let i be Element of NAT;
             assume A45: i >= 8;
             hence IExec(WH2,t).intpos i=It.intpos i by A23,A24,A36,A41,A42
,A43
              .=t.intpos i by A1,A24,A25,A45,Lm14;
          end;
       hence for i be Element of NAT st i >= 8
       holds IExec(WH2,t).intpos i=t.intpos i;
          consider m5,mE3 be Element of NAT such that
      A46: m5=IExec(WH2,It).a5 & IExec(WH2,It).a3=mE3 & mE3+m5=m3 &
          m5 <= It.a7 & (for i be Element of NAT st It.a3 <= i & i < mE3 holds
          IExec(WH2,It).intpos md > IExec(WH2,It).intpos i) &
          (m5=0 or IExec(WH2,It).intpos md <= IExec(WH2,It).intpos mE3)
            by A23,A24,A36,A41,A42;
            take m5;
            take mE3;
      thus m5=IExec(WH2,t).a5 by A24,A28,A29,A46,Lm12,Th6;
      thus IExec(WH2,t).a3=mE3 by A24,A28,A29,A46,Lm12,Th6;
      thus mE3+m5=m3 by A46;
                 It.a7 < t.a7 by A36,A38,XREAL_1:148;
      hence m5 <= t.a7 by A46,XXREAL_0:2;
            hereby
               let i be Element of NAT;
               assume A47: t.a3 <= i & i < mE3;
               per cases;
               suppose A48: i=t.a3;
                     IExec(WH2,t).intpos me =t.intpos me by A24,A44;
             hence IExec(WH2,t).intpos md > IExec(WH2,t).intpos i by A1,A38,A44
,A48;

               end;
               suppose i<>t.a3;
                  then t.a3 < i by A47,REAL_1:def 5;
                  then It.a3 <= i by A40,INT_1:20;
              hence IExec(WH2,t).intpos md > IExec(WH2,t).intpos i by A43,A46
,A47;
           end;
           end;
           thus m5=0 or
            IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3 by A43,A46;

   end;
   suppose A49: t.intpos md <= t.intpos me;
A50:    now let x;
           thus IExec(WH2,t).x =IExec(WH2,It).x by A24,A26,A29,Lm12,Th6
             .=It.x by A36,A37,A49,SCMPDS_8:23;
       end;
      hence IExec(WH2,t).a=0 by A36;
      thus IExec(WH2,t).a1=t.a1 by A36,A50;
      thus IExec(WH2,t).a7=0 by A36,A49,A50;
      thus IExec(WH2,t).a2=t.a2 by A36,A50;
      thus IExec(WH2,t).a4=t.a4 by A36,A50;
A51:    now let i be Element of NAT;
           assume A52: i >= 8;
           thus IExec(WH2,t).intpos i=It.intpos i by A50
           .=t.intpos i by A1,A24,A25,A52,Lm14;
       end;
    hence for i be Element of NAT st i >= 8
    holds IExec(WH2,t).intpos i=t.intpos i;
A53:    IExec(WH2,t).intpos me=t.intpos me by A24,A51;
       take m5=k+1+1;
       take mE3=me;
       thus IExec(WH2,t).a5=m5 by A24,A36,A49,A50;
       thus IExec(WH2,t).a3=mE3 by A36,A49,A50;
      thus mE3+m5=m3 by A24;
       thus m5 <= t.a7 by A24;
       thus for i be Element of NAT st t.a3 <= i & i < mE3
         holds IExec(WH2,t).intpos md > IExec(WH2,t).intpos i;
       thus m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3
          by A1,A49,A51,A53;
     end;
     end;
     hence P[k+1];
    end;
A54: for k be Element of NAT holds P[k] from NAT_1:sch 1(A21,A22);
         s.a7 >=1+0 by A1,INT_1:20;
    then s.a7-1 >= 0 by XREAL_1:50;
    then reconsider m7=s.a7-1 as Element of NAT by INT_1:16;
     s.a7=m7+1;
    hence thesis by A1,A54;
end;

Lm16:
 for s being State of SCMPDS,md be Element of NAT st s.GBP=0 & s.a7 > 0 &
   s.a3>=8 & s.a2=md & md >= 8 holds
   WH2 is_closed_on s & WH2 is_halting_on s
proof
    let s be State of SCMPDS,md be Element of NAT;
    set a=GBP;
    set b=DataLoc(s.a,7);
    assume A1: s.a=0 & s.a7 > 0 & s.a3>=8 & s.a2=md & md >= 8;
then A2:  b=intpos (0+7) by SCMP_GCD:5;
      now let v be State of SCMPDS;
         assume A3: v.a3 >= 8 & v.a2=s.a2 & v.a=s.a & v.b > 0;
               then v.a3 > 0;
               then reconsider ME=v.a3 as Element of NAT by INT_1:16;
           A4: ME=v.a3;
           A5: (v.intpos md > v.intpos ME implies IExec(WB2,v).a7=v.a7-1 &
               IExec(WB2,v).a3=v.a3+1 & IExec(WB2,v).a5=v.a7-1) &
               (v.intpos md <= v.intpos ME implies IExec(WB2,v).a7=0 &
               IExec(WB2,v).a3=v.a3 & IExec(WB2,v).a5=v.a7)
               by A1,A2,A3,Lm14;
           thus IExec(WB2,v).a=v.a by A1,A2,A3,A4,Lm14;
           thus WB2 is_closed_on v & WB2 is_halting_on v by SCMPDS_6:34,
35;
           hereby
              per cases;
              suppose A6: v.intpos md > v.intpos ME;
             hence IExec(WB2,v).b < v.b by A2,A5,XREAL_1:148;
               A7: IExec(WB2,v).a3=v.a3+1 by A1,A2,A3,A6,Lm14;
                        v.a3 +1 > v.a3 by XREAL_1:31;
             hence IExec(WB2,v).a3 >= 8 by A3,A7,XXREAL_0:2;
              end;
              suppose A8:v.intpos md <= v.intpos ME;
              hence IExec(WB2,v).b < v.b by A1,A2,A3,Lm14;
              thus IExec(WB2,v).a3 >= 8 by A1,A2,A3,A8,Lm14;
           end;
           end;
           thus IExec(WB2,v).a2=v.a2 by A1,A2,A3,A4,Lm14;
    end;
    hence thesis by A1,Lm12,Th6;
end;

Lm17:
  card WB3=29
proof
   thus card WB3=card (WH1 ';' WH2 )+card IF3 by SCMPDS_4:45
    .=11+ 11+card IF3 by Lm11,Lm13,SCMPDS_4:45
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0)+1) by SCMPDS_6:89
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9)+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6 ';' k7 ';' k8)+1+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6 ';' k7)+1+1+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6)+1+1+1+1+1) by SCMP_GCD:8
    .=22+(2+1+1+1+1+1) by SCMP_GCD:9
    .=29;
end;

Lm18:
  card WH3=31
proof
   thus card WH3=29+2 by Lm17,SCMPDS_8:17
         .=31;
end;

begin :: The Basic Property of Partition Program

theorem Th12:
  card Partition=38
proof
  thus card Partition=card (K4 ';' WH3 ';' j8 ';' j9)+1 by SCMP_GCD:8
  .=card (K4 ';' WH3 ';' j8)+1+1 by SCMP_GCD:8
  .=card (K4 ';' WH3)+1+1+1 by SCMP_GCD:8
  .=card K4+card WH3+1+1+1 by SCMPDS_4:45
  .=4+31+1+1+1 by Lm18,Th4
  .=38;
end;

Lm19:
 for s be State of SCMPDS,m3,m4 be Element of NAT st s.GBP=0 & s.a5 > 0 &
 s.a3=m3 & s.a4=m4 & m3>6 & m4 > 6 holds
  IExec(IF3,s).GBP=0 & IExec(IF3,s).a1=s.a1 & IExec(IF3,s).a2=s.a2 &
  IExec(IF3,s).intpos m3=s.intpos m4 &
  IExec(IF3,s).intpos m4=s.intpos m3 & IExec(IF3,s).a3=s.a3+1 &
  IExec(IF3,s).a4=s.a4-1 & IExec(IF3,s).a5=s.a5-2 &
  for i be Element of NAT st i >= 8 & i <> m3 & i <> m4 holds
     IExec(IF3,s).intpos i=s.intpos i
proof
   let s be State of SCMPDS,m3,m4 be Element of NAT;
   set a=GBP;
   assume A1: s.a=0 & s.a5 > 0 & s.a3=m3 & s.a4=m4 & m3 > 6 & m4 > 6;
    then A2: DataLoc(s.a,5)=intpos(0+5) by SCMP_GCD:5;
    set x=intpos m3,
        y=intpos m4,
        t0=Initialized s,
        t1=IExec(k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0,s),
        t2=IExec(k5 ';' k6 ';' k7 ';' k8 ';' k9,s),
        t3=IExec(k5 ';' k6 ';' k7 ';' k8,s),
        t4=IExec(k5 ';' k6 ';' k7,s),
        t5=IExec(k5 ';' k6,s),
        t6=Exec(k5,t0);
A3:  m4 > 0 by A1;
A4:  m3 > 0 by A1;
A5:  m4 > 3 by A1,XXREAL_0:2;
A6:  m4 > 5 by A1,XXREAL_0:2;
A7:  m3 > 5 by A1,XXREAL_0:2;
A8:  m3 > 3 by A1,XXREAL_0:2;
A9: m3 > 4 by A1,XXREAL_0:2;
A10: m4 > 4 by A1,XXREAL_0:2;

A11: t0.a=0 by A1,SCMPDS_5:40;
A12: t0.a1=s.a1 by SCMPDS_5:40;
A13: t0.a2=s.a2 by SCMPDS_5:40;
A14: t0.a3=m3 by A1,SCMPDS_5:40;
A15: t0.a4=m4 by A1,SCMPDS_5:40;
A16: t0.a5=s.a5 by SCMPDS_5:40;
A17: t0.x=s.x by SCMPDS_5:40;

A18:  DataLoc(t0.a,6)=intpos (0+6) by A11,SCMP_GCD:5;
     then a<>DataLoc(t0.a,6) by AMI_3:52;
then A19: t6.a =0 by A11,SCMPDS_2:59;
          a1<>DataLoc(t0.a,6) by A18,AMI_3:52;
then A20: t6.a1 =s.a1 by A12,SCMPDS_2:59;
          a2<>DataLoc(t0.a,6) by A18,AMI_3:52;
then A21: t6.a2 =s.a2 by A13,SCMPDS_2:59;
          a3<>DataLoc(t0.a,6) by A18,AMI_3:52;
then A22: t6.a3 =m3 by A14,SCMPDS_2:59;
          a4<>DataLoc(t0.a,6) by A18,AMI_3:52;
then A23: t6.a4 =m4 by A15,SCMPDS_2:59;
          a5<>DataLoc(t0.a,6) by A18,AMI_3:52;
then A24: t6.a5 =s.a5 by A16,SCMPDS_2:59;
A25: t6.a6 =t0.DataLoc(t0.a4,0) by A18,SCMPDS_2:59
      .=t0.intpos(m4+0) by A15,SCMP_GCD:5
      .=s.y by SCMPDS_5:40;
     A26: x<>DataLoc(t0.a,6) by A1,A18,AMI_3:52;
A27: now
       let i be Element of NAT;
       assume i >= 8 & i <> m3 & i <> m4;
       then i > 6 by XXREAL_0:2;
       then intpos i<>DataLoc(t0.a,6) by A18,AMI_3:52;
       hence t6.intpos i =t0.intpos i by SCMPDS_2:59
        .=s.intpos i by SCMPDS_5:40;
     end;

A28:  DataLoc(t6.a4,0)=intpos (m4+0) by A23,SCMP_GCD:5;
then A29:  a<>DataLoc(t6.a4,0) by A3,AMI_3:52;
A30: t5.a =Exec(k6, t6).a by SCMPDS_5:47
     .=0 by A19,A29,SCMPDS_2:59;
          m4 > 1 by A1,XXREAL_0:2;
then A31:  a1<>DataLoc(t6.a4,0) by A28,AMI_3:52;
A32: t5.a1 =Exec(k6, t6).a1 by SCMPDS_5:47
     .=s.a1 by A20,A31,SCMPDS_2:59;
          m4 > 2 by A1,XXREAL_0:2;
then A33:  a2<>DataLoc(t6.a4,0) by A28,AMI_3:52;
A34: t5.a2 =Exec(k6, t6).a2 by SCMPDS_5:47
     .=s.a2 by A21,A33,SCMPDS_2:59;
A35:  a3<>DataLoc(t6.a4,0) by A5,A28,AMI_3:52;
A36: t5.a3 =Exec(k6, t6).a3 by SCMPDS_5:47
     .=m3 by A22,A35,SCMPDS_2:59;
A37:  a4<>DataLoc(t6.a4,0) by A10,A28,AMI_3:52;
A38: t5.a4 =Exec(k6, t6).a4 by SCMPDS_5:47
     .=m4 by A23,A37,SCMPDS_2:59;
A39:  a5<>DataLoc(t6.a4,0) by A6,A28,AMI_3:52;
A40: t5.a5 =Exec(k6, t6).a5 by SCMPDS_5:47
     .=s.a5 by A24,A39,SCMPDS_2:59;
A41:  a6<>DataLoc(t6.a4,0) by A1,A28,AMI_3:52;
A42: t5.a6 =Exec(k6, t6).a6 by SCMPDS_5:47
     .=s.y by A25,A41,SCMPDS_2:59;
A43: t5.y=Exec(k6, t6).y by SCMPDS_5:47
     .=t6.DataLoc(t6.a3,0) by A28,SCMPDS_2:59
     .=t6.intpos(m3+0) by A22,SCMP_GCD:5
     .=s.x by A17,A26,SCMPDS_2:59;
A44: now
       let i be Element of NAT;
       assume A45: i >= 8 & i <> m3 & i <> m4;
   then A46: intpos i <> DataLoc(t6.a4,0) by A28,AMI_3:52;
       thus t5.intpos i =Exec(k6, t6).intpos i by SCMPDS_5:47
       .=t6.intpos i by A46,SCMPDS_2:59
       .=s.intpos i by A27,A45;
     end;

A47:  DataLoc(t5.a3,0)=intpos (m3+0) by A36,SCMP_GCD:5;
then A48:  a<>DataLoc(t5.a3,0) by A4,AMI_3:52;
A49: t4.a =Exec(k7, t5).a by SCMPDS_5:46
     .=0 by A30,A48,SCMPDS_2:59;
          m3 > 1 by A1,XXREAL_0:2;
then A50:  a1<>DataLoc(t5.a3,0) by A47,AMI_3:52;
A51: t4.a1 =Exec(k7, t5).a1 by SCMPDS_5:46
     .=s.a1 by A32,A50,SCMPDS_2:59;
          m3 > 2 by A1,XXREAL_0:2;
then A52:  a2<>DataLoc(t5.a3,0) by A47,AMI_3:52;
A53: t4.a2 =Exec(k7, t5).a2 by SCMPDS_5:46
     .=s.a2 by A34,A52,SCMPDS_2:59;
A54:  a3<>DataLoc(t5.a3,0) by A8,A47,AMI_3:52;
A55: t4.a3 =Exec(k7, t5).a3 by SCMPDS_5:46
     .=m3 by A36,A54,SCMPDS_2:59;
A56:  a4<>DataLoc(t5.a3,0) by A9,A47,AMI_3:52;
A57: t4.a4 =Exec(k7, t5).a4 by SCMPDS_5:46
     .=m4 by A38,A56,SCMPDS_2:59;
A58:  a5<>DataLoc(t5.a3,0) by A7,A47,AMI_3:52;
A59: t4.a5 =Exec(k7, t5).a5 by SCMPDS_5:46
     .=s.a5 by A40,A58,SCMPDS_2:59;
A60:  t5.DataLoc(t5.a,6)=s.y by  A30,SCMP_GCD:5,A42;
A61: t4.x=Exec(k7, t5).x by SCMPDS_5:46
     .=s.y by A47,A60,SCMPDS_2:59;
A62: now
        per cases;
        suppose A63: y<>DataLoc(t5.a3,0);
         thus t4.y =Exec(k7, t5).y by SCMPDS_5:46
           .=s.x by A43,A63,SCMPDS_2:59;
        end;
        suppose A64: y=DataLoc(t5.a3,0);
         thus t4.y =Exec(k7, t5).y by SCMPDS_5:46
           .=s.x by A47,A60,A64,SCMPDS_2:59;
      end;
      end;
A65: now
       let i be Element of NAT;
       assume A66: i >= 8 & i <> m3 & i <> m4;
   then A67: intpos i <> DataLoc(t5.a3,0) by A47,AMI_3:52;
       thus t4.intpos i =Exec(k7, t5).intpos i by SCMPDS_5:46
       .=t5.intpos i by A67,SCMPDS_2:59
       .=s.intpos i by A44,A66;
     end;

A68:  DataLoc(t4.a,5)=intpos (0+5) by A49,SCMP_GCD:5;
then A69:  a<>DataLoc(t4.a,5) by AMI_3:52;
A70: t3.a =Exec(k8, t4).a by SCMPDS_5:46
     .=0 by A49,A69,SCMPDS_2:60;
A71:  a1<>DataLoc(t4.a,5) by A68,AMI_3:52;
A72: t3.a1 =Exec(k8, t4).a1 by SCMPDS_5:46
     .=s.a1 by A51,A71,SCMPDS_2:60;
A73:  a2<>DataLoc(t4.a,5) by A68,AMI_3:52;
A74: t3.a2 =Exec(k8, t4).a2 by SCMPDS_5:46
     .=s.a2 by A53,A73,SCMPDS_2:60;
A75:  a3<>DataLoc(t4.a,5) by A68,AMI_3:52;
A76: t3.a3 =Exec(k8, t4).a3 by SCMPDS_5:46
     .=m3 by A55,A75,SCMPDS_2:60;
A77:  a4<>DataLoc(t4.a,5) by A68,AMI_3:52;
A78: t3.a4 =Exec(k8, t4).a4 by SCMPDS_5:46
     .=m4 by A57,A77,SCMPDS_2:60;
A79: t3.a5 =Exec(k8, t4).a5 by SCMPDS_5:46
     .=t4.a5+-2 by A68,SCMPDS_2:60
     .=s.a5-2 by A59;
A80:  x<>DataLoc(t4.a,5) by A7,A68,AMI_3:52;
A81: t3.x =Exec(k8, t4).x by SCMPDS_5:46
     .=s.y by A61,A80,SCMPDS_2:60;
A82:  y<>DataLoc(t4.a,5) by A6,A68,AMI_3:52;
A83: t3.y =Exec(k8, t4).y by SCMPDS_5:46
     .=s.x by A62,A82,SCMPDS_2:60;
A84: now
       let i be Element of NAT;
       assume A85: i >= 8 & i <> m3 & i <> m4;
       then i > 5 by XXREAL_0:2;
   then A86: intpos i <> DataLoc(t4.a,5) by A68,AMI_3:52;
       thus t3.intpos i =Exec(k8, t4).intpos i by SCMPDS_5:46
       .=t4.intpos i by A86,SCMPDS_2:60
       .=s.intpos i by A65,A85;
     end;

A87:  DataLoc(t3.a,3)=intpos (0+3) by A70,SCMP_GCD:5;
then A88:  a<>DataLoc(t3.a,3) by AMI_3:52;
A89: t2.a =Exec(k9, t3).a by SCMPDS_5:46
     .=0 by A70,A88,SCMPDS_2:60;
A90:  a2<>DataLoc(t3.a,3) by A87,AMI_3:52;
A91: t2.a2 =Exec(k9, t3).a2 by SCMPDS_5:46
     .=s.a2 by A74,A90,SCMPDS_2:60;
A92:  a1<>DataLoc(t3.a,3) by A87,AMI_3:52;
A93: t2.a1 =Exec(k9, t3).a1 by SCMPDS_5:46
     .=s.a1 by A72,A92,SCMPDS_2:60;
A94: t2.a3 =Exec(k9, t3).a3 by SCMPDS_5:46
     .=m3+1 by A76,A87,SCMPDS_2:60;
A95:  a4<>DataLoc(t3.a,3) by A87,AMI_3:52;
A96: t2.a4 =Exec(k9, t3).a4 by SCMPDS_5:46
     .=m4 by A78,A95,SCMPDS_2:60;
A97:  a5<>DataLoc(t3.a,3) by A87,AMI_3:52;
A98: t2.a5 =Exec(k9, t3).a5 by SCMPDS_5:46
     .=s.a5-2 by A79,A97,SCMPDS_2:60;
A99:  x<>DataLoc(t3.a,3) by A8,A87,AMI_3:52;
A100: t2.x =Exec(k9, t3).x by SCMPDS_5:46
     .=s.y by A81,A99,SCMPDS_2:60;
A101:  y<>DataLoc(t3.a,3) by A5,A87,AMI_3:52;
A102: t2.y =Exec(k9, t3).y by SCMPDS_5:46
     .=s.x by A83,A101,SCMPDS_2:60;
A103: now
       let i be Element of NAT;
       assume A104: i >= 8 & i <> m3 & i <> m4;
       then i > 3 by XXREAL_0:2;
   then A105: intpos i <> DataLoc(t3.a,3) by A87,AMI_3:52;
       thus t2.intpos i =Exec(k9, t3).intpos i by SCMPDS_5:46
       .=t3.intpos i by A105,SCMPDS_2:60
       .=s.intpos i by A84,A104;
     end;

A106:  DataLoc(t2.a,4)=intpos (0+4) by A89,SCMP_GCD:5;
then A107:  a<>DataLoc(t2.a,4) by AMI_3:52;
A108: t1.a =Exec(k0, t2).a by SCMPDS_5:46
     .=0 by A89,A107,SCMPDS_2:60;
A109:  a1<>DataLoc(t2.a,4) by A106,AMI_3:52;
A110: t1.a1 =Exec(k0, t2).a1 by SCMPDS_5:46
     .=s.a1 by A93,A109,SCMPDS_2:60;
A111:  a2<>DataLoc(t2.a,4) by A106,AMI_3:52;
A112: t1.a2 =Exec(k0, t2).a2 by SCMPDS_5:46
     .=s.a2 by A91,A111,SCMPDS_2:60;
A113:  a3<>DataLoc(t2.a,4) by A106,AMI_3:52;
A114: t1.a3 =Exec(k0, t2).a3 by SCMPDS_5:46
     .=m3+1 by A94,A113,SCMPDS_2:60;
A115: t1.a4 =Exec(k0, t2).a4 by SCMPDS_5:46
     .=t2.a4+-1 by A106,SCMPDS_2:60
     .=s.a4-1 by A1,A96;
A116:  a5<>DataLoc(t2.a,4) by A106,AMI_3:52;
A117: t1.a5 =Exec(k0, t2).a5 by SCMPDS_5:46
     .=s.a5-2 by A98,A116,SCMPDS_2:60;
A118:  x<>DataLoc(t2.a,4) by A9,A106,AMI_3:52;
A119: t1.x =Exec(k0, t2).x by SCMPDS_5:46
     .=s.y by A100,A118,SCMPDS_2:60;
A120:  y<>DataLoc(t2.a,4) by A10,A106,AMI_3:52;
A121: t1.y =Exec(k0, t2).y by SCMPDS_5:46
     .=s.x by A102,A120,SCMPDS_2:60;
A122: now
       let i be Element of NAT;
       assume A123: i >= 8 & i <> m3 & i <> m4;
       then i > 4 by XXREAL_0:2;
   then A124: intpos i <> DataLoc(t2.a,4) by A106,AMI_3:52;
       thus t1.intpos i =Exec(k0, t2).intpos i by SCMPDS_5:46
       .=t2.intpos i by A124,SCMPDS_2:60
       .=s.intpos i by A103,A123;
     end;
    thus IExec(IF3,s).a=0 by A1,A2,A108,SCMPDS_6:97;
    thus IExec(IF3,s).a1=s.a1 by A1,A2,A110,SCMPDS_6:97;
    thus IExec(IF3,s).a2=s.a2 by A1,A2,A112,SCMPDS_6:97;
    thus IExec(IF3,s).x=s.y by A1,A2,A119,SCMPDS_6:97;
    thus IExec(IF3,s).y=s.x by A1,A2,A121,SCMPDS_6:97;
    thus IExec(IF3,s).a3=s.a3+1 by A1,A2,A114,SCMPDS_6:97;
    thus IExec(IF3,s).a4=s.a4-1 by A1,A2,A115,SCMPDS_6:97;
    thus IExec(IF3,s).a5=s.a5-2 by A1,A2,A117,SCMPDS_6:97;
    hereby
       let i be Element of NAT;
       assume A125: i >= 8 & i <> m3 & i <> m4;
       thus IExec(IF3,s).intpos i = t1.intpos i by A1,A2,SCMPDS_6:97
        .=s.intpos i by A122,A125;
    end;
end;

Lm20:
 for s be State of SCMPDS,md,m3 be Element of NAT st s.GBP=0 & s.a5 > 0 &
 s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= 8 & md <= m3
 holds WB3 is_closed_on s & WB3 is_halting_on s &
  IExec(WB3,s).GBP=0 & IExec(WB3,s).a1=s.a1 &
  IExec(WB3,s).a2=md & IExec(WB3,s).a3 >= s.a3 &
  IExec(WB3,s).a4 <= s.a4 & IExec(WB3,s).a4 >= m3 &
  IExec(WB3,s).a5 < s.a5 & IExec(WB3,s).a5 >= -1 &
  IExec(WB3,s).a4=IExec(WB3,s).a3-1+IExec(WB3,s).a5 &
  ex n1,n2 be Element of NAT st n1=IExec(WB3,s).a3-1 & n2=IExec(WB3,s).a4+1 &
   (for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds
       IExec(WB3,s).intpos i=s.intpos i) &
  (IExec(WB3,s).intpos n1=s.intpos n1 & IExec(WB3,s).intpos n2=s.intpos n2 or
  n1 >= s.a3 & n2 <= s.a4 &
  IExec(WB3,s).intpos n1=s.intpos n2 & IExec(WB3,s).intpos n2=s.intpos n1) &
  (for i be Element of NAT st s.a3<=i & i <= n1 holds
   IExec(WB3,s).intpos md >= IExec(WB3,s).intpos i) &
   (for i be Element of NAT st n2<=i & i <= s.a4 holds
   IExec(WB3,s).intpos md <= IExec(WB3,s).intpos i)
proof
   let s be State of SCMPDS,md,m3 be Element of NAT;
   set a=GBP;
   assume A1: s.a=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 &
       s.a2=md & md >= 8 & md <= m3;
     set s1=IExec(WH1,s);
A2:  m3 >= 8 by A1,XXREAL_0:2;
then A3:  s1.a=0 & s1.a1=s.a1 & s1.a5=0 & s1.a2=s.a2 & s1.a3=s.a3 &
     (for i be Element of NAT st i >= 8 holds s1.intpos i=s.intpos i)
     by A1,Lm9;
     consider mE be Element of NAT such that
A4:  mE=s1.a7 & s1.a4=m3+mE & mE <= s.a5 &
     (for i be Element of NAT st m3+mE < i & i <=s.a4
     holds s1.intpos md < s1.intpos i)
     & (mE = 0 or s1.intpos md >= s1.intpos(m3+mE)) by A1,A2,Lm9;
A5:  WH1 is_closed_on s & WH1 is_halting_on s by A1,A2,Lm10;
     set s2=IExec(WH2,s1),
         sm=m3+1+mE,
         s12=IExec(WH1 ';' WH2,s),
         s3=IExec(WB3,s),
         m4=m3+mE;
  s1.a3=m3+1 by A1,A2,Lm9;
     then m3 < s1.a3 by XREAL_1:31;
then A6:  s1.a3 >= 8 by A2,XXREAL_0:2;
A7:  s1.a3+s1.a7=sm by A1,A2,A4,Lm9;
     A8: m3+mE <= m3+s.a5 by A4,XREAL_1:8;
A9:  m4 >= 8 by A2,NAT_1:12;

     per cases;
     suppose A10: mE <= 0;
       A11: DataLoc(s1.a,7)=intpos(0+7) by A3,SCMP_GCD:5;
then A12:    WH2 is_closed_on s1 & WH2 is_halting_on s1 by A4,A10,SCMPDS_8:20;
then A13:    WH1 ';' WH2 is_closed_on s & WH1 ';' WH2 is_halting_on s
         by A5,SCMPDS_7:43;
    hence WB3 is_closed_on s & WB3 is_halting_on s by SCPISORT:9;
A14:    mE=0 by A10;
A15:    s12.a=s2.a by A5,A12,SCMPDS_7:49
       .=0 by A3,A4,A10,A11,SCMPDS_8:23;
A16:    s12.a5=s2.a5 by A5,A12,SCMPDS_7:49
       .=0 by A3,A4,A10,A11,SCMPDS_8:23;
       A17: DataLoc(s12.a,5)=intpos(0+5) by A15,SCMP_GCD:5;
     thus IExec(WB3,s).a=IExec(IF3,s12).a by A13,SCPISORT:7
             .=0 by A15,A16,A17,SCMPDS_6:98;
     thus IExec(WB3,s).a1=IExec(IF3,s12).a1 by A13,SCPISORT:7
             .= s12.a1 by A16,A17,SCMPDS_6:98
             .= s2.a1 by A5,A12,SCMPDS_7:49
             .= s.a1 by A3,A4,A10,A11,SCMPDS_8:23;
     thus s3.a2=IExec(IF3,s12).a2 by A13,SCPISORT:7
             .= s12.a2 by A16,A17,SCMPDS_6:98
             .= s2.a2 by A5,A12,SCMPDS_7:49
             .= md by A1,A3,A4,A10,A11,SCMPDS_8:23;
     A18:   s3.a3=IExec(IF3,s12).a3 by A13,SCPISORT:7
             .= s12.a3 by A16,A17,SCMPDS_6:98
             .= s2.a3 by A5,A12,SCMPDS_7:49
             .= s.a3 by A3,A4,A10,A11,SCMPDS_8:23;
         hence s3.a3 >= s.a3;
     A19:   s3.a4=IExec(IF3,s12).a4 by A13,SCPISORT:7
             .= s12.a4 by A16,A17,SCMPDS_6:98
             .= s2.a4 by A5,A12,SCMPDS_7:49
             .= m4 by A4,A10,A11,SCMPDS_8:23;
         hence s3.a4 <= s.a4 by A1,A4,XREAL_1:8;
         thus s3.a4 >= m3 by A19,NAT_1:12;
     A20:   s3.a5=IExec(IF3,s12).a5 by A13,SCPISORT:7
             .=0 by A16,A17,SCMPDS_6:98;
         hence s3.a5 < s.a5 by A1;
         thus s3.a5 >= -1 by A20;
     thus s3.a4=s3.a3-1+s3.a5 by A1,A10,A18,A19,A20,XXREAL_0:1;
          take n1=m4;
          take n2=m4+1;
       thus n1=s3.a3-1 by A1,A14,A18;
       thus n2=s3.a4+1 by A19;
     A21: now
            let x;
            thus s3.x=IExec(IF3,s12).x by A13,SCPISORT:7
              .=s12.x by A16,A17,SCMPDS_6:98
              .=s2.x by A5,A12,SCMPDS_7:49;
         end;
     A22: now
            let i be Element of NAT;
            assume A23: i >= 8;
            thus s3.intpos i=s2.intpos i by A21
              .=s1.intpos i by A4,A10,A11,SCMPDS_8:23
              .=s.intpos i by A1,A2,A23,Lm9;
         end;
         hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds
             s3.intpos i=s.intpos i;
      A24: m4 < n2 by XREAL_1:31;
          then 8 < n2 by A9,XXREAL_0:2;
     hence s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or
        n1 >= s.a3 & n2 <= s.a4 &
        s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A9,A22;
     hereby
         let i be Element of NAT;
         assume A25: s.a3<=i & i <= n1;
         assume not s3.intpos md >= s3.intpos i;
                n1 < s.a3 by A1,A14,XREAL_1:148;
          hence contradiction by A25,XXREAL_0:2;
     end;
     hereby
         let i be Element of NAT;
         assume A26: n2<=i & i <= s.a4;
         then A27: m4 < i by A24,XXREAL_0:2;
        A28: s3.intpos md=s2.intpos md by A21
            .=s1.intpos md by A4,A10,A11,SCMPDS_8:23;
                 s3.intpos i=s2.intpos i by A21
            .=s1.intpos i by A4,A10,A11,SCMPDS_8:23;
         hence s3.intpos md <= s3.intpos i by A4,A26,A27,A28;
     end;

     end;
     suppose A29: mE > 0;
     then A30: m4 > m3+0 by XREAL_1:8;
then A31:  m4 >= m3+1 by INT_1:20;
A32: s2.a=0 & s2.a1=s1.a1 & s2.a7=0 & s2.a2=s1.a2 & s2.a4=s1.a4 &
    (for i be Element of NAT st i >= 8 holds s2.intpos i=s1.intpos i)
      by A1,A3,A6,A7,A29,Lm15;
     consider m5,mE3 be Element of NAT such that
A33:  m5=s2.a5 & s2.a3=mE3 & mE3+m5=sm & m5 <= s1.a7 &
     (for i be Element of NAT st s1.a3 <= i & i < mE3
     holds s2.intpos md > s2.intpos i)
     & (m5 = 0 or s2.intpos md <= s2.intpos mE3)
       by A1,A3,A4,A6,A29,Lm15;
A34:  WH2 is_closed_on s1 & WH2 is_halting_on s1 by A1,A3,A4,A6,A29,Lm16;
then A35:  WH1 ';' WH2 is_closed_on s & WH1 ';' WH2 is_halting_on s
      by A5,SCMPDS_7:43;
    hence WB3 is_closed_on s & WB3 is_halting_on s by SCPISORT:9;

A36:  s12.a=0 by A5,A32,A34,SCMPDS_7:49;
      A37: mE3+m5 <= mE3+s1.a7 by A33,XREAL_1:8;
     A38: s1.a3+s1.a7 <= mE3+s1.a7 by A1,A3,A4,A33,XREAL_1:8;
A39:  s1.a3 <= mE3 by A1,A3,A4,A33,A37,XREAL_1:8;
A40:  s.a3 <= mE3 by A3,A38,XREAL_1:8;
A41:  s12.a3=mE3 by A5,A33,A34,SCMPDS_7:49;
A42:  mE3 >= 8 by A3,A6,A40,XXREAL_0:2;
then A43:  mE3 > 6 by XXREAL_0:2;
A44:  s12.a4=m4 by A4,A5,A32,A34,SCMPDS_7:49;
A45:  m4 > 6 by A9,XXREAL_0:2;
A46:  s12.a2=md by A1,A3,A5,A32,A34,SCMPDS_7:49;
A47:  s12.a1=s.a1 by A3,A5,A32,A34,SCMPDS_7:49;
A48:  s12.a5=m5 by A5,A33,A34,SCMPDS_7:49;
     hereby
        per cases;
        suppose A49: s12.a5 > 0;
then A50:      IExec(IF3,s12).a=0 & IExec(IF3,s12).a1=s12.a1 &
         IExec(IF3,s12).a2=s12.a2 &
         IExec(IF3,s12).intpos mE3=s12.intpos m4 &
         IExec(IF3,s12).intpos m4=s12.intpos mE3 &
         IExec(IF3,s12).a3=s12.a3+1 & IExec(IF3,s12).a4=s12.a4-1 &
         IExec(IF3,s12).a5=s12.a5-2 &
          for i be Element of NAT st i >= 8 & i <> mE3 & i <> m4 holds
          IExec(IF3,s12).intpos i=s12.intpos i by A36,A41,A43,A44,A45,Lm19;
         hence IExec(WB3,s).a=0 by A35,SCPISORT:7;
         thus IExec(WB3,s).a1=s.a1 by A35,A47,A50,SCPISORT:7;
         thus s3.a2=md by A35,A46,A50,SCPISORT:7;
   A51:    s3.a3=mE3+1 by A35,A41,A50,SCPISORT:7;
             then mE3 < s3.a3 by XREAL_1:31;
         hence s3.a3 >= s.a3 by A3,A39,XXREAL_0:2;
   A52:    s3.a4=m4-1 by A35,A44,A50,SCPISORT:7;
             then s3.a4 < m4 by XREAL_1:148;
         hence s3.a4 <= s.a4 by A1,A8,XXREAL_0:2;
         thus s3.a4 >= m3 by A31,A52,XREAL_1:21;
  A53:      s3.a5 =s12.a5-2 by A35,A50,SCPISORT:7;
            m5 <= s.a5 by A4,A33,XXREAL_0:2;
           then m5-2 < s.a5-0 by REAL_1:92;
         hence s3.a5 < s.a5 by A5,A33,A34,A53,SCMPDS_7:49;
               s12.a5 >=0+1 by A49,INT_1:20;
          then A54: s12.a5-2 >= 1-2 by XREAL_1:11;
       hence
           s3.a5 >= -1 by A35,A50,SCPISORT:7;
     A55:  s3.a4=mE3+s3.a5 by  A35,A44,A50,SCPISORT:7,A33,A48,A53;
      hence s3.a4=s3.a3-1+s3.a5 by A51;

          take n1=mE3;
          take n2=m4;
          thus n1=s3.a3-1 by A51;
          thus
     A56:   n2=m4+-1+1
             .=s3.a4+1 by A35,A44,A50,SCPISORT:7;
     A57:   now
            let i be Element of NAT;
            assume A58: i >= 8;
            thus s12.intpos i=s2.intpos i by A5,A34,SCMPDS_7:49
              .=s1.intpos i by A1,A3,A6,A7,A29,A58,Lm15
              .=s.intpos i by A1,A2,A58,Lm9;
          end;
     A59:  now
            let i be Element of NAT;
            assume A60: i >= 8 & i <>n1 & i<> n2;
            thus s3.intpos i=IExec(IF3,s12).intpos i by A35,SCPISORT:7
              .=s12.intpos i by A36,A41,A43,A44,A45,A49,A60,Lm19
              .=s.intpos i by A57,A60;
          end;
      hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds
           s3.intpos i=s.intpos i;
      A61: s3.intpos n1=s12.intpos n2 by A35,A50,SCPISORT:7
          .=s.intpos n2 by A9,A57;
      A62: s3.intpos n2=s12.intpos n1 by A35,A50,SCPISORT:7
          .=s.intpos n1 by A42,A57;
       hence s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or
          s.a3 <= n1 & n2 <= s.a4 &
          s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A1,A3,A4,A38
,A61,XREAL_1:8;
               m3 < m3+1 by XREAL_1:31;
          then m3 < n1 by A1,A3,A39,XXREAL_0:2;
      then A63: md < n1 by A1,XXREAL_0:2;
      A64: n2=n1+(s3.a5+1) by A55,A56;
               s3.a5+1 >= -1+1 by A53,A54,XREAL_1:8;
      then A65: n2 >= n1+0 by A64,XREAL_1:8;
      then md < n2 by A63,XXREAL_0:2;
      then A66: n2 >= 8 by A1,XXREAL_0:2;
      A67: n1 >= 8 by A1,A63,XXREAL_0:2;
      A68: s3.intpos md=s.intpos md by A1,A59,A63,A65;
      A69: s2.intpos md=s1.intpos md by A1,A3,A6,A7,A29,Lm15
          .=s3.intpos md by A1,A2,A68,Lm9;
      A70: s1.intpos md=s3.intpos md by A1,A2,A68,Lm9;
      hereby
             let i be Element of NAT;
             assume A71: s.a3<=i & i <= n1;
          then A72: s1.a3 <= i by A1,A2,Lm9;
          A73: i >= 8 by A3,A6,A71,XXREAL_0:2;
           per cases;
           suppose A74: i < n1;
                      s2.intpos i=s1.intpos i by A1,A3,A6,A7,A29,A73,Lm15
                 .=s.intpos i by A1,A2,A73,Lm9
                 .=s3.intpos i by A59,A65,A73,A74;
             hence s3.intpos md >= s3.intpos i by A33,A69,A72,A74;
          end;
          suppose i >= n1;
             then i=n1 by A71,XXREAL_0:1;
              hence s3.intpos md >= s3.intpos i by A1,A2,A4,A29,A61,A66,A70,Lm9
;
       end;
       end;

       hereby let i be Element of NAT;
            assume A75: n2<=i & i <= s.a4;
          then A76: i >= 8 by A66,XXREAL_0:2;
          per cases;
           suppose A77: n2 < i;
                      s1.intpos i=s.intpos i by A1,A2,A76,Lm9
                 .=s3.intpos i by A59,A65,A76,A77;
             hence s3.intpos md <= s3.intpos i by A4,A70,A75,A77;
          end;
          suppose n2 >= i;
             then i=n2 by A75,XXREAL_0:1;
                then s3.intpos i=s1.intpos n1 by A1,A2,A62,A67,Lm9
                  .=s2.intpos n1 by A1,A3,A6,A7,A29,A67,Lm15;
              hence s3.intpos md <= s3.intpos i by A5,A33,A34,A49,A69,
SCMPDS_7:49;
       end;
       end;

       end;
       suppose A78: s12.a5 <= 0;
     A79:  DataLoc(s12.a,5)=intpos(0+5) by A36,SCMP_GCD:5;
         thus IExec(WB3,s).a=IExec(IF3,s12).a by A35,SCPISORT:7
             .=0 by A36,A78,A79,SCMPDS_6:98;
         thus IExec(WB3,s).a1=IExec(IF3,s12).a1 by A35,SCPISORT:7
             .= s.a1 by A47,A78,A79,SCMPDS_6:98;
         thus s3.a2=IExec(IF3,s12).a2 by A35,SCPISORT:7
             .= md by A46,A78,A79,SCMPDS_6:98;
     A80:   s3.a3=IExec(IF3,s12).a3 by A35,SCPISORT:7
             .= mE3 by A41,A78,A79,SCMPDS_6:98;
         hence s3.a3 >= s.a3 by A1,A4,A33,A37,XREAL_1:8;
     A81:   s3.a4=IExec(IF3,s12).a4 by A35,SCPISORT:7
             .= m4 by A44,A78,A79,SCMPDS_6:98;
         hence s3.a4 <= s.a4 by A1,A4,XREAL_1:8;
         thus s3.a4 >= m3 by A30,A81;
        A82:  s12.a5=0 by A48,A78;
        A83:  s3.a5=IExec(IF3,s12).a5 by A35,SCPISORT:7
             .=0 by A79,A82,SCMPDS_6:98;
         hence s3.a5 < s.a5 by A1;
         thus s3.a5 >= -1 by A83;
     A84:  m4=m3+mE+1-1
          .=mE3+0-1 by A5,A33,A34,A82,SCMPDS_7:49;
        hence s3.a4=s3.a3-1+s3.a5 by A80,A81,A83;

          take n1=m4;
          take n2=m4+1;
        thus n1=s3.a3-1 by A80,A84;
        thus n2=s3.a4+1 by A81;
     A85: now
            let x;
            thus s3.x=IExec(IF3,s12).x by A35,SCPISORT:7
              .=s12.x by A78,A79,SCMPDS_6:98
              .=s2.x by A5,A34,SCMPDS_7:49;
         end;
     A86: now
            let i be Element of NAT;
            assume A87: i >= 8;
            thus s3.intpos i=s2.intpos i by A85
              .=s1.intpos i by A1,A3,A6,A7,A29,A87,Lm15
              .=s.intpos i by A1,A2,A87,Lm9;
         end;
         hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds
             s3.intpos i=s.intpos i;
      A88: m4 < n2 by XREAL_1:31;
          then 8 < n2 by A9,XXREAL_0:2;
     hence s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or
        s.a3 <= n1 & n2 <= s.a4 &
        s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A9,A86;
     hereby
         let i be Element of NAT;
         assume A89: s.a3<=i & i <= n1;
                   mE3-1 < mE3 by XREAL_1:148;
              then i < mE3 by A84,A89,XXREAL_0:2;
          then A90: s2.intpos md > s2.intpos i by A3,A33,A89;
               s3.intpos md=s2.intpos md by A85;
          hence s3.intpos md >= s3.intpos i by A85,A90;
     end;
     hereby
         let i be Element of NAT;
         assume A91: n2<=i & i <= s.a4;
        then A92: m4 < i by A88,XXREAL_0:2;
        A93: s3.intpos md=s2.intpos md by A85
            .=s1.intpos md by A1,A3,A6,A7,A29,Lm15;
        A94: i >= 8 by A9,A92,XXREAL_0:2;
                 s3.intpos i=s2.intpos i by A85
            .=s1.intpos i by A1,A3,A6,A7,A29,A94,Lm15;
         hence s3.intpos md <= s3.intpos i by A4,A91,A92,A93;
     end;
   end;
   end;
end;
end;

Lm21:
 for i be Integer st i >= -1 & i <= 0 holds i=-1 or i=0
proof
   let i be Integer;
   assume A1: i >= -1 & i <= 0;
   per cases;
   suppose i <= -1;
    hence thesis by A1,XXREAL_0:1;
   end;
   suppose i > -1;
    then i >= -1+1 by INT_1:20;
    hence thesis by A1;
end;
end;

Lm22:
  for i1,i2 be Integer,n1,n2,i be Element of NAT
  st i1 >= -1 & i1 <= 0 & n2=i2+1 &
  i2=n1+i1 & i < n2 holds i <= n1
proof
   let i1,i2 be Integer,n1,n2,i be Element of NAT;
    assume A1: i1 >= -1 & i1 <= 0 & n2=i2+1 & i2=n1+i1 & i < n2;
    per cases by A1,Lm21;
    suppose i1=0;
     hence i <= n1 by A1,NAT_1:13;
    end;
    suppose i1=-1;
     hence i <= n1 by A1;
end;
end;

Lm23:
  for i1,i2 be Integer,n1,n2 be Element of NAT st i1 >= -1 & n2=i2+1 & i2=n1+i1
  holds n1 <= n2
proof
    let i1,i2 be Integer,n1,n2 be Element of NAT;
    assume A1: i1 >= -1 & n2=i2+1 & i2=n1+i1;
    then n1+i1 >= n1+ -1 by XREAL_1:8;
    then i2+1 >= n1+ -1+1 by A1,XREAL_1:8;
   hence n1 <= n2 by A1;
end;

Lm24:
 for s,s1 be State of SCMPDS,n0,n1,n2,n be Element of NAT,f,
 f1 be FinSequence of INT st
 f is_FinSequence_on s,n0 & f1 is_FinSequence_on s1,n0 & len f=n &
 len f1 = n &
  (for i be Element of NAT st i >= n0+1 & i<>n1 & i<>n2
  holds s1.intpos i=s.intpos i) &
  (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
  n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n &
  s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1)
  holds f,f1 are_fiberwise_equipotent
proof
   let s,s1 be State of SCMPDS,n0,n1,n2,n be Element of NAT,
   f,f1 be FinSequence of INT;
   assume A1: f is_FinSequence_on s,n0 & f1 is_FinSequence_on s1,n0;
   assume A2: len f=n & len f1 = n;
   assume A3: for i be Element of NAT st i >= n0+1 & i<>n1 & i<>n2 holds
              s1.intpos i=s.intpos i;
   assume A4: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
              n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n &
              s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;
    per cases by A4;
    suppose A5:s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
          now
        let i be Element of NAT;
        assume i in Seg n;
     then A6: 1 <= i & i <= n by FINSEQ_1:3;
     then A7: n0+1 <= n0+i & n0+i <= n0+n by XREAL_1:8;
        per cases;
        suppose A8: n0+i<>n1 & n0+i<>n2;
            thus f1.i=s1.intpos (n0+i) by A1,A2,A6,SCPISORT:def 1
              .=s.intpos (n0+i) by A3,A7,A8
              .=f.i by A1,A2,A6,SCPISORT:def 1;
        end;
        suppose A9: not (n0+i<>n1 & n0+i<>n2);
           hereby
                per cases by A9;
                suppose n0+i=n1;
                hence f1.i=s.intpos (n0+i) by A1,A2,A5,A6,SCPISORT:def 1
                 .=f.i by A1,A2,A6,SCPISORT:def 1;
                end;
                suppose n0+i=n2;
                hence f1.i=s.intpos (n0+i) by A1,A2,A5,A6,SCPISORT:def 1
                 .=f.i by A1,A2,A6,SCPISORT:def 1;
           end;
           end;
      end;
      end;
      hence thesis by A2,FINSEQ_2:10;
    end;
    suppose A10: n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n &
      s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;
then A11:  n1-n0 >= 1 by XREAL_1:21;
     then n1-n0 > 0;
     then reconsider m1=n1-n0 as Element of NAT by INT_1:16;
A12:  n2-n0 >= 1 by A10,XREAL_1:21;
     then n2-n0 > 0;
     then reconsider m2=n2-n0 as Element of NAT by INT_1:16;
A13:  m1 <= len f by A2,A10,XREAL_1:22;
A14:  m2 <= len f1 by A2,A10,XREAL_1:22;
A15:  m2 <= len f by A2,A10,XREAL_1:22;
A16:  n1=m1+n0;
A17:  n2=m2+n0;
A18:  f.m1=s1.intpos n2 by A1,A10,A11,A13,A16,SCPISORT:def 1
     .=f1.m2 by A1,A12,A14,A17,SCPISORT:def 1;
A19:  f.m2=s1.intpos n1 by A1,A10,A12,A15,A17,SCPISORT:def 1
     .=f1.m1 by A1,A2,A11,A13,A16,SCPISORT:def 1;
          now
        let k be Element of NAT;
        assume A20: k <> m1 & k <> m2 & 1 <= k & k <= len f;
          then A21: k+n0 <> m1+n0 & k+n0 <> m2+n0;
    A22:   n0+1 <= n0+k by A20,XREAL_1:8;
     thus f.k=s.intpos(k+n0) by A1,A20,SCPISORT:def 1
       .=s1.intpos (k+n0) by A3,A21,A22
       .=f1.k by A1,A2,A20,SCPISORT:def 1;
     end;
     hence thesis by A2,A11,A12,A13,A15,A18,A19,SCPISORT:4;
end;
end;

Lm25:
   for s,s1 be State of SCMPDS,n0,n1,n2 be Element of NAT,c1,c2 be Integer st
   (for i be Element of NAT st i >= n0 & i <>n1 & i<> n2
   holds s1.intpos i=s.intpos i) &
    n1 <= n2 & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
 c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1)
holds
   for i be Element of NAT st i >= n0 & (i < c1 or i > c2)
   holds s1.intpos i=s.intpos i
proof
    let s,s1 be State of SCMPDS,n0,n1,n2 be Element of NAT,c1,c2 be Integer;
    assume
A1:  for i be Element of NAT st i >= n0 & i<>n1 & i<>n2
holds s1.intpos i=s.intpos i;
    assume A2: n1 <= n2;
    assume A3: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
     c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;
    per cases by A3;
    suppose A4: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
     hereby
          let i be Element of NAT;
          assume A5: i >= n0 & (i < c1 or i > c2);
         per cases;
         suppose i<>n1 & i<>n2;
            hence s1.intpos i=s.intpos i by A1,A5;
         end;
         suppose A6: not (i<>n1 & i<>n2);
           hereby
              per cases by A6;
              suppose i=n1;
                hence s1.intpos i=s.intpos i by A4;
              end;
              suppose i=n2;
                hence s1.intpos i=s.intpos i by A4;
           end;
           end;
     end;
     end;
     end;
     suppose A7: c1 <= n1 & n2 <= c2 &
         s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;
     hereby
         let i be Element of NAT;
         assume A8: i >= n0 & (i < c1 or i > c2);
         per cases by A8;
         suppose i < c1;
      then i < n1 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
         end;
         suppose i > c2;
      then i > n2 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
    end;
    end;
end;
end;

Lm26:
 for s be State of SCMPDS,md,m3,n0 be Element of NAT,f,f1 be FinSequence of INT
 st s.GBP=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md &
 md >= n0+1 & md <= m3 & n0+1 <= s.a3 & s.a4 <= n0+n &
 f is_FinSequence_on s,n0 &
 f1 is_FinSequence_on IExec(WH3,s),n0 & n0 >= 7 & len f=n & len f1=n
holds IExec(WH3,s).GBP=0 & IExec(WH3,s).a1=s.a1 & IExec(WH3,s).a2=md &
   IExec(WH3,s).a4 >= md & IExec(WH3,s).a4 <= s.a4 &
   f,f1 are_fiberwise_equipotent &
   (for i be Element of NAT st s.a3<=i & i <= IExec(WH3,s).a4 holds
   IExec(WH3,s).intpos md >= IExec(WH3,s).intpos i) &
   (for i be Element of NAT st IExec(WH3,s).a4 < i & i <= s.a4 holds
   IExec(WH3,s).intpos md <= IExec(WH3,s).intpos i) &
   (for i be Element of NAT st i >= n0+1 & (i < s.a3 or i > s.a4) holds
         IExec(WH3,s).intpos i = s.intpos i)
proof
    let s be State of SCMPDS,md,m3,n0 be Element of NAT,
    f,f1 be FinSequence of INT;
    set a=GBP;
    assume A1: s.a=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 &
         s.a2=md & md >= n0+1 & md <= m3 & n0+1 <= s.a3 & s.a4 <= n0+n;
    assume A2: f is_FinSequence_on s,n0;
    assume A3: f1 is_FinSequence_on IExec(WH3,s),n0;
    assume A4: n0 >= 7 & len f=n & len f1=n;
        then  n0+1 >= 7+1 by XREAL_1:8;
then A5: md >= 8 by A1,XXREAL_0:2;
    defpred P[Element of NAT] means
      for t be State of SCMPDS,n3 be Element of NAT,
      g,g1 be FinSequence of INT st
     t.a=0 & t.a5 > 0 & t.a5<= $1+1 & t.a4=n3+t.a5 & n3=t.a3-1 &
     t.a2=md & md <= n3 & n0+1 <= t.a3 & t.a4 <= n0+n &
     g is_FinSequence_on t,n0 &
         g1 is_FinSequence_on IExec(WH3,t),n0 & len g=n & len g1=n
       holds IExec(WH3,t).a=0 & IExec(WH3,t).a1=t.a1 &
       IExec(WH3,t).a2=md & IExec(WH3,t).a4 >= md &
       IExec(WH3,t).a4 <= t.a4 & g,g1 are_fiberwise_equipotent &
       (for i be Element of NAT st t.a3<=i & i <= IExec(WH3,t).a4 holds
         IExec(WH3,t).intpos md >= IExec(WH3,t).intpos i) &
       (for i be Element of NAT st IExec(WH3,t).a4 < i & i <= t.a4 holds
         IExec(WH3,t).intpos md <= IExec(WH3,t).intpos i) &
       (for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4) holds
         IExec(WH3,t).intpos i = t.intpos i);
A6: P[0]
    proof
      let t be State of SCMPDS,n3 be Element of NAT,g,g1 be FinSequence of INT;
       assume A7: t.a=0 & t.a5 > 0 & t.a5<= 0+1 & t.a4=n3+t.a5 &
                  n3=t.a3-1 & t.a2=md & md <= n3 & n0+1 <= t.a3 & t.a4 <= n0+n;
       assume A8: g is_FinSequence_on t,n0;
       assume A9: g1 is_FinSequence_on IExec(WH3,t),n0;
       assume A10: len g=n & len g1=n;
       set t1=IExec(WB3,t);

        A11: DataLoc(t.a,5)=intpos(0+5) by A7,SCMP_GCD:5;
A12:  now
         let v be State of SCMPDS;
         assume A13: v.a4=v.a3-1+v.a5 & md <= v.a3-1 &
            v.a2=t.a2 & v.a=t.a & v.DataLoc(t.a,5) > 0;
            then v.a3-1 > 0 by A1;
            then reconsider mm=v.a3-1 as Element of NAT by INT_1:16;
      A14:  DataLoc(t.a,5)=intpos(0+5) by A7,SCMP_GCD:5;
      A15:  v.a4=mm+v.a5 & md <= mm by A13;
           set Iv=IExec(WB3,v);
        thus Iv.a=v.a by A5,A7,A13,A14,A15,Lm20;
        thus WB3 is_closed_on v & WB3 is_halting_on v
          by A5,A7,A13,A14,A15,Lm20;
        thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A5,A7,A13,A14,A15,Lm20;
        thus Iv.a4=Iv.a3-1+Iv.a5 by A5,A7,A13,A14,A15,Lm20;
               Iv.a3 >= v.a3 by A5,A7,A13,A14,A15,Lm20;
          then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
        hence md <= Iv.a3-1 by A13,XXREAL_0:2;
        thus Iv.a2=v.a2 by A5,A7,A13,A14,A15,Lm20;
     end;
A16: t1.a=0 & t1.a1=t.a1 & t1.a2=md & t1.a3 >= t.a3 & t1.a4 <= t.a4 &
    t1.a4 >= n3 & t1.a5 < t.a5 & t1.a5 >= -1 & t1.a4=t1.a3-1+t1.a5
    by A5,A7,Lm20;
    consider n1,n2 be Element of NAT such that
A17: n1=t1.a3-1 & n2=t1.a4+1 &
    (for i be Element of NAT st i >= 8 & i <>n1 & i<> n2
    holds t1.intpos i=t.intpos i) &
    (t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or
t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 &
   t1.intpos n2=t.intpos n1) &
    (for i be Element of NAT st t.a3<=i & i <= n1
    holds t1.intpos md >= t1.intpos i) &
    (for i be Element of NAT st n2<=i & i <= t.a4
    holds t1.intpos md <= t1.intpos i)
     by A5,A7,Lm20;
A18:  DataLoc(t1.a,5)=intpos(0+5) by A16,SCMP_GCD:5;
          t1.a5+1 <= t.a5 by A16,INT_1:20;
     then t1.a5+1 <= 0+1 by A7,XXREAL_0:2;
then A19:  t1.a5 <= 0 by XREAL_1:8;
     set t2=IExec(WH3,t);
A20:  now let x;
        thus t2.x =IExec(WH3,t1).x by A7,A11,A12,Lm17,Th7
        .=t1.x by A18,A19,SCMPDS_8:23;
     end;
     hence t2.a=0 by A16;
     thus t2.a1=t.a1 by A16,A20;
     thus t2.a2=md by A16,A20;
               t2.a4 >= n3 by A16,A20;
     hence t2.a4 >= md by A7,XXREAL_0:2;
     thus t2.a4 <= t.a4 by A16,A20;
A21:  now let i be Element of NAT;
         assume A22: i >= n0+1 & i<>n1 & i<>n2;
                n0+1 >= 7+1 by A4,XREAL_1:8;
       then A23: i >= 8 by A22,XXREAL_0:2;
          thus t2.intpos i=t1.intpos i by A20
            .=t.intpos i by A17,A22,A23;
     end;
A24:  n1 <= n2 by A16,A17,Lm23;
A25:  t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or
     t.a3 <= n1 & n2 <= t.a4 &
     t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1
     proof
          per cases by A17;
          suppose t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis by A20;
          end;
          suppose t.a3 <= n1 & n2 <= t.a4 &
              t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1;
           hence thesis by A20;
     end;
     end;
      t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or
     n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n &
     t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1
     proof
          per cases by A25;
          suppose t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose A26:t.a3 <= n1 & n2 <= t.a4 &
              t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1;
          then A27: n1 >= n0+1 by A7,XXREAL_0:2;
               n2 <= n0+n by A7,A26,XXREAL_0:2;
           hence thesis by A24,A26,A27,XXREAL_0:2;
     end;
     end;
     hence g,g1 are_fiberwise_equipotent by A8,A9,A10,A21,Lm24;
A28:  t2.a4=n2-1 by A17,A20;
     hereby let i be Element of NAT;
        assume A29: t.a3 <= i & i <= t2.a4;
             t2.a4 < n2 by A28,XREAL_1:148;
        then i < n2 by A29,XXREAL_0:2;
        then i <= n1 by A16,A17,A19,Lm22;
        then t1.intpos md >= t1.intpos i by A17,A29;
        then t2.intpos md >= t1.intpos i by A20;
        hence t2.intpos md >= t2.intpos i by A20;
     end;
     hereby let i be Element of NAT;
        assume A30: t2.a4 < i & i <= t.a4;
             t2.a4+1=n2 by A17,A20;
        then n2 <= i by A30,INT_1:20;
        then t1.intpos md <= t1.intpos i by A17,A30;
        then t2.intpos md <= t1.intpos i by A20;
      hence t2.intpos md <= t2.intpos i by A20;
     end;
     thus for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4) holds
         t2.intpos i = t.intpos i by A21,A24,A25,Lm25;
   end;
A31:now
       let k be Element of NAT;
       assume A32: P[k];
            now
          let t be State of SCMPDS,n3 be Element of NAT,
          g,g1 be FinSequence of INT;
          assume A33: t.a=0 & t.a5 > 0 & t.a5<= (k+1)+1 & t.a4=n3+t.a5 &
                  n3=t.a3-1 & t.a2=md & md <= n3 & n0+1 <= t.a3 & t.a4 <= n0+n;
          assume A34: g is_FinSequence_on t,n0;
          assume A35: g1 is_FinSequence_on IExec(WH3,t),n0;
          assume A36: len g=n & len g1=n;
          set t1=IExec(WB3,t);
             A37: DataLoc(t.a,5)=intpos(0+5) by A33,SCMP_GCD:5;
A38:     now
         let v be State of SCMPDS;
         assume A39: v.a4=v.a3-1+v.a5 & md <= v.a3-1 &
            v.a2=t.a2 & v.a=t.a & v.DataLoc(t.a,5) > 0;
            then v.a3-1 > 0 by A1;
            then reconsider mm=v.a3-1 as Element of NAT by INT_1:16;
      A40:  DataLoc(t.a,5)=intpos(0+5) by A33,SCMP_GCD:5;
      A41:  v.a4=mm+v.a5 & md <= mm by A39;
           set Iv=IExec(WB3,v);
        thus Iv.a=v.a by A5,A33,A39,A40,A41,Lm20;
        thus WB3 is_closed_on v & WB3 is_halting_on v
          by A5,A33,A39,A40,A41,Lm20;
        thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A5,A33,A39,A40,A41,Lm20;
        thus Iv.a4=Iv.a3-1+Iv.a5 by A5,A33,A39,A40,A41,Lm20;
               Iv.a3 >= v.a3 by A5,A33,A39,A40,A41,Lm20;
          then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
        hence md <= Iv.a3-1 by A39,XXREAL_0:2;
        thus Iv.a2=v.a2 by A5,A33,A39,A40,A41,Lm20;
      end;
A42:   t1.a=0 & t1.a1=t.a1 & t1.a2=md & t1.a3 >= t.a3 & t1.a4 <= t.a4 &
      t1.a4 >= n3 & t1.a5 < t.a5 & t1.a5 >= -1 & t1.a4=t1.a3-1+t1.a5
      by A5,A33,Lm20;
      consider n1,n2 be Element of NAT such that
A43:   n1=t1.a3-1 & n2=t1.a4+1 &
    (for i be Element of NAT st i >= 8 & i <>n1 & i<> n2
    holds t1.intpos i=t.intpos i) &
    (t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or
 t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 &
 t1.intpos n2=t.intpos n1) &
    (for i be Element of NAT st t.a3<=i & i <= n1
    holds t1.intpos md >= t1.intpos i) &
    (for i be Element of NAT st n2<=i & i <= t.a4
    holds t1.intpos md <= t1.intpos i)
     by A5,A33,Lm20;
A44:  DataLoc(t1.a,5)=intpos(0+5) by A42,SCMP_GCD:5;
          t1.a5+1 <= t.a5 by A42,INT_1:20;
     then t1.a5+1 <= (k+1)+1 by A33,XXREAL_0:2;
then A45:  t1.a5 <= k+1 by XREAL_1:8;
A46:  n1 <= n2 by A42,A43,Lm23;
     set t2=IExec(WH3,t);

     per cases;
     suppose A47: t1.a5 > 0;
        set t3=IExec(WH3,t1);
        consider f3 be FinSequence of INT such that
   A48:  len f3=n & for i be Element of NAT st 1<=i & i <= len f3 holds
          f3.i=t1.intpos(n0+i) by SCPISORT:2;
   A49:  f3 is_FinSequence_on t1,n0 by A48,SCPISORT:def 1;
        consider f4 be FinSequence of INT such that
   A50:  len f4=n & for i be Element of NAT st 1<=i & i <= len f4 holds
          f4.i=t3.intpos(n0+i) by SCPISORT:2;
   A51:  f4 is_FinSequence_on t3,n0 by A50,SCPISORT:def 1;
             t1.a3-1 >= t.a3-1 by A42,XREAL_1:11;
   then A52:  md <= n1 by A33,A43,XXREAL_0:2;
   A53:  n0+1 <= t1.a3 by A33,A42,XXREAL_0:2;
   A54:  t1.a4 <= n0+n by A33,A42,XXREAL_0:2;
   then A55:  t3.a=0 & t3.a1=t1.a1 & t3.a2=md & t3.a4 >= md & t3.a4 <= t1.a4 &
        f3,f4 are_fiberwise_equipotent &
       (for i be Element of NAT st t1.a3<=i & i <= t3.a4 holds
         t3.intpos md >= t3.intpos i) &
       (for i be Element of NAT st t3.a4 < i & i <= t1.a4 holds
         t3.intpos md <= t3.intpos i) &
         (for i be Element of NAT st i >= n0+1 & (i < t1.a3 or i > t1.a4) holds
         t3.intpos i = t1.intpos i)
           by A32,A42,A43,A45,A47,A48,A49,A50,A51,A52,A53;
   A56:  t2 =t3 by A33,A37,A38,Lm17,Th7;
        hence t2.a=0 by A32,A42,A43,A45,A47,A48,A49,A50,A51,A52,A53,A54;
        thus t2.a1=t.a1 by A32,A42,A43,A45,A47,A48,A49,A50,A51,A52,A53,A54,A56
;
        thus t2.a2=md by A32,A42,A43,A45,A47,A48,A49,A50,A51,A52,A53,A54,A56;
        thus t2.a4 >= md by A32,A42,A43,A45,A47,A48,A49,A50,A51,A52,A53,A54,A56
;
        thus t2.a4 <= t.a4 by A42,A55,A56,XXREAL_0:2;
   A57:  now let i be Element of NAT;
         assume A58: i >= n0+1 & i<>n1 & i<>n2;
                n0+1 >= 7+1 by A4,XREAL_1:8;
       then i >= 8 by A58,XXREAL_0:2;
          hence t1.intpos i=t.intpos i by A43,A58;
      end;
         t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or
        n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n &
        t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1
        proof
          per cases by A43;
          suppose t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose A59:t.a3 <= n1 & n2 <= t.a4 &
              t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1;
          then A60: n1 >= n0+1 by A33,XXREAL_0:2;
               n2 <= n0+n by A33,A59,XXREAL_0:2;
           hence thesis by A46,A59,A60,XXREAL_0:2;
      end;
      end;
 then A61:  g,f3 are_fiberwise_equipotent by A34,A36,A48,A49,A57,Lm24;
             now
          let i be Element of NAT;
          assume i in Seg n;
           then A62: 1 <= i & i <= n by FINSEQ_1:3;
        hence f4.i=t2.intpos (n0+i) by A50,A56
            .=g1.i by A35,A36,A62,SCPISORT:def 1;
      end;
      then f4=g1 by A36,A50,FINSEQ_2:10;
    hence g,g1 are_fiberwise_equipotent by A55,A61,RFINSEQ:2;
            n1 < t1.a3 by A43,XREAL_1:148;
   then md < t1.a3 by A52,XXREAL_0:2;
   then A63: t2.intpos md = t1.intpos md by A1,A32,A42,A43,A45,A47,A48,A49,A50
,A51,A52,A53,A54,A56;
   A64: t1.a3=n1+1 by A43;
      hereby
          let i be Element of NAT;
          assume A65: t.a3<=i & i <= t2.a4;
          then A66: n0+1 <= i by A33,XXREAL_0:2;
          hereby
            per cases;
            suppose A67: i < t1.a3;
            then A68: i <= n1 by A64,INT_1:20;
                 t2.intpos i = t1.intpos i by A32,A42,A43,A45,A47,A48,A49,A50
,A51,A52,A53,A54,A56,A66,A67;
             hence t2.intpos md >= t2.intpos i by A43,A63,A65,A68;
            end;
            suppose i >= t1.a3;
            hence t2.intpos md >= t2.intpos i by A32,A42,A43,A45,A47,A48,A49
,A50,A51,A52,A53,A54,A56,A65;
        end;
        end;
      end;
      hereby
          let i be Element of NAT;
          assume A69: t2.a4 < i & i <= t.a4;
          hereby
            per cases;
            suppose A70: i > t1.a4;
            then A71: i >= n2 by A43,INT_1:20;
                     t1.a4 > n1+0 by A42,A43,A47,XREAL_1:8
;
                then n2 > n1+1 by A43,XREAL_1:8;
                then n2 >= n0+1 by A43,A53,XXREAL_0:2;
            then i >= n0+1 by A71,XXREAL_0:2;
            then t2.intpos i = t1.intpos i by A32,A42,A43,A45,A47,A48,A49,A50
,A51,A52,A53,A54,A56,A70;
             hence t2.intpos md <= t2.intpos i by A43,A63,A69,A71;
            end;
            suppose i <= t1.a4;
            hence t2.intpos md <= t2.intpos i by A32,A42,A43,A45,A47,A48,A49
,A50,A51,A52,A53,A54,A56,A69;
        end;
        end;
      end;
      hereby
          let i be Element of NAT;
          assume A72: i >= n0+1 & (i < t.a3 or i > t.a4);
                n0+1 >= 7+1 by A4,XREAL_1:8;
          then i >= 8 by A72,XXREAL_0:2;
      then A73: t1.intpos i = t.intpos i by A43,A46,A72,Lm25;
          per cases by A72;
          suppose i < t.a3;
      then i < t1.a3 by A42,XXREAL_0:2;
           hence t2.intpos i =t.intpos i by A32,A42,A43,A45,A47,A48,A49,A50,A51
,A52,A53,A54,A56,A72,A73;
          end;
          suppose i > t.a4;
      then i > t1.a4 by A42,XXREAL_0:2;
           hence t2.intpos i =t.intpos i by A32,A42,A43,A45,A47,A48,A49,A50,A51
,A52,A53,A54,A56,A72,A73;
     end;
     end;

     end;
     suppose A74: t1.a5 <= 0;
A75:   now let x;
        thus t2.x =IExec(WH3,t1).x by A33,A37,A38,Lm17,Th7
        .=t1.x by A44,A74,SCMPDS_8:23;
      end;
      hence t2.a=0 by A42;
      thus t2.a1=t.a1 by A42,A75;
      thus t2.a2=md by A42,A75;
             t2.a4 >= n3 by A42,A75;
      hence t2.a4 >= md by A33,XXREAL_0:2;
      thus t2.a4 <= t.a4 by A42,A75;
A76:   now let i be Element of NAT;
         assume A77: i >= n0+1 & i<>n1 & i<>n2;
                n0+1 >= 7+1 by A4,XREAL_1:8;
       then A78: i >= 8 by A77,XXREAL_0:2;
          thus t2.intpos i=t1.intpos i by A75
            .=t.intpos i by A43,A77,A78;
      end;
A79:  t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or
     t.a3 <= n1 & n2 <= t.a4 &
     t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1
     proof
          per cases by A43;
          suppose t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis by A75;
          end;
          suppose t.a3 <= n1 & n2 <= t.a4 &
              t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1;
           hence thesis by A75;
     end;
     end;
      t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or
     n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n &
     t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1
     proof
          per cases by A79;
          suppose t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose A80:t.a3 <= n1 & n2 <= t.a4 &
              t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1;
          then A81: n1 >= n0+1 by A33,XXREAL_0:2;
               n2 <= n0+n by A33,A80,XXREAL_0:2;
           hence thesis by A46,A80,A81,XXREAL_0:2;
     end;
     end;
      hence g,g1 are_fiberwise_equipotent by A34,A35,A36,A76,Lm24;
A82:   t2.a4=n2-1 by A43,A75;
      hereby let i be Element of NAT;
        assume A83: t.a3 <= i & i <= t2.a4;
             t2.a4 < n2 by A82,XREAL_1:148;
        then i < n2 by A83,XXREAL_0:2;
        then i <= n1 by A42,A43,A74,Lm22;
        then t1.intpos md >= t1.intpos i by A43,A83;
        then t2.intpos md >= t1.intpos i by A75;
        hence t2.intpos md >= t2.intpos i by A75;
      end;
      hereby let i be Element of NAT;
        assume A84: t2.a4 < i & i <= t.a4;
             t2.a4+1=n2 by A43,A75;
        then n2 <= i by A84,INT_1:20;
        then t1.intpos md <= t1.intpos i by A43,A84;
        then t2.intpos md <= t1.intpos i by A75;
       hence t2.intpos md <= t2.intpos i by A75;
      end;
      thus for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4) holds
         t2.intpos i = t.intpos i by A46,A76,A79,Lm25;
     end;
     end;
     hence P[k+1];
   end;
A85: for k be Element of NAT holds P[k] from NAT_1:sch 1(A6,A31);
         s.a5 >=1+0 by A1,INT_1:20;
    then s.a5-1 >= 0 by XREAL_1:50;
    then reconsider m5=s.a5-1 as Element of NAT by INT_1:16;
     s.a5=m5+1;
    hence thesis by A1,A2,A3,A4,A85;
end;

Lm27:
 for s be State of SCMPDS,md,m3,n0 be Element of NAT st s.GBP=0 & s.a5 > 0 &
 s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1 & md <= m3 & n0 >= 7
holds WH3 is_closed_on s & WH3 is_halting_on s
proof
    let s be State of SCMPDS,md,m3,n0 be Element of NAT;
    set a=GBP;
    assume A1: s.a=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md &
       md >= n0+1 & md <= m3 & n0 >= 7;
    then  n0+1 >= 7+1 by XREAL_1:8;
then A2: md >= 8 by A1,XXREAL_0:2;
A3: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:5;
      now
         let v be State of SCMPDS;
         assume A4: v.a4=v.a3-1+v.a5 & md <= v.a3-1 &
            v.a2=s.a2 & v.a=s.a & v.DataLoc(s.a,5) > 0;
            then v.a3-1 > 0 by A1;
            then reconsider mm=v.a3-1 as Element of NAT by INT_1:16;
      A5:  v.a4=mm+v.a5 & md <= mm by A4;
           set Iv=IExec(WB3,v);
        thus Iv.a=v.a by A1,A2,A3,A4,A5,Lm20;
        thus WB3 is_closed_on v & WB3 is_halting_on v
          by A1,A2,A3,A4,A5,Lm20;
        thus Iv.DataLoc(s.a,5) < v.DataLoc(s.a,5) by A1,A2,A3,A4,A5,Lm20;
        thus Iv.a4=Iv.a3-1+Iv.a5 by A1,A2,A3,A4,A5,Lm20;
               Iv.a3 >= v.a3 by A1,A2,A3,A4,A5,Lm20;
          then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
        hence md <= Iv.a3-1 by A4,XXREAL_0:2;
        thus Iv.a2=v.a2 by A1,A2,A3,A4,A5,Lm20;
     end;
     hence thesis by A1,Lm17,Th7;
end;

Lm28:
  for s being State of SCMPDS st s.GBP=0 holds
    IExec(K4,s).GBP=0 & IExec(K4,s).a1=s.a1 &
    IExec(K4,s).a2=s.a2 & IExec(K4,s).a3=s.a2+1 &
    IExec(K4,s).a4=s.a4 & IExec(K4,s).a5=s.a4-s.a2 &
    (for i be Element of NAT st i >= 8 holds IExec(K4,s).intpos i=s.intpos i)
proof
   let s be State of SCMPDS;
   set a=GBP;
   assume A1: s.a=0;
   set t0=Initialized s,
       t1=IExec(k1 ';' k2 ';' k3 ';' k4,s),
       t2=IExec(k1 ';' k2 ';' k3,s),
       t3=IExec(k1 ';' k2,s),
       t4=Exec(k1, t0);
A2: t0.a=0 by A1,SCMPDS_5:40;
A3: t0.a1=s.a1 by SCMPDS_5:40;
A4: t0.a2=s.a2 by SCMPDS_5:40;
A5: t0.a4=s.a4 by SCMPDS_5:40;

A6:  DataLoc(t0.a,5)=intpos (0+5) by A2,SCMP_GCD:5;
     then a<>DataLoc(t0.a,5) by AMI_3:52;
then A7: t4.a =0 by A2,SCMPDS_2:59;
          a1<>DataLoc(t0.a,5) by A6,AMI_3:52;
then A8: t4.a1 =s.a1 by A3,SCMPDS_2:59;
     A9: a2<>DataLoc(t0.a,5) by A6,AMI_3:52;
then A10: t4.a2 =s.a2 by A4,SCMPDS_2:59;
          a4<>DataLoc(t0.a,5) by A6,AMI_3:52;
then A11: t4.a4 =s.a4 by A5,SCMPDS_2:59;
A12: t4.a5=t0.DataLoc(t0.a,4) by A6,SCMPDS_2:59
      .=t0.intpos (0+4) by A2,SCMP_GCD:5
      .=s.a4 by SCMPDS_5:40;
A13: now let i be Element of NAT;
        assume i>=8;
        then i > 5 by XXREAL_0:2;
    then intpos i <> DataLoc(t0.a,5) by A6,AMI_3:52;
        hence t4.intpos i=t0.intpos i by SCMPDS_2:59
          .=s.intpos i by SCMPDS_5:40;
     end;

A14:  DataLoc(t4.a,5)=intpos (0+5) by A7,SCMP_GCD:5;
then A15:  a<>DataLoc(t4.a,5) by AMI_3:52;
A16: t3.a=Exec(k2, t4).a by SCMPDS_5:47
     .=0 by A7,A15,SCMPDS_2:62;
A17:  a1<>DataLoc(t4.a,5) by A14,AMI_3:52;
A18: t3.a1=Exec(k2, t4).a1 by SCMPDS_5:47
     .=s.a1 by A8,A17,SCMPDS_2:62;
A19:  a2<>DataLoc(t4.a,5) by A14,AMI_3:52;
A20: t3.a2=Exec(k2, t4).a2 by SCMPDS_5:47
     .=s.a2 by A10,A19,SCMPDS_2:62;
A21:  a4<>DataLoc(t4.a,5) by A14,AMI_3:52;
A22: t3.a4=Exec(k2, t4).a4 by SCMPDS_5:47
     .=s.a4 by A11,A21,SCMPDS_2:62;
A23: t3.a5=Exec(k2, t4).a5 by SCMPDS_5:47
     .=t4.a5-t4.DataLoc(t4.a,2) by A14,SCMPDS_2:62
     .=t4.a5-t4.intpos(0+2) by A7,SCMP_GCD:5
     .=s.a4-s.a2 by A4,A9,A12,SCMPDS_2:59;
A24: now let i be Element of NAT;
        assume A25:i>=8;
        then i > 5 by XXREAL_0:2;
    then A26: intpos i <> DataLoc(t4.a,5) by A14,AMI_3:52;
        thus t3.intpos i=Exec(k2, t4).intpos i by SCMPDS_5:47
             .=t4.intpos i by A26,SCMPDS_2:62
             .=s.intpos i by A13,A25;
     end;

A27:  DataLoc(t3.a,3)=intpos (0+3) by A16,SCMP_GCD:5;
then A28:  a <> DataLoc(t3.a,3) by AMI_3:52;
A29: t2.a =Exec(k3, t3).a by SCMPDS_5:46
     .=0 by A16,A28,SCMPDS_2:59;
A30:  a1 <> DataLoc(t3.a,3) by A27,AMI_3:52;
A31: t2.a1 =Exec(k3, t3).a1 by SCMPDS_5:46
     .=s.a1 by A18,A30,SCMPDS_2:59;
A32:  a2 <> DataLoc(t3.a,3) by A27,AMI_3:52;
A33: t2.a2 =Exec(k3, t3).a2 by SCMPDS_5:46
     .=s.a2 by A20,A32,SCMPDS_2:59;
A34: t2.a3 =Exec(k3, t3).a3 by SCMPDS_5:46
     .=t3.DataLoc(t3.a,2) by A27,SCMPDS_2:59
     .=s.a2 by  A16,SCMP_GCD:5,A20;
A35:  a4 <> DataLoc(t3.a,3) by A27,AMI_3:52;
A36: t2.a4 =Exec(k3, t3).a4 by SCMPDS_5:46
     .=s.a4 by A22,A35,SCMPDS_2:59;
A37:  a5<>DataLoc(t3.a,3) by A27,AMI_3:52;
A38: t2.a5 =Exec(k3, t3).a5 by SCMPDS_5:46
     .=s.a4-s.a2 by A23,A37,SCMPDS_2:59;
A39: now let i be Element of NAT;
        assume A40:i>=8;
        then i > 3 by XXREAL_0:2;
    then A41: intpos i <> DataLoc(t3.a,3) by A27,AMI_3:52;
        thus t2.intpos i=Exec(k3, t3).intpos i by SCMPDS_5:46
             .=t3.intpos i by A41,SCMPDS_2:59
             .=s.intpos i by A24,A40;
     end;

A42:  DataLoc(t2.a,3)=intpos (0+3) by A29,SCMP_GCD:5;
then A43:  a<>DataLoc(t2.a,3) by AMI_3:52;
   thus t1.a =Exec(k4, t2).a by SCMPDS_5:46
       .=0 by A29,A43,SCMPDS_2:60;
A44:  a1<>DataLoc(t2.a,3) by A42,AMI_3:52;
   thus t1.a1 =Exec(k4, t2).a1 by SCMPDS_5:46
       .=s.a1 by A31,A44,SCMPDS_2:60;
A45:  a2<>DataLoc(t2.a,3) by A42,AMI_3:52;
   thus t1.a2 =Exec(k4, t2).a2 by SCMPDS_5:46
       .=s.a2 by A33,A45,SCMPDS_2:60;
   thus t1.a3 =Exec(k4, t2).a3 by SCMPDS_5:46
      .=s.a2+1 by A34,A42,SCMPDS_2:60;
A46:  a4<>DataLoc(t2.a,3) by A42,AMI_3:52;
   thus t1.a4 =Exec(k4, t2).a4 by SCMPDS_5:46
       .=s.a4 by A36,A46,SCMPDS_2:60;
A47:  a5<>DataLoc(t2.a,3) by A42,AMI_3:52;
   thus t1.a5 =Exec(k4, t2).a5 by SCMPDS_5:46
       .=s.a4-s.a2 by A38,A47,SCMPDS_2:60;
   hereby let i be Element of NAT;
        assume A48:i>=8;
        then i > 3 by XXREAL_0:2;
    then A49: intpos i <> DataLoc(t2.a,3) by A42,AMI_3:52;
        thus t1.intpos i=Exec(k4, t2).intpos i by SCMPDS_5:46
             .=t2.intpos i by A49,SCMPDS_2:60
             .=s.intpos i by A39,A48;
    end;
end;

theorem Th13:
 for s be State of SCMPDS,md,p0 be Element of NAT st s.GBP=0 &
 s.intpos 4-s.intpos 2 > 0 & s.intpos 2=md & md >= p0+1 & p0 >= 7
 holds Partition is_closed_on s & Partition is_halting_on s
proof
    let s be State of SCMPDS,md,n0 be Element of NAT;
    set s2=IExec(K4,s),
        a=GBP;
  assume A1: s.a=0 & s.a4-s.a2 > 0 & s.a2=md & md >= n0+1 & n0 >= 7;
then A2: s2.a=0 & s2.a2=s.a2 & s2.a3=s.a2+1 & s2.a4=s.a4 &
    s2.a5=s.a4-s.a2 by Lm28;
    set m3=md;
A3: s.a2=s2.a3-1 by A2;
     s2.a4=m3+s2.a5 by A1,A2;
then A4: WH3 is_closed_on s2 & WH3 is_halting_on s2 by A1,A2,A3,Lm27;
    set KW=K4 ';' WH3;
     KW is_closed_on s & KW is_halting_on s by A4,SCPISORT:10;
then KW ';' j8 is_closed_on s & KW ';' j8 is_halting_on s by SCPISORT:11;
then KW ';' j8 ';' j9 is_closed_on s & KW ';' j8 ';' j9 is_halting_on s
     by SCPISORT:11;
    hence Partition is_closed_on s & Partition is_halting_on s by
SCPISORT:11;
end;

theorem Th14:
 for s be State of SCMPDS,md,p0,n be Element of NAT,f,f1 be FinSequence of INT
 st s.GBP=0 & s.intpos 4-s.intpos 2 > 0 & s.intpos 2=md &
 md >= p0+1 & s.intpos 4 <= p0+n & p0 >= 7 &
 f is_FinSequence_on s,p0 & len f=n &
 f1 is_FinSequence_on IExec(Partition,s),p0 & len f1=n
holds IExec(Partition,s).GBP=0 &
   IExec(Partition,s).intpos 1=s.intpos 1 &
   f,f1 are_fiberwise_equipotent &
   ex m4 be Element of NAT st m4=IExec(Partition,s).intpos 4 &
   md <= m4 & m4 <= s.intpos 4 &
   (for i be Element of NAT st md<=i & i < m4 holds
   IExec(Partition,s).intpos m4 >= IExec(Partition,s).intpos i) &
   (for i be Element of NAT st m4 < i & i <= s.intpos 4 holds
   IExec(Partition,s).intpos m4 <= IExec(Partition,s).intpos i) &
   (for i be Element of NAT st i >= p0+1 & (i < s.intpos 2 or i > s.intpos 4)
   holds
         IExec(Partition,s).intpos i = s.intpos i)
proof
    let s be State of SCMPDS,md,n0,n be Element of NAT,
    f,f1 be FinSequence of INT;
    set s1=IExec(Partition,s),
        s2=IExec(K4,s),
        s3=IExec(K4 ';' WH3 ,s),
        a=GBP;
  assume A1: s.a=0 & s.a4-s.a2 > 0 & s.a2=md & md >= n0+1 & s.a4 <= n0+n &
            n0 >= 7;
  assume A2: f is_FinSequence_on s,n0 & len f=n;
  assume A3: f1 is_FinSequence_on s1,n0 & len f1=n;
A4: s2.GBP=0 & s2.a1=s.a1 & s2.a2=s.a2 & s2.a3=s.a2+1 & s2.a4=s.a4 &
    s2.a5=s.a4-s.a2 &
    (for i be Element of NAT st i >= 8 holds s2.intpos i=s.intpos i)
    by A1,Lm28;
    set m3=md;
A5: s.a2=s2.a3-1 by A4;
A6: m3=s2.a3-1 by A1,A4;
A7: s2.a4=m3+s2.a5 by A1,A4;
         s.a2 < s2.a3 by A4,XREAL_1:31;
then A8: n0+1 <= s2.a3 by A1,XXREAL_0:2;
    set s4=IExec(WH3,s2);
    consider f2 be FinSequence of INT such that
A9:  len f2=n & for i be Element of NAT st 1<=i & i <= len f2 holds
     f2.i=s2.intpos(n0+i) by SCPISORT:2;
A10:  f2 is_FinSequence_on s2,n0 by A9,SCPISORT:def 1;
    consider f3 be FinSequence of INT such that
A11:  len f3=n & for i be Element of NAT st 1<=i & i <= len f3 holds
     f3.i=s4.intpos(n0+i) by SCPISORT:2;
A12:  f3 is_FinSequence_on s4,n0 by A11,SCPISORT:def 1;
then A13:  s4.a=0 & s4.a1=s2.a1 & s4.a2=md & s4.a4 >= md & s4.a4 <= s2.a4 &
     f2,f3 are_fiberwise_equipotent &
     (for i be Element of NAT st s2.a3<=i & i <= s4.a4 holds
      s4.intpos md >= s4.intpos i) &
     (for i be Element of NAT st s4.a4 < i & i <= s2.a4 holds
      s4.intpos md <= s4.intpos i) &
     (for i be Element of NAT st i >= n0+1 & (i < s2.a3 or i > s2.a4) holds
       s4.intpos i = s2.intpos i)
      by A1,A4,A5,A7,A8,A9,A10,A11,Lm26;
A14: WH3 is_closed_on s2 & WH3 is_halting_on s2 by A1,A4,A5,A7,Lm27;
    set KW=K4 ';' WH3;
A15: KW is_closed_on s & KW is_halting_on s by A14,SCPISORT:10;
then A16: KW ';' j8 is_closed_on s & KW ';' j8 is_halting_on s by SCPISORT:11;
then A17: KW ';' j8 ';' j9 is_closed_on s & KW ';' j8 ';' j9 is_halting_on s
     by SCPISORT:11;
A18:  s3.a=0 by A13,A14,SCPISORT:8;
A19:  n0+1 >= 7+1 by A1,XREAL_1:8;
then A20:  md >= 8 by A1,XXREAL_0:2;
A21:  md > 0 by A1;
A22:  s4.a4 >= 8 by A13,A20,XXREAL_0:2;
  s4.a4 > 0 by A1,A4,A5,A7,A8,A9,A10,A11,A12,Lm26;
     then reconsider m4=s4.a4 as Element of NAT by INT_1:16;
A23:  s3.a2=md by A13,A14,SCPISORT:8;
A24:  s3.a4 =m4 by A14,SCPISORT:8;

    set t2=IExec(KW ';' j8 ';' j9,s),
        t3=IExec(KW ';' j8,s);

A25:  DataLoc(s3.a,6)=intpos(0+6) by A18,SCMP_GCD:5;
then A26:   a <> DataLoc(s3.a,6) by AMI_3:52;
A27:  t3.a=Exec(j8,s3).a by A15,SCMPDS_7:50
      .=0 by A18,A26,SCMPDS_2:59;
A28:   a1 <> DataLoc(s3.a,6) by A25,AMI_3:52;
A29:  t3.a1=Exec(j8,s3).a1 by A15,SCMPDS_7:50
      .=s3.a1 by A28,SCMPDS_2:59
      .=s.a1 by A4,A13,A14,SCPISORT:8;
A30:   a2 <> DataLoc(s3.a,6) by A25,AMI_3:52;
A31:  t3.a2=Exec(j8,s3).a2 by A15,SCMPDS_7:50
      .=md by A23,A30,SCMPDS_2:59;
A32:   a4 <> DataLoc(s3.a,6) by A25,AMI_3:52;
A33:  t3.a4=Exec(j8,s3).a4 by A15,SCMPDS_7:50
      .=m4 by A24,A32,SCMPDS_2:59;
A34:  t3.a6=Exec(j8,s3).a6 by A15,SCMPDS_7:50
      .=s3.DataLoc(s3.a4,0) by A25,SCMPDS_2:59
      .=s3.intpos(m4+0) by A24,SCMP_GCD:5
      .=s4.intpos m4 by A14,SCPISORT:8;
A35: now
       let i be Element of NAT;
       assume i >= 8;
       then i > 6 by XXREAL_0:2;
    then A36: intpos i<>DataLoc(s3.a,6) by A25,AMI_3:52;
     thus t3.intpos i =Exec(j8,s3).intpos i by A15,SCMPDS_7:50
         .=s3.intpos i by A36,SCMPDS_2:59
         .=s4.intpos i by A14,SCPISORT:8;
     end;

A37:  DataLoc(t3.a4,0)=intpos(m4+0) by A33,SCMP_GCD:5;
then A38:   a <> DataLoc(t3.a4,0) by A13,A21,AMI_3:52;
A39:  t2.a=Exec(j9,t3).a by A16,SCMPDS_7:50
      .=0 by A27,A38,SCMPDS_2:59;
           m4 > 1 by A22,XXREAL_0:2;
then A40:   a1 <> DataLoc(t3.a4,0) by A37,AMI_3:52;
A41:  t2.a1=Exec(j9,t3).a1 by A16,SCMPDS_7:50
      .=s.a1 by A29,A40,SCMPDS_2:59;
           m4 > 2 by A22,XXREAL_0:2;
then A42:   a2 <> DataLoc(t3.a4,0) by A37,AMI_3:52;
A43:  t2.a2=Exec(j9,t3).a2 by A16,SCMPDS_7:50
      .=md by A31,A42,SCMPDS_2:59;
           m4 > 4 by A22,XXREAL_0:2;
then A44:   a4 <> DataLoc(t3.a4,0) by A37,AMI_3:52;
A45:  t2.a4=Exec(j9,t3).a4 by A16,SCMPDS_7:50
      .=m4 by A33,A44,SCMPDS_2:59;
           m4 > 6 by A22,XXREAL_0:2;
then A46:   a6 <> DataLoc(t3.a4,0) by A37,AMI_3:52;
A47:  t2.a6=Exec(j9,t3).a6 by A16,SCMPDS_7:50
      .=s4.intpos m4 by A34,A46,SCMPDS_2:59;
A48:  t2.intpos m4=Exec(j9,t3).intpos m4 by A16,SCMPDS_7:50
      .=t3.DataLoc(t3.a2,0) by A37,SCMPDS_2:59
      .=t3.intpos (md+0) by A31,SCMP_GCD:5
      .=s4.intpos md by A20,A35;
A49: now
       let i be Element of NAT;
       assume A50: i >= 8 & i <> m4;
    then A51: intpos i<>DataLoc(t3.a4,0) by A37,AMI_3:52;
     thus t2.intpos i =Exec(j9,t3).intpos i by A16,SCMPDS_7:50
         .=t3.intpos i by A51,SCMPDS_2:59
         .=s4.intpos i by A35,A50;
     end;
A52:  DataLoc(t2.a2,0)=intpos(md+0) by A43,SCMP_GCD:5;
then A53:   a <> DataLoc(t2.a2,0) by A21,AMI_3:52;
    thus s1.a=Exec(j0,t2).a by A17,SCMPDS_7:50
      .=0 by A39,A53,SCMPDS_2:59;
           md > 1 by A20,XXREAL_0:2;
then A54:   a1 <> DataLoc(t2.a2,0) by A52,AMI_3:52;
   thus s1.a1=Exec(j0,t2).a1 by A17,SCMPDS_7:50
      .=s.a1 by A41,A54,SCMPDS_2:59;

A55:  s1.intpos md=Exec(j0,t2).intpos md by A17,SCMPDS_7:50
      .=t2.DataLoc(t2.a,6) by A52,SCMPDS_2:59
      .=s4.intpos m4 by  A39,SCMP_GCD:5,A47;
A56:  now
         per cases;
         suppose m4=md;
       hence s1.intpos m4=s4.intpos md by A55;
         end;
         suppose m4<>md;
     then A57:  intpos m4 <> DataLoc(t2.a2,0) by A52,AMI_3:52;
         thus s1.intpos m4=Exec(j0,t2).intpos m4 by A17,SCMPDS_7:50
            .=s4.intpos md by A48,A57,SCMPDS_2:59;
      end;
      end;
A58: now
       let i be Element of NAT;
       assume A59: i >= 8 & i <> m4 & i<>md;
    then A60: intpos i<>DataLoc(t2.a2,0) by A52,AMI_3:52;
     thus s1.intpos i =Exec(j0,t2).intpos i by A17,SCMPDS_7:50
         .=t2.intpos i by A60,SCMPDS_2:59
         .=s4.intpos i by A49,A59;
     end;

A61:   md-n0 >= 1 by A1,XREAL_1:21;
      then md-n0 > 0;
      then reconsider n1=md-n0 as Element of NAT by INT_1:16;
           md < s.a4 by A1,REAL_2:106;
      then md < n0+n by A1,XXREAL_0:2;
then A62:   n1 <= len f3 by A11,XREAL_1:22;
          A63: m4-n0 >= md-n0 by A13,XREAL_1:11;
then A64:   m4-n0 >= 1 by A61,XXREAL_0:2;
       m4-n0 > 0 by A61,A63;
      then reconsider n2=m4-n0 as Element of NAT by INT_1:16;
           m4 <= n0+n by A1,A4,A13,XXREAL_0:2;
then A65:   n2 <= len f3 by A11,XREAL_1:22;
A66:   md=n0+n1;
A67:   m4=n0+n2;
A68:   f3.n1=s1.intpos m4 by A11,A56,A61,A62,A66
      .=f1.n2 by A3,A11,A64,A65,A67,SCPISORT:def 1;
A69:   f3.n2=s1.intpos md by A11,A55,A64,A65,A67
      .=f1.n1 by A3,A11,A61,A62,A66,SCPISORT:def 1;
      now
         let k be Element of NAT;
         assume A70: k<>n1 & k<>n2 & 1<=k & k <= len f3;
         then A71:  k+n0<>md;
         A72:  k+n0<>m4 by A70;
                   k+n0 >= n0+1 by A70,XREAL_1:8;
         then A73:  k+n0 >= 8 by A19,XXREAL_0:2;
         thus f3.k=s4.intpos(n0+k) by A11,A70
         .=s1.intpos(n0+k) by A58,A71,A72,A73
         .=f1.k by A3,A11,A70,SCPISORT:def 1;
     end;
     then f3,f1 are_fiberwise_equipotent
        by A3,A11,A61,A62,A64,A65,A68,A69,SCPISORT:4;
then A74:  f2,f1 are_fiberwise_equipotent by A13,RFINSEQ:2;
          now
        let i be Element of NAT;
         assume i in Seg n;
         then A75: 1 <= i & i <= n by FINSEQ_1:3;
             then i+n0 >= n0+1 by XREAL_1:8;
         then A76: n0+i >= 8 by A19,XXREAL_0:2;
        thus f2.i=s2.intpos (n0+i) by A9,A75
            .=s.intpos (n0+i) by A1,A76,Lm28
            .=f.i by A2,A75,SCPISORT:def 1;
      end;
     hence f,f1 are_fiberwise_equipotent by A2,A9,A74,FINSEQ_2:10;
     take m4;
           md > 4 by A20,XXREAL_0:2;
then A77:   a4 <> DataLoc(t2.a2,0) by A52,AMI_3:52;
   thus s1.a4=Exec(j0,t2).a4 by A17,SCMPDS_7:50
      .=m4 by A45,A77,SCMPDS_2:59;
   thus md <= m4 by A1,A4,A6,A7,A8,A9,A10,A11,A12,Lm26;
   thus m4 <= s.a4 by A1,A4,A5,A7,A8,A9,A10,A11,A12,Lm26;
A78: s2.a3=md+1 by A1,Lm28;
    hereby
         let i be Element of NAT;
         assume A79: md<=i & i < m4;
         per cases;
        suppose A80: i=md;
          then s2.a3 <= m4 by A78,A79,INT_1:20;
          hence s1.intpos m4 >= s1.intpos i by A1,A4,A6,A7,A8,A9,A10,A11,A12
,A55,A56,A80,Lm26;
        end;
        suppose A81: i<>md;
       then md < i by A79,REAL_1:def 5;
           then s2.a3 <= i by A1,A4,INT_1:20;
           then A82: s4.intpos md >= s4.intpos i by A1,A4,A6,A7,A8,A9,A10,A11
,A12,A79,Lm26;
                i >= 8 by A20,A79,XXREAL_0:2;
        hence s1.intpos m4 >= s1.intpos i by A56,A58,A81,A82;
    end;
    end;
    hereby
        let i be Element of NAT;
        assume A83: m4 < i & i <= s.a4;
            then A84: s4.intpos md <= s4.intpos i by A1,A4,A5,A7,A8,A9,A10,A11
,A12,Lm26;
         md < i by A13,A83,XXREAL_0:2;
            then i > 8 by A20,XXREAL_0:2;
        hence s1.intpos m4 <= s1.intpos i by A13,A56,A58,A83,A84;
    end;
    hereby
        let i be Element of NAT;
        assume A85: i >= n0+1 & (i < s.a2 or i > s.a4);
      then A86: i >= 8 by A19,XXREAL_0:2;
      A87: now
            per cases by A85;
            case A88: i < s.a2;
                   s.a2 < s2.a3 by A4,XREAL_1:31;
              hence i < s2.a3 by A88,XXREAL_0:2;
            end;
            case i > s.a4;
              hence i > s2.a4 by A1,Lm28;
         end;
         end;
              i<>md & i<>m4
         proof
           per cases by A85;
           suppose i< s.a2;
             hence thesis by A1,A4,A5,A7,A8,A9,A10,A11,A12,Lm26;
           end;
           suppose i > s.a4;
             hence thesis by A4,A13,XXREAL_0:2;
         end;
         end;
        hence s1.intpos i = s4.intpos i by A58,A86
          .=s2.intpos i by A1,A4,A6,A7,A8,A9,A10,A11,A12,A85,A87,Lm26
          .=s.intpos i by A1,A86,Lm28;
     end;
end;

theorem
       Partition is No-StopCode shiftable;

Lm29:
 for s being State of SCMPDS,p0,n being Element of NAT holds
    card QuickSort(n,p0)=57 & (p0 >= 7 implies
    QuickSort(n,p0) is_halting_on s &
    ex f,g be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 &
    len g = n & g is_FinSequence_on IExec(QuickSort(n,p0),s),p0 &
    f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n)
proof
    let s be State of SCMPDS,p0,n be Element of NAT;
   reconsider Pt=Partition as No-StopCode shiftable Program-block;
   set pn=p0+n;
   set l1= (GBP,2):=(SBP,pn+1),
        l2= SubFrom(GBP,2,SBP,pn),
        l3= (GBP,2):=(SBP,pn),
        l4= (GBP,4):=(SBP,pn+1),
        l5= (SBP,pn+3):=(SBP,pn+1),
        l6= (SBP,pn+1):=(GBP,4),
        l7= (SBP,pn+2):=(GBP,4),
        l8= AddTo(SBP,pn+1,-1),
        l9= AddTo(SBP,pn+2,1),
        l0= AddTo(GBP,1,2),
        lb= Load AddTo(GBP,1,-2),
        L5= l5 ';' l6 ';' l7 ';' l8 ';' l9 ';' l0,
        TR= l3 ';' l4 ';' Pt ';' L5,
        IF4= if>0(GBP,2,TR,lb),
        WB4= l1 ';' l2 ';' IF4,
        WH4= while>0(GBP,1,WB4);

A1: card L5= card (l5 ';' l6 ';' l7 ';' l8 ';' l9 )+1 by SCMP_GCD:8
    .= card (l5 ';' l6 ';' l7 ';' l8)+1+1 by SCMP_GCD:8
    .= 4+1+1 by Th4;
A2: card WB4=card (l1 ';' l2) + card IF4 by SCMPDS_4:45
    .=2+card IF4 by SCMP_GCD:9
    .=2+(card TR +card lb +2) by SCMPDS_6:79
    .=2+(card TR +1 +2) by SCMPDS_5:6
    .=2+(card (l3 ';' l4 ';' Partition)+ card L5+1+2) by SCMPDS_4:45
    .=2+(card (l3 ';' l4) + card Partition + card L5+1+2) by SCMPDS_4:45
    .=2+(2+ 38 + card L5+1+2) by Th12,SCMP_GCD:9
    .=51 by A1;
    set m1= GBP:=0,
         m2= SBP:=1,
         m3= (SBP,pn):=(p0+1),
         m4= (SBP,pn+1):=pn,
         M4= m1 ';' m2 ';' m3 ';' m4;
    thus card QuickSort(n,p0)=card M4 + card WH4 by SCMPDS_4:45
     .=4 + card WH4 by Th4
     .=4 + (51+2) by A2,SCMPDS_8:17
     .=57;
    assume A3: p0 >= 7;
     set s1=IExec(M4,s),
         a=GBP;
A4:  pn >= 7+n by A3,XREAL_1:8;
          7+n >= 7 by NAT_1:11;
then A5:  pn >= 7 by A4,XXREAL_0:2;
then A6:  pn+1 >= 7+1 by XREAL_1:8;
A7:  pn+2 >= 7+2 by A5,XREAL_1:8;

A8:  for t being State of SCMPDS,m,m1 be Element of NAT st t.a=0 &
t.SBP=m1 & m1=m+1
     holds IExec(L5,t).a=0 & IExec(L5,t).SBP=m1+2 &
     IExec(L5,t).intpos (m1+pn)=t.intpos (m1+pn) &
     IExec(L5,t).intpos (m1+pn+1)=t.a4-1 &
     IExec(L5,t).intpos (m1+pn+2)=t.a4+1 &
     IExec(L5,t).intpos (m1+pn+3)=t.intpos (m1+pn+1) &
     (for i be Element of NAT st i >= 8 & i < m1+pn holds
       IExec(L5,t).intpos i=t.intpos i)
    proof
        let t be State of SCMPDS,m,m1 be Element of NAT;
        assume A9:t.a=0 & t.SBP=m1 & m1=m+1;
    set t0=Initialized t,
        t1=IExec(L5,t),
        t2=IExec(l5 ';' l6 ';' l7 ';' l8 ';' l9,t),
        t3=IExec(l5 ';' l6 ';' l7 ';' l8,t),
        t4=IExec(l5 ';' l6 ';' l7 , t),
        t5=IExec(l5 ';' l6, t),
        t6=Exec(l5, t0),
        mp=m1+pn;
          m1 >= 1 by A9,NAT_1:11;
then A10:  mp >= 1+7 by A5,XREAL_1:9;
then A11:  mp+1 >= 8+1 by XREAL_1:8;
A12:  mp+2 >= 8+2 by A10,XREAL_1:8;
A13:  mp+3 >= 8+3 by A10,XREAL_1:8;
A14: t0.SBP =m1 by A9,SCMPDS_5:40;

then A15:  DataLoc(t0.SBP,pn+3)=intpos (mp+3) by SCMP_GCD:5;
A16:  now
        let i be Element of NAT;
        assume i<>mp+3;
        then intpos i <> DataLoc(t0.SBP,pn+3) by A15,AMI_3:52;
      hence t6.intpos i=t0.intpos i by SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
     end;
then A17: t6.a=0 by A9;
          mp+3 > 1 by A13,XXREAL_0:2;
then A18: t6.SBP=m1 by A9,A16;
     A19: mp+3 > 4 by A13,XXREAL_0:2;
then A20: t6.a4=t.a4 by A16;
          mp+0 <> mp+3;
then A21: t6.intpos mp=t.intpos mp by A16;
A22: t6.intpos (mp+3)=t0.DataLoc(t0.SBP,pn+1) by A15,SCMPDS_2:59
     .=t0.intpos(m1+(pn+1)) by A14,SCMP_GCD:5
     .=t.intpos (mp+1) by SCMPDS_5:40;

A23:  DataLoc(t6.SBP,pn+1)=intpos (mp+1) by A18,SCMP_GCD:5;
A24:  now
        let i be Element of NAT;
        assume i<>mp+1;
      then A25: intpos i <> DataLoc(t6.SBP,pn+1) by A23,AMI_3:52;
      thus t5.intpos i=Exec(l6, t6).intpos i by SCMPDS_5:47
           .=t6.intpos i by A25,SCMPDS_2:59;
     end;
then A26: t5.a=0 by A17;
          mp+1 > 1 by A11,XXREAL_0:2;
then A27: t5.SBP=m1 by A18,A24;
     A28: mp+1 > 4 by A11,XXREAL_0:2;
          mp+0 <> mp+1;
then A29: t5.intpos mp=t.intpos mp by A21,A24;
A30: t5.intpos (mp+1)=Exec(l6, t6).intpos(mp+1) by SCMPDS_5:47
     .=t6.DataLoc(t6.GBP,4) by A23,SCMPDS_2:59
     .=t6.intpos(0+4) by A17,SCMP_GCD:5
     .=t.a4 by A16,A19;
          mp+3 <> mp+1;
then A31: t5.intpos(mp+3)=t.intpos(mp+1) by A22,A24;

A32:  DataLoc(t5.SBP,pn+2)=intpos (mp+2) by A27,SCMP_GCD:5;
A33:  now
        let i be Element of NAT;
        assume i<>mp+2;
      then A34: intpos i <> DataLoc(t5.SBP,pn+2) by A32,AMI_3:52;
      thus t4.intpos i=Exec(l7, t5).intpos i by SCMPDS_5:46
           .=t5.intpos i by A34,SCMPDS_2:59;
     end;
then A35: t4.a=0 by A26;
          mp+2 > 1 by A12,XXREAL_0:2;
then A36: t4.SBP=m1 by A27,A33;
          mp+0 <> mp+2;
then A37: t4.intpos mp=t.intpos mp by A29,A33;
          mp+1 <> mp+2;
then A38: t4.intpos (mp+1)=t.a4 by A30,A33;
A39: t4.intpos(mp+2)=Exec(l7, t5).intpos(mp+2) by SCMPDS_5:46
     .=t5.DataLoc(t5.GBP,4) by A32,SCMPDS_2:59
     .=t5.intpos(0+4) by A26,SCMP_GCD:5
     .=t.a4 by A20,A24,A28;
          mp+3 <> mp+2;
then A40: t4.intpos(mp+3)=t.intpos(mp+1) by A31,A33;

A41:  DataLoc(t4.SBP,pn+1)=intpos (mp+1) by A36,SCMP_GCD:5;
A42:  now
        let i be Element of NAT;
        assume i<>mp+1;
      then A43: intpos i <> DataLoc(t4.SBP,pn+1) by A41,AMI_3:52;
      thus t3.intpos i=Exec(l8, t4).intpos i by SCMPDS_5:46
           .=t4.intpos i by A43,SCMPDS_2:60;
     end;
then A44: t3.a=0 by A35;
          m1+pn+1 > 1 by A11,XXREAL_0:2;
then A45: t3.SBP=m1 by A36,A42;
          mp+0 <> mp+1;
then A46: t3.intpos mp=t.intpos mp by A37,A42;
A47: t3.intpos(mp+1)=Exec(l8, t4).intpos(mp+1) by SCMPDS_5:46
     .=t.a4+-1 by A38,A41,SCMPDS_2:60
     .=t.a4-1;
          mp+1 <> mp+2;
then A48: t3.intpos(mp+2)=t.a4 by A39,A42;
          mp+3 <> mp+1;
then A49: t3.intpos(mp+3)=t.intpos(mp+1) by A40,A42;

A50:  DataLoc(t3.SBP,pn+2)=intpos (mp+2) by A45,SCMP_GCD:5;
A51:  now
        let i be Element of NAT;
        assume i<>mp+2;
      then A52: intpos i <> DataLoc(t3.SBP,pn+2) by A50,AMI_3:52;
      thus t2.intpos i=Exec(l9, t3).intpos i by SCMPDS_5:46
           .=t3.intpos i by A52,SCMPDS_2:60;
     end;
then A53: t2.a=0 by A44;
          mp+2 > 1 by A12,XXREAL_0:2;
then A54: t2.SBP=m1 by A45,A51;
          mp+0 <> mp+2;
then A55: t2.intpos mp=t.intpos mp by A46,A51;
          mp+1 <> mp+2;
then A56: t2.intpos(mp+1)=t.a4-1 by A47,A51;
A57: t2.intpos(mp+2)=Exec(l9, t3).intpos(mp+2) by SCMPDS_5:46
     .=t.a4+1 by A48,A50,SCMPDS_2:60;
          mp+3 <> mp+2;
then A58: t2.intpos(mp+3)=t.intpos(mp+1) by A49,A51;

A59:  DataLoc(t2.a,1)=intpos (0+1) by A53,SCMP_GCD:5;
A60:  now
        let i be Element of NAT;
        assume i<>1;
      then A61: intpos i <> DataLoc(t2.a,1) by A59,AMI_3:52;
      thus t1.intpos i=Exec(l0, t2).intpos i by SCMPDS_5:46
           .=t2.intpos i by A61,SCMPDS_2:60;
     end;
    hence t1.a=0 by A53;
    thus t1.SBP=Exec(l0, t2).SBP by SCMPDS_5:46
      .=m1+2 by A54,A59,SCMPDS_2:60;
          mp > 1 by A10,XXREAL_0:2;
   hence t1.intpos mp=t.intpos mp by A55,A60;
          mp+1 > 1 by A11,XXREAL_0:2;
   hence t1.intpos(mp+1)=t.a4-1 by A56,A60;
          mp+2 > 1 by A12,XXREAL_0:2;
    hence t1.intpos(mp+2)=t.a4+1 by A57,A60;
          mp+3 > 1 by A13,XXREAL_0:2;
    hence t1.intpos(mp+3)=t.intpos(mp+1) by A58,A60;
    hereby
         let i be Element of NAT;
         assume A62: i >= 8 & i < mp;
     then A63: i > 1 by XXREAL_0:2;
         A64: mp <= mp+2 by NAT_1:11;
         A65: mp <= mp+1 by NAT_1:11;
         A66: mp <= mp+3 by NAT_1:11;
     thus t1.intpos i=t2.intpos i by A60,A63
         .=t3.intpos i by A51,A62,A64
         .=t4.intpos i by A42,A62,A65
         .=t5.intpos i by A33,A62,A64
         .=t6.intpos i by A24,A62,A65
         .=t.intpos i by A16,A62,A66;
     end;
   end;

A67:  for t be State of SCMPDS,m1 be Element of NAT st t.a=0 & t.SBP=m1
    holds IExec(l3 ';' l4, t).a2=t.intpos(m1+pn) &
    IExec(l3 ';' l4, t).a4=t.intpos(m1+pn+1) &
    for i be Element of NAT st i <> 2 & i <> 4 holds
       IExec(l3 ';' l4, t).intpos i=t.intpos i
   proof
      let t be State of SCMPDS,m1 be Element of NAT;
    set t0=Initialized t,
        t2=IExec(l3 ';' l4, t),
        t3=Exec(l3, t0),
        mp=m1+pn;
      assume A68: t.a=0 & t.SBP=m1;
     mp >= 0+7 by A5,XREAL_1:9;
then A69:  mp+1 >= 7+1 by XREAL_1:8;
A70: t0.a =0 by A68,SCMPDS_5:40;
A71: t0.SBP =m1 by A68,SCMPDS_5:40;

A72:  DataLoc(t0.a,2)=intpos (0+2) by A70,SCMP_GCD:5;
     then a <> DataLoc(t0.a,2) by AMI_3:52;
then A73: t3.a=0 by A70,SCMPDS_2:59;
          SBP <> DataLoc(t0.a,2) by A72,AMI_3:52;
then A74: t3.SBP=m1 by A71,SCMPDS_2:59;
A75: t3.a2=t0.DataLoc(t0.SBP,pn) by A72,SCMPDS_2:59
     .=t0.intpos mp by A71,SCMP_GCD:5
     .=t.intpos mp by SCMPDS_5:40;
          mp+1 > 2 by A69,XXREAL_0:2;
     then intpos(mp+1) <> DataLoc(t0.a,2) by A72,AMI_3:52;
then A76: t3.intpos(mp+1)=t0.intpos(mp+1) by SCMPDS_2:59
     .=t.intpos(mp+1) by SCMPDS_5:40;

A77:  DataLoc(t3.a,4)=intpos (0+4) by A73,SCMP_GCD:5;
then A78:  a2 <> DataLoc(t3.a,4) by AMI_3:52;
    thus t2.a2=Exec(l4, t3).a2 by SCMPDS_5:47
      .=t.intpos mp by A75,A78,SCMPDS_2:59;
    thus t2.a4=Exec(l4, t3).a4 by SCMPDS_5:47
      .=t3.DataLoc(t3.SBP,pn+1) by A77,SCMPDS_2:59
      .=t.intpos(mp+1) by  A74,SCMP_GCD:5,A76;
    hereby
        let i be Element of NAT;
        assume A79: i<>2 & i <> 4;
      then A80: intpos i <> DataLoc(t0.a,2) by A72,AMI_3:52;
      A81: intpos i <> DataLoc(t3.a,4) by A77,A79,AMI_3:52;
    thus t2.intpos i =Exec(l4, t3).intpos i by SCMPDS_5:47
         .=t3.intpos i by A81,SCMPDS_2:59
         .=t0.intpos i by A80,SCMPDS_2:59
          .=t.intpos i by SCMPDS_5:40;
     end;
    end;

A82:  for t be State of SCMPDS,m1,md be Element of NAT st t.a=0 & t.SBP=m1 &
     t.intpos(m1+pn)=md & md >= p0+1 & t.intpos(m1+pn+1)-md > 0
    holds TR is_closed_on t & TR is_halting_on t
    proof
       let t be State of SCMPDS,m1,md be Element of NAT;
    set lPt=l3 ';' l4 ';' Pt,
        t2=IExec(l3 ';' l4, t),
        mp=m1+pn;
      assume A83: t.a=0 & t.SBP=m1 & t.intpos mp=md & md >= p0+1 &
          t.intpos (mp+1)-md > 0;
then A84:   t2.a2=t.intpos mp & t2.a4=t.intpos(mp+1) &
    for i be Element of NAT st i <> 2 & i <> 4
    holds t2.intpos i=t.intpos i by A67;
 t2.a=0 by A67,A83;
      then Pt is_closed_on t2 & Pt is_halting_on t2 by A3,A83,A84,Th13;
      then lPt is_closed_on t & lPt is_halting_on t by SCPISORT:10;
     hence TR is_closed_on t & TR is_halting_on t by SCPISORT:9;
   end;

A85:  for t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer,
f1,f2 be
     FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md &
       md >= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn &
       f1 is_FinSequence_on t,p0 & len f1=n &
       f2 is_FinSequence_on IExec(TR,t),p0 & len f2=n
     holds
       IExec(TR,t).a=0 & IExec(TR,t).a1=m1+2 &
       md=IExec(TR,t).intpos(m1+pn) &
       n4=IExec(TR,t).intpos (m1+pn+3) &
      (for j be Element of NAT st 1<=j & j<m1 holds
          IExec(TR,t).intpos(pn+j)=t.intpos(pn+j)) &
       f1,f2 are_fiberwise_equipotent &
       ex m4 be Element of NAT st md <= m4 & m4 <= n4 &
        m4-1=IExec(TR,t).intpos (m1+pn+1) &
        m4+1=IExec(TR,t).intpos (m1+pn+2) &
      (for i be Element of NAT st md<=i & i < m4 holds
      IExec(TR,t).intpos m4 >= IExec(TR,t).intpos i) &
      (for i be Element of NAT st m4 < i & i <= n4 holds
      IExec(TR,t).intpos m4 <= IExec(TR,t).intpos i) &
       (for j be Element of NAT st (p0+1<=j & j<md) or (n4<j & j <= p0+n) holds
        IExec(TR,t).intpos j = t.intpos j)
    proof
      let t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer,
      f1,f2 be
       FinSequence of INT;
    set t1=IExec(TR,t),
        lPt=l3 ';' l4 ';' Pt,
        t2=IExec(lPt,t),
        t4=IExec(l3 ';' l4, t),
        mp=m1+pn;
      set tp=IExec(Pt,t4);
      assume A86: t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos mp=md &
         md >= p0+1 & n4=t.intpos (mp+1) & n4-md > 0 & n4 <= pn;
      assume A87: f1 is_FinSequence_on t,p0 & len f1=n;
      assume A88: f2 is_FinSequence_on IExec(TR,t),p0 & len f2=n;

A89:   t4.a2=t.intpos mp & t4.a4=t.intpos(mp+1) &
    for i be Element of NAT st i <> 2 & i <> 4 holds t4.intpos i=t.intpos i
    by A67,A86;
A90: t4.a=0 by A67,A86;
A91: t4.a4=n4 by A67,A86;
A92:  p0+1 >= 7+1 by A3,XREAL_1:8;
          now let i be Element of NAT;
         assume A93: 1 <= i & i <= len f1;
         then p0+i >= p0+1 by XREAL_1:8;
     then p0+i >= 8 by A92,XXREAL_0:2;
     then A94: p0+i > 2 & p0+i > 4 by XXREAL_0:2;
         thus f1.i=t.intpos(p0+i) by A87,A93,SCPISORT:def 1
            .=t4.intpos(p0+i) by A67,A86,A94;
     end;
then A95:  f1 is_FinSequence_on t4,p0 by SCPISORT:def 1;
     consider f4 be FinSequence of INT such that
A96:  len f4=n & for i be Element of NAT st 1<=i & i <= len f4 holds
     f4.i=tp.intpos(p0+i) by SCPISORT:2;
A97:  f4 is_FinSequence_on tp,p0 by A96,SCPISORT:def 1;
then A98:  tp.a=0 & tp.a1=t4.a1 & f1,f4 are_fiberwise_equipotent
       by A3,A86,A87,A89,A90,A95,A96,Th14;
    consider m4 be Element of NAT such that
A99:  m4=tp.a4 & md <= m4 & m4 <= t4.a4 &
    (for i be Element of NAT st md<=i & i < m4
    holds tp.intpos m4 >= tp.intpos i) &
    (for i be Element of NAT st m4 < i & i <= t4.a4
    holds tp.intpos m4 <= tp.intpos i) &
    (for i be Element of NAT st i >= p0+1 & (i < t4.a2 or i > t4.a4) holds
         tp.intpos i = t4.intpos i) by A3,A86,A87,A89,A90,A95,A96,A97,Th14;
A100: Pt is_closed_on t4 & Pt is_halting_on t4 by A3,A86,A89,A90,Th13;
then A101: lPt is_closed_on t & lPt is_halting_on t by SCPISORT:10;
A102:  t2.a=0 by A98,A100,SCPISORT:8;
A103:  t2.SBP=t4.a1 by A98,A100,SCPISORT:8
     .=m1 by A67,A86;
then A104:  IExec(L5,t2).a=0 & IExec(L5,t2).SBP=m1+2 &
     IExec(L5,t2).intpos mp=t2.intpos mp &
     IExec(L5,t2).intpos (mp+1)=t2.a4-1 &
     IExec(L5,t2).intpos (mp+2)=t2.a4+1 &
     IExec(L5,t2).intpos (mp+3)=t2.intpos (mp+1) &
     for i be Element of NAT st i >= 8 & i < mp holds
       IExec(L5,t2).intpos i=t2.intpos i by A8,A86,A102;
A105:  m1 >= 1 by A86,NAT_1:11;
then A106:  mp >= 1+7 by A5,XREAL_1:9;
A107:  pn >= p0 by NAT_1:11;
then A108:  mp >= p0+1 by A105,XREAL_1:9;
A109:  mp >= 1+pn by A105,XREAL_1:8;
A110:  1+pn > pn by XREAL_1:31;
then A111:  mp > pn by A109,XXREAL_0:2;
then A112:  mp > t4.a4 by A86,A91,XXREAL_0:2;
    thus t1.a=0 by A101,A104,SCPISORT:7;
    thus t1.a1=m1+2 by A101,A104,SCPISORT:7;
           mp > 2 & mp > 4 by A106,XXREAL_0:2;
     hence md=t4.intpos mp by A67,A86
      .=tp.intpos mp by A99,A108,A112
      .=IExec(L5,t2).intpos mp by A100,A104,SCPISORT:8
      .=t1.intpos mp by A101,SCPISORT:7;
A113:  mp+1 >= 8+1 by A106,XREAL_1:8;
A114:  mp+1 > mp by XREAL_1:31;
then A115:  mp+1 >= p0+1 by A108,XXREAL_0:2;
A116:  mp+1 > t4.a4 by A112,A114,XXREAL_0:2;
           mp+1 > 2 & mp+1 > 4 by A113,XXREAL_0:2;
     hence n4=t4.intpos (mp+1) by A67,A86
      .=tp.intpos (mp+1) by A99,A115,A116
      .=IExec(L5,t2).intpos (mp+3) by A100,A104,SCPISORT:8
      .=t1.intpos (mp+3) by A101,SCPISORT:7;
    hereby
       let j be Element of NAT;
       assume A117: 1<=j & j<m1;
       then A118: pn+j >= 1+7 by A5,XREAL_1:9;
       A119: pn+j < mp by A117,XREAL_1:8;
       A120: pn+j >= p0+1 by A107,A117,XREAL_1:9;
                pn+j >= pn+1 by A117,XREAL_1:8;
           then pn+j > pn by A110,XXREAL_0:2;
      then A121:  pn+j > t4.a4 by A86,A91,XXREAL_0:2;
      A122:  pn+j > 2 & pn+j > 4 by A118,XXREAL_0:2;
       thus t1.intpos(pn+j)=IExec(L5,t2).intpos(pn+j) by A101,SCPISORT:7
          .=t2.intpos (pn+j) by A8,A86,A102,A103,A118,A119
          .=tp.intpos (pn+j) by A100,SCPISORT:8
          .=t4.intpos (pn+j) by A99,A120,A121
          .=t.intpos(pn+j) by A67,A86,A122;
    end;
         now let i be Element of NAT;
         assume i in Seg n;
     then A123:  1 <= i & i <= n by FINSEQ_1:3;
          then p0+i >= p0+1 by XREAL_1:8;
     then A124:  p0+i >= 8 by A92,XXREAL_0:2;
               p0+i <= pn by A123,XREAL_1:8;
     then A125:  p0+i < mp by A111,XXREAL_0:2;
      thus f2.i = t1.intpos(p0+i) by A88,A123,SCPISORT:def 1
          .=IExec(L5,t2).intpos(p0+i) by A101,SCPISORT:7
          .=t2.intpos (p0+i) by A8,A86,A102,A103,A124,A125
          .=tp.intpos (p0+i) by A100,SCPISORT:8
          .=f4.i by A96,A123;
    end;
  hence f1,f2 are_fiberwise_equipotent by A88,A96,A98,FINSEQ_2:10;
    take m4;
    thus
  md <= m4 & m4 <= n4 by A67,A86,A99;
A126:  md >= 8 by A86,A92,XXREAL_0:2;
A127:  m4 < mp by A99,A112,XXREAL_0:2;
A128:  m4 >= 8 by A99,A126,XXREAL_0:2;

     thus m4-1=t2.a4-1 by A99,A100,SCPISORT:8
      .=t1.intpos (mp+1) by A101,A104,SCPISORT:7;
    thus m4+1=t2.a4+1 by A99,A100,SCPISORT:8
      .=t1.intpos (mp+2) by A101,A104,SCPISORT:7;
    hereby
         let i be Element of NAT;
         assume A129: md<=i & i < m4;
       then A130: i < mp by A127,XXREAL_0:2;
       A131: i >= 8 by A126,A129,XXREAL_0:2;
       A132: tp.intpos i=t2.intpos i by A100,SCPISORT:8
           .=IExec(L5,t2).intpos i by A8,A86,A102,A103,A130,A131
           .=t1.intpos i by A101,SCPISORT:7;
                tp.intpos m4=t2.intpos m4 by A100,SCPISORT:8
           .=IExec(L5,t2).intpos m4 by A8,A86,A102,A103,A127,A128
           .=t1.intpos m4 by A101,SCPISORT:7;
         hence t1.intpos m4 >= t1.intpos i by A99,A129,A132;
    end;
    hereby
         let i be Element of NAT;
         assume A133: m4 < i & i <= n4;
       then A134: i < mp by A86,A89,A112,XXREAL_0:2;
                i >= md by A99,A133,XXREAL_0:2;
       then A135: i >= 8 by A126,XXREAL_0:2;
       A136: tp.intpos i=t2.intpos i by A100,SCPISORT:8
           .=IExec(L5,t2).intpos i by A8,A86,A102,A103,A134,A135
           .=t1.intpos i by A101,SCPISORT:7;
                tp.intpos m4=t2.intpos m4 by A100,SCPISORT:8
           .=IExec(L5,t2).intpos m4 by A8,A86,A102,A103,A127,A128
           .=t1.intpos m4 by A101,SCPISORT:7;
         hence t1.intpos m4 <= t1.intpos i by A91,A99,A133,A136;
    end;
    hereby
       let j be Element of NAT;
       assume A137: (p0+1<=j & j<md) or (n4<j & j <= pn);
    A138: now
         per cases by A137;
         suppose A139: p0+1<=j & j<md;
          hence j >= p0+1 & (j < t4.a2 or j > t4.a4) by A67,A86;
                md < mp by A99,A127,XXREAL_0:2;
          hence j < mp by A139,XXREAL_0:2;
        end;
        suppose A140: n4<j & j <= pn;
                 n4 >= md by A91,A99,XXREAL_0:2;
            then j >= md by A140,XXREAL_0:2;
         hence j >= p0+1 by A86,XXREAL_0:2;
         thus (j < t4.a2 or j > t4.a4) by A67,A86,A140;
         thus j < mp by A111,A140,XXREAL_0:2;
       end;
       end;
    then A141: j >= 8 by A92,XXREAL_0:2;
    then A142: j > 2 & j > 4 by XXREAL_0:2;
       thus t1.intpos j=IExec(L5,t2).intpos j by A101,SCPISORT:7
          .=t2.intpos j by A8,A86,A102,A103,A138,A141
          .=tp.intpos j by A100,SCPISORT:8
          .=t4.intpos j by A99,A138
          .=t.intpos j by A67,A86,A142;
     end;
   end;

A143: for t be State of SCMPDS,m be Element of NAT st t.a=0 & t.SBP=m
    holds IExec(l1 ';' l2,t).a2=t.intpos (m+pn+1)-t.intpos (m+pn) &
       for i be Element of NAT st i <> 2
       holds IExec(l1 ';' l2,t).intpos i=t.intpos i
   proof
      let t be State of SCMPDS,m be Element of NAT;
      assume A144: t.a=0 & t.SBP=m;
    set t0=Initialized t,
        t1=IExec(l1 ';' l2, t),
        t2=Exec(l1, t0),
        mp=m+pn;
A145:  mp >= 0+7 by A5,XREAL_1:9;
A146: t0.a =0 by A144,SCMPDS_5:40;
A147: t0.SBP =m by A144,SCMPDS_5:40;

A148:  DataLoc(t0.a,2)=intpos (0+2) by A146,SCMP_GCD:5;
     then a <> DataLoc(t0.a,2) by AMI_3:52;
then A149: t2.a=0 by A146,SCMPDS_2:59;
          SBP <> DataLoc(t0.a,2) by A148,AMI_3:52;
then A150: t2.SBP=m by A147,SCMPDS_2:59;
A151: t2.a2=t0.DataLoc(t0.SBP,pn+1) by A148,SCMPDS_2:59
     .=t0.intpos (m+(pn+1)) by A147,SCMP_GCD:5
     .=t.intpos (mp+1) by SCMPDS_5:40;
          mp > 2 by A145,XXREAL_0:2;
     then intpos mp <> DataLoc(t0.a,2) by A148,AMI_3:52;
then A152: t2.intpos mp=t0.intpos mp by SCMPDS_2:59
     .=t.intpos mp by SCMPDS_5:40;

A153: DataLoc(t2.a,2)=intpos (0+2) by A149,SCMP_GCD:5;
    thus t1.a2=Exec(l2, t2).a2 by SCMPDS_5:47
      .=t2.a2-t2.DataLoc(t2.SBP,pn) by A153,SCMPDS_2:62
      .=t.intpos (mp+1)-t.intpos mp by A150,A151,A152,SCMP_GCD:5;
    hereby
         let i be Element of NAT;
         assume A154: i <> 2;
      then A155: intpos i <> DataLoc(t0.a,2) by A148,AMI_3:52;
      A156: intpos i <> DataLoc(t2.a,2) by A153,A154,AMI_3:52;
        thus t1.intpos i=Exec(l2, t2).intpos i by SCMPDS_5:47
      .=t2.intpos i by A156,SCMPDS_2:62
      .=t0.intpos i by A155,SCMPDS_2:59
       .=t.intpos i by SCMPDS_5:40;
      end;
    end;

A157: for t be State of SCMPDS,m,md be Element of NAT st t.a=0 & t.SBP=m &
    t.intpos(m+pn)=md & (md >= p0+1 or t.intpos(m+pn+1)-md <= 0)
    holds WB4 is_closed_on t & WB4 is_halting_on t
    proof
        let t be State of SCMPDS,m,md be Element of NAT;
        set mp=m+pn,
            t1=IExec(l1 ';' l2,t);
        assume A158: t.a=0 & t.SBP=m & t.intpos mp=md &
         (md >= p0+1 or t.intpos(mp+1)-md <= 0);

then A159:  t1.a2=t.intpos (mp+1)-t.intpos mp &
     for i be Element of NAT st i <> 2 holds t1.intpos i=t.intpos i by A143;
A160:  t1.a=0 by A143,A158;
then A161:  DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
     per cases;
     suppose A162: t1.DataLoc(t1.a,2) > 0;
     A163: t1.SBP=m by A143,A158;
     A164:  mp >= 0+7 by A5,XREAL_1:9;
          then mp > 2 by XXREAL_0:2;
     then A165: t1.intpos mp=md by A143,A158;
          mp+1 >= 7+1 by A164,XREAL_1:8;
          then mp+1 > 2 by XXREAL_0:2;
     then t1.intpos(mp+1)-md > 0 by A158,A159,A161,A162;
     then TR is_closed_on t1 & TR is_halting_on t1 by A82,A143,A158,A160,A161
,A162,A163,A165;
     then IF4 is_closed_on t1 & IF4 is_halting_on t1 by A162,SCMPDS_6:82;
      hence thesis by SCPISORT:10;

    end;
    suppose A166: t1.DataLoc(t1.a,2) <= 0;
              lb is_closed_on t1 & lb is_halting_on t1 by SCMPDS_6:34,
35;
         then IF4 is_closed_on t1 & IF4 is_halting_on t1 by A166,SCMPDS_6:83;
         hence thesis by SCPISORT:10;
    end;
    end;

A167:  for t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer,
f1,f2 be
     FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md &
       md >= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn &
       f1 is_FinSequence_on t,p0 & len f1=n &
       f2 is_FinSequence_on IExec(WB4,t),p0 & len f2=n
    holds
       IExec(WB4,t).a=0 & IExec(WB4,t).a1=m1+2 &
       md=IExec(WB4,t).intpos(m1+pn) & n4=IExec(WB4,t).intpos (m1+pn+3) &
   (for j be Element of NAT st (1<=j & j<m1) holds
    IExec(WB4,t).intpos(pn+j)=t.intpos(pn+j)) &
       f1,f2 are_fiberwise_equipotent &
    ex m4 be Element of NAT st md <= m4 & m4 <= n4 &
    m4-1=IExec(WB4,t).intpos (m1+pn+1) & m4+1=IExec(WB4,t).intpos (m1+pn+2) &
    (for i be Element of NAT st md<=i & i < m4 holds
      IExec(WB4,t).intpos m4 >= IExec(WB4,t).intpos i) &
   (for i be Element of NAT st m4 < i & i <= n4 holds
      IExec(WB4,t).intpos m4 <= IExec(WB4,t).intpos i) &
   (for j be Element of NAT st (p0+1<=j & j<md) or (n4<j & j <= p0+n) holds
        IExec(WB4,t).intpos j = t.intpos j)
   proof
      let t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer,
      f1,f2 be
       FinSequence of INT;
     set mp=m1+pn,
         t1=IExec(l1 ';' l2,t);
      assume A168: t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos mp=md &
         md >= p0+1 & n4=t.intpos (mp+1) & n4-md > 0 & n4 <= pn;
      assume A169: f1 is_FinSequence_on t,p0 & len f1=n;
      assume A170: f2 is_FinSequence_on IExec(WB4,t),p0 & len f2=n;
A171:  t1.SBP=m1 by A143,A168;
A172:  mp >= 0+7 by A5,XREAL_1:9;
      then mp > 2 by XXREAL_0:2;
then A173: t1.intpos mp=md by A143,A168;
     mp+1 >= 7+1 by A172,XREAL_1:8;
     then mp+1 > 2 by XXREAL_0:2;
then A174:  n4=t1.intpos (mp+1) by A143,A168;
A175:  t1.a=0 by A143,A168;
then A176:  DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
     A177: t1.a2 > 0 by A143,A168;
A178:  TR is_closed_on t1 & TR is_halting_on t1 by A82,A168,A171,A173,A174,A175
;
then A179:  IF4 is_closed_on t1 & IF4 is_halting_on t1 by A176,A177,SCMPDS_6:82
;
A180:  now let x;
        thus IExec(WB4,t).x = IExec(IF4,t1).x by A179,SCPISORT:8
        .=IExec(TR,t1).x by A176,A177,A178,Th1;
      end;
A181:  p0+1>= 7+1 by A3,XREAL_1:8;
          now let i be Element of NAT;
       assume A182: 1 <= i & i <= len f1;
         then p0+i >= p0+1 by XREAL_1:8;
     then p0+i >= 8 by A181,XXREAL_0:2;
     then A183: p0+i > 2 by XXREAL_0:2;
    thus f1.i=t.intpos(p0+i) by A169,A182,SCPISORT:def 1
         .= t1.intpos(p0+i) by A143,A168,A183;
     end;
then A184: f1 is_FinSequence_on t1,p0 by SCPISORT:def 1;
          now let i be Element of NAT;
       assume 1 <= i & i <= len f2;
     hence f2.i=IExec(WB4,t).intpos(p0+i) by A170,SCPISORT:def 1
         .= IExec(TR,t1).intpos(p0+i) by A180;
     end;
then A185:  f2 is_FinSequence_on IExec(TR,t1),p0 by SCPISORT:def 1;
then A186:   IExec(TR,t1).a=0 & IExec(TR,t1).a1=m1+2 &
       md=IExec(TR,t1).intpos mp &
       n4=IExec(TR,t1).intpos (mp+3) &
      (for j be Element of NAT st (1<=j & j<m1) holds
          IExec(TR,t1).intpos(pn+j)=t1.intpos(pn+j))
        by A85,A168,A169,A170,A171,A173,A174,A175,A184;
    hence IExec(WB4,t).a=0 by A180;
    thus IExec(WB4,t).a1=m1+2 by A180,A186;
    thus md=IExec(WB4,t).intpos mp by A180,A186;
    thus n4=IExec(WB4,t).intpos (mp+3) by A180,A186;
    hereby let j be Element of NAT;
       assume A187:1<=j & j<m1;
       then pn+j >= pn+1 by XREAL_1:8;
   then pn+j >= 8 by A6,XXREAL_0:2;
   then A188: pn+j > 2 by XXREAL_0:2;
     thus IExec(WB4,t).intpos(pn+j)=IExec(TR,t1).intpos(pn+j) by A180
       .=t1.intpos(pn+j) by A85,A168,A169,A170,A171,A173,A174,A175,A184,A185
,A187
       .=t.intpos(pn+j) by A143,A168,A188;
    end;
    thus f1,f2 are_fiberwise_equipotent by A85,A168,A169,A170,A171,A173,A174
,A175,A184,A185;
     consider m4 be Element of NAT such that
A189:     md <= m4 & m4 <= n4 &
        m4-1=IExec(TR,t1).intpos (mp+1) &
        m4+1=IExec(TR,t1).intpos (mp+2) &
      (for i be Element of NAT st md<=i & i < m4 holds
      IExec(TR,t1).intpos m4 >= IExec(TR,t1).intpos i) &
      (for i be Element of NAT st m4 < i & i <= n4 holds
      IExec(TR,t1).intpos m4 <= IExec(TR,t1).intpos i) &
       (for j be Element of NAT st (p0+1<=j & j<md) or (n4<j & j <= p0+n) holds
        IExec(TR,t1).intpos j = t1.intpos j)
          by A85,A168,A169,A170,A171,A173,A174,A175,A184,A185;
       take m4;
    thus md <= m4 & m4 <= n4 by A189;
    thus m4-1=IExec(WB4,t).intpos (mp+1) by A180,A189;
    thus m4+1=IExec(WB4,t).intpos (mp+2) by A180,A189;
    hereby let i be Element of NAT;
       assume md<=i & i < m4;
       then IExec(TR,t1).intpos m4 >= IExec(TR,t1).intpos i by A189;
       then IExec(WB4,t).intpos m4 >= IExec(TR,t1).intpos i by A180;
      hence IExec(WB4,t).intpos m4 >= IExec(WB4,t).intpos i by A180;
    end;
    hereby let i be Element of NAT;
    assume m4 < i & i <= n4;
       then IExec(TR,t1).intpos m4 <= IExec(TR,t1).intpos i by A189;
       then IExec(WB4,t).intpos m4 <= IExec(TR,t1).intpos i by A180;
      hence IExec(WB4,t).intpos m4 <= IExec(WB4,t).intpos i by A180;
    end;
    hereby let j be Element of NAT;
      assume A190: (p0+1<=j & j<md) or (n4<j & j <= p0+n);
           now
         per cases by A190;
         suppose p0+1<=j & j<md;
           hence p0+1<=j;
         end;
         suppose n4<j & j <= p0+n;
           then j >= m4 by A189,XXREAL_0:2;
           then j >= md by A189,XXREAL_0:2;
         hence j >= p0+1 by A168,XXREAL_0:2;
      end;
      end;
   then j >= 8 by A181,XXREAL_0:2;
   then A191: j > 2 by XXREAL_0:2;
   thus IExec(WB4,t).intpos j = IExec(TR,t1).intpos j by A180
       .=t1.intpos j by A189,A190
       .=t.intpos j by A143,A168,A191;
      end;
    end;

A192: for t be State of SCMPDS,m be Element of NAT st
    t.a=0 & t.SBP=m & t.intpos (m+pn+1) <= t.intpos (m+pn)
    holds IExec(WB4,t).a=0 & IExec(WB4,t).a1=m-2 &
    (for j be Element of NAT st 1<=j & j<m holds
          IExec(WB4,t).intpos(pn+j)=t.intpos(pn+j)) &
    (for j be Element of NAT st 1<=j & j <= n holds
          IExec(WB4,t).intpos (p0+j) = t.intpos (p0+j))
  proof
    let t be State of SCMPDS,m be Element of NAT;
    set mp=m+pn,
         t1=IExec(l1 ';' l2,t);
    assume A193: t.a=0 & t.SBP=m & t.intpos (mp+1) <= t.intpos mp;
then A194:  t1.a2=t.intpos (mp+1)-t.intpos mp &
     for i be Element of NAT st i <> 2 holds t1.intpos i=t.intpos i by A143;
A195:  t1.a=0 by A143,A193;
then A196:  DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
     A197: t1.a2 <= 0 by A193,A194,REAL_2:106;
          lb is_closed_on t1 & lb is_halting_on t1 by SCMPDS_6:34,35;
then A198:  IF4 is_closed_on t1 & IF4 is_halting_on t1 by A196,A197,SCMPDS_6:83
;
     set li=AddTo(GBP,1,-2),
         t0=Initialized t1;
A199:  now let x;
        thus IExec(WB4,t).x = IExec(IF4,t1).x by A198,SCPISORT:8
          .=IExec(lb,t1).x by A196,A197,SCMPDS_6:88
          .=Exec(li,t0).x by SCMPDS_5:45;
     end;
A200:  t1.a1=m by A143,A193;
      t0.a=0 by A195,SCMPDS_5:40;
then A201:  DataLoc(t0.a,1)=intpos (0+1) by SCMP_GCD:5;
A202:  now let i be Element of NAT;
        assume i <> 1;
      then A203: intpos i <> DataLoc(t0.a,1) by A201,AMI_3:52;
       thus IExec(WB4,t).intpos i=Exec(li,t0).intpos i by A199
        .=t0.intpos i by A203,SCMPDS_2:60
        .=t1.intpos i by SCMPDS_5:40;
     end;
     hence IExec(WB4,t).a=0 by A195;
     thus IExec(WB4,t).a1=Exec(li,t0).a1 by A199
       .=t0.a1+-2 by A201,SCMPDS_2:60
       .=t0.a1-2
       .=m-2 by A200,SCMPDS_5:40;
     hereby
        let j be Element of NAT;
        assume 1<=j & j<m;
        then pn+j >= pn+1 by XREAL_1:8;
    then A204: pn+j >= 8 by A6,XXREAL_0:2;
    then A205: pn+j > 2 by XXREAL_0:2;
             pn+j > 1 by A204,XXREAL_0:2;
     hence IExec(WB4,t).intpos(pn+j)=t1.intpos(pn+j) by A202
         .=t.intpos(pn+j) by A143,A193,A205;
     end;
     hereby
        let j be Element of NAT;
        assume 1<=j & j<=n;
     then A206: p0+j >= p0+1 by XREAL_1:8;
              p0+1 >= 7+1 by A3,XREAL_1:8;
     then A207: p0+j >= 8 by A206,XXREAL_0:2;
     then A208: p0+j > 2 by XXREAL_0:2;
             p0+j > 1 by A207,XXREAL_0:2;
     hence IExec(WB4,t).intpos(p0+j)=t1.intpos(p0+j) by A202
         .=t.intpos(p0+j) by A143,A193,A208;
    end;
  end;

    set b1=DataLoc(0,1);
A209: b1=intpos(0+1) by SCMP_GCD:5;
A210: now
      let t be State of SCMPDS,f1,f2 be FinSequence of INT,
      k1,k2,y1,yn be Element of NAT;
      set mm=2*k1+1,
          md=p0+y1,
          n4=p0+yn;
      assume A211: t.a=0 & mm=t.b1 & k2=pn+2*k1+1 & md=t.intpos k2 &
        n4=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn);
        set mp=mm+pn;
    A212: k2=mp by A211;
    A213: md=t.intpos mp by A211;
    A214: n4=t.intpos(mp+1) by A211;
             now
          per cases by A211;
          case 1 <= y1 & yn <= n;
           hence p0+1 <= md by XREAL_1:8;
          end;
          case y1 >= yn;
           then md >= t.intpos (mp+1) by A211,XREAL_1:8;
           hence t.intpos (mp+1) -md <= 0 by REAL_2:106;
        end;
        end;
    hence WB4 is_closed_on t & WB4 is_halting_on t by A157,A209,A211,A213;
     consider f3 be FinSequence of INT such that
A215:  len f3=n & for i be Element of NAT st 1<=i & i <= len f3 holds
     f3.i=t.intpos(p0+i) by SCPISORT:2;
A216:  f3 is_FinSequence_on t,p0 by A215,SCPISORT:def 1;
     consider f4 be FinSequence of INT such that
A217:  len f4=n & for i be Element of NAT st 1<=i & i <= len f4 holds
     f4.i=IExec(WB4,t).intpos(p0+i) by SCPISORT:2;
A218:  f4 is_FinSequence_on IExec(WB4,t),p0 by A217,SCPISORT:def 1;
     hereby
        per cases;
        suppose t.intpos (mp+1) <= t.intpos mp;
         hence IExec(WB4,t).a=t.a &
           for j be Element of NAT st 1<=j & j<mm holds
             IExec(WB4,t).intpos(pn+j)=t.intpos(pn+j) by A192,A209,A211;
        end;
        suppose A219: t.intpos (mp+1) > t.intpos mp;
      then A220:  n4-md > 0 by A213,A214,XREAL_1:52;
            p0+1 <= md & n4 <= pn by A211,A219,XREAL_1:8;
        hence IExec(WB4,t).a=t.a & for j be Element of NAT st 1<=j & j<mm holds
            IExec(WB4,t).intpos(pn+j)=t.intpos(pn+j)
           by A167,A209,A211,A213,A215,A216,A217,A218,A220;
     end;
     end;
     hereby
        assume y1>=yn;
       then A221: t.intpos (mp+1) <= t.intpos mp by A213,A214,XREAL_1:8;
        hence IExec(WB4,t).b1=2*k1+1-2 by A192,A209,A211
          .=2*k1-1;
        thus for j be Element of NAT st (1<=j & j <= n) holds
          IExec(WB4,t).intpos (p0+j) = t.intpos (p0+j) by A192,A209,A211,A221;
    end;
    hereby
         assume A222: y1<yn;
      then n4 > md by XREAL_1:8;
      then A223:  n4-md > 0 by XREAL_1:52;
      A224:  p0+1 <= md & n4 <= pn by A211,A222,XREAL_1:8;
      hence IExec(WB4,t).b1=2*k1+1+2 by A167,A209,A211,A213,A215,A216,A217
,A218,A223
           .=2*k1+3;
           consider m4 be Element of NAT such that
      A225:  md <= m4 & m4 <= n4 & m4-1=IExec(WB4,t).intpos (mp+1) &
           m4+1=IExec(WB4,t).intpos (mp+2) &
           (for i be Element of NAT st md<=i & i < m4 holds
           IExec(WB4,t).intpos m4 >= IExec(WB4,t).intpos i) &
           (for i be Element of NAT st m4 < i & i <= n4 holds
           IExec(WB4,t).intpos m4 <= IExec(WB4,t).intpos i) &
           (for j be Element of NAT st (p0+1<=j & j<md) or (n4<j & j <= p0+n)
           holds
           IExec(WB4,t).intpos j = t.intpos j)
           by A167,A209,A211,A215,A216,A217,A218,A223,A224;
           hereby
              let j be Element of NAT;
              assume (1<=j & j<y1) or (yn<j & j <= n);
               then (p0+1<=p0+j & p0+j<md) or (n4<p0+j & p0+j <= p0+n) by
XREAL_1:8;
             hence IExec(WB4,t).intpos(p0+j) = t.intpos (p0+j) by A225;
           end;
       A226: m4-p0 >= y1 by A225,XREAL_1:21;
        reconsider ym=m4-p0 as Element of NAT by A226,INT_1:16;
        A227: m4=p0+ym;
            take ym;
          thus y1 <= ym & ym <= yn by A225,A227,XREAL_1:8;
          thus md=IExec(WB4,t).intpos k2 by A167,A209,A211,A212,A215,A216,A217
,A218,A223,A224;
          thus p0+ym-1=IExec(WB4,t).intpos (k2+1) by A211,A225;
          thus p0+ym+1=IExec(WB4,t).intpos (k2+2) by A211,A225;
          thus n4=IExec(WB4,t).intpos (k2+3) by A167,A209,A211,A212,A215,A216
,A217,A218,A223,A224;
        hereby
           let j be Element of NAT;
           assume y1 <= j & j < ym;
           then p0+y1 <= p0+j & p0+j < p0+ym by XREAL_1:8;
   hence IExec(WB4,t).intpos (p0+j) <= IExec(WB4,t).intpos (p0+ym) by A225;
       end;
        hereby
           let j be Element of NAT;
           assume ym < j & j <= yn;
            then p0+ym < p0+j & p0+j <= p0+yn by XREAL_1:8;
     hence IExec(WB4,t).intpos (p0+j) >= IExec(WB4,t).intpos (p0+ym) by A225;
       end;
     end;
     hereby
        assume A228: f1 is_FinSequence_on t,p0 &
         f2 is_FinSequence_on IExec(WB4,t),p0 & len f1=n & len f2=n;
        per cases;
        suppose A229: t.intpos (mp+1) <= t.intpos mp;
                now let i be Element of NAT;
              assume i in Seg n;
           then A230: 1 <= i & i <= n by FINSEQ_1:3;
            hence f1.i = t.intpos(p0+i) by A228,SCPISORT:def 1
               .=IExec(WB4,t).intpos(p0+i) by A192,A209,A211,A229,A230
               .=f2.i by A228,A230,SCPISORT:def 1;
           end;
          hence f1,f2 are_fiberwise_equipotent by A228,FINSEQ_2:10;
        end;
        suppose A231: t.intpos (mp+1) > t.intpos mp;
      then A232:  n4-md > 0 by A213,A214,XREAL_1:52;
            p0+1 <= md & n4 <= pn by A211,A231,XREAL_1:8;
       hence f1,f2 are_fiberwise_equipotent by A167,A209,A211,A213,A228
,A232;
     end;
     end;
   end;
A233:  s1.a=0 & s1.a1=1 & s1.intpos(pn+1)=p0+1 & s1.intpos(pn+2)=pn &
     (for i be Element of NAT st i >= 8 & i <= pn holds s1.intpos i=s.intpos i)
    proof
    set t0=Initialized s,
        t2=IExec(m1 ';' m2 ';' m3,s),
        t3=IExec(m1 ';' m2,s),
        t4=Exec(m1, t0);

A234: t4.a =0 by SCMPDS_2:57;
A235: now let i be Element of NAT;
       assume i >= 8;
        then i > 0;
        then a <> intpos i by AMI_3:52;
      hence t4.intpos i =t0.intpos i by SCMPDS_2:57
        .=s.intpos i by SCMPDS_5:40;
     end;
A236: t3.a=Exec(m2, t4).a by SCMPDS_5:47
     .=0 by A234,SCMPDS_2:57,SCMP_GCD:7;
A237: t3.SBP=Exec(m2, t4).SBP by SCMPDS_5:47
     .=1 by SCMPDS_2:57;
A238: now let i be Element of NAT;
       assume A239: i >= 8;
        then i > 1 by XXREAL_0:2;
    then A240:  SBP <> intpos i by AMI_3:52;
      thus t3.intpos i =Exec(m2, t4).intpos i by SCMPDS_5:47
        .=t4.intpos i by A240,SCMPDS_2:57
        .=s.intpos i by A235,A239;
     end;

A241:  DataLoc(t3.SBP,pn)=intpos (pn+1) by A237,SCMP_GCD:5;
then A242:  a <> DataLoc(t3.SBP,pn) by AMI_3:52;
A243: t2.a=Exec(m3,t3).a by SCMPDS_5:46
     .=0 by A236,A242,SCMPDS_2:58;
          pn+1 > 1 by A6,XXREAL_0:2;
then A244:  SBP <> DataLoc(t3.SBP,pn) by A241,AMI_3:52;
A245: t2.SBP=Exec(m3,t3).SBP by SCMPDS_5:46
     .=1 by A237,A244,SCMPDS_2:58;
A246: t2.intpos (pn+1)=Exec(m3,t3).intpos (pn+1) by SCMPDS_5:46
     .=p0+1 by A241,SCMPDS_2:58;
A247: now let i be Element of NAT;
       assume A248: i >= 8 & i <=pn;
             pn+1 > pn by XREAL_1:31;
    then A249: DataLoc(t3.SBP,pn) <> intpos i by A241,A248,AMI_3:52;
      thus t2.intpos i =Exec(m3, t3).intpos i by SCMPDS_5:46
        .=t3.intpos i by A249,SCMPDS_2:58
        .=s.intpos i by A238,A248;
     end;

A250:  DataLoc(t2.SBP,pn+1)=intpos (pn+(1+1)) by A245,SCMP_GCD:5;
then A251:  a <> DataLoc(t2.SBP,pn+1) by AMI_3:52;
    thus s1.a=Exec(m4,t2).a by SCMPDS_5:46
     .=0 by A243,A251,SCMPDS_2:58;
          pn+2 > 1 by A7,XXREAL_0:2;
then A252:  SBP <> DataLoc(t2.SBP,pn+1) by A250,AMI_3:52;
    thus s1.a1=Exec(m4,t2).SBP by SCMPDS_5:46
     .=1 by A245,A252,SCMPDS_2:58;
          pn+2 > pn+1 by XREAL_1:8;
then A253:  intpos (pn+1) <> DataLoc(t2.SBP,pn+1) by A250,AMI_3:52;
    thus s1.intpos (pn+1)=Exec(m4,t2).intpos (pn+1) by SCMPDS_5:46
     .=p0+1 by A246,A253,SCMPDS_2:58;
    thus s1.intpos (pn+2)=Exec(m4,t2).intpos (pn+2) by SCMPDS_5:46
     .=pn by A250,SCMPDS_2:58;
    hereby let i be Element of NAT;
       assume A254: i >= 8 & i <=pn;
             pn+2 > pn+0 by XREAL_1:8;
    then A255: DataLoc(t2.SBP,pn+1) <> intpos i by A250,A254,AMI_3:52;
      thus s1.intpos i =Exec(m4, t2).intpos i by SCMPDS_5:46
        .=t2.intpos i by A255,SCMPDS_2:58
        .=s.intpos i by A247,A254;
     end;
   end;
A256: s1.intpos(pn+1+1)=pn by A233;
then A257:  WH4 is_halting_on s1 & WH4 is_closed_on s1
       by A2,A209,A210,A233,Lm6;
      then M4 ';' WH4 is_halting_on s by SCPISORT:10;
     hence QuickSort(n,p0) is_halting_on s;
   consider f be FinSequence of INT such that
A258:  len f=n & f is_FinSequence_on s,p0 by SCPISORT:3;
   consider g be FinSequence of INT such that
A259:  len g=n & g is_FinSequence_on IExec(QuickSort(n,p0),s),p0 by SCPISORT:3;
   take f,g;
   thus len f=n & f is_FinSequence_on s,p0 & len g=n &
   g is_FinSequence_on IExec(QuickSort(n,p0),s),p0 by A258,A259;
          now let i be Element of NAT;
         assume A260: 1 <= i & i <= len f;
      then A261: p0+i >= p0+1 by XREAL_1:8;
               p0+1 >= 7+1 by A3,XREAL_1:8;
      then A262: p0+i >= 8 by A261,XXREAL_0:2;
      A263: p0+i <= pn by A258,A260,XREAL_1:8;
         thus f.i=s.intpos(p0+i) by A258,A260,SCPISORT:def 1
           .=s1.intpos(p0+i) by A233,A262,A263;
     end;
then A264:  f is_FinSequence_on s1,p0 by SCPISORT:def 1;
          now let i be Element of NAT;
         assume 1 <= i & i <= len g;
         hence g.i=IExec(M4 ';' WH4,s).intpos(p0+i) by A259,SCPISORT:def 1
           .=IExec(WH4,s1).intpos(p0+i) by A257,SCPISORT:8;
     end;
then g is_FinSequence_on IExec(WH4,s1),p0 by SCPISORT:def 1;
     hence f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
       by A2,A209,A210,A233,A256,A258,A259,A264,Lm4;
end;

begin :: The Basic Property of Quick Sort and Its Correctness

theorem
         card QuickSort(n,p0)=57 by Lm29;

theorem
      for p0,n being Element of NAT st p0 >= 7
      holds QuickSort(n,p0) is parahalting
proof
   let p0,n be Element of NAT;
   assume p0 >= 7;
   then for s be State of SCMPDS holds QuickSort(n,p0) is_halting_on s by Lm29
;
   hence thesis by SCMPDS_6:35;
end;

theorem
      for s being State of SCMPDS,p0,n being Element of NAT st p0 >= 7 holds
    ex f,g be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 &
    len g = n & g is_FinSequence_on IExec(QuickSort(n,p0),s),p0 &
    f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n by Lm29;
