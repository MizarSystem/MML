:: Quick Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, SCMPDS_4, SCMFSA6A, SCMFSA8A, SCMFSA_7,
      INT_1, SCMFSA8B, CARD_1, SCMPDS_5, FUNCT_1, UNIALG_2, SCMFSA7B, SCMFSA6B,
      FUNCT_4, SCMPDS_3, RELAT_1, AMI_2, SCMFSA_9, ARYTM_1, RELOC, SCM_1,
      FUNCT_7, BOOLE, FUNCOP_1, CARD_3, SCMPDS_8, FINSEQ_1, GRAPH_2, RFINSEQ,
      SCPISORT, SCMP_GCD, SCPQSORT, ARYTM, AMI_5, SCMNORM;
 notations TARSKI, XBOOLE_0, FUNCT_2, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, RELAT_1, FUNCT_1, RECDEF_1, INT_1, NAT_1, AMI_1, SCMNORM,
      AMI_2, FUNCT_7, SCMPDS_2, SCMPDS_3, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMP_GCD, CARD_3, FINSEQ_1, SCMPDS_8, GRAPH_2, CLASSES1, SCPISORT;
 constructors REAL_1, NAT_1, RECDEF_1, NEWTON, RFINSEQ, MESFUNC1, SCM_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT, SCMNORM,
      CLASSES1, SCMPDS_3;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMPDS_8, ORDINAL1, VALUED_0, SCMNORM, VALUED_1, AMI_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMPDS_2, SCMP_GCD, SCMPDS_3, SCMNORM;
 theorems AMI_1, AMI_3, NAT_1, TARSKI, FUNCT_4, SCMPDS_2, FUNCT_7, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_7, SCMPDS_8, FINSEQ_1, FINSEQ_2, RFINSEQ,
      RELAT_1, SCPISORT, XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, GRAPH_2, AMI_2,
      ORDINAL1, CLASSES1, SCMPDS_6, SCMP_GCD, INT_1;
 schemes NAT_1, SCMPDS_8;

begin :: The Several Properties of "while" Program and Finite Sequence

reserve x for Int_position,
  n,p0 for Element of NAT;

Lm1: for s being State of SCMPDS, I,J being shiftable Program of SCMPDS, n
being Element of NAT holds I ';' Goto n ';' J is shiftable

proof

  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, n be Element
  of NAT;

  I ';' Goto n ';' J = I ';' Load (goto n) ';' J by SCMPDS_6:def 1;
  hence thesis;
end;

registration
  let I,J be shiftable Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> shiftable;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I + 2), G =Goto (card J+1);
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS by Lm1;
    if>0(a,k1,I,J) = i ';' I ';' G ';' J by SCMPDS_6:def 5
      .=i ';' (I ';' G) ';' J by SCMPDS_4:50
      .=i ';' IJ by SCMPDS_4:50
      .=Load i ';' IJ by SCMPDS_4:def 4;
    hence thesis;
  end;
end;

theorem Th1: :: see SCMPDS_6:87
  for s being State of SCMPDS,I being No-StopCode shiftable Program
  of SCMPDS, J being shiftable Program of SCMPDS,a,b be Int_position,k1 being
  Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s & I is_halting_on s holds
  IExec(if>0(a,k1,I,J),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a,b be Int_position,k1 be Integer;
  assume that
A1: s.DataLoc(s.a,k1)>0 and
A2: I is_closed_on s and
A3: I is_halting_on s;
A4: not b in dom Start-At inspos (card I + card J + 2) by SCMPDS_4:59;
  IExec(if>0(a,k1,I,J),s) = IExec(I,s) +* Start-At inspos (card I + card J
  + 2) by A1,A2,A3,SCMPDS_6:84;
  hence thesis by A4,FUNCT_4:12;
end;
set A = NAT, D = SCM-Data-Loc;

Lm2: for a be Int_position,i be Integer,I be Program of SCMPDS holds while>0(a
,i,I)= ((a,i)<=0_goto (card I +2)) ';' (I ';' goto -(card I+1))

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2), i2=goto -(card I+1);
  thus while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
    .= i1 ';' (I ';' i2) by SCMPDS_4:51;
end;

Lm3: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A1: while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
    .= i1 ';' I ';' Load i2 by SCMPDS_4:def 5
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

theorem Th2:
  for s,sm be State of SCMPDS,I be No-StopCode shiftable Program of
  SCMPDS, a be Int_position,i be Integer, m be Element of NAT st card I>0 & I
  is_closed_on s & I is_halting_on s & s.DataLoc(s.a,i) > 0 & m=LifeSpan (s +*
Initialized stop I)+2 & sm=Computation((s +* Initialized stop while>0(a,i,I)),m
) holds DataPart sm = DataPart IExec(I,s) & sm +*Initialized stop while>0(a,i,I
  )=sm
proof
  let s,sm be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a
  be Int_position,i be Integer,m be Element of NAT;
  set b=DataLoc(s.a,i);
  set WH =while>0(a,i,I), iWH=Initialized stop WH, IsI=Initialized stop I;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  set s2 = s +* IsI, s3 = s +* iWH, s4 = Computation(s3,1);
  assume that
A1: card I>0 and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: s.b > 0 and
A5: m=LifeSpan s2+2 and
A6: sm= Computation((s +* iWH),m);
A7: IsI c= s2 by FUNCT_4:26;
A8: iWH c= s3 by FUNCT_4:26;
  WH c= iWH by SCMPDS_6:17;
  then
A9: WH c= s3 by A8,XBOOLE_1:1;
  Shift(I,1) c= WH by Lm3;
  then Shift(I,1) c= s3 by A9,XBOOLE_1:1;
  then
A10: Shift(I,1) c= s4 by AMI_1:81;
  WH = i1 ';' (I ';' i2) by Lm2;
  then
A11: CurInstr s3 = i1 by SCMPDS_6:22;
A12: Computation(s3,0+1) = Following Computation(s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A11,AMI_1:def 18;
  set m2=LifeSpan s2, s5= Computation( s4,m2), l1=inspos (card I + 1);
A13: IC s3 =inspos 0 by SCMPDS_6:21;
A14: s3.DataLoc(s3.a,i)= s3.b by SCMPDS_5:19
    .= s.b by SCMPDS_5:19;
  set m3=m2 +1;
  set s6= Computation( s3,m3);
A15: s6=s5 by AMI_1:51;
  set s7= Computation(s3,m3+1);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A16: l1 in dom WH by SCMPDS_8:18;
A17: dom (s | A) = A by SCMPDS_6:1;
A18: I is_closed_on s2 by A2,SCMPDS_6:38;
A19: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let x;
    thus s2.x = s3.x by A19,SCMPDS_4:23
      .= s4.x by A12,SCMPDS_2:68;
  end;
  then
A20: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A21: ProgramPart s2 halts_on s2 by A3,SCMPDS_6:def 3;
  s2 = s2+*IsI by A7,FUNCT_4:79;
  then ProgramPart(s2+*IsI) halts_on s2+*IsI by A7,FUNCT_4:79,A21;
  then
A22: I is_halting_on s2 by SCMPDS_6:def 3;
A23: IC s4 = s4.IC SCMPDS by AMI_1:def 15
    .= Next inspos 0 by A4,A13,A12,A14,SCMPDS_2:68
    .= inspos(0+1);
  then DataPart Computation( s2,m2) = DataPart s5 by A1,A7,A22,A18,A20,A10,
SCMPDS_7:36;
  then
A24: DataPart s5 = DataPart(Result s2) by A21,AMI_1:122
    .= DataPart(Result s2 +* s | A) by A17,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart IExec(I,s) by SCMPDS_4:def 8;
A25: IC s5=l1 by A1,A7,A22,A18,A23,A20,A10,SCMPDS_7:36;
  then
A26: CurInstr s6=s5.l1 by A15,AMI_1:def 16
    .=s4.l1 by AMI_1:54
    .=s3.l1 by AMI_1:54
    .=WH.l1 by A16,A9,GRFUNC_1:8
    .=i2 by SCMPDS_8:19;
A27: s7 = Following s6 by AMI_1:14
    .= Exec(i2,s6) by A26,AMI_1:def 18;
  now
    let x;
    thus sm.x=s6.x by A5,A6,A27,SCMPDS_2:66
      .=s5.x by AMI_1:51;
  end;
  hence DataPart sm = DataPart IExec(I,s) by A24,SCMPDS_4:23;
  IC s7=s7.IC SCMPDS by AMI_1:def 15
    .=ICplusConst(s6,0-(card I+1)) by A27,SCMPDS_2:66
    .=inspos 0 by A25,A15,SCMPDS_7:1;
  hence thesis by A5,A6,SCMPDS_7:37;
end;

theorem Th3:
  for s be State of SCMPDS,I be Program of SCMPDS st for t be State
  of SCMPDS st DataPart t = DataPart s holds I is_halting_on t holds I
  is_closed_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: for t be State of SCMPDS st DataPart t = DataPart s holds I
  is_halting_on t;
  set pI=stop I, II=Initialized pI, sI=s +* II;
  defpred X[Nat] means not IC Computation(sI,$1) in dom pI;
A2: for a be Int_position holds s.a = sI.a by SCMPDS_5:19;
  assume
  not I is_closed_on s;
  then ex k be Element of NAT st X[k] by SCMPDS_6:def 2;
  then
A3: ex k be Nat st X[k];
  consider n be Nat such that
A4: X[n] and
A5: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A3);
  reconsider n as Element of NAT by ORDINAL1:def 13;
  set s2 = Computation(sI,n), Ig = ((IC s2,Next IC s2) --> (goto 1, goto -1)),
s0 = sI +* Ig, s1 = s2 +* Ig, t1= sI +* (IC s2,goto 1), t2= t1 +* (Next IC s2,
  goto -1), t3= s2 +* (IC s2,goto 1), t4= t3 +* (Next IC s2,goto -1);
X: Next IC s2 in NAT by ORDINAL1:def 13;
  then
A6: t1,t2 equal_outside NAT by FUNCT_7:93;
  sI | NAT = s2 | NAT by AMI_1:123;
  then t1 | NAT = t3 | NAT by FUNCT_7:95;
  then t2 | NAT = t4 | NAT by FUNCT_7:95;
  then s0 | NAT = t4 | NAT by SCMPDS_4:69;
  then s0 | NAT = s1 | NAT by SCMPDS_4:69;
  then
A7: Computation(s0,n) | NAT = s1 | NAT by AMI_1:123;
A8: t3,t4 equal_outside NAT by X,FUNCT_7:93;
A9: IC s2 in NAT by AMI_1:def 4;
  then sI,t1 equal_outside NAT by FUNCT_7:93;
  then sI,t2 equal_outside NAT by A6,FUNCT_7:29;
  then
A10: sI,s0 equal_outside NAT by SCMPDS_4:69;
  then
A11: s0,sI equal_outside NAT by FUNCT_7:28;
  s2,t3 equal_outside NAT by A9,FUNCT_7:93;
  then s2,t4 equal_outside NAT by A8,FUNCT_7:29;
  then
A12: s2,s1 equal_outside NAT by SCMPDS_4:69;
A13: for m be Element of NAT st m < n holds IC( Computation( sI,m)) in dom
  pI by A5;
  set IAt = pI +* Start-At inspos 0;
A14: II = IAt by SCMPDS_4:def 2;
  (IAt) | NAT = pI by SCMPDS_4:58;
  then
A15: dom stop (I) = dom(IAt) /\ NAT by RELAT_1:90;
  not Next IC Computation(sI,n) in dom pI by A4,SCMPDS_4:71;
  then
A16: not Next IC s2 in dom IAt by A15,X,XBOOLE_0:def 4;
  dom stop(I) misses dom Start-At inspos 0 by SCMPDS_4:54;
  then
A17: pI c= IAt by FUNCT_4:33;
  II c= sI by FUNCT_4:26;
  then
A18: stop I c= sI by A17,A14,XBOOLE_1:1;
  not IC s2 in dom IAt by A4,A9,A15,XBOOLE_0:def 4;
  then IAt c= t1 by A14,FUNCT_4:26,FUNCT_7:91;
  then IAt c= t2 by A16,FUNCT_7:91;
  then
A19: IAt c= s0 by SCMPDS_4:69;
  then stop I c= s0 by A17,XBOOLE_1:1;
  then Computation(s0,n),s2 equal_outside NAT by A11,A18,A13,SCMPDS_4:67;
  then Computation(s0,n), s1 equal_outside NAT by A12,FUNCT_7:29;
  then
A20: Computation(s0,n) = s1 by A7,FUNCT_7:92;
  DataPart s0 = DataPart sI by A10,SCMPDS_4:24
    .= DataPart s by A2,SCMPDS_4:23;
  then I is_halting_on s0 by A1;
  then
A21: ProgramPart(s0+*II) halts_on s0+*II by SCMPDS_6:def 3;
A22: not ProgramPart s1 halts_on s1 by SCMPDS_4:66;
X:  s0 +* II=s0 by A14,A19,FUNCT_4:79;
   then ProgramPart s0 halts_on s1 by AMI_1:144,93,A22,A21,A20;
  hence contradiction by A21,A20,A22,AMI_1:93,144,X;
end;

theorem Th4:
  for i1,i2,i3,i4 be Instruction of SCMPDS holds card (i1 ';' i2
  ';' i3 ';' i4)=4
proof
  let x1,x2,x3,x4 be Instruction of SCMPDS;
  thus card (x1 ';' x2 ';' x3 ';' x4)=card (x1 ';' x2 ';' x3)+1 by SCMP_GCD:8
    .=card (x1 ';' x2 )+1+1 by SCMP_GCD:8
    .=2+1+1 by SCMP_GCD:9
    .=4;
end;

theorem Th5:
  for s being State of SCMPDS,I being No-StopCode shiftable Program
  of SCMPDS, a,x,y be Int_position, i,c be Integer st card I > 0 & s.x >= c+s.
DataLoc(s.a,i) & (for t be State of SCMPDS st t.x >= c+t.DataLoc(s.a,i) & t.y=s
.y & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I is_closed_on t &
I is_halting_on t & IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) & IExec(I,t).x
  >= c+IExec(I,t).DataLoc(s.a,i) & IExec(I,t).y=t.y) holds while>0(a,i,I)
is_closed_on s & while>0(a,i,I) is_halting_on s & (s.DataLoc(s.a,i) > 0 implies
  IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a,x1,
  y1 be Int_position, i,c be Integer;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
  s.x1 >= c+s.b;
  then
A2: for x st x in {x1} holds s.x >= c+s.b by TARSKI:def 1;
  assume
A3: for t be State of SCMPDS st t.x1 >= c+t.b & t.y1=s.y1 & t.a=s.a & t.
b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t
  ).b < t.b & IExec(I,t).x1 >= c+IExec(I,t).b & IExec(I,t).y1=t.y1;
  now
    let t be State of SCMPDS;
    assume that
A4: for x st x in {x1} holds t.x >= c+t.b and
A5: for x st x in {y1} holds t.x=s.x and
A6: t.a=s.a and
A7: t.b > 0;
    y1 in {y1} by TARSKI:def 1;
    then
A8: t.y1=s.y1 by A5;
    x1 in {x1} by TARSKI:def 1;
    then
A9: t.x1 >= c+t.b by A4;
    hence
    IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).
    b < t.b by A3,A6,A7,A8;
    hereby
      let x;
      assume
A10:  x in {x1};
      IExec(I,t).x1 >= c+IExec(I,t).b by A3,A6,A7,A9,A8;
      hence IExec(I,t).x >= c+IExec(I,t).b by A10,TARSKI:def 1;
    end;
    hereby
      let x;
      assume
A11:  x in {y1};
      hence IExec(I,t).x=IExec(I,t).y1 by TARSKI:def 1
        .=t.y1 by A3,A6,A7,A9,A8
        .=t.x by A11,TARSKI:def 1;
    end;
  end;
  hence thesis by A1,A2,SCMPDS_8:27;
end;

theorem Th6:
  for s being State of SCMPDS,I being No-StopCode shiftable Program
  of SCMPDS, a,x,y be Int_position, i,c be Integer st card I > 0 & s.x >= c & (
for t be State of SCMPDS st t.x >= c & t.y=s.y & t.a=s.a & t.DataLoc(s.a,i) > 0
  holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).
DataLoc(s.a,i) < t.DataLoc(s.a,i) & IExec(I,t).x >= c & IExec(I,t).y=t.y) holds
while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s & ( s.DataLoc(s.
  a,i) > 0 implies IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x >= c & t.y=s.y;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b <= 0 implies f.s =0) & (s.b > 0
  implies f.s=s.b) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = f.$1;
A3: for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
  proof
    let t be State of SCMPDS;
    thus F(Dstate t)=0 implies t.b <= 0
    proof
      assume
A4:   F(Dstate t)=0;
      assume
      t.b > 0;
      then (Dstate t).b > 0 by SCMPDS_8:4;
      hence contradiction by A2,A4;
    end;
    assume
    t.b <= 0;
    then (Dstate t).b <= 0 by SCMPDS_8:4;
    hence thesis by A2;
  end;
  then
A5: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
  assume
A6: s.x >= c;
A7: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    thus t.x >= c by A6,SCMPDS_8:4;
    thus thesis by SCMPDS_8:4;
  end;
  assume
A8: for t be State of SCMPDS st t.x >= c & t.y=s.y & t.a=s.a & t.b > 0
holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).b <
  t.b & IExec(I,t).x >= c & IExec(I,t).y=t.y;
A9: now
    let t be State of SCMPDS;
    assume that
A10: P[Dstate t] and
A11: t.a=s.a and
A12: t.b > 0;
    set It=IExec(I,t), t2=Dstate It, t1=Dstate t;
A13: t.y=s.y by A10,SCMPDS_8:4;
A14: t.x >= c by A10,SCMPDS_8:4;
    hence
    IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t by A8,A11,A12,A13;
    thus F(t2) < F(t1)
    proof
      t1.b > 0 by A12,SCMPDS_8:4;
      then
A15:  F(t1)=t1.b by A2
        .=t.b by SCMPDS_8:4;
      assume
A16:  F(t2) >= F(t1);
      then It.b > 0 by A3,A12,A15;
      then t2.b > 0 by SCMPDS_8:4;
      then F(t2)=t2.b by A2
        .=It.b by SCMPDS_8:4;
      hence contradiction by A8,A11,A12,A14,A13,A16,A15;
    end;
    thus P[Dstate It]
    proof
      take v=Dstate It;
      thus v=Dstate It;
      It.x >= c by A8,A11,A12,A14,A13;
      hence v.x >= c by SCMPDS_8:4;
      It.y=t.y by A8,A11,A12,A14,A13;
      hence thesis by A13,SCMPDS_8:4;
    end;
  end;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s & while>0(a,i,I)
  is_halting_on s from SCMPDS_8:sch 3(A1,A5,A7,A9);
  hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;
  assume
A17: s.b > 0;
  (F(s)=F(s) or P[s]) & IExec(while>0(a,i,I),s) = IExec(while>0(a,i,I),
  IExec(I,s)) from SCMPDS_8:sch 4(A1,A17,A5,A7,A9);
  hence thesis;
end;

theorem Th7:
  for s being State of SCMPDS,I being No-StopCode shiftable Program
of SCMPDS, a,x1,x2,x3,x4 be Int_position, i,c,md be Integer st card I > 0 & s.
x4=s.x3-c+s.x1 & md <= s.x3-c & (for t be State of SCMPDS st t.x4=t.x3-c+t.x1 &
md <= t.x3-c & t.x2=s.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.
  a & I is_closed_on t & I is_halting_on t & IExec(I,t).DataLoc(s.a,i) < t.
DataLoc(s.a,i) & IExec(I,t).x4=IExec(I,t).x3-c+IExec(I,t).x1 & md <= IExec(I,t)
.x3-c & IExec(I,t).x2=t.x2) holds while>0(a,i,I) is_closed_on s & while>0(a,i,I
  ) is_halting_on s & ( s.DataLoc(s.a,i) > 0 implies IExec(while>0(a,i,I),s) =
  IExec(while>0(a,i,I),IExec(I,s)) )
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a,x1,
  x2,x3,x4 be Int_position, i,c,md be Integer;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x4=t.x3-c+t.x1 & md
  <= t.x3-c & t.x2=s.x2;
  assume that
A2: s.x4=s.x3-c+s.x1 and
A3: md <= s.x3-c;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4: for s be State of SCMPDS holds (s.b <= 0 implies f.s =0) & (s.b > 0
  implies f.s=s.b) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = f.$1;
A5: for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
  proof
    let t be State of SCMPDS;
    thus F(Dstate t)=0 implies t.b <= 0
    proof
      assume
A6:   F(Dstate t)=0;
      assume
      t.b > 0;
      then (Dstate t).b > 0 by SCMPDS_8:4;
      hence contradiction by A4,A6;
    end;
    assume
    t.b <= 0;
    then (Dstate t).b <= 0 by SCMPDS_8:4;
    hence thesis by A4;
  end;
  then
A7: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
  assume
A8: for t be State of SCMPDS st t.x4=t.x3-c+t.x1 & md <= t.x3-c & t.x2=s
.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I is_closed_on t
& I is_halting_on t & IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) & IExec(I,t)
.x4=IExec(I,t).x3-c+IExec(I,t).x1 & md <= IExec(I,t).x3-c & IExec(I,t).x2=t.x2;
A9: now
    let t be State of SCMPDS;
    assume that
A10: P[Dstate t] and
A11: t.a=s.a and
A12: t.b > 0;
    set It=IExec(I,t), t2=Dstate It, t1=Dstate t;
    consider v be State of SCMPDS such that
A13: v=Dstate t and
A14: v.x4=v.x3-c+v.x1 and
A15: md <= v.x3-c and
A16: v.x2=s.x2 by A10;
A17: t.x2=s.x2 by A13,A16,SCMPDS_8:4;
    t.x4=v.x3-c+v.x1 by A13,A14,SCMPDS_8:4;
    then t.x4=t.x3-c+v.x1 by A13,SCMPDS_8:4;
    then
A18: t.x4=t.x3-c+t.x1 by A13,SCMPDS_8:4;
A19: md <= t.x3-c by A13,A15,SCMPDS_8:4;
    hence
    IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t by A8,A11,A12,A18
,A17;
    thus F(t2) < F(t1)
    proof
      t1.b > 0 by A12,SCMPDS_8:4;
      then
A20:  F(t1)=t1.b by A4
        .=t.b by SCMPDS_8:4;
      assume
A21:  F(t2) >= F(t1);
      then It.b > 0 by A5,A12,A20;
      then t2.b > 0 by SCMPDS_8:4;
      then F(t2)=t2.b by A4
        .=It.b by SCMPDS_8:4;
      hence contradiction by A8,A11,A12,A18,A19,A17,A21,A20;
    end;
    thus P[Dstate It]
    proof
      take v=Dstate It;
      thus v=Dstate It;
      It.x4=It.x3-c+It.x1 by A8,A11,A12,A18,A19,A17;
      then v.x4=It.x3-c+It.x1 by SCMPDS_8:4;
      then v.x4=v.x3-c+It.x1 by SCMPDS_8:4;
      hence v.x4=v.x3-c+v.x1 by SCMPDS_8:4;
      md <= It.x3-c by A8,A11,A12,A18,A19,A17;
      hence md <= v.x3-c by SCMPDS_8:4;
      It.x2=t.x2 by A8,A11,A12,A18,A19,A17;
      hence thesis by A17,SCMPDS_8:4;
    end;
  end;
A22: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    t.x4=s.x3-c+s.x1 by A2,SCMPDS_8:4;
    then t.x4=t.x3-c+s.x1 by SCMPDS_8:4;
    hence t.x4=t.x3-c+t.x1 by SCMPDS_8:4;
    thus md <= t.x3-c by A3,SCMPDS_8:4;
    thus thesis by SCMPDS_8:4;
  end;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s & while>0(a,i,I)
  is_halting_on s from SCMPDS_8:sch 3(A1,A7,A22,A9);
  hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;
  assume
A23: s.b > 0;
  (F(s)=F(s) or P[s]) & IExec(while>0(a,i,I),s) = IExec(while>0(a,i,I),
  IExec(I,s)) from SCMPDS_8:sch 4(A1,A23,A7,A22,A9);
  hence thesis;
end;

theorem Th8:
  for f being FinSequence of INT,m,k1,k,n be Element of NAT st k1=k
  -1 & f is_non_decreasing_on m,k1 & f is_non_decreasing_on k+1,n & (for i be
  Element of NAT st m <= i & i < k holds f.i <= f.k) & (for i be Element of NAT
  st k < i & i <= n holds f.k <= f.i) holds f is_non_decreasing_on m,n
proof
  let f be FinSequence of INT,m,k1,k,n be Element of NAT;
  assume that
A1: k1=k-1;
  assume
A2: f is_non_decreasing_on m,k1;
  assume
A3: f is_non_decreasing_on k+1,n;
  assume
A4: for i be Element of NAT st m <= i & i < k holds f.i <= f.k;
  assume
A5: for i be Element of NAT st k < i & i <= n holds f.k <= f.i;
  now
    let i,j be Element of NAT;
    assume that
A6: m <= i and
A7: i <= j and
A8: j <= n;
    per cases by XXREAL_0:1;
    suppose
      j < k;
      then j+1 <= k by INT_1:20;
      then j <= k1 by A1,XREAL_1:21;
      hence f.i <= f.j by A2,A6,A7,GRAPH_2:def 13;
    end;
    suppose
A9:   j = k;
      hereby
        per cases;
        suppose
          i=j;
          hence f.i <= f.j;
        end;
        suppose
          i<>j;
          then i<j by A7,XXREAL_0:1;
          hence f.i <= f.j by A4,A6,A9;
        end;
      end;
    end;
    suppose
A10:  j > k;
      hereby
        per cases by XXREAL_0:1;
        suppose
          i < k;
          then
A11:      f.k >= f.i by A4,A6;
          f.j >= f.k by A5,A8,A10;
          hence f.i <= f.j by A11,XXREAL_0:2;
        end;
        suppose
A12:      i = k;
          hereby
            per cases;
            suppose
              i=j;
              hence f.i <= f.j;
            end;
            suppose
              i<>j;
              then i<j by A7,XXREAL_0:1;
              hence f.i <= f.j by A5,A8,A12;
            end;
          end;
        end;
        suppose
          i > k;
          then i >= k+1 by INT_1:20;
          hence f.i <= f.j by A3,A7,A8,GRAPH_2:def 13;
        end;
      end;
    end;
  end;
  hence thesis by GRAPH_2:def 13;
end;

Lm4: for s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,f,g be FinSequence of INT,m,n,m1 be Element of
NAT st card I> 0 & s.a=c & len f=n & len g=n & f is_FinSequence_on s,m & g
is_FinSequence_on IExec(while>0(a,i,I),s),m & 1=s.DataLoc(c,i) & m1=m+n+1 & m+1
=s.intpos m1 & m+n=s.intpos(m1+1) & (for t be State of SCMPDS,f1,f2 be
FinSequence of INT,k1,k2,y1, yn be Element of NAT st t.a=c & 2*k1+1=t.DataLoc(c
,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & (1 <= y1 & yn <=
n or y1 >= yn) holds I is_closed_on t & I is_halting_on t & IExec(I,t).a=t.a &
(for j be Element of NAT st (1<=j & j<2*k1+1) holds IExec(I,t).intpos(m+n+j)=t.
intpos(m+n+j)) & (y1>=yn implies IExec(I,t).DataLoc(c,i)=2*k1-1 & (for j be
Element of NAT st (1<=j & j <= n) holds IExec(I,t).intpos (m+j) = t.intpos (m+j
))) & (y1<yn implies IExec(I,t).DataLoc(c,i)=2*k1+3 & (for j be Element of NAT
st (1<=j & j<y1) or (yn<j & j <= n) holds IExec(I,t).intpos(m+j) = t.intpos (m+
j)) & (ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=IExec(I,t).intpos
k2 & m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).intpos (k2+2) & m+yn=
IExec(I,t).intpos (k2+3) & (for j be Element of NAT st y1 <= j & j < ym holds
IExec(I,t).intpos (m+j) <= IExec(I,t).intpos (m+ym)) & (for j be Element of NAT
st ym < j & j <= yn holds IExec(I,t).intpos (m+j) >= IExec(I,t).intpos (m+ym)))
) & (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),m & len f1=n &
len f2=n implies f1,f2 are_fiberwise_equipotent)) holds while>0(a,i,I)
is_halting_on s & f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n

proof

  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,f,g be FinSequence of INT, m,n,m1 be Element of
  NAT;

  set b=DataLoc(c,i);
  assume that
A1: card I>0 and
A2: s.a=c and
A3: len f=n and
A4: len g=n;
  set WH =while>0(a,i,I), sWH=stop WH, iWH=Initialized sWH;
  assume
A5: f is_FinSequence_on s,m;

  defpred P[Element of NAT] means for t be State of SCMPDS,f1 be FinSequence

of INT, k1,k2,y1,yn be Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & (

1 <= y1 & yn <= n or y1 >= yn) & m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & yn-y1
  <=$1 & f1 is_FinSequence_on t,m & len f1=n holds ex k be Element of NAT,f2 be
  FinSequence of INT st Computation(t+*iWH,k)+*iWH= Computation(t+*iWH,k) & f2
  is_FinSequence_on Computation(t+*iWH,k),m & len f2=n & f1,f2

are_fiberwise_equipotent & f2 is_non_decreasing_on y1,yn & (for j be Element of

NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n) holds f2.j= t.intpos(m+j)) & (for

j be Element of NAT st y1>=yn & 1<=j & j<= n holds f2.j= t.intpos(m+j)) & (for

j be Element of NAT st (1<=j & j<2*k1+1) holds Computation(t+*iWH,k).intpos(m+n

+j)=t.intpos(m+n+j)) & Computation(t+*iWH,k).b=t.b-2 & Computation(t+*iWH,k).a=
  c;

  assume
A6: g is_FinSequence_on IExec(while>0(a,i,I),s),m;
  assume
A7: 1=s.b;
  assume that
A8: m1=m+n+1 and
A9: m+1=s.intpos m1 and
A10: m+n=s.intpos(m1+1);
A11: m1=m+n+2*0+1 by A8;
  assume

A12: for t be State of SCMPDS,f1,f2 be FinSequence of INT, k1,k2,y1,yn

be Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+

yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t & I

is_halting_on t & IExec(I,t).a=t.a & (for j be Element of NAT st (1<=j & j<2*k1

+1) holds IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn implies IExec(I,t

).b=2*k1-1 & for j be Element of NAT st 1<=j & j <= n holds IExec(I,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,t).b=2*k1+3 & (for j be

Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds IExec(I,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=
  IExec(I,t).intpos k2 & m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).

intpos (k2+2) & m+yn=IExec(I,t).intpos (k2+3) & (for j be Element of NAT st y1

<= j & j < ym holds IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) & for j

be Element of NAT st ym < j & j <= yn holds IExec(I,t).intpos(m+j) >= IExec(I,t

).intpos(m+ym) ) & (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

A13: P[0]
  proof

    let t be State of SCMPDS,f1 be FinSequence of INT,k1,k2,y1,yn be Element
    of NAT;

    assume that
A14: t.a=c and
A15: 2*k1+1=t.b and
A16: k2=m+n+2*k1+1 and
A17: 1 <= y1 & yn <= n or y1 >= yn and
A18: m+y1=t.intpos k2 and
A19: m+yn=t.intpos(k2+1) and
A20: yn-y1<=0 and
A21: f1 is_FinSequence_on t,m and
A22: len f1=n;
A23: I is_halting_on t by A12,A14,A15,A16,A17,A18,A19;
    take k=LifeSpan (t +* Initialized stop I)+2;
    set tk= Computation(t+*iWH,k);
A24: I is_closed_on t by A12,A14,A15,A16,A17,A18,A19;
    then
A25: DataPart tk = DataPart IExec(I,t) by A1,A14,A15,A23,Th2;
    consider f2 be FinSequence of INT such that
A26: len f2=n and

A27: for i be Element of NAT st 1<=i & i <= len f2 holds f2.i=IExec(I,
    t) .intpos(m+i) by SCPISORT:2;

    take f2;
    thus tk+*iWH =tk by A1,A14,A15,A24,A23,Th2;
    now
      let i be Element of NAT;
      assume that
A28:  1<=i and
A29:  i <= len f2;
      thus f2.i=IExec(I,t).intpos(m+i) by A27,A28,A29
        .=tk.intpos(m+i) by A25,SCMPDS_4:23;
    end;
    hence f2 is_FinSequence_on tk,m by SCPISORT:def 1;
    thus len f2=n by A26;
    f2 is_FinSequence_on IExec(I,t),m by A27,SCPISORT:def 1;

    hence
    f1,f2 are_fiberwise_equipotent by A12,A14,A15,A16,A17,A18,A19,A21,A22,A26;

    thus f2 is_non_decreasing_on y1,yn by A20,SCPISORT:1,XREAL_1:52;

    thus for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
    holds f2.j= t.intpos(m+j) by A20,XREAL_1:52;

    hereby
      let j be Element of NAT;
      assume that
A30:  y1>=yn and
A31:  1<=j and
A32:  j<= n;
      thus f2.j=IExec(I,t).intpos (m+j) by A26,A27,A31,A32
        .=t.intpos(m+j) by A12,A14,A15,A16,A18,A19,A30,A31,A32;
    end;
    hereby
      let j be Element of NAT;
      assume that
A33:  1<=j and
A34:  j<2*k1+1;
      thus tk.intpos(m+n+j)=IExec(I,t).intpos(m+n+j) by A25,SCMPDS_4:23
        .=t.intpos(m+n+j) by A12,A14,A15,A16,A17,A18,A19,A33,A34;
    end;

    y1>=yn implies IExec(I,t).b=2*k1-1 & for j be Element of NAT st 1<=j

& j <= n holds IExec(I,t).intpos (m+j) = t.intpos (m+j) by A12,A14,A15,A16,A18
,A19;

    hence tk.b=t.b-2 by A15,A20,A25,SCMPDS_4:23,XREAL_1:52;
    IExec(I,t).a=t.a by A12,A14,A15,A16,A17,A18,A19;
    hence thesis by A14,A25,SCMPDS_4:23;
  end;
A35: now
    let k be Element of NAT;
    assume
A36: P[k];
    now

      let t be State of SCMPDS,f1 be FinSequence of INT, k1,k2,y1,ym,yn be
      Element of NAT;

      assume that
A37:  t.a=c and
A38:  2*k1+1=t.b and
A39:  k2=m+n+2*k1+1 and
A40:  1 <= y1 & yn <= n or y1 >= yn and
A41:  m+y1=t.intpos k2 and
A42:  m+yn=t.intpos(k2+1) and
A43:  yn-y1<=k+1 and
A44:  f1 is_FinSequence_on t,m and
A45:  len f1=n;
      per cases;
      suppose
        yn-y1<=0;

        hence
        ex kk be Element of NAT,f2 be FinSequence of INT st Computation(t

+*iWH,kk)+*iWH= Computation(t+*iWH,kk) & f2 is_FinSequence_on Computation(t+*

iWH,kk),m & len f2=n & f1,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on

y1,yn & (for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n) holds

f2.j= t.intpos(m+j)) & (for j be Element of NAT st y1>=yn & 1<=j & j<= n holds

f2.j= t.intpos(m+j)) & (for j be Element of NAT st (1<=j & j<2*k1+1) holds

Computation(t+*iWH,kk).intpos(m+n+j)=t.intpos(m+n+j)) & Computation(t+*iWH,kk).

b=t.b-2 & Computation(t+*iWH,kk).a=c by A13,A37,A38,A39,A40,A41,A42,A44,A45;

      end;
      suppose
A46:    yn-y1>0;
        set m1=LifeSpan (t +* Initialized stop I)+2;
        set t1= Computation((t +* iWH),m1);
A47:    I is_halting_on t by A12,A37,A38,A39,A40,A41,A42;
        y1-1 >= 0 by A40,A46,XREAL_1:49,50;
        then reconsider y0=y1-1 as Element of NAT by INT_1:16;
        set jj=2*k1+1;
A48:    yn-y1-1 <= k+1-1 by A43,XREAL_1:11;
A49:    yn <= y1+(k+1) by A43,XREAL_1:22;
        consider f2 be FinSequence of INT such that
A50:    len f2=n and

A51:    for i be Element of NAT st 1<=i & i <= len f2 holds f2.i=t1.
        intpos( m+i) by SCPISORT:2;

A52:    f2 is_FinSequence_on t1,m by A51,SCPISORT:def 1;
        set It=IExec(I,t);

A53:    y1<yn implies It.b=2*k1+3 & (for j be Element of NAT st (1<=j & j

<y1) or (yn<j & j <= n) holds IExec(I,t).intpos (m+j) = t.intpos (m+j)) & ex ym

be Element of NAT st y1 <= ym & ym <= yn & m+y1=It.intpos k2 & m+ym-1=It.intpos

(k2+1) & m+ym+1=It.intpos (k2+2) & m+yn=It.intpos (k2+3) & (for j be Element of

NAT st y1 <= j & j < ym holds IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)

) & for j be Element of NAT st ym < j & j <= yn holds IExec(I,t).intpos(m+j) >=
        IExec(I,t).intpos(m+ym) by A12,A37,A38,A39,A40,A41,A42;

        then consider ym be Element of NAT such that
A54:    y1 <= ym and
A55:    ym <= yn and
A56:    m+y1=It.intpos k2 and
A57:    m+ym-1=It.intpos (k2+1) and
A58:    m+ym+1=It.intpos (k2+2) and
A59:    m+yn=It.intpos (k2+3) and

A60:    for j be Element of NAT st y1 <= j & j < ym holds IExec(I,t).
        intpos(m+j) <= IExec(I,t).intpos(m+ym) and

A61:    for j be Element of NAT st ym < j & j <= yn holds IExec(I,t).
        intpos(m+j) >= IExec(I,t).intpos(m+ym) by A46,XREAL_1:49;

A62:    I is_closed_on t by A12,A37,A38,A39,A40,A41,A42;
        then
A63:    DataPart t1 = DataPart IExec(I,t) by A1,A37,A38,A47,Th2;
        then
A64:    t1.b=2*k1+3 by A46,A53,SCMPDS_4:23,XREAL_1:49;
A65:    ym >= 1 by A40,A46,A54,XREAL_1:49,XXREAL_0:2;
        then reconsider yc=ym-1 as Element of NAT by INT_1:16,XREAL_1:50;
A66:    yc <= yn by A55,XREAL_1:148,XXREAL_0:2;
        then
A67:    yc <= n by A40,A46,XREAL_1:49,XXREAL_0:2;
A68:    t1.b=2*(k1+1)+1 by A46,A53,A63,SCMPDS_4:23,XREAL_1:49;
        IExec(I,t).a=t.a by A12,A37,A38,A39,A40,A41,A42;
        then
A69:    t1.a=c by A37,A63,SCMPDS_4:23;
        set k3=m+n+2*(k1+1)+1, yd=ym+1;
A70:    yd > ym by XREAL_1:31;
        then
A71:    yd >= y1 by A54,XXREAL_0:2;
        then
A72:    yd >= 1 by A40,A46,XREAL_1:49,XXREAL_0:2;
A73:    t1.intpos(k3+1)=m+yn by A39,A63,A59,SCMPDS_4:23;
        ym+(1+k) >= y1+(1+k) by A54,XREAL_1:8;
        then yn <= yd+k by A49,XXREAL_0:2;
        then
A74:    yn-yd<=k by XREAL_1:22;
        t1.intpos k3=m+yd by A39,A63,A58,SCMPDS_4:23;
        then consider kl be Element of NAT,f3 be FinSequence of INT such that
A75:    Computation(t1+*iWH,kl)+*iWH= Computation(t1+*iWH,kl) and
A76:    f3 is_FinSequence_on Computation(t1+*iWH,kl),m and
A77:    len f3=n and
A78:    f2,f3 are_fiberwise_equipotent and
A79:    f3 is_non_decreasing_on yd,yn and

A80:    for j be Element of NAT st yd<yn & (1<=j & j<yd or yn<j & j<=
        n) holds f3.j= t1.intpos(m+j) and

A81:    for j be Element of NAT st yd>=yn & 1<=j & j<= n holds f3.j=
        t1. intpos(m+j) and

A82:    for j be Element of NAT st 1<=j & j<2*(k1+1)+1 holds
        Computation (t1+*iWH,kl).intpos(m+n+j)=t1.intpos(m+n+j) and
A83:    Computation(t1+*iWH,kl).b=t1.b-2 and

A84:    Computation(t1+*iWH,kl).a=c by A36,A40,A46,A69,A68,A72,A73,A74,A50,A52,
XREAL_1:49;

        set t2= Computation(t1+*iWH,kl);
A85:    2*k1+3=2*(k1+1)+1;
        then jj < 2*(k1+1)+1 by XREAL_1:8;
        then
A86:    t2.intpos k2=t1.intpos(m+n+jj) by A39,A82,NAT_1:11
          .=m+y1 by A39,A63,A56,SCMPDS_4:23;
A87:    ym <= n by A40,A46,A55,XREAL_1:49,XXREAL_0:2;
A88:    now
          per cases;
          suppose
            yd<yn;
            hence f3.ym= t1.intpos(m+ym) by A70,A80,A65;
          end;
          suppose
            yd>=yn;
            hence f3.ym= t1.intpos(m+ym) by A81,A65,A87;
          end;
        end;
A89:    now
          let i be Element of NAT;
          assume that
A90:      1<=i and
A91:      i<=ym;
A92:      i<=n by A87,A91,XXREAL_0:2;
A93:      i<yd by A70,A91,XXREAL_0:2;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.i= t1.intpos(m+i) by A80,A90,A93;
            end;
            suppose
              yd>=yn;
              hence f3.i= t1.intpos(m+i) by A81,A90,A92;
            end;
          end;
          hence f3.i=f2.i by A50,A51,A90,A92;
        end;
        yc <= yn-1 by A55,XREAL_1:11;
        then yc-y1 <= yn-1-y1 by XREAL_1:11;
        then
A94:    yc-y1<=k by A48,XXREAL_0:2;
A95:    yc < yd by A70,XREAL_1:148,XXREAL_0:2;
        set jj=2*k1+2;
        jj >= 2 by NAT_1:11;
        then
A96:    jj >= 1 by XXREAL_0:2;
        jj < 2*(k1+1)+1 by A85,XREAL_1:8;
        then t2.intpos (k2+1)=t1.intpos(m+n+jj) by A39,A82,A96
          .=m+yc by A39,A63,A57,SCMPDS_4:23;
        then consider km be Element of NAT,f4 be FinSequence of INT such that
A97:    Computation(t2+*iWH,km)+*iWH= Computation(t2+*iWH,km) and
A98:    f4 is_FinSequence_on Computation(t2+*iWH,km),m and
A99:    len f4=n and
A100:   f3,f4 are_fiberwise_equipotent and
A101:   f4 is_non_decreasing_on y1,yc and

A102:   for j be Element of NAT st y1<yc & (1<=j & j<y1 or yc<j & j
        <= n) holds f4.j= t2.intpos(m+j) and

A103:   for j be Element of NAT st y1>=yc & 1<=j & j<= n holds f4.j=
        t2. intpos(m+j) and

A104:   for j be Element of NAT st 1<=j & j<2*k1+1 holds Computation
        (t2 +*iWH,km).intpos(m+n+j)=t2.intpos(m+n+j) and
A105:   Computation(t2+*iWH,km).b=t2.b-2 and

A106:   Computation(t2+*iWH,km).a=c by A36,A39,A40,A46,A64,A76,A77,A83,A84,A67
,A86,A94,XREAL_1:49;

A107:   now
          let i be Element of NAT;
          assume that
A108:     yc<i and
A109:     i<=len f4;
A110:     1+0 <= i by A108,INT_1:20;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.i= t2.intpos(m+i) by A99,A102,A108,A109;
            end;
            suppose
              y1>=yc;
              hence f4.i= t2.intpos(m+i) by A99,A103,A109,A110;
            end;
          end;
          hence f4.i=f3.i by A76,A77,A99,A109,A110,SCPISORT:def 1;
        end;
        then f4.ym=f3.ym by A99,A87,XREAL_1:148;
        then
A111:   f4.ym=IExec(I,t).intpos(m+ym) by A63,A88,SCMPDS_4:23;
A112:   now
          let i be Element of NAT;
          assume that
A113:     yn<i and
A114:     i<=len f3;
A115:     1+0<=i by A113,INT_1:20;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.i= t1.intpos(m+i) by A77,A80,A113,A114;
            end;
            suppose
              yd>=yn;
              hence f3.i= t1.intpos(m+i) by A77,A81,A114,A115;
            end;
          end;
          hence f3.i=f2.i by A50,A51,A77,A114,A115;
        end;
A116:   now
          let i be Element of NAT;
          assume that
A117:     ym < i and
A118:     i <= yn;
          consider j be Element of NAT such that
A119:     ym<j and
A120:     j<=yn and

A121:     f3.i=f2.j by A40,A46,A55,A77,A78,A89,A112,A117,A118,RFINSEQ:45
,XREAL_1:49;

A122:     yc < i by A117,XREAL_1:148,XXREAL_0:2;
A123:     1<=j by A65,A119,XXREAL_0:2;
A124:     j<=len f2 by A40,A46,A50,A120,XREAL_1:49,XXREAL_0:2;
          i<=len f4 by A40,A46,A99,A118,XREAL_1:49,XXREAL_0:2;
          then f4.i=f2.j by A107,A122,A121
            .=t1.intpos(m+j) by A51,A123,A124
            .=IExec(I,t).intpos(m+j) by A63,SCMPDS_4:23;
          hence f4.ym <= f4.i by A61,A111,A119,A120;
        end;
A125:   yn>y1 by A46,XREAL_1:49;
A126:   now
          let i be Element of NAT;
          assume that
A127:     1<=i and
A128:     i<=y0;
          i-1 < y1-1 by A128,XREAL_1:148,XXREAL_0:2;
          then
A129:     i<y1 by XREAL_1:11;
          y1 <= n by A40,A125,XXREAL_0:2;
          then
A130:     i<=n by A129,XXREAL_0:2;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.i= t2.intpos(m+i) by A102,A127,A129;
            end;
            suppose
              y1>=yc;
              hence f4.i= t2.intpos(m+i) by A103,A127,A130;
            end;
          end;
          hence f4.i=f3.i by A76,A77,A127,A130,SCPISORT:def 1;
        end;
A131:   y0 <= yc by A54,XREAL_1:11;
A132:   now
          let i be Element of NAT;
          assume that
A133:     y1 <= i and
A134:     i < ym;
          i+1 <= ym by A134,INT_1:20;
          then
A135:     i<=yc by XREAL_1:21;
          y0 < i by A133,XREAL_1:148,XXREAL_0:2;
          then consider j be Element of NAT such that
A136:     y0<j and
A137:     j<=yc and

A138:     f4.i=f3.j by A67,A99,A100,A131,A126,A107,A135,RFINSEQ:45;

A139:     1+0 <= j by A136,INT_1:20;
A140:     j<= n by A67,A137,XXREAL_0:2;
A141:     j<yd by A95,A137,XXREAL_0:2;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.j= t1.intpos(m+j) by A80,A139,A141;
            end;
            suppose
              yd>=yn;
              hence f3.j= t1.intpos(m+j) by A81,A139,A140;
            end;
          end;
          then
A142:     f4.i=IExec(I,t).intpos(m+j) by A63,A138,SCMPDS_4:23;
A143:     j < ym by A137,XREAL_1:148,XXREAL_0:2;
          y1-1+1 <= j by A136,INT_1:20;
          hence f4.i <= f4.ym by A60,A111,A143,A142;
        end;
        take mm=m1+(kl+km);
        set tm= Computation((t +* iWH),mm);
        take f4;
        t1+*iWH =t1 by A1,A37,A38,A62,A47,Th2;
        then
A144:   tm= Computation(t1+*iWH,kl+km) by AMI_1:51
          .= Computation(t2+*iWH,km) by A75,AMI_1:51;
        hence tm+*iWH =tm by A97;
        thus f4 is_FinSequence_on tm,m by A98,A144;
        thus len f4=n by A99;
        now
          let i be Element of NAT;
          assume that
A145:     1<=i and
A146:     i <= len f2;
          thus f2.i=t1.intpos(m+i) by A51,A145,A146
            .=IExec(I,t).intpos(m+i) by A63,SCMPDS_4:23;
        end;
        then f2 is_FinSequence_on IExec(I,t),m by SCPISORT:def 1;

        then f1,f2 are_fiberwise_equipotent by A12,A37,A38,A39,A40,A41,A42,A44
,A45,A50;

        then f1,f3 are_fiberwise_equipotent by A78,CLASSES1:84;
        hence f1,f4 are_fiberwise_equipotent by A100,CLASSES1:84;
A147:   now
          let j be Element of NAT;
          assume that
A148:     yd<=j and
A149:     j<=yn;
A150:     1<=j by A72,A148,XXREAL_0:2;
A151:     j <= n by A40,A46,A149,XREAL_1:49,XXREAL_0:2;
A152:     yc < j by A95,A148,XXREAL_0:2;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.j=t2.intpos(m+j) by A102,A151,A152;
            end;
            suppose
              y1>=yc;
              hence f4.j=t2.intpos(m+j) by A103,A151,A150;
            end;
          end;
          hence f4.j=f3.j by A76,A77,A151,A150,SCPISORT:def 1;
        end;
        now
          let i,j be Element of NAT;
          assume that
A153:     yd <= i and
A154:     i <= j and
A155:     j <= yn;
          yd <= j by A153,A154,XXREAL_0:2;
          then
A156:     f4.j=f3.j by A147,A155;
          i <= yn by A154,A155,XXREAL_0:2;
          then f4.i=f3.i by A147,A153;
          hence f4.i <= f4.j by A79,A153,A154,A155,A156,GRAPH_2:def 13;
        end;
        then f4 is_non_decreasing_on yd,yn by GRAPH_2:def 13;
        hence f4 is_non_decreasing_on y1,yn by A101,A132,A116,Th8;

        thus for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
        holds f4.j= t.intpos(m+j)

        proof
          let j be Element of NAT;
          assume that
A157:     y1<yn and
A158:     1<=j & j<y1 or yn<j & j<= n;
A159:     1<=j & j<= n
          proof
            per cases by A158;
            suppose
A160:         1<=j & j<y1;
              then j<yn by A157,XXREAL_0:2;
              hence thesis by A40,A46,A160,XREAL_1:49,XXREAL_0:2;
            end;
            suppose
A161:         yn<j & j<=n;
              then y1 < j by A157,XXREAL_0:2;
              hence thesis by A40,A46,A161,XREAL_1:49,XXREAL_0:2;
            end;
          end;
A162:     1<=j & j<yd or yn<j & j<= n
          proof
            per cases by A158;
            suppose
              1<=j & j<y1;
              hence thesis by A71,XXREAL_0:2;
            end;
            suppose
              yn<j & j<=n;
              hence thesis;
            end;
          end;
A163:     now
            per cases;
            suppose
              yd<yn;
              hence f3.j=t1.intpos(m+j) by A80,A162;
            end;
            suppose
              yd>=yn;
              hence f3.j=t1.intpos(m+j) by A81,A159;
            end;
          end;
A164:     1<=j & j<y1 or yc<j & j<= n
          proof
            per cases by A158;
            suppose
              1<=j & j<y1;
              hence thesis;
            end;
            suppose
              yn<j & j<=n;
              hence thesis by A66,XXREAL_0:2;
            end;
          end;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.j=t2.intpos(m+j) by A102,A164;
            end;
            suppose
              y1>=yc;
              hence f4.j=t2.intpos(m+j) by A103,A159;
            end;
          end;
          hence f4.j=f3.j by A76,A77,A159,SCPISORT:def 1
            .=IExec(I,t).intpos(m+j) by A63,A163,SCMPDS_4:23
            .=t.intpos(m+j) by A12,A37,A38,A39,A40,A41,A42,A157,A158;
        end;

        thus for j be Element of NAT st y1>=yn & 1<=j & j<= n holds f4.j=t.
        intpos(m+j) by A46,XREAL_1:49;

        hereby
          let j be Element of NAT;
          assume that
A165:     1<=j and
A166:     j<2*k1+1;
          2*k1+1 < 2*(k1+1)+1 by A85,XREAL_1:8;
          then
A167:     j < 2*(k1+1)+1 by A166,XXREAL_0:2;
          thus tm.intpos(m+n+j)=t2.intpos(m+n+j) by A104,A144,A165,A166
            .=t1.intpos(m+n+j) by A82,A165,A167
            .=IExec(I,t).intpos(m+n+j) by A63,SCMPDS_4:23
            .=t.intpos(m+n+j) by A12,A37,A38,A39,A40,A41,A42,A165,A166;
        end;
        thus tm.b=t.b-2 by A38,A64,A83,A105,A144;
        thus tm.a=c by A106,A144;
      end;
    end;
    hence P[k+1];
  end;
A168: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A35);

  ex k be Element of NAT,f2 be FinSequence of INT st Computation(s+*iWH,

k)+*iWH= Computation(s+*iWH,k) & f2 is_FinSequence_on Computation(s+*iWH,k),m &

len f2=n & f,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n & (for j

be Element of NAT st 1<n & (1<=j & j<1 or n<j & j<= n) holds f2.j= s.intpos(m+j

)) & (for j be Element of NAT st 1>=n & 1<=j & j<= n holds f2.j= s.intpos(m+j))
  & (for j be Element of NAT st (1<=j & j<2*0+1) holds Computation(s+*iWH,k).

intpos(m+n+j)=s.intpos(m+n+j)) & Computation(s+*iWH,k).b=s.b-2 & Computation(s
  +*iWH,k).a=c

  proof
    per cases;
    suppose
      n-1<=0;
      hence thesis by A2,A3,A5,A7,A9,A10,A13,A11;
    end;
    suppose
      n-1>0;
      then reconsider nn=n-1 as Element of NAT by INT_1:16;
      P[nn] by A168;
      hence thesis by A2,A3,A5,A7,A9,A10,A11;
    end;
  end;
  then consider k be Element of NAT,f2 be FinSequence of INT such that
A169: Computation(s+*iWH,k)+*iWH= Computation(s+*iWH,k) and
A170: f2 is_FinSequence_on Computation(s+*iWH,k),m and
A171: len f2=n and
A172: f,f2 are_fiberwise_equipotent and
A173: f2 is_non_decreasing_on 1,n and
A174: Computation(s+*iWH,k).b=s.b-2 and
A175: Computation(s+*iWH,k).a=c;
  set sk= Computation(s+*iWH,k), s1 = sk +* iWH, s2 = Computation(s1,1);
A176: IC s1 =inspos 0 by SCMPDS_6:21;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A177: card WH=card I+2 by SCMPDS_8:17;
  then
A178: inspos(card I+2) in dom sWH by SCMPDS_6:25;
A179: dom g = Seg n by A4,FINSEQ_1:def 3;
  iWH c= s1 by FUNCT_4:26;
  then sWH c= s2 by AMI_1:81,SCMPDS_4:57;
  then
A180: s2.inspos(card I+2) = sWH.inspos(card I+2) by A178,GRFUNC_1:8
    .=halt SCMPDS by A177,SCMPDS_6:25;
  WH = i1 ';' (I ';' i2 ) by Lm2;
  then
A181: CurInstr s1 = i1 by SCMPDS_6:22;
A182: Computation(s1,0+1) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i1,s1) by A181,AMI_1:def 18;
  IC s2 = s2.IC SCMPDS by AMI_1:def 15
    .= ICplusConst(s1,(card I+2)) by A7,A169,A174,A175,A182,SCMPDS_2:68
    .= inspos(0+(card I+2)) by A176,SCMPDS_6:23;
  then
A183: CurInstr s2 = halt SCMPDS by A180,AMI_1:def 16;
A184: s2= Computation(s+*iWH,k+1) by A169,AMI_1:51;
  then
A185: ProgramPart(s+*iWH) halts_on s+*iWH by A183,AMI_1:146;
  hence WH is_halting_on s by SCMPDS_6:def 3;
A186: Result (s +* iWH)=s2 by A183,A184,A185,AMI_1:def 22;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    set xi=intpos (m+a);
A187: dom (s | A) = A by SCMPDS_6:1;
A188: now
      assume
      xi in dom (s | A);

      then reconsider l=xi as Instruction-Location of SCMPDS by A187,
AMI_1:def 4;

      l=xi;
      hence contradiction by SCMPDS_2:53;
    end;
    assume
A189: i in dom g;
    then
A190: 1 <= i by A179,FINSEQ_1:3;
A191: i <= n by A179,A189,FINSEQ_1:3;
    IExec(WH,s)=s2 +* s | A by A186,SCMPDS_4:def 8;
    hence g.i=(s2 +* s | A).xi by A4,A6,A190,A191,SCPISORT:def 1
      .=s2.xi by A188,FUNCT_4:12
      .=s1.xi by A182,SCMPDS_2:68
      .=f2.i by A169,A170,A171,A190,A191,SCPISORT:def 1;
  end;
  hence thesis by A4,A171,A172,A173,FINSEQ_2:10;
end;

Lm5: for s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,m,n,m1 be Element of NAT st card I> 0 & s.a=c &
1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) & (for t be
State of SCMPDS,f1,f2 be FinSequence of INT, k1,k2,y1,yn be Element of NAT st t
.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos
(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t & I
is_halting_on t & IExec(I,t).a=t.a & (for j be Element of NAT st (1<=j & j<2*k1
+1) holds IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn implies IExec(I,t
).DataLoc(c,i)=2*k1-1 & (for j be Element of NAT st (1<=j & j <= n) holds IExec
(I,t).intpos (m+j) = t.intpos (m+j))) & (y1<yn implies IExec(I,t).DataLoc(c,i)=
2*k1+3 & (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
IExec(I,t).intpos(m+j) = t.intpos (m+j)) & (ex ym be Element of NAT st y1 <= ym
& ym <= yn & m+y1=IExec(I,t).intpos k2 & m+ym-1=IExec(I,t).intpos (k2+1) & m+ym
+1=IExec(I,t).intpos (k2+2) & m+yn=IExec(I,t).intpos (k2+3) & (for j be Element
of NAT st y1 <= j & j < ym holds IExec(I,t).intpos (m+j) <= IExec(I,t).intpos (
m+ym)) & (for j be Element of NAT st ym < j & j <= yn holds IExec(I,t).intpos (
m+j) >= IExec(I,t).intpos (m+ym)))) & (f1 is_FinSequence_on t,m & f2
is_FinSequence_on IExec(I,t),m & len f1=n & len f2=n implies f1,f2
are_fiberwise_equipotent)) holds while>0(a,i,I) is_halting_on s

proof

  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,m,n,m1 be Element of NAT;

  set b=DataLoc(c,i);
  assume that
A1: card I>0 and
A2: s.a=c;
  consider f be FinSequence of INT such that
A3: len f=n and

A4: for i be Element of NAT st 1<=i & i <= len f holds f.i=s.intpos(m+i)
  by SCPISORT:2;

A5: f is_FinSequence_on s,m by A4,SCPISORT:def 1;
  set ss=IExec(while>0(a,i,I),s);
  assume
A6: 1=s.b;
  consider g be FinSequence of INT such that
A7: len g=n and

A8: for i be Element of NAT st 1<=i & i <= len g holds g.i=ss.intpos(m+
  i ) by SCPISORT:2;

A9: g is_FinSequence_on ss,m by A8,SCPISORT:def 1;
  assume that
A10: m1=m+n+1 and
A11: m+1=s.intpos m1 and
A12: m+n=s.intpos(m1+1);
  assume

  for t be State of SCMPDS,f1,f2 be FinSequence of INT, k1,k2,y1,yn be

Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=
  t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t & I

is_halting_on t & IExec(I,t).a=t.a & (for j be Element of NAT st (1<=j & j<2*k1

+1) holds IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn implies IExec(I,t

).b=2*k1-1 & for j be Element of NAT st 1<=j & j <= n holds IExec(I,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,t).b=2*k1+3 & (for j be

Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds IExec(I,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=
  IExec(I,t).intpos k2 & m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).

intpos (k2+2) & m+yn=IExec(I,t).intpos (k2+3) & (for j be Element of NAT st y1

<= j & j < ym holds IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) & for j

be Element of NAT st ym < j & j <= yn holds IExec(I,t).intpos(m+j) >= IExec(I,t

).intpos(m+ym) ) & (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

  hence thesis by A1,A2,A6,A10,A11,A12,A3,A5,A7,A9,Lm4;
end;

Lm6: for s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,m,n,m1 be Element of NAT st card I> 0 & s.a=c &
1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) & (for t be
State of SCMPDS,f1,f2 be FinSequence of INT, k1,k2,y1,yn be Element of NAT st t
.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos
(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t & I
is_halting_on t & IExec(I,t).a=t.a & (for j be Element of NAT st (1<=j & j<2*k1
+1) holds IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn implies IExec(I,t
).DataLoc(c,i)=2*k1-1 & (for j be Element of NAT st (1<=j & j <= n) holds IExec
(I,t).intpos (m+j) = t.intpos (m+j))) & (y1<yn implies IExec(I,t).DataLoc(c,i)=
2*k1+3 & (for j be Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds
IExec(I,t).intpos(m+j) = t.intpos (m+j)) & (ex ym be Element of NAT st y1 <= ym
& ym <= yn & m+y1=IExec(I,t).intpos k2 & m+ym-1=IExec(I,t).intpos (k2+1) & m+ym
+1=IExec(I,t).intpos (k2+2) & m+yn=IExec(I,t).intpos (k2+3) & (for j be Element
of NAT st y1 <= j & j < ym holds IExec(I,t).intpos (m+j) <= IExec(I,t).intpos (
m+ym)) & (for j be Element of NAT st ym < j & j <= yn holds IExec(I,t).intpos (
m+j) >= IExec(I,t).intpos (m+ym)))) & (f1 is_FinSequence_on t,m & f2
is_FinSequence_on IExec(I,t),m & len f1=n & len f2=n implies f1,f2
are_fiberwise_equipotent)) holds while>0(a,i,I) is_halting_on s & while>0(a,i,I
) is_closed_on s

proof

  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,m,n,m1 be Element of NAT;

  set b=DataLoc(c,i);
  assume
A1: card I>0;
  assume
A2: s.a=c;
  assume
A3: 1=s.b;
  assume that
A4: m1=m+n+1 and
A5: m+1=s.intpos m1 and
A6: m+n=s.intpos(m1+1);
  assume

A7: for t be State of SCMPDS,f1,f2 be FinSequence of INT, k1,k2,y1,yn be

Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=
  t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t & I

is_halting_on t & IExec(I,t).a=t.a & (for j be Element of NAT st (1<=j & j<2*k1

+1) holds IExec(I,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn implies IExec(I,t

).b=2*k1-1 & for j be Element of NAT st 1<=j & j <= n holds IExec(I,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,t).b=2*k1+3 & (for j be

Element of NAT st (1<=j & j<y1) or (yn<j & j <= n) holds IExec(I,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=
  IExec(I,t).intpos k2 & m+ym-1=IExec(I,t).intpos (k2+1) & m+ym+1=IExec(I,t).

intpos (k2+2) & m+yn=IExec(I,t).intpos (k2+3) & (for j be Element of NAT st y1

<= j & j < ym holds IExec(I,t).intpos(m+j) <= IExec(I,t).intpos(m+ym)) & for j

be Element of NAT st ym < j & j <= yn holds IExec(I,t).intpos(m+j) >= IExec(I,t

).intpos(m+ym) ) & (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

A8: now
    let v be State of SCMPDS;
    assume
A9: DataPart v = DataPart s;
    then
A10: 1 =v.b by A3,SCMPDS_4:23;
A11: m+n =v.intpos (m1+1) by A6,A9,SCMPDS_4:23;
A12: m+1 =v.intpos m1 by A5,A9,SCMPDS_4:23;
    v.a =c by A2,A9,SCMPDS_4:23;
    hence while>0(a,i,I) is_halting_on v by A1,A4,A7,A10,A12,A11,Lm5;
  end;
  hence while>0(a,i,I) is_halting_on s;
  thus thesis by A8,Th3;
end;

begin :: Program Partition is to split a sequence into a "smaller" and

::       a "larger" subsequence
:: a5=a7=length  a2=mid(x[1]), a3=x[2], a4=x[n], a6=save

definition
  func Partition -> Program of SCMPDS equals
  ((GBP,5):=(GBP,4) ';' SubFrom(GBP
,5,GBP,2) ';' (GBP,3):=(GBP,2) ';' AddTo(GBP,3,1)) ';' while>0(GBP,5, while>0(
  GBP,5, (GBP,7):=(GBP,5) ';' AddTo(GBP,5,-1) ';' (GBP,6):=(intpos 4,0) ';'
SubFrom(GBP,6,intpos 2,0) ';' if>0(GBP,6, AddTo(GBP,4,-1) ';' AddTo(GBP,7,-1),
Load (GBP,5):=0 ) ) ';' while>0(GBP,7, (GBP,5):=(GBP,7) ';' AddTo(GBP,7,-1) ';'
(GBP,6):=(intpos 2,0) ';' SubFrom(GBP,6,intpos 3,0) ';' if>0(GBP,6, AddTo(GBP,3
,1) ';' AddTo(GBP,5,-1), Load (GBP,7):=0 ) ) ';' if>0(GBP,5,((GBP,6):=(intpos 4
,0) ';' (intpos 4,0):=(intpos 3,0) ';' (intpos 3,0):=(GBP,6) ';' AddTo(GBP,5,-2
  ) ';' AddTo(GBP,3,1)) ';' AddTo(GBP,4,-1) ) ) ';' (GBP,6):=(intpos 4,0) ';' (
  intpos 4,0):=(intpos 2,0) ';' (intpos 2,0):=(GBP,6);
  coherence;
end;

begin :: The Construction of Quick Sort

:: a0=global, a1=stack, a2=stack depth

definition
  let n,p0 be Element of NAT;
  func QuickSort(n,p0) -> Program of SCMPDS equals
  ((GBP:=0) ';' (SBP:=1) ';'
(SBP,p0+n):=(p0+1) ';' (SBP,p0+n+1):=(p0+n)) ';' while>0(GBP,1, (GBP,2):=(SBP,
  p0+n+1) ';' SubFrom(GBP,2,SBP,p0+n) ';' if>0(GBP,2, (GBP,2):=(SBP,p0+n) ';' (
GBP,4):=(SBP,p0+n+1) ';' Partition ';' (((SBP,p0+n+3):=(SBP,p0+n+1) ';' (SBP,p0
  +n+1):=(GBP,4) ';' (SBP,p0+n+2):=(GBP,4) ';' AddTo(SBP,p0+n+1,-1)) ';' AddTo(
  SBP,p0+n+2,1) ';' AddTo(GBP,1,2)), Load AddTo(GBP,1,-2) ) );
  coherence;
end;

set i1= (GBP,7):=(GBP,5), i2= AddTo(GBP,5,-1), i3= (GBP,6):=(intpos 4,0), i4=
SubFrom(GBP,6,intpos 2,0), i5= AddTo(GBP,4,-1), i6= AddTo(GBP,7,-1), i7= Load (
GBP,5):=0, IF1= if>0(GBP,6,i5 ';' i6,i7), WB1= i1 ';' i2 ';' i3 ';' i4 ';' IF1,
WH1= while>0(GBP,5,WB1), j1= (GBP,5):=(GBP,7), j2= AddTo(GBP,7,-1), j3= (GBP,6)
:=(intpos 2,0), j4= SubFrom(GBP,6,intpos 3,0), j5= AddTo(GBP,3,1), j6= AddTo(
GBP,5,-1), j7= Load (GBP,7):=0, IF2= if>0(GBP,6,j5 ';' j6, j7), WB2= j1 ';' j2
';' j3 ';' j4 ';' IF2, WH2= while>0(GBP,7,WB2), k1 = (GBP,5):=(GBP,4), k2 =
SubFrom(GBP,5,GBP,2), k3 = (GBP,3):=(GBP,2), k4 = AddTo(GBP,3,1), K4 = k1 ';'
k2 ';' k3 ';' k4, k5 = (GBP,6):=(intpos 4,0), k6 = (intpos 4,0):=(intpos 3,0),
k7 = (intpos 3,0):=(GBP,6), k8 = AddTo(GBP,5,-2), k9 = AddTo(GBP,3,1), k0 =
AddTo(GBP,4,-1), IF3= if>0(GBP,5, k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0), WB3=
WH1 ';' WH2 ';' IF3, WH3= while>0(GBP,5,WB3), j8 = (GBP,6):=(intpos 4,0), j9 =
(intpos 4,0):=(intpos 2,0), j0 = (intpos 2,0):=(GBP,6);

set a1=intpos 1, a2=intpos 2, a3=intpos 3, a4=intpos 4, a5=intpos 5, a6=intpos
6, a7=intpos 7;

Lm7: card WB1=9
proof
  thus card WB1= card (i1 ';' i2 ';' i3 ';' i4) + card IF1 by SCMPDS_4:45
    .= 4+card IF1 by Th4
    .= 4+(card (i5 ';' i6)+card i7+2) by SCMPDS_6:79
    .= 4+(2+card i7+2) by SCMP_GCD:9
    .= 4+(2+1+2) by SCMPDS_5:6
    .= 9;
end;

Lm8: for s being State of SCMPDS,md,me be Element of NAT st s.a2=md & s.a4=me
& md >= 8 & me >= 8 & s.GBP=0 holds IExec(WB1,s).GBP=0 & IExec(WB1,s).a1=s.a1 &
IExec(WB1,s).a2=s.a2 & IExec(WB1,s).a3=s.a3 & (for i be Element of NAT st i >=
8 holds IExec(WB1,s).intpos i=s.intpos i) & (s.intpos md < s.intpos me implies
IExec(WB1,s).a5=s.a5-1 & IExec(WB1,s).a4=s.a4-1 & IExec(WB1,s).a7=s.a5-1) & (s.
intpos md >= s.intpos me implies IExec(WB1,s).a5=0 & IExec(WB1,s).a4=s.a4 &
IExec(WB1,s).a7=s.a5)

proof
  set a=GBP;
  let s be State of SCMPDS,md,me be Element of NAT;
  assume that
A1: s.a2=md and
A2: s.a4=me and
A3: md >= 8 and
A4: me >= 8 and
A5: s.a=0;

  set t0=Initialized s, t1=IExec(i1 ';' i2 ';' i3 ';' i4,s), t2=IExec(i1 ';'
  i2 ';' i3,s), t3=IExec(i1 ';' i2,s), t4=Exec(i1, t0);

A6: t0.a=0 by A5,SCMPDS_5:40;
  then
A7: DataLoc(t0.a,7)=intpos (0+7) by SCMP_GCD:5;
  then
A8: t4.a =0 by A6,AMI_3:52,SCMPDS_2:59;
  then
A9: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:5;
  t0.a4=me by A2,SCMPDS_5:40;
  then
A10: t4.a4 =me by A7,AMI_3:52,SCMPDS_2:59;
A11: t3.a4 =Exec(i2, t4).a4 by SCMPDS_5:47
    .=me by A10,A9,AMI_3:52,SCMPDS_2:60;
  then
A12: DataLoc(t3.a4,0)=intpos (me+0) by SCMP_GCD:5;
A13: t3.a =Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A8,A9,AMI_3:52,SCMPDS_2:60;
  then
A14: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:5;
  t0.a2=md by A1,SCMPDS_5:40;
  then
A15: t4.a2 =md by A7,AMI_3:52,SCMPDS_2:59;
A16: t3.a2 =Exec(i2, t4).a2 by SCMPDS_5:47
    .=md by A15,A9,AMI_3:52,SCMPDS_2:60;
A17: t0.a5=s.a5 by SCMPDS_5:40;
  then
A18: t4.a5 =s.a5 by A7,AMI_3:52,SCMPDS_2:59;
  set t01=Initialized t1, ii7= (GBP,5):=0, t5=Exec(i5,t01);
A19: t2.a2 =Exec(i3, t3).a2 by SCMPDS_5:46
    .=md by A16,A14,AMI_3:52,SCMPDS_2:59;
A20: t2.a =Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A13,A14,AMI_3:52,SCMPDS_2:59;
  then
A21: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:5;
  DataLoc(t0.a,5)=intpos (0+5) by A6,SCMP_GCD:5;
  then
A22: t4.a7 =s.a5 by A17,A7,SCMPDS_2:59;
A23: t3.a7 =Exec(i2, t4).a7 by SCMPDS_5:47
    .=s.a5 by A22,A9,AMI_3:52,SCMPDS_2:60;
A24: t2.a7 =Exec(i3, t3).a7 by SCMPDS_5:46
    .=s.a5 by A23,A14,AMI_3:52,SCMPDS_2:59;
  t1.a7 =Exec(i4, t2).a7 by SCMPDS_5:46
    .=s.a5 by A24,A21,AMI_3:52,SCMPDS_2:62;
  then
A25: t01.a7=s.a5 by SCMPDS_5:40;
  t1.a2 =Exec(i4, t2).a2 by SCMPDS_5:46
    .=md by A19,A21,AMI_3:52,SCMPDS_2:62;
  then
A26: t01.a2=s.a2 by A1,SCMPDS_5:40;
A27: now
    let i be Element of NAT;
    assume
    i>=8;
    then i > 7 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A7,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A28: now
    let i be Element of NAT;
    assume
A29: i>=8;
    then
A30: i > 5 by XXREAL_0:2;
    thus t3.intpos i =Exec(i2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A9,A30,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A27,A29;
  end;
A31: now
    let i be Element of NAT;
    assume
A32: i>=8;
    then
A33: i > 6 by XXREAL_0:2;
    thus t2.intpos i=Exec(i3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A14,A33,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A28,A32;
  end;
A34: now
    let i be Element of NAT;
    assume
A35: i>=8;
    then
A36: i > 6 by XXREAL_0:2;
    thus t1.intpos i=Exec(i4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A21,A36,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A31,A35;
  end;
  t0.a3=s.a3 by SCMPDS_5:40;
  then
A37: t4.a3 =s.a3 by A7,AMI_3:52,SCMPDS_2:59;
A38: t3.a3 =Exec(i2, t4).a3 by SCMPDS_5:47
    .=s.a3 by A37,A9,AMI_3:52,SCMPDS_2:60;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A39: t4.a1 =s.a1 by A7,AMI_3:52,SCMPDS_2:59;
A40: t3.a1 =Exec(i2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A39,A9,AMI_3:52,SCMPDS_2:60;
A41: t2.a1 =Exec(i3, t3).a1 by SCMPDS_5:46
    .=s.a1 by A40,A14,AMI_3:52,SCMPDS_2:59;
  t1.a1 =Exec(i4, t2).a1 by SCMPDS_5:46
    .=s.a1 by A41,A21,AMI_3:52,SCMPDS_2:62;
  then
A42: t01.a1=s.a1 by SCMPDS_5:40;
A43: t2.a3 =Exec(i3, t3).a3 by SCMPDS_5:46
    .=s.a3 by A38,A14,AMI_3:52,SCMPDS_2:59;
  t1.a3 =Exec(i4, t2).a3 by SCMPDS_5:46
    .=s.a3 by A43,A21,AMI_3:52,SCMPDS_2:62;
  then
A44: t01.a3=s.a3 by SCMPDS_5:40;
A45: t1.a =Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A20,A21,AMI_3:52,SCMPDS_2:62;
  then
A46: t01.a=0 by SCMPDS_5:40;
  then
A47: DataLoc(t01.a,5)=intpos(0+5) by SCMP_GCD:5;
  a3<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A48: t5.a3=s.a3 by A44,SCMPDS_2:60;
  a2<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A49: t5.a2=s.a2 by A26,SCMPDS_2:60;
  a<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A50: t5.a=0 by A46,SCMPDS_2:60;
  then
A51: DataLoc(t5.a,7)=intpos(0+7) by SCMP_GCD:5;
A52: t2.a6 =Exec(i3, t3).a6 by SCMPDS_5:46
    .=t3.intpos me by A14,A12,SCMPDS_2:59
    .=s.intpos me by A4,A28;
  t1.a6 =Exec(i4, t2).a6 by SCMPDS_5:46
    .=t2.a6-t2.DataLoc(t2.a2,0) by A21,SCMPDS_2:62
    .=t2.a6-t2.intpos(md+0) by A19,SCMP_GCD:5
    .=s.intpos me - s.intpos md by A3,A52,A31;
  then
A53: t1.DataLoc(t1.a,6)=s.intpos me - s.intpos md by A45,SCMP_GCD:5;
  a1<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A54: t5.a1=s.a1 by A42,SCMPDS_2:60;
A55: now
    per cases;
    suppose
A56:  t1.DataLoc(t1.a,6) <= 0;
      hence IExec(IF1,t1).a=IExec(i7,t1).a by SCMPDS_6:88
        .=Exec(ii7,t01).a by SCMPDS_5:45
        .=0 by A46,A47,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF1,t1).a1=IExec(i7,t1).a1 by A56,SCMPDS_6:88
        .=Exec(ii7,t01).a1 by SCMPDS_5:45
        .=s.a1 by A42,A47,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF1,t1).a2=IExec(i7,t1).a2 by A56,SCMPDS_6:88
        .=Exec(ii7,t01).a2 by SCMPDS_5:45
        .=s.a2 by A26,A47,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF1,t1).a3=IExec(i7,t1).a3 by A56,SCMPDS_6:88
        .=Exec(ii7,t01).a3 by SCMPDS_5:45
        .=s.a3 by A44,A47,AMI_3:52,SCMPDS_2:58;
      hereby
        let i be Element of NAT;
        assume
A57:    i>=8;
        then
A58:    i > 5 by XXREAL_0:2;
        thus IExec(WB1,s).intpos i=IExec(IF1,t1).intpos i by SCMPDS_5:39
          .=IExec(i7,t1).intpos i by A56,SCMPDS_6:88
          .=Exec(ii7,t01).intpos i by SCMPDS_5:45
          .=t01.intpos i by A47,A58,AMI_3:52,SCMPDS_2:58
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A34,A57;
      end;
    end;
    suppose
A59:  t1.DataLoc(t1.a,6) > 0;
      hence IExec(IF1,t1).a=IExec(i5 ';' i6,t1).a by SCMPDS_6:87
        .=Exec(i6,t5).a by SCMPDS_5:47
        .=0 by A50,A51,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF1,t1).a1=IExec(i5 ';' i6,t1).a1 by A59,SCMPDS_6:87
        .=Exec(i6,t5).a1 by SCMPDS_5:47
        .=s.a1 by A54,A51,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF1,t1).a2=IExec(i5 ';' i6,t1).a2 by A59,SCMPDS_6:87
        .=Exec(i6,t5).a2 by SCMPDS_5:47
        .=s.a2 by A49,A51,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF1,t1).a3=IExec(i5 ';' i6,t1).a3 by A59,SCMPDS_6:87
        .=Exec(i6,t5).a3 by SCMPDS_5:47
        .=s.a3 by A48,A51,AMI_3:52,SCMPDS_2:60;
      hereby
        let i be Element of NAT;
        assume
A60:    i>=8;
        then
A61:    i > 7 by XXREAL_0:2;
        i > 4 by A60,XXREAL_0:2;
        then
A62:    intpos i<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
        thus IExec(WB1,s).intpos i=IExec(IF1,t1).intpos i by SCMPDS_5:39
          .=IExec(i5 ';' i6,t1).intpos i by A59,SCMPDS_6:87
          .=Exec(i6,t5).intpos i by SCMPDS_5:47
          .=t5.intpos i by A51,A61,AMI_3:52,SCMPDS_2:60
          .=t01.intpos i by A62,SCMPDS_2:60
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A34,A60;
      end;
    end;
  end;

  hence
  IExec(WB1,s).a=0 & IExec(WB1,s).a1=s.a1 & IExec(WB1,s).a2=s.a2 & IExec(
  WB1,s).a3=s.a3 by SCMPDS_5:39;

  thus for i be Element of NAT st i >= 8 holds IExec(WB1,s).intpos i=s.intpos
  i by A55;

A63: t3.a5 =Exec(i2, t4).a5 by SCMPDS_5:47
    .=t4.a5+ -1 by A9,SCMPDS_2:60
    .=s.a5-1 by A18;
A64: t2.a5 =Exec(i3, t3).a5 by SCMPDS_5:46
    .=s.a5-1 by A63,A14,AMI_3:52,SCMPDS_2:59;
  t1.a5 =Exec(i4, t2).a5 by SCMPDS_5:46
    .=s.a5-1 by A64,A21,AMI_3:52,SCMPDS_2:62;
  then
A65: t01.a5=s.a5-1 by SCMPDS_5:40;
A66: t2.a4 =Exec(i3, t3).a4 by SCMPDS_5:46
    .=me by A11,A14,AMI_3:52,SCMPDS_2:59;
  t1.a4 =Exec(i4, t2).a4 by SCMPDS_5:46
    .=me by A66,A21,AMI_3:52,SCMPDS_2:62;
  then
A67: t01.a4=s.a4 by A2,SCMPDS_5:40;
A68: DataLoc(t01.a,4)=intpos(0+4) by A46,SCMP_GCD:5;
  hereby
A69: a5<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
    assume
A70: s.intpos md < s.intpos me;
    thus IExec(WB1,s).a5=IExec(IF1,t1).a5 by SCMPDS_5:39
      .=IExec(i5 ';' i6,t1).a5 by A53,A70,SCMPDS_6:87,XREAL_1:52
      .=Exec(i6,t5).a5 by SCMPDS_5:47
      .=t5.a5 by A51,AMI_3:52,SCMPDS_2:60
      .=s.a5-1 by A65,A69,SCMPDS_2:60;
    thus IExec(WB1,s).a4=IExec(IF1,t1).a4 by SCMPDS_5:39
      .=IExec(i5 ';' i6,t1).a4 by A53,A70,SCMPDS_6:87,XREAL_1:52
      .=Exec(i6,t5).a4 by SCMPDS_5:47
      .=t5.a4 by A51,AMI_3:52,SCMPDS_2:60
      .=t01.a4+-1 by A68,SCMPDS_2:60
      .=s.a4-1 by A67;
A71: a7<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
    thus IExec(WB1,s).a7=IExec(IF1,t1).a7 by SCMPDS_5:39
      .=IExec(i5 ';' i6,t1).a7 by A53,A70,SCMPDS_6:87,XREAL_1:52
      .=Exec(i6,t5).a7 by SCMPDS_5:47
      .=t5.a7+ -1 by A51,SCMPDS_2:60
      .=t5.a7-1
      .=s.a5-1 by A25,A71,SCMPDS_2:60;
  end;
  hereby
    assume
A72: s.intpos md >= s.intpos me;
    thus IExec(WB1,s).a5=IExec(IF1,t1).a5 by SCMPDS_5:39
      .=IExec(i7,t1).a5 by A53,A72,SCMPDS_6:88,XREAL_1:49
      .=Exec(ii7,t01).a5 by SCMPDS_5:45
      .=0 by A47,SCMPDS_2:58;
    thus IExec(WB1,s).a4=IExec(IF1,t1).a4 by SCMPDS_5:39
      .=IExec(i7,t1).a4 by A53,A72,SCMPDS_6:88,XREAL_1:49
      .=Exec(ii7,t01).a4 by SCMPDS_5:45
      .=s.a4 by A47,A67,AMI_3:52,SCMPDS_2:58;
    thus IExec(WB1,s).a7=IExec(IF1,t1).a7 by SCMPDS_5:39
      .=IExec(i7,t1).a7 by A53,A72,SCMPDS_6:88,XREAL_1:49
      .=Exec(ii7,t01).a7 by SCMPDS_5:45
      .=s.a5 by A25,A47,AMI_3:52,SCMPDS_2:58;
  end;
end;

Lm9: for s being State of SCMPDS,m4,md be Element of NAT st s.GBP=0 & s.a5 > 0
& s.a4=m4+s.a5 & m4>=8 & s.a2=md & md >= 8 holds IExec(WH1,s).GBP=0 & IExec(WH1
,s).a1=s.a1 & IExec(WH1,s).a5=0 & IExec(WH1,s).a2=s.a2 & IExec(WH1,s).a3=s.a3 &
(for i be Element of NAT st i >= 8 holds IExec(WH1,s).intpos i=s.intpos i) & ex
mE be Element of NAT st mE=IExec(WH1,s).a7 & IExec(WH1,s).a4=m4+mE & mE <= s.a5
& (for i be Element of NAT st m4+mE < i & i <=s.a4 holds IExec(WH1,s).intpos md
< IExec(WH1,s).intpos i) & (mE = 0 or IExec(WH1,s).intpos md >= IExec(WH1,s).
intpos(m4+mE))

proof
  set a=GBP;
  let s be State of SCMPDS,m4,md be Element of NAT;
  assume that
A1: s.GBP=0 and
A2: s.a5 > 0 and
A3: s.a4=m4+s.a5 and
A4: m4>=8 and
A5: s.a2=md and
A6: md >= 8;
  s.a5 >=1+0 by A2,INT_1:20;
  then reconsider m5=s.a5-1 as Element of NAT by INT_1:16,XREAL_1:50;
A7: s.a5=m5+1;

  defpred P[Element of NAT] means for t being State of SCMPDS st t.a=0 & t.a5

=$1+1 & t.a4=m4+t.a5 & t.a2=md holds IExec(WH1,t).a=0 & IExec(WH1,t).a1=t.a1 &
  IExec(WH1,t).a5=0 & IExec(WH1,t).a2=t.a2 & IExec(WH1,t).a3=t.a3 & (for i be
  Element of NAT st i >= 8 holds IExec(WH1,t).intpos i=t.intpos i) & ex mE be
  Element of NAT st mE=IExec(WH1,t).a7 & IExec(WH1,t).a4=m4+mE & mE <= t.a5 & (

for i be Element of NAT st m4+mE < i & i <=t.a4 holds IExec(WH1,t).intpos md <

IExec(WH1,t).intpos i) & (mE=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos
  (m4+mE));

A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      set me=m4+(k+1+1);
      let t be State of SCMPDS;
      set b=DataLoc(t.a,5);
      assume that
A10:  t.a=0 and
A11:  t.a5 =(k+1)+1 and
A12:  t.a4=m4+t.a5 and
A13:  t.a2=md;
      set It=IExec(WB1,t);
A14:  me>=m4 by NAT_1:11;
      then
A15:  me>=8 by A4,XXREAL_0:2;
      then
A16:  It.a1=t.a1 by A6,A10,A11,A12,A13,Lm8;

A17:  t.intpos md >= t.intpos me implies It.a5=0 & It.a4=t.a4 & It.a7=t.
      a5 by A6,A10,A11,A12,A13,A15,Lm8;

A18:  b=intpos (0+5) by A10,SCMP_GCD:5;
A19:  now
        let v be State of SCMPDS;
        assume that
A20:    v.a4 >= m4+v.b and
A21:    v.a2=t.a2 and
A22:    v.a=t.a and
A23:    v.b > 0;
A24:    m4+v.b>m4+0 by A23,XREAL_1:8;
        then reconsider ME=v.a4 as Element of NAT by A20,INT_1:16;
        v.a4 >=m4 by A20,A24,XXREAL_0:2;
        then
A25:    ME >= 8 by A4,XXREAL_0:2;

        then
A26:    v.intpos md < v.intpos ME implies IExec(WB1,v).a5=v.a5-1 & IExec(
        WB1,v ).a4=v.a4-1 & IExec(WB1,v).a7=v.a5-1 by A6,A10,A13,A21,A22,Lm8;

        thus IExec(WB1,v).a=v.a by A6,A10,A13,A21,A22,A25,Lm8;
        thus WB1 is_closed_on v & WB1 is_halting_on v by SCMPDS_6:34,35;

A27:    v.intpos md >= v.intpos ME implies IExec(WB1,v).a5=0 & IExec(WB1,
        v).a4 =v.a4 & IExec(WB1,v).a7=v.a5 by A6,A10,A13,A21,A22,A25,Lm8;

        hereby
          per cases;
          suppose
A28:        v.intpos md < v.intpos ME;
            hence IExec(WB1,v).b < v.b by A18,A26,XREAL_1:148;
            m4+v.b-1=m4+IExec(WB1,v).b by A18,A26,A28;

            hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A20,A26,A28,
XREAL_1:11;

          end;
          suppose
A29:        v.intpos md >= v.intpos ME;

            hence IExec(WB1,v).b < v.b by A6,A10,A13,A18,A21,A22,A23,A25,Lm8;

            m4+IExec(WB1,v).b < m4+v.b by A18,A23,A27,A29,XREAL_1:8;

            hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A20,A27,A29,
XXREAL_0:2;

          end;
        end;
        thus IExec(WB1,v).a2=v.a2 by A6,A10,A13,A21,A22,A25,Lm8;
      end;
A30:  It.a3=t.a3 by A6,A10,A11,A12,A13,A15,Lm8;

A31:  t.intpos md < t.intpos me implies It.a5=t.a5-1 & It.a4=t.a4-1 & It.
      a7= t.a5-1 by A6,A10,A11,A12,A13,A15,Lm8;

A32:  It.a=0 by A6,A10,A11,A12,A13,A15,Lm8;
      then
A33:  DataLoc(It.a,5)=intpos(0+5) by SCMP_GCD:5;
A34:  It.a2=t.a2 by A6,A10,A11,A12,A13,A15,Lm8;
      per cases;
      suppose
A35:    t.intpos md < t.intpos me;
        then
A36:    It.a4=m4+It.a5 by A12,A31;
        then consider mE be Element of NAT such that
A37:    mE=IExec(WH1,It).a7 and
A38:    IExec(WH1,It).a4=m4+mE and
A39:    mE <= It.a5 and

A40:    for i be Element of NAT st m4+mE < i & i <=It.a4 holds IExec(
        WH1, It).intpos md < IExec(WH1,It).intpos i and

A41:    mE=0 or IExec(WH1,It).intpos md >= IExec(WH1,It).intpos (m4+
        mE) by A9,A11,A12,A13,A32,A34,A31,A17;

A42:    IExec(WH1,t)=IExec(WH1,It) by A11,A12,A18,A19,Lm7,Th5;
        hence IExec(WH1,t).a=0 by A9,A11,A12,A13,A32,A34,A31,A17,A36;

        thus IExec(WH1,t).a1=t.a1 by A9,A11,A12,A13,A32,A16,A34,A31,A17,A36,A42
;

        thus IExec(WH1,t).a5=0 by A9,A11,A12,A13,A32,A34,A31,A17,A36,A42;
        thus IExec(WH1,t).a2=t.a2 by A9,A11,A12,A13,A32,A34,A31,A17,A36,A42;

        thus IExec(WH1,t).a3=t.a3 by A9,A11,A12,A13,A32,A34,A30,A31,A17,A36,A42
;

A43:    now
          let i be Element of NAT;
          assume
A44:      i >= 8;

          hence IExec(WH1,t).intpos i=It.intpos i by A9,A11,A12,A13,A32,A34,A31
,A17,A36,A42

            .=t.intpos i by A6,A10,A11,A12,A13,A15,A44,Lm8;
        end;

        hence for i be Element of NAT st i >= 8 holds IExec(WH1,t).intpos i=t.
        intpos i;

        take mE;
        thus mE=IExec(WH1,t).a7 by A11,A12,A18,A19,A37,Lm7,Th5;
        thus IExec(WH1,t).a4=m4+mE by A11,A12,A18,A19,A38,Lm7,Th5;
        thus mE <= t.a5 by A31,A35,A39,XREAL_1:148,XXREAL_0:2;
A45:    It.a4=t.a4-1 by A6,A10,A11,A12,A13,A15,A35,Lm8;
        hereby
          let i be Element of NAT;
          assume that
A46:      m4+mE < i and
A47:      i <=t.a4;
          per cases;
          suppose
A48:        i=t.a4;

            IExec(WH1,t).intpos me =t.intpos me by A4,A14,A43,XXREAL_0:2;

            hence IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A6,A11,A12
,A35,A43,A48;

          end;
          suppose
            i<>t.a4;
            then i < t.a4 by A47,XXREAL_0:1;
            then i+1 <= t.a4 by INT_1:20;
            then i <= It.a4 by A45,XREAL_1:21;

            hence
            IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A42,A40,A46;

          end;
        end;

        thus mE=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+mE) by
A42,A41;

      end;
      suppose
A49:    t.intpos md >= t.intpos me;
A50:    now
          let x;
          thus IExec(WH1,t).x =IExec(WH1,It).x by A11,A12,A18,A19,Lm7,Th5
            .=It.x by A17,A33,A49,SCMPDS_8:23;
        end;
        hence IExec(WH1,t).a=0 by A32;
        thus IExec(WH1,t).a1=t.a1 by A16,A50;
        thus IExec(WH1,t).a5=0 by A17,A49,A50;
        thus IExec(WH1,t).a2=t.a2 by A34,A50;
        thus IExec(WH1,t).a3=t.a3 by A30,A50;
A51:    now
          let i be Element of NAT;
          assume
A52:      i >= 8;
          thus IExec(WH1,t).intpos i=It.intpos i by A50
            .=t.intpos i by A6,A10,A11,A12,A13,A15,A52,Lm8;
        end;

        hence for i be Element of NAT st i >= 8 holds IExec(WH1,t).intpos i=t.
        intpos i;

        take ME=k+1+1;
        thus IExec(WH1,t).a7=ME by A11,A17,A49,A50;
        thus IExec(WH1,t).a4=m4+ME by A11,A12,A17,A49,A50;
        thus ME <= t.a5 by A11;

        thus for i be Element of NAT st m4+ME < i & i <=t.a4 & not IExec(WH1,t
        ).intpos md < IExec(WH1,t).intpos i holds contradiction by A11,A12;

        IExec(WH1,t).intpos me=t.intpos me by A4,A14,A51,XXREAL_0:2;

        hence ME=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+ME) by
A6,A49,A51;

      end;
    end;
    hence P[k+1];
  end;
  now
    set me=m4+1;
    let t be State of SCMPDS;
    set b=DataLoc(t.a,5);
    assume that
A53: t.a=0 and
A54: t.a5 =0+1 and
A55: t.a4=m4+t.a5 and
A56: t.a2=md;
    set It=IExec(WB1,t);
A57: me>=m4 by NAT_1:11;
    then
A58: me>=8 by A4,XXREAL_0:2;

    then
A59: t.intpos md < t.intpos me implies It.a5=t.a5-1 & It.a4=t.a4-1 & It.a7
    = t.a5-1 by A6,A53,A54,A55,A56,Lm8;

A60: t.intpos md >= t.intpos me implies It.a5=0 & It.a4=t.a4 & It.a7=t.a5
    by A6,A53,A54,A55,A56,A58,Lm8;

A61: b=intpos (0+5) by A53,SCMP_GCD:5;
A62: now
      let v be State of SCMPDS;
      assume that
A63:  v.a4 >= m4+v.b and
A64:  v.a2=t.a2 and
A65:  v.a=t.a and
A66:  v.b > 0;
A67:  m4+v.b>m4+0 by A66,XREAL_1:8;
      then reconsider ME=v.a4 as Element of NAT by A63,INT_1:16;
      v.a4 >=m4 by A63,A67,XXREAL_0:2;
      then
A68:  ME >= 8 by A4,XXREAL_0:2;

      then
A69:  v.intpos md < v.intpos ME implies IExec(WB1,v).a5=v.a5-1 & IExec(
      WB1,v ).a4=v.a4-1 & IExec(WB1,v).a7=v.a5-1 by A6,A53,A56,A64,A65,Lm8;

      thus IExec(WB1,v).a=v.a by A6,A53,A56,A64,A65,A68,Lm8;
      thus WB1 is_closed_on v & WB1 is_halting_on v by SCMPDS_6:34,35;

A70:  v.intpos md >= v.intpos ME implies IExec(WB1,v).a5=0 & IExec(WB1,v)
      .a4 =v.a4 & IExec(WB1,v).a7=v.a5 by A6,A53,A56,A64,A65,A68,Lm8;

      hereby
        per cases;
        suppose
A71:      v.intpos md < v.intpos ME;
          hence IExec(WB1,v).b < v.b by A61,A69,XREAL_1:148;
          m4+v.b-1=m4+IExec(WB1,v).b by A61,A69,A71;

          hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A63,A69,A71,XREAL_1:11;

        end;
        suppose
A72:      v.intpos md >= v.intpos ME;
          hence IExec(WB1,v).b < v.b by A6,A53,A56,A61,A64,A65,A66,A68,Lm8;
          m4+IExec(WB1,v).b < m4+v.b by A61,A66,A70,A72,XREAL_1:8;

          hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A63,A70,A72,XXREAL_0:2;

        end;
      end;
      thus IExec(WB1,v).a2=v.a2 by A6,A53,A56,A64,A65,A68,Lm8;
    end;
A73: It.a=0 by A6,A53,A54,A55,A56,A58,Lm8;
    then
A74: It.DataLoc(It.a,5)=0 by A54,A59,A60,SCMP_GCD:5;
A75: now
      let x;
      thus IExec(WH1,t).x =IExec(WH1,It).x by A54,A55,A61,A62,Lm7,Th5
        .=It.x by A74,SCMPDS_8:23;
    end;
    hence IExec(WH1,t).a=0 by A73;
    It.a1=t.a1 by A6,A53,A54,A55,A56,A58,Lm8;
    hence IExec(WH1,t).a1=t.a1 by A75;
    thus IExec(WH1,t).a5=0 by A54,A59,A60,A75;
    It.a2=t.a2 by A6,A53,A54,A55,A56,A58,Lm8;
    hence IExec(WH1,t).a2=t.a2 by A75;
    It.a3=t.a3 by A6,A53,A54,A55,A56,A58,Lm8;
    hence IExec(WH1,t).a3=t.a3 by A75;
A76: now
      let i be Element of NAT;
      assume
A77:  i >= 8;
      thus IExec(WH1,t).intpos i=It.intpos i by A75
        .=t.intpos i by A6,A53,A54,A55,A56,A58,A77,Lm8;
    end;

    hence for i be Element of NAT st i >= 8 holds IExec(WH1,t).intpos i=t.
    intpos i;

A78: IExec(WH1,t).intpos me=t.intpos me by A4,A57,A76,XXREAL_0:2;
    hereby
      per cases;
      suppose
A79:    t.intpos md < t.intpos me;
        take ME=0;
        thus IExec(WH1,t).a7=ME by A54,A59,A75,A79;
        thus IExec(WH1,t).a4=m4+ME by A54,A55,A59,A75,A79;
        thus ME <= t.a5 by A54;
        hereby
          let i be Element of NAT;
          assume that
A80:      m4+ME < i and
A81:      i <=t.a4;
          m4+1 <= i by A80,INT_1:20;
          then i=m4+1 by A54,A55,A81,XXREAL_0:1;

          hence IExec(WH1,t).intpos md < IExec(WH1,t).intpos i by A6,A76,A78
,A79;

        end;
        thus ME=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+ ME );
      end;
      suppose
A82:    t.intpos md >= t.intpos me;
        take ME=1;
        thus IExec(WH1,t).a7=ME by A54,A60,A75,A82;
        thus IExec(WH1,t).a4=m4+ME by A54,A55,A60,A75,A82;
        thus ME <= t.a5 by A54;

        thus for i be Element of NAT st m4+ME < i & i <=t.a4 holds IExec(WH1,t
        ).intpos md < IExec(WH1,t).intpos i by A54,A55;

        thus ME=0 or IExec(WH1,t).intpos md >= IExec(WH1,t).intpos (m4+ME) by
A6,A76,A78,A82;

      end;
    end;
  end;
  then
A83: P[0];
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A83,A8);
  hence thesis by A1,A3,A5,A7;
end;

Lm10: for s being State of SCMPDS,m4,md be Element of NAT st s.GBP=0 & s.a4=m4
+s.a5 & m4>=8 & s.a2=md & md >= 8 holds WH1 is_closed_on s & WH1 is_halting_on
s

proof
  set a=GBP;
  let s be State of SCMPDS,m4,md be Element of NAT;
  assume that
A1: s.GBP=0 and
A2: s.a4=m4+s.a5 and
A3: m4>=8 and
A4: s.a2=md and
A5: md >= 8;
  set b=DataLoc(s.a,5);
A6: b=intpos (0+5) by A1,SCMP_GCD:5;
  now
    let v be State of SCMPDS;
    assume that
A7: v.a4 >= m4+v.b and
A8: v.a2=s.a2 and
A9: v.a=s.a and
A10: v.b > 0;
A11: m4+v.b>m4+0 by A10,XREAL_1:8;
    then reconsider ME=v.a4 as Element of NAT by A7,INT_1:16;
    v.a4 >=m4 by A7,A11,XXREAL_0:2;
    then
A12: ME >= 8 by A3,XXREAL_0:2;

    then
A13: v.intpos md < v.intpos ME implies IExec(WB1,v).a5=v.a5-1 & IExec(WB1,
    v) .a4=v.a4-1 & IExec(WB1,v).a7=v.a5-1 by A1,A4,A5,A8,A9,Lm8;

    thus IExec(WB1,v).a=v.a by A1,A4,A5,A8,A9,A12,Lm8;
    thus WB1 is_closed_on v & WB1 is_halting_on v by SCMPDS_6:34,35;

A14: v.intpos md >= v.intpos ME implies IExec(WB1,v).a5=0 & IExec(WB1,v).
    a4= v.a4 & IExec(WB1,v).a7=v.a5 by A1,A4,A5,A8,A9,A12,Lm8;

    hereby
      per cases;
      suppose
A15:    v.intpos md < v.intpos ME;
        hence IExec(WB1,v).b < v.b by A6,A13,XREAL_1:148;
        m4+v.b-1=m4+IExec(WB1,v).b by A6,A13,A15;

        hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A7,A13,A15,XREAL_1:11;

      end;
      suppose
A16:    v.intpos md >= v.intpos ME;
        hence IExec(WB1,v).b < v.b by A1,A4,A5,A6,A8,A9,A10,A12,Lm8;
        m4+IExec(WB1,v).b < m4+v.b by A6,A10,A14,A16,XREAL_1:8;

        hence IExec(WB1,v).a4 >= m4+IExec(WB1,v).b by A7,A14,A16,XXREAL_0:2;

      end;
    end;
    thus IExec(WB1,v).a2=v.a2 by A1,A4,A5,A8,A9,A12,Lm8;
  end;
  hence thesis by A2,A6,Lm7,Th5;
end;

Lm11: card WH1=11
proof
  thus card WH1=9+2 by Lm7,SCMPDS_8:17
    .=11;
end;

Lm12: card WB2=9
proof
  thus card WB2= card (j1 ';' j2 ';' j3 ';' j4) + card IF2 by SCMPDS_4:45
    .= 4+card IF2 by Th4
    .= 4+(card (j5 ';' j6) +card j7+2) by SCMPDS_6:79
    .= 4+(2+card j7+2) by SCMP_GCD:9
    .= 4+(2+1+2) by SCMPDS_5:6
    .= 9;
end;

Lm13: card WH2=11
proof
  thus card WH2= 9+2 by Lm12,SCMPDS_8:17
    .=11;
end;

Lm14: for s being State of SCMPDS,md,me be Element of NAT st s.a2=md & s.a3=me
& md >= 8 & me >= 8 & s.GBP=0 holds IExec(WB2,s).GBP=0 & IExec(WB2,s).a1=s.a1 &
IExec(WB2,s).a2=s.a2 & IExec(WB2,s).a4=s.a4 & (for i be Element of NAT st i >=
8 holds IExec(WB2,s).intpos i=s.intpos i) & (s.intpos md > s.intpos me implies
IExec(WB2,s).a7=s.a7-1 & IExec(WB2,s).a3=s.a3+1 & IExec(WB2,s).a5=s.a7-1) & (s.
intpos md <= s.intpos me implies IExec(WB2,s).a7=0 & IExec(WB2,s).a3=s.a3 &
IExec(WB2,s).a5=s.a7)

proof
  set a=GBP;
  let s be State of SCMPDS,md,me be Element of NAT;
  assume that
A1: s.a2=md and
A2: s.a3=me and
A3: md >= 8 and
A4: me >= 8 and
A5: s.a=0;

  set t0=Initialized s, t1=IExec(j1 ';' j2 ';' j3 ';' j4,s), t2=IExec(j1 ';'
  j2 ';' j3,s), t3=IExec(j1 ';' j2,s), t4=Exec(j1, t0);

A6: t0.a=0 by A5,SCMPDS_5:40;
  then
A7: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A8: t4.a =0 by A6,AMI_3:52,SCMPDS_2:59;
  then
A9: DataLoc(t4.a,7)=intpos (0+7) by SCMP_GCD:5;
  t0.a2=md by A1,SCMPDS_5:40;
  then
A10: t4.a2 =md by A7,AMI_3:52,SCMPDS_2:59;
A11: t3.a2 =Exec(j2, t4).a2 by SCMPDS_5:47
    .=md by A10,A9,AMI_3:52,SCMPDS_2:60;
  then
A12: DataLoc(t3.a2,0)=intpos (md+0) by SCMP_GCD:5;
A13: t3.a =Exec(j2, t4).a by SCMPDS_5:47
    .=0 by A8,A9,AMI_3:52,SCMPDS_2:60;
  then
A14: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:5;
  t0.a3=me by A2,SCMPDS_5:40;
  then
A15: t4.a3 =me by A7,AMI_3:52,SCMPDS_2:59;
A16: t3.a3 =Exec(j2, t4).a3 by SCMPDS_5:47
    .=me by A15,A9,AMI_3:52,SCMPDS_2:60;
A17: t0.a7=s.a7 by SCMPDS_5:40;
  then
A18: t4.a7 =s.a7 by A7,AMI_3:52,SCMPDS_2:59;
  set t01=Initialized t1, jj7= (GBP,7):=0, t5=Exec(j5,t01);
A19: t2.a3 =Exec(j3, t3).a3 by SCMPDS_5:46
    .=me by A16,A14,AMI_3:52,SCMPDS_2:59;
A20: t2.a =Exec(j3, t3).a by SCMPDS_5:46
    .=0 by A13,A14,AMI_3:52,SCMPDS_2:59;
  then
A21: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:5;
  t0.a4=s.a4 by SCMPDS_5:40;
  then
A22: t4.a4 =s.a4 by A7,AMI_3:52,SCMPDS_2:59;
A23: t3.a4 =Exec(j2, t4).a4 by SCMPDS_5:47
    .=s.a4 by A22,A9,AMI_3:52,SCMPDS_2:60;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A24: t4.a1 =s.a1 by A7,AMI_3:52,SCMPDS_2:59;
A25: t3.a1 =Exec(j2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A24,A9,AMI_3:52,SCMPDS_2:60;
A26: t2.a1 =Exec(j3, t3).a1 by SCMPDS_5:46
    .=s.a1 by A25,A14,AMI_3:52,SCMPDS_2:59;
  t1.a1 =Exec(j4, t2).a1 by SCMPDS_5:46
    .=s.a1 by A26,A21,AMI_3:52,SCMPDS_2:62;
  then
A27: t01.a1=s.a1 by SCMPDS_5:40;
A28: t2.a4 =Exec(j3, t3).a4 by SCMPDS_5:46
    .=s.a4 by A23,A14,AMI_3:52,SCMPDS_2:59;
  t1.a4 =Exec(j4, t2).a4 by SCMPDS_5:46
    .=s.a4 by A28,A21,AMI_3:52,SCMPDS_2:62;
  then
A29: t01.a4=s.a4 by SCMPDS_5:40;
A30: t1.a =Exec(j4, t2).a by SCMPDS_5:46
    .=0 by A20,A21,AMI_3:52,SCMPDS_2:62;
  then
A31: t01.a=0 by SCMPDS_5:40;
  then
A32: DataLoc(t01.a,7)=intpos(0+7) by SCMP_GCD:5;
  DataLoc(t0.a,7)=intpos (0+7) by A6,SCMP_GCD:5;
  then
A33: t4.a5 =s.a7 by A17,A7,SCMPDS_2:59;
A34: t3.a5 =Exec(j2, t4).a5 by SCMPDS_5:47
    .=s.a7 by A33,A9,AMI_3:52,SCMPDS_2:60;
A35: t2.a5 =Exec(j3, t3).a5 by SCMPDS_5:46
    .=s.a7 by A34,A14,AMI_3:52,SCMPDS_2:59;
  t1.a5 =Exec(j4, t2).a5 by SCMPDS_5:46
    .=s.a7 by A35,A21,AMI_3:52,SCMPDS_2:62;
  then
A36: t01.a5=s.a7 by SCMPDS_5:40;
A37: t2.a2 =Exec(j3, t3).a2 by SCMPDS_5:46
    .=md by A11,A14,AMI_3:52,SCMPDS_2:59;
  t1.a2 =Exec(j4, t2).a2 by SCMPDS_5:46
    .=md by A37,A21,AMI_3:52,SCMPDS_2:62;
  then
A38: t01.a2=s.a2 by A1,SCMPDS_5:40;
  a4<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
  then
A39: t5.a4=s.a4 by A29,SCMPDS_2:60;
  a2<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
  then
A40: t5.a2=s.a2 by A38,SCMPDS_2:60;
  a<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
  then
A41: t5.a=0 by A31,SCMPDS_2:60;
  then
A42: DataLoc(t5.a,5)=intpos(0+5) by SCMP_GCD:5;
A43: now
    let i be Element of NAT;
    assume
    i>=8;
    then i > 5 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A7,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A44: now
    let i be Element of NAT;
    assume
A45: i>=8;
    then
A46: i > 7 by XXREAL_0:2;
    thus t3.intpos i =Exec(j2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A9,A46,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A43,A45;
  end;
A47: now
    let i be Element of NAT;
    assume
A48: i>=8;
    then
A49: i > 6 by XXREAL_0:2;
    thus t2.intpos i=Exec(j3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A14,A49,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A44,A48;
  end;
A50: now
    let i be Element of NAT;
    assume
A51: i>=8;
    then
A52: i > 6 by XXREAL_0:2;
    thus t1.intpos i=Exec(j4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A21,A52,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A47,A51;
  end;
A53: t2.a6 =Exec(j3, t3).a6 by SCMPDS_5:46
    .=t3.intpos md by A14,A12,SCMPDS_2:59
    .=s.intpos md by A3,A44;
  t1.a6 =Exec(j4, t2).a6 by SCMPDS_5:46
    .=t2.a6-t2.DataLoc(t2.a3,0) by A21,SCMPDS_2:62
    .=t2.a6-t2.intpos(me+0) by A19,SCMP_GCD:5
    .=s.intpos md - s.intpos me by A4,A53,A47;
  then
A54: t1.DataLoc(t1.a,6)=s.intpos md - s.intpos me by A30,SCMP_GCD:5;
  a1<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
  then
A55: t5.a1=s.a1 by A27,SCMPDS_2:60;
A56: now
    per cases;
    suppose
A57:  t1.DataLoc(t1.a,6) <= 0;
      hence IExec(IF2,t1).a=IExec(j7,t1).a by SCMPDS_6:88
        .=Exec(jj7,t01).a by SCMPDS_5:45
        .=0 by A31,A32,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF2,t1).a1=IExec(j7,t1).a1 by A57,SCMPDS_6:88
        .=Exec(jj7,t01).a1 by SCMPDS_5:45
        .=s.a1 by A27,A32,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF2,t1).a2=IExec(j7,t1).a2 by A57,SCMPDS_6:88
        .=Exec(jj7,t01).a2 by SCMPDS_5:45
        .=s.a2 by A38,A32,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF2,t1).a4=IExec(j7,t1).a4 by A57,SCMPDS_6:88
        .=Exec(jj7,t01).a4 by SCMPDS_5:45
        .=s.a4 by A29,A32,AMI_3:52,SCMPDS_2:58;
      hereby
        let i be Element of NAT;
        assume
A58:    i>=8;
        then
A59:    i > 7 by XXREAL_0:2;
        thus IExec(WB2,s).intpos i=IExec(IF2,t1).intpos i by SCMPDS_5:39
          .=IExec(j7,t1).intpos i by A57,SCMPDS_6:88
          .=Exec(jj7,t01).intpos i by SCMPDS_5:45
          .=t01.intpos i by A32,A59,AMI_3:52,SCMPDS_2:58
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A50,A58;
      end;
    end;
    suppose
A60:  t1.DataLoc(t1.a,6) > 0;
      hence IExec(IF2,t1).a=IExec(j5 ';' j6,t1).a by SCMPDS_6:87
        .=Exec(j6,t5).a by SCMPDS_5:47
        .=0 by A41,A42,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF2,t1).a1=IExec(j5 ';' j6,t1).a1 by A60,SCMPDS_6:87
        .=Exec(j6,t5).a1 by SCMPDS_5:47
        .=s.a1 by A55,A42,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF2,t1).a2=IExec(j5 ';' j6,t1).a2 by A60,SCMPDS_6:87
        .=Exec(j6,t5).a2 by SCMPDS_5:47
        .=s.a2 by A40,A42,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF2,t1).a4=IExec(j5 ';' j6,t1).a4 by A60,SCMPDS_6:87
        .=Exec(j6,t5).a4 by SCMPDS_5:47
        .=s.a4 by A39,A42,AMI_3:52,SCMPDS_2:60;
      hereby
        let i be Element of NAT;
        assume
A61:    i>=8;
        then
A62:    i > 5 by XXREAL_0:2;
        i > 3 by A61,XXREAL_0:2;
        then
A63:    intpos i<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
        thus IExec(WB2,s).intpos i=IExec(IF2,t1).intpos i by SCMPDS_5:39
          .=IExec(j5 ';' j6,t1).intpos i by A60,SCMPDS_6:87
          .=Exec(j6,t5).intpos i by SCMPDS_5:47
          .=t5.intpos i by A42,A62,AMI_3:52,SCMPDS_2:60
          .=t01.intpos i by A63,SCMPDS_2:60
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A50,A61;
      end;
    end;
  end;

  hence
  IExec(WB2,s).a=0 & IExec(WB2,s).a1=s.a1 & IExec(WB2,s).a2=s.a2 & IExec(
  WB2,s).a4=s.a4 by SCMPDS_5:39;

  thus for i be Element of NAT st i >= 8 holds IExec(WB2,s).intpos i=s.intpos
  i by A56;

A64: t3.a7 =Exec(j2, t4).a7 by SCMPDS_5:47
    .=t4.a7+ -1 by A9,SCMPDS_2:60
    .=s.a7-1 by A18;
A65: t2.a7 =Exec(j3, t3).a7 by SCMPDS_5:46
    .=s.a7-1 by A64,A14,AMI_3:52,SCMPDS_2:59;
  t1.a7 =Exec(j4, t2).a7 by SCMPDS_5:46
    .=s.a7-1 by A65,A21,AMI_3:52,SCMPDS_2:62;
  then
A66: t01.a7=s.a7-1 by SCMPDS_5:40;
  t1.a3 =Exec(j4, t2).a3 by SCMPDS_5:46
    .=me by A19,A21,AMI_3:52,SCMPDS_2:62;
  then
A67: t01.a3=s.a3 by A2,SCMPDS_5:40;
A68: DataLoc(t01.a,3)=intpos(0+3) by A31,SCMP_GCD:5;
  hereby
A69: a7<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
    assume
A70: s.intpos md > s.intpos me;
    thus IExec(WB2,s).a7=IExec(IF2,t1).a7 by SCMPDS_5:39
      .=IExec(j5 ';' j6,t1).a7 by A54,A70,SCMPDS_6:87,XREAL_1:52
      .=Exec(j6,t5).a7 by SCMPDS_5:47
      .=t5.a7 by A42,AMI_3:52,SCMPDS_2:60
      .=s.a7-1 by A66,A69,SCMPDS_2:60;
    thus IExec(WB2,s).a3=IExec(IF2,t1).a3 by SCMPDS_5:39
      .=IExec(j5 ';' j6,t1).a3 by A54,A70,SCMPDS_6:87,XREAL_1:52
      .=Exec(j6,t5).a3 by SCMPDS_5:47
      .=t5.a3 by A42,AMI_3:52,SCMPDS_2:60
      .=s.a3+1 by A68,A67,SCMPDS_2:60;
A71: a5<>DataLoc(t01.a,3) by A31,AMI_3:52,SCMP_GCD:5;
    thus IExec(WB2,s).a5=IExec(IF2,t1).a5 by SCMPDS_5:39
      .=IExec(j5 ';' j6,t1).a5 by A54,A70,SCMPDS_6:87,XREAL_1:52
      .=Exec(j6,t5).a5 by SCMPDS_5:47
      .=t5.a5+ -1 by A42,SCMPDS_2:60
      .=t5.a5-1
      .=s.a7-1 by A36,A71,SCMPDS_2:60;
  end;
  hereby
    assume
A72: s.intpos md <= s.intpos me;
    thus IExec(WB2,s).a7=IExec(IF2,t1).a7 by SCMPDS_5:39
      .=IExec(j7,t1).a7 by A54,A72,SCMPDS_6:88,XREAL_1:49
      .=Exec(jj7,t01).a7 by SCMPDS_5:45
      .=0 by A32,SCMPDS_2:58;
    thus IExec(WB2,s).a3=IExec(IF2,t1).a3 by SCMPDS_5:39
      .=IExec(j7,t1).a3 by A54,A72,SCMPDS_6:88,XREAL_1:49
      .=Exec(jj7,t01).a3 by SCMPDS_5:45
      .=s.a3 by A32,A67,AMI_3:52,SCMPDS_2:58;
    thus IExec(WB2,s).a5=IExec(IF2,t1).a5 by SCMPDS_5:39
      .=IExec(j7,t1).a5 by A54,A72,SCMPDS_6:88,XREAL_1:49
      .=Exec(jj7,t01).a5 by SCMPDS_5:45
      .=s.a7 by A36,A32,AMI_3:52,SCMPDS_2:58;
  end;
end;

Lm15: for s being State of SCMPDS,m3,md be Element of NAT st s.GBP=0 & s.a7 >
0 & s.a3+s.a7=m3 & s.a3>=8 & s.a2=md & md >= 8 holds IExec(WH2,s).GBP=0 & IExec
(WH2,s).a1=s.a1 & IExec(WH2,s).a7=0 & IExec(WH2,s).a2=s.a2 & IExec(WH2,s).a4=s.
a4 & (for i be Element of NAT st i >= 8 holds IExec(WH2,s).intpos i=s.intpos i)
& ex m5,mE3 be Element of NAT st m5=IExec(WH2,s).a5 & IExec(WH2,s).a3=mE3 & mE3
+m5=m3 & m5 <= s.a7 & (for i be Element of NAT st s.a3 <= i & i < mE3 holds
IExec(WH2,s).intpos md > IExec(WH2,s).intpos i) & (m5 = 0 or IExec(WH2,s).
intpos md <= IExec(WH2,s).intpos mE3)

proof
  set a=GBP;
  let s be State of SCMPDS,m3,md be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a7 > 0 and
A3: s.a3+s.a7=m3 and
A4: s.a3>=8 and
A5: s.a2=md and
A6: md >= 8;
  s.a7 >=1+0 by A2,INT_1:20;
  then reconsider m7=s.a7-1 as Element of NAT by INT_1:16,XREAL_1:50;
A7: s.a7=m7+1;

  defpred P[Element of NAT] means for t being State of SCMPDS st t.a=0 & t.a7

=$1+1 & t.a3+t.a7=m3 & t.a3>=8 & t.a2=md holds IExec(WH2,t).a=0 & IExec(WH2,t).
  a1=t.a1 & IExec(WH2,t).a7=0 & IExec(WH2,t).a2=t.a2 & IExec(WH2,t).a4=t.a4 & (

for i be Element of NAT st i >= 8 holds IExec(WH2,t).intpos i=t.intpos i) & ex

m5,mE3 be Element of NAT st m5=IExec(WH2,t).a5 & IExec(WH2,t).a3=mE3 & mE3+m5=

m3 & m5 <= t.a7 & (for i be Element of NAT st t.a3 <= i & i < mE3 holds IExec(

WH2,t).intpos md > IExec(WH2,t).intpos i) & (m5=0 or IExec(WH2,t).intpos md <=
  IExec(WH2,t).intpos mE3);

A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      let t be State of SCMPDS;
      set b=DataLoc(t.a,7);
      assume that
A10:  t.a=0 and
A11:  t.a7 =(k+1)+1 and
A12:  t.a3+t.a7=m3 and
A13:  t.a3>=8 and
A14:  t.a2=md;
      reconsider me=t.a3 as Element of NAT by A13,INT_1:16;
      set It=IExec(WB2,t);

A15:  t.intpos md > t.intpos me implies It.a7=t.a7-1 & It.a3=t.a3+1 & It.
      a5= t.a7-1 by A6,A10,A13,A14,Lm14;

A16:  b=intpos (0+7) by A10,SCMP_GCD:5;
A17:  now
        let v be State of SCMPDS;
        assume that
A18:    v.a3 >= 8 and
A19:    v.a2=t.a2 and
A20:    v.a=t.a and
A21:    v.b > 0;
        reconsider ME=v.a3 as Element of NAT by A18,INT_1:16;
A22:    ME=v.a3;
        hence IExec(WB2,v).a=v.a by A6,A10,A14,A18,A19,A20,Lm14;
        thus WB2 is_closed_on v & WB2 is_halting_on v by SCMPDS_6:34,35;

A23:    v.intpos md > v.intpos ME implies IExec(WB2,v).a7=v.a7-1 & IExec(

WB2,v ).a3=v.a3+1 & IExec(WB2,v).a5=v.a7-1 by A6,A10,A14,A18,A19,A20,Lm14;

        hereby
          per cases;
          suppose
A24:        v.intpos md > v.intpos ME;
            hence IExec(WB2,v).b < v.b by A16,A23,XREAL_1:148;
A25:        v.a3 +1 > v.a3 by XREAL_1:31;
            IExec(WB2,v).a3=v.a3+1 by A6,A10,A14,A18,A19,A20,A24,Lm14;
            hence IExec(WB2,v).a3 >= 8 by A18,A25,XXREAL_0:2;
          end;
          suppose
A26:        v.intpos md <= v.intpos ME;

            hence IExec(WB2,v).b < v.b by A6,A10,A14,A16,A18,A19,A20,A21,Lm14;

            thus IExec(WB2,v).a3 >= 8 by A6,A10,A14,A18,A19,A20,A26,Lm14;
          end;
        end;
        thus IExec(WB2,v).a2=v.a2 by A6,A10,A14,A18,A19,A20,A22,Lm14;
      end;

A27:  t.intpos md <= t.intpos me implies It.a7=0 & It.a3=t.a3 & It.a5=t.
      a7 by A6,A10,A13,A14,Lm14;

A28:  me=t.a3;
      then
A29:  It.a=0 by A6,A10,A13,A14,Lm14;
      then
A30:  DataLoc(It.a,7)=intpos(0+7) by SCMP_GCD:5;
A31:  It.a1=t.a1 by A6,A10,A13,A14,A28,Lm14;
A32:  It.a4=t.a4 by A6,A10,A13,A14,A28,Lm14;
A33:  It.a2=t.a2 by A6,A10,A13,A14,A28,Lm14;
      per cases;
      suppose
A34:    t.intpos md > t.intpos me;
        then t.a3 < It.a3 by A15,XREAL_1:31;
        then
A35:    It.a3 >= 8 by A13,XXREAL_0:2;
A36:    It.a3+It.a7=m3 by A12,A15,A34;
        then consider m5,mE3 be Element of NAT such that
A37:    m5=IExec(WH2,It).a5 and
A38:    IExec(WH2,It).a3=mE3 and
A39:    mE3+m5=m3 and
A40:    m5 <= It.a7 and

A41:    for i be Element of NAT st It.a3 <= i & i < mE3 holds IExec(
        WH2,It ).intpos md > IExec(WH2,It).intpos i and

A42:    m5=0 or IExec(WH2,It).intpos md <= IExec(WH2,It).intpos mE3
        by A9,A11,A12,A14,A29,A33,A15,A27,A35;

A43:    IExec(WH2,t)=IExec(WH2,It) by A11,A13,A16,A17,Lm12,Th6;
        hence IExec(WH2,t).a=0 by A9,A11,A12,A14,A29,A33,A15,A27,A35,A36;

        thus IExec(WH2,t).a1=t.a1 by A9,A11,A12,A14,A29,A31,A33,A15,A27,A35,A36
,A43;

        thus IExec(WH2,t).a7=0 by A9,A11,A12,A14,A29,A33,A15,A27,A35,A36,A43;

        thus IExec(WH2,t).a2=t.a2 by A9,A11,A12,A14,A29,A33,A15,A27,A35,A36,A43
;

        thus IExec(WH2,t).a4=t.a4 by A9,A11,A12,A14,A29,A33,A32,A15,A27,A35,A36
,A43;

A44:    now
          let i be Element of NAT;
          assume
A45:      i >= 8;

          hence IExec(WH2,t).intpos i=It.intpos i by A9,A11,A12,A14,A29,A33,A15
,A27,A35,A36,A43

            .=t.intpos i by A6,A10,A13,A14,A28,A45,Lm14;
        end;

        hence for i be Element of NAT st i >= 8 holds IExec(WH2,t).intpos i=t.
        intpos i;

        take m5;
        take mE3;
        thus m5=IExec(WH2,t).a5 by A11,A13,A16,A17,A37,Lm12,Th6;
        thus IExec(WH2,t).a3=mE3 by A11,A13,A16,A17,A38,Lm12,Th6;
        thus mE3+m5=m3 by A39;
        thus m5 <= t.a7 by A15,A34,A40,XREAL_1:148,XXREAL_0:2;
A46:    It.a3=t.a3+1 by A6,A10,A13,A14,A34,Lm14;
        hereby
          let i be Element of NAT;
          assume that
A47:      t.a3 <= i and
A48:      i < mE3;
          per cases;
          suppose
A49:        i=t.a3;
            IExec(WH2,t).intpos me =t.intpos me by A13,A44;

            hence IExec(WH2,t).intpos md > IExec(WH2,t).intpos i by A6,A34,A44
,A49;

          end;
          suppose
            i<>t.a3;
            then t.a3 < i by A47,XXREAL_0:1;
            then It.a3 <= i by A46,INT_1:20;

            hence
            IExec(WH2,t).intpos md > IExec(WH2,t).intpos i by A43,A41,A48;

          end;
        end;

        thus m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3 by A43
,A42;

      end;
      suppose
A50:    t.intpos md <= t.intpos me;
A51:    now
          let x;
          thus IExec(WH2,t).x =IExec(WH2,It).x by A11,A13,A16,A17,Lm12,Th6
            .=It.x by A27,A30,A50,SCMPDS_8:23;
        end;
        hence IExec(WH2,t).a=0 by A29;
        thus IExec(WH2,t).a1=t.a1 by A31,A51;
        thus IExec(WH2,t).a7=0 by A27,A50,A51;
        thus IExec(WH2,t).a2=t.a2 by A33,A51;
        thus IExec(WH2,t).a4=t.a4 by A32,A51;
A52:    now
          let i be Element of NAT;
          assume
A53:      i >= 8;
          thus IExec(WH2,t).intpos i=It.intpos i by A51
            .=t.intpos i by A6,A10,A13,A14,A28,A53,Lm14;
        end;

        hence for i be Element of NAT st i >= 8 holds IExec(WH2,t).intpos i=t.
        intpos i;

        take m5=k+1+1;
        take mE3=me;
        thus IExec(WH2,t).a5=m5 by A11,A27,A50,A51;
        thus IExec(WH2,t).a3=mE3 by A27,A50,A51;
        thus mE3+m5=m3 by A11,A12;
        thus m5 <= t.a7 by A11;

        thus for i be Element of NAT st t.a3 <= i & i < mE3 holds IExec(WH2,t)
        .intpos md > IExec(WH2,t).intpos i;

        IExec(WH2,t).intpos me=t.intpos me by A13,A52;

        hence m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3 by A6
,A50,A52;

      end;
    end;
    hence P[k+1];
  end;
  now
    let t be State of SCMPDS;
    set b=DataLoc(t.a,7);
    assume that
A54: t.a=0 and
A55: t.a7 =0+1 and
A56: t.a3+t.a7=m3 and
A57: t.a3>=8 and
A58: t.a2=md;
    reconsider me=t.a3 as Element of NAT by A57,INT_1:16;
    set It=IExec(WB2,t);

A59: t.intpos md > t.intpos me implies It.a7=t.a7-1 & It.a3=t.a3+1 & It.a5
    = t.a7-1 by A6,A54,A57,A58,Lm14;

A60: b=intpos (0+7) by A54,SCMP_GCD:5;
A61: now
      let v be State of SCMPDS;
      assume that
A62:  v.a3 >= 8 and
A63:  v.a2=t.a2 and
A64:  v.a=t.a and
A65:  v.b > 0;
      reconsider ME=v.a3 as Element of NAT by A62,INT_1:16;
A66:  ME=v.a3;
      hence IExec(WB2,v).a=v.a by A6,A54,A58,A62,A63,A64,Lm14;
      thus WB2 is_closed_on v & WB2 is_halting_on v by SCMPDS_6:34,35;

A67:  v.intpos md > v.intpos ME implies IExec(WB2,v).a7=v.a7-1 & IExec(

WB2,v) .a3=v.a3+1 & IExec(WB2,v).a5=v.a7-1 by A6,A54,A58,A62,A63,A64,Lm14;

      hereby
        per cases;
        suppose
A68:      v.intpos md > v.intpos ME;
          hence IExec(WB2,v).b < v.b by A60,A67,XREAL_1:148;
A69:      v.a3 +1 > v.a3 by XREAL_1:31;
          IExec(WB2,v).a3=v.a3+1 by A6,A54,A58,A62,A63,A64,A68,Lm14;
          hence IExec(WB2,v).a3 >= 8 by A62,A69,XXREAL_0:2;
        end;
        suppose
A70:      v.intpos md <= v.intpos ME;
          hence IExec(WB2,v).b < v.b by A6,A54,A58,A60,A62,A63,A64,A65,Lm14;
          thus IExec(WB2,v).a3 >= 8 by A6,A54,A58,A62,A63,A64,A70,Lm14;
        end;
      end;
      thus IExec(WB2,v).a2=v.a2 by A6,A54,A58,A62,A63,A64,A66,Lm14;
    end;

A71: t.intpos md <= t.intpos me implies It.a7=0 & It.a3=t.a3 & It.a5=t.a7
    by A6,A54,A57,A58,Lm14;

A72: me=t.a3;
    then
A73: It.a=0 by A6,A54,A57,A58,Lm14;
    then
A74: It.DataLoc(It.a,7)=0 by A55,A59,A71,SCMP_GCD:5;
A75: now
      let x;
      thus IExec(WH2,t).x =IExec(WH2,It).x by A55,A57,A60,A61,Lm12,Th6
        .=It.x by A74,SCMPDS_8:23;
    end;
    hence IExec(WH2,t).a=0 by A73;
    It.a1=t.a1 by A6,A54,A57,A58,A72,Lm14;
    hence IExec(WH2,t).a1=t.a1 by A75;
    thus IExec(WH2,t).a7=0 by A55,A59,A71,A75;
    It.a2=t.a2 by A6,A54,A57,A58,A72,Lm14;
    hence IExec(WH2,t).a2=t.a2 by A75;
    It.a4=t.a4 by A6,A54,A57,A58,A72,Lm14;
    hence IExec(WH2,t).a4=t.a4 by A75;
A76: now
      let i be Element of NAT;
      assume
A77:  i >= 8;
      thus IExec(WH2,t).intpos i=It.intpos i by A75
        .=t.intpos i by A6,A54,A57,A58,A72,A77,Lm14;
    end;

    hence for i be Element of NAT st i >= 8 holds IExec(WH2,t).intpos i=t.
    intpos i;

A78: IExec(WH2,t).intpos me=t.intpos me by A57,A76;
    hereby
      per cases;
      suppose
A79:    t.intpos md > t.intpos me;
        take m5=0;
        take mE3=m3;
        thus IExec(WH2,t).a5=m5 by A55,A59,A75,A79;
        thus IExec(WH2,t).a3 =mE3 by A55,A56,A59,A75,A79;
        thus mE3+m5=m3;
        thus m5 <= t.a7 by A55;
        hereby
          let i be Element of NAT;
          assume that
A80:      t.a3 <= i and
A81:      i < mE3;
          i <= me by A55,A56,A81,NAT_1:13;
          then i=t.a3 by A80,XXREAL_0:1;

          hence IExec(WH2,t).intpos md > IExec(WH2,t).intpos i by A6,A76,A78
,A79;

        end;
        thus m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3;
      end;
      suppose
A82:    t.intpos md <= t.intpos me;
        take m5=1;
        take mE3=me;
        thus IExec(WH2,t).a5=m5 by A55,A71,A75,A82;
        thus IExec(WH2,t).a3=mE3 by A71,A75,A82;
        thus mE3+m5=m3 by A55,A56;
        thus m5 <= t.a7 by A55;

        thus for i be Element of NAT st t.a3 <= i & i < mE3 holds IExec(WH2,t)
        .intpos md > IExec(WH2,t).intpos i;

        thus m5=0 or IExec(WH2,t).intpos md <= IExec(WH2,t).intpos mE3 by A6
,A76,A78,A82;

      end;
    end;
  end;
  then
A83: P[0];
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A83,A8);
  hence thesis by A1,A3,A4,A5,A7;
end;

Lm16: for s being State of SCMPDS,md be Element of NAT st s.GBP=0 & s.a3>=8 &
s.a2=md & md >= 8 holds WH2 is_closed_on s & WH2 is_halting_on s

proof
  set a=GBP;
  let s be State of SCMPDS,md be Element of NAT;
  set b=DataLoc(s.a,7);
  assume that
A1: s.a=0 and
A2: s.a3>=8 and
A3: s.a2=md and
A4: md >= 8;
A5: b=intpos (0+7) by A1,SCMP_GCD:5;
  now
    let v be State of SCMPDS;
    assume that
A6: v.a3 >= 8 and
A7: v.a2=s.a2 and
A8: v.a=s.a and
A9: v.b > 0;
    reconsider ME=v.a3 as Element of NAT by A6,INT_1:16;
A10: ME=v.a3;
    hence IExec(WB2,v).a=v.a by A1,A3,A4,A6,A7,A8,Lm14;
    thus WB2 is_closed_on v & WB2 is_halting_on v by SCMPDS_6:34,35;

A11: v.intpos md > v.intpos ME implies IExec(WB2,v).a7=v.a7-1 & IExec(WB2,
    v) .a3=v.a3+1 & IExec(WB2,v).a5=v.a7-1 by A1,A3,A4,A6,A7,A8,Lm14;

    hereby
      per cases;
      suppose
A12:    v.intpos md > v.intpos ME;
        hence IExec(WB2,v).b < v.b by A5,A11,XREAL_1:148;
A13:    v.a3 +1 > v.a3 by XREAL_1:31;
        IExec(WB2,v).a3=v.a3+1 by A1,A3,A4,A6,A7,A8,A12,Lm14;
        hence IExec(WB2,v).a3 >= 8 by A6,A13,XXREAL_0:2;
      end;
      suppose
A14:    v.intpos md <= v.intpos ME;
        hence IExec(WB2,v).b < v.b by A1,A3,A4,A5,A6,A7,A8,A9,Lm14;
        thus IExec(WB2,v).a3 >= 8 by A1,A3,A4,A6,A7,A8,A14,Lm14;
      end;
    end;
    thus IExec(WB2,v).a2=v.a2 by A1,A3,A4,A6,A7,A8,A10,Lm14;
  end;
  hence thesis by A2,Lm12,Th6;
end;

Lm17: card WB3=29
proof
  thus card WB3=card (WH1 ';' WH2 )+card IF3 by SCMPDS_4:45
    .=11+ 11+card IF3 by Lm11,Lm13,SCMPDS_4:45
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0)+1) by SCMPDS_6:89
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9)+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6 ';' k7 ';' k8)+1+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6 ';' k7)+1+1+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6)+1+1+1+1+1) by SCMP_GCD:8
    .=22+(2+1+1+1+1+1) by SCMP_GCD:9
    .=29;
end;

Lm18: card WH3=31
proof
  thus card WH3=29+2 by Lm17,SCMPDS_8:17
    .=31;
end;

begin :: The Basic Property of Partition Program

canceled 3;

theorem Th12:
  card Partition=38
proof
  thus card Partition=card (K4 ';' WH3 ';' j8 ';' j9)+1 by SCMP_GCD:8
    .=card (K4 ';' WH3 ';' j8)+1+1 by SCMP_GCD:8
    .=card (K4 ';' WH3)+1+1+1 by SCMP_GCD:8
    .=card K4+card WH3+1+1+1 by SCMPDS_4:45
    .=4+31+1+1+1 by Lm18,Th4
    .=38;
end;

Lm19: for s be State of SCMPDS,m3,m4 be Element of NAT st s.GBP=0 & s.a5 > 0 &
s.a3=m3 & s.a4=m4 & m3>6 & m4 > 6 holds IExec(IF3,s).GBP=0 & IExec(IF3,s).a1=s.
a1 & IExec(IF3,s).a2=s.a2 & IExec(IF3,s).intpos m3=s.intpos m4 & IExec(IF3,s).
intpos m4=s.intpos m3 & IExec(IF3,s).a3=s.a3+1 & IExec(IF3,s).a4=s.a4-1 & IExec
(IF3,s).a5=s.a5-2 & for i be Element of NAT st i >= 8 & i <> m3 & i <> m4 holds
IExec(IF3,s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be State of SCMPDS,m3,m4 be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a3=m3 and
A4: s.a4=m4 and
A5: m3 > 6 and
A6: m4 > 6;
A7: m4 > 3 by A6,XXREAL_0:2;

  set x=intpos m3, y=intpos m4, t0=Initialized s, t1=IExec(k5 ';' k6 ';' k7

';' k8 ';' k9 ';' k0,s), t2=IExec(k5 ';' k6 ';' k7 ';' k8 ';' k9,s), t3=IExec(

k5 ';' k6 ';' k7 ';' k8,s), t4=IExec(k5 ';' k6 ';' k7,s), t5=IExec(k5 ';' k6,s)
  , t6=Exec(k5,t0);

A8: t0.a=0 by A1,SCMPDS_5:40;
  then
A9: DataLoc(t0.a,6)=intpos (0+6) by SCMP_GCD:5;
  then
A10: t6.a =0 by A8,AMI_3:52,SCMPDS_2:59;
A11: t0.a4=m4 by A4,SCMPDS_5:40;
  then
A12: t6.a4 =m4 by A9,AMI_3:52,SCMPDS_2:59;
  then
A13: DataLoc(t6.a4,0)=intpos (m4+0) by SCMP_GCD:5;
A14: t5.a =Exec(k6, t6).a by SCMPDS_5:47
    .=0 by A6,A10,A13,AMI_3:52,SCMPDS_2:59;
A15: t6.a6 =t0.DataLoc(t0.a4,0) by A9,SCMPDS_2:59
    .=t0.intpos(m4+0) by A11,SCMP_GCD:5
    .=s.y by SCMPDS_5:40;
  t5.a6 =Exec(k6, t6).a6 by SCMPDS_5:47
    .=s.y by A6,A15,A13,AMI_3:52,SCMPDS_2:59;
  then
A16: t5.DataLoc(t5.a,6)=s.y by A14,SCMP_GCD:5;
  t0.a3=m3 by A3,SCMPDS_5:40;
  then
A17: t6.a3 =m3 by A9,AMI_3:52,SCMPDS_2:59;
A18: t5.a3 =Exec(k6, t6).a3 by SCMPDS_5:47
    .=m3 by A7,A17,A13,AMI_3:52,SCMPDS_2:59;
  then
A19: DataLoc(t5.a3,0)=intpos (m3+0) by SCMP_GCD:5;
A20: t0.x=s.x by SCMPDS_5:40;
A21: t5.y=Exec(k6, t6).y by SCMPDS_5:47
    .=t6.DataLoc(t6.a3,0) by A13,SCMPDS_2:59
    .=t6.intpos(m3+0) by A17,SCMP_GCD:5
    .=s.x by A5,A20,A9,AMI_3:52,SCMPDS_2:59;
A22: now
    per cases;
    suppose
A23:  y<>DataLoc(t5.a3,0);
      thus t4.y =Exec(k7, t5).y by SCMPDS_5:46
        .=s.x by A21,A23,SCMPDS_2:59;
    end;
    suppose
A24:  y=DataLoc(t5.a3,0);
      thus t4.y =Exec(k7, t5).y by SCMPDS_5:46
        .=s.x by A19,A16,A24,SCMPDS_2:59;
    end;
  end;
  t0.a2=s.a2 by SCMPDS_5:40;
  then
A25: t6.a2 =s.a2 by A9,AMI_3:52,SCMPDS_2:59;
A26: m4 > 2 by A6,XXREAL_0:2;
A27: m3 > 5 by A5,XXREAL_0:2;
A28: t4.a =Exec(k7, t5).a by SCMPDS_5:46
    .=0 by A5,A14,A19,AMI_3:52,SCMPDS_2:59;
  then
A29: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:5;
A30: t3.a =Exec(k8, t4).a by SCMPDS_5:46
    .=0 by A28,A29,AMI_3:52,SCMPDS_2:60;
  then
A31: a<>DataLoc(t3.a,3) by AMI_3:52,SCMP_GCD:5;
A32: m3 > 3 by A5,XXREAL_0:2;
  then
A33: x<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A34: t4.a3 =Exec(k7, t5).a3 by SCMPDS_5:46
    .=m3 by A32,A18,A19,AMI_3:52,SCMPDS_2:59;
A35: t3.a3 =Exec(k8, t4).a3 by SCMPDS_5:46
    .=m3 by A34,A29,AMI_3:52,SCMPDS_2:60;
A36: DataLoc(t3.a,3)=intpos (0+3) by A30,SCMP_GCD:5;
A37: t2.a3 =Exec(k9, t3).a3 by SCMPDS_5:46
    .=m3+1 by A35,A36,SCMPDS_2:60;
A38: m3 > 2 by A5,XXREAL_0:2;
A39: m4 > 5 by A6,XXREAL_0:2;
A40: t5.a2 =Exec(k6, t6).a2 by SCMPDS_5:47
    .=s.a2 by A25,A13,A26,AMI_3:52,SCMPDS_2:59;
A41: t4.x=Exec(k7, t5).x by SCMPDS_5:46
    .=s.y by A19,A16,SCMPDS_2:59;
A42: t3.x =Exec(k8, t4).x by SCMPDS_5:46
    .=s.y by A27,A41,A29,AMI_3:52,SCMPDS_2:60;
A43: t2.x =Exec(k9, t3).x by SCMPDS_5:46
    .=s.y by A42,A33,SCMPDS_2:60;
A44: t3.y =Exec(k8, t4).y by SCMPDS_5:46
    .=s.x by A39,A22,A29,AMI_3:52,SCMPDS_2:60;
A45: y<>DataLoc(t3.a,3) by A7,A30,AMI_3:52,SCMP_GCD:5;
A46: t2.y =Exec(k9, t3).y by SCMPDS_5:46
    .=s.x by A44,A45,SCMPDS_2:60;
A47: t4.a2 =Exec(k7, t5).a2 by SCMPDS_5:46
    .=s.a2 by A40,A19,A38,AMI_3:52,SCMPDS_2:59;
A48: t3.a2 =Exec(k8, t4).a2 by SCMPDS_5:46
    .=s.a2 by A47,A29,AMI_3:52,SCMPDS_2:60;
A49: a2<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A50: t2.a2 =Exec(k9, t3).a2 by SCMPDS_5:46
    .=s.a2 by A48,A49,SCMPDS_2:60;
A51: m4 > 1 by A6,XXREAL_0:2;
A52: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:5;
  t0.a5=s.a5 by SCMPDS_5:40;
  then
A53: t6.a5 =s.a5 by A9,AMI_3:52,SCMPDS_2:59;
A54: t5.a5 =Exec(k6, t6).a5 by SCMPDS_5:47
    .=s.a5 by A39,A53,A13,AMI_3:52,SCMPDS_2:59;
A55: t4.a5 =Exec(k7, t5).a5 by SCMPDS_5:46
    .=s.a5 by A27,A54,A19,AMI_3:52,SCMPDS_2:59;
A56: t3.a5 =Exec(k8, t4).a5 by SCMPDS_5:46
    .=t4.a5+-2 by A29,SCMPDS_2:60
    .=s.a5-2 by A55;
A57: a5<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A58: t2.a5 =Exec(k9, t3).a5 by SCMPDS_5:46
    .=s.a5-2 by A56,A57,SCMPDS_2:60;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A59: t6.a1 =s.a1 by A9,AMI_3:52,SCMPDS_2:59;
A60: m3 > 1 by A5,XXREAL_0:2;
A61: t2.a =Exec(k9, t3).a by SCMPDS_5:46
    .=0 by A30,A31,SCMPDS_2:60;
  then
A62: a<>DataLoc(t2.a,4) by AMI_3:52,SCMP_GCD:5;
A63: m4 > 4 by A6,XXREAL_0:2;
  then
A64: y<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A65: m3 > 4 by A5,XXREAL_0:2;
  then
A66: x<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A67: a4<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A68: t5.a4 =Exec(k6, t6).a4 by SCMPDS_5:47
    .=m4 by A63,A12,A13,AMI_3:52,SCMPDS_2:59;
A69: t4.a4 =Exec(k7, t5).a4 by SCMPDS_5:46
    .=m4 by A65,A68,A19,AMI_3:52,SCMPDS_2:59;
A70: t3.a4 =Exec(k8, t4).a4 by SCMPDS_5:46
    .=m4 by A69,A29,AMI_3:52,SCMPDS_2:60;
A71: t2.a4 =Exec(k9, t3).a4 by SCMPDS_5:46
    .=m4 by A70,A67,SCMPDS_2:60;
A72: a3<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A73: t5.a1 =Exec(k6, t6).a1 by SCMPDS_5:47
    .=s.a1 by A59,A13,A51,AMI_3:52,SCMPDS_2:59;
A74: t4.a1 =Exec(k7, t5).a1 by SCMPDS_5:46
    .=s.a1 by A73,A19,A60,AMI_3:52,SCMPDS_2:59;
A75: t3.a1 =Exec(k8, t4).a1 by SCMPDS_5:46
    .=s.a1 by A74,A29,AMI_3:52,SCMPDS_2:60;
A76: a1<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A77: t2.a1 =Exec(k9, t3).a1 by SCMPDS_5:46
    .=s.a1 by A75,A76,SCMPDS_2:60;
A78: a1<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t1.a =Exec(k0, t2).a by SCMPDS_5:46
    .=0 by A61,A62,SCMPDS_2:60;
  hence IExec(IF3,s).a=0 by A2,A52,SCMPDS_6:97;
  t1.a1 =Exec(k0, t2).a1 by SCMPDS_5:46
    .=s.a1 by A77,A78,SCMPDS_2:60;
  hence IExec(IF3,s).a1=s.a1 by A2,A52,SCMPDS_6:97;
A79: a2<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t1.a2 =Exec(k0, t2).a2 by SCMPDS_5:46
    .=s.a2 by A50,A79,SCMPDS_2:60;
  hence IExec(IF3,s).a2=s.a2 by A2,A52,SCMPDS_6:97;
  t1.x =Exec(k0, t2).x by SCMPDS_5:46
    .=s.y by A43,A66,SCMPDS_2:60;
  hence IExec(IF3,s).x=s.y by A2,A52,SCMPDS_6:97;
  t1.y =Exec(k0, t2).y by SCMPDS_5:46
    .=s.x by A46,A64,SCMPDS_2:60;
  hence IExec(IF3,s).y=s.x by A2,A52,SCMPDS_6:97;
A80: DataLoc(t2.a,4)=intpos (0+4) by A61,SCMP_GCD:5;
  t1.a3 =Exec(k0, t2).a3 by SCMPDS_5:46
    .=m3+1 by A37,A72,SCMPDS_2:60;
  hence IExec(IF3,s).a3=s.a3+1 by A2,A3,A52,SCMPDS_6:97;
  t1.a4 =Exec(k0, t2).a4 by SCMPDS_5:46
    .=t2.a4+-1 by A80,SCMPDS_2:60
    .=s.a4-1 by A4,A71;
  hence IExec(IF3,s).a4=s.a4-1 by A2,A52,SCMPDS_6:97;
A81: a5<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t1.a5 =Exec(k0, t2).a5 by SCMPDS_5:46
    .=s.a5-2 by A58,A81,SCMPDS_2:60;
  hence IExec(IF3,s).a5=s.a5-2 by A2,A52,SCMPDS_6:97;
A82: now
    let i be Element of NAT;
    assume that
A83: i >= 8 and
    i <> m3 and
    i <> m4;
    i > 6 by A83,XXREAL_0:2;
    hence t6.intpos i =t0.intpos i by A9,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A84: now
    let i be Element of NAT;
    assume that
A85: i >= 8 and
A86: i <> m3 and
A87: i <> m4;
    thus t5.intpos i =Exec(k6, t6).intpos i by SCMPDS_5:47
      .=t6.intpos i by A13,A87,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A82,A85,A86,A87;
  end;
A88: now
    let i be Element of NAT;
    assume that
A89: i >= 8 and
A90: i <> m3 and
A91: i <> m4;
    thus t4.intpos i =Exec(k7, t5).intpos i by SCMPDS_5:46
      .=t5.intpos i by A19,A90,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A84,A89,A90,A91;
  end;
A92: now
    let i be Element of NAT;
    assume that
A93: i >= 8 and
A94: i <> m3 and
A95: i <> m4;
A96: i > 5 by A93,XXREAL_0:2;
    thus t3.intpos i =Exec(k8, t4).intpos i by SCMPDS_5:46
      .=t4.intpos i by A29,A96,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A88,A93,A94,A95;
  end;
A97: now
    let i be Element of NAT;
    assume that
A98: i >= 8 and
A99: i <> m3 and
A100: i <> m4;
    i > 3 by A98,XXREAL_0:2;
    then
A101: intpos i <> DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
    thus t2.intpos i =Exec(k9, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A101,SCMPDS_2:60
      .=s.intpos i by A92,A98,A99,A100;
  end;
A102: now
    let i be Element of NAT;
    assume that
A103: i >= 8 and
A104: i <> m3 and
A105: i <> m4;
    i > 4 by A103,XXREAL_0:2;
    then
A106: intpos i <> DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
    thus t1.intpos i =Exec(k0, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A106,SCMPDS_2:60
      .=s.intpos i by A97,A103,A104,A105;
  end;
  hereby
    let i be Element of NAT;
    assume that
A107: i >= 8 and
A108: i <> m3 and
A109: i <> m4;
    thus IExec(IF3,s).intpos i = t1.intpos i by A2,A52,SCMPDS_6:97
      .=s.intpos i by A102,A107,A108,A109;
  end;
end;

Lm20: for s be State of SCMPDS,md,m3 be Element of NAT st s.GBP=0 & s.a5 > 0 &
s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= 8 & md <= m3 holds WB3 is_closed_on
s & WB3 is_halting_on s & IExec(WB3,s).GBP=0 & IExec(WB3,s).a1=s.a1 & IExec(WB3
,s).a2=md & IExec(WB3,s).a3 >= s.a3 & IExec(WB3,s).a4 <= s.a4 & IExec(WB3,s).a4
>= m3 & IExec(WB3,s).a5 < s.a5 & IExec(WB3,s).a5 >= -1 & IExec(WB3,s).a4=IExec(
WB3,s).a3-1+IExec(WB3,s).a5 & ex n1,n2 be Element of NAT st n1=IExec(WB3,s).a3-
1 & n2=IExec(WB3,s).a4+1 & (for i be Element of NAT st i >= 8 & i <>n1 & i<> n2
holds IExec(WB3,s).intpos i=s.intpos i) & (IExec(WB3,s).intpos n1=s.intpos n1 &
IExec(WB3,s).intpos n2=s.intpos n2 or n1 >= s.a3 & n2 <= s.a4 & IExec(WB3,s).
intpos n1=s.intpos n2 & IExec(WB3,s).intpos n2=s.intpos n1) & (for i be Element
of NAT st s.a3<=i & i <= n1 holds IExec(WB3,s).intpos md >= IExec(WB3,s).intpos
i) & for i be Element of NAT st n2<=i & i <= s.a4 holds IExec(WB3,s).intpos md
<= IExec(WB3,s).intpos i

proof
  set a=GBP;
  let s be State of SCMPDS,md,m3 be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a4=m3+s.a5 and
A4: m3=s.a3-1 and
A5: s.a2=md and
A6: md >= 8 and
A7: md <= m3;
  set s1=IExec(WH1,s);
A8: m3 >= 8 by A6,A7,XXREAL_0:2;
  then consider mE be Element of NAT such that
A9: mE=s1.a7 and
A10: s1.a4=m3+mE and
A11: mE <= s.a5 and

A12: for i be Element of NAT st m3+mE < i & i <=s.a4 holds s1.intpos md
  < s1.intpos i and

A13: mE = 0 or s1.intpos md >= s1.intpos(m3+mE) by A1,A2,A3,A5,A6,Lm9;

A14: s1.a=0 by A1,A2,A3,A5,A6,A8,Lm9;
A15: s1.a1=s.a1 by A1,A2,A3,A5,A6,A8,Lm9;
A16: WH1 is_halting_on s by A1,A3,A5,A6,A8,Lm10;

  set s2=IExec(WH2,s1), sm=m3+1+mE, s12=IExec(WH1 ';' WH2,s), s3=IExec(WB3,s),
  m4=m3+mE;

A17: s1.a3+s1.a7=sm by A1,A2,A3,A4,A5,A6,A8,A9,Lm9;
A18: m4 >= 8 by A8,NAT_1:12;
A19: s1.a2=s.a2 by A1,A2,A3,A5,A6,A8,Lm9;
A20: s1.a3=s.a3 by A1,A2,A3,A5,A6,A8,Lm9;
  s1.a3=m3+1 by A1,A2,A3,A4,A5,A6,A8,Lm9;
  then m3 < s1.a3 by XREAL_1:31;
  then
A21: s1.a3 >= 8 by A8,XXREAL_0:2;
A22: s1.a5=0 by A1,A2,A3,A5,A6,A8,Lm9;
A23: m3+mE <= m3+s.a5 by A11,XREAL_1:8;
A24: WH1 is_closed_on s by A1,A3,A5,A6,A8,Lm10;
  per cases;
  suppose
A25: mE <= 0;
A26: DataLoc(s1.a,7)=intpos(0+7) by A14,SCMP_GCD:5;
    then
A27: WH2 is_halting_on s1 by A9,A25,SCMPDS_8:20;
A28: WH2 is_closed_on s1 by A9,A25,A26,SCMPDS_8:20;
    then
A29: s12.a5=s2.a5 by A24,A16,A27,SCMPDS_7:49
      .=0 by A22,A9,A25,A26,SCMPDS_8:23;
A30: s12.a=s2.a by A24,A16,A28,A27,SCMPDS_7:49
      .=0 by A14,A9,A25,A26,SCMPDS_8:23;
    then
A31: DataLoc(s12.a,5)=intpos(0+5) by SCMP_GCD:5;
A32: WH1 ';' WH2 is_halting_on s by A24,A16,A28,A27,SCMPDS_7:43;
A33: WH1 ';' WH2 is_closed_on s by A24,A16,A28,A27,SCMPDS_7:43;
    hence WB3 is_closed_on s & WB3 is_halting_on s by A32,SCPISORT:9;
    thus IExec(WB3,s).a=IExec(IF3,s12).a by A33,A32,SCPISORT:7
      .=0 by A30,A29,A31,SCMPDS_6:98;
    thus IExec(WB3,s).a1=IExec(IF3,s12).a1 by A33,A32,SCPISORT:7
      .= s12.a1 by A29,A31,SCMPDS_6:98
      .= s2.a1 by A24,A16,A28,A27,SCMPDS_7:49
      .= s.a1 by A15,A9,A25,A26,SCMPDS_8:23;
    thus s3.a2=IExec(IF3,s12).a2 by A33,A32,SCPISORT:7
      .= s12.a2 by A29,A31,SCMPDS_6:98
      .= s2.a2 by A24,A16,A28,A27,SCMPDS_7:49
      .= md by A5,A19,A9,A25,A26,SCMPDS_8:23;
A34: s3.a3=IExec(IF3,s12).a3 by A33,A32,SCPISORT:7
      .= s12.a3 by A29,A31,SCMPDS_6:98
      .= s2.a3 by A24,A16,A28,A27,SCMPDS_7:49
      .= s.a3 by A20,A9,A25,A26,SCMPDS_8:23;
    hence s3.a3 >= s.a3;
A35: s3.a4=IExec(IF3,s12).a4 by A33,A32,SCPISORT:7
      .= s12.a4 by A29,A31,SCMPDS_6:98
      .= s2.a4 by A24,A16,A28,A27,SCMPDS_7:49
      .= m4 by A9,A10,A25,A26,SCMPDS_8:23;
    hence s3.a4 <= s.a4 by A3,A11,XREAL_1:8;
    thus s3.a4 >= m3 by A35,NAT_1:12;
A36: s3.a5=IExec(IF3,s12).a5 by A33,A32,SCPISORT:7
      .=0 by A29,A31,SCMPDS_6:98;
    hence s3.a5 < s.a5 by A2;
    thus s3.a5 >= -1 by A36;
    thus s3.a4=s3.a3-1+s3.a5 by A4,A25,A34,A35,A36;
    take n1=m4;
    take n2=m4+1;
A37: mE=0 by A25;
    hence n1=s3.a3-1 by A4,A34;
    thus n2=s3.a4+1 by A35;
A38: now
      let x;
      thus s3.x=IExec(IF3,s12).x by A33,A32,SCPISORT:7
        .=s12.x by A29,A31,SCMPDS_6:98
        .=s2.x by A24,A16,A28,A27,SCMPDS_7:49;
    end;
A39: now
      let i be Element of NAT;
      assume
A40:  i >= 8;
      thus s3.intpos i=s2.intpos i by A38
        .=s1.intpos i by A9,A25,A26,SCMPDS_8:23
        .=s.intpos i by A1,A2,A3,A5,A6,A8,A40,Lm9;
    end;

    hence
    for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds s3.intpos i
    =s.intpos i;

A41: m4 < n2 by XREAL_1:31;

    hence s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or n1 >= s.a3 &

n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A18,A39,
XXREAL_0:2;

    thus for i be Element of NAT st s.a3<=i & i <= n1 holds s3.intpos md >= s3
    .intpos i by A4,A37,XREAL_1:148,XXREAL_0:2;

    hereby
A42:  s3.intpos md=s2.intpos md by A38
        .=s1.intpos md by A9,A25,A26,SCMPDS_8:23;
      let i be Element of NAT;
      assume that
A43:  n2<=i and
A44:  i <= s.a4;
A45:  s3.intpos i=s2.intpos i by A38
        .=s1.intpos i by A9,A25,A26,SCMPDS_8:23;
      m4 < i by A41,A43,XXREAL_0:2;
      hence s3.intpos md <= s3.intpos i by A12,A44,A42,A45;
    end;
  end;
  suppose
A46: mE > 0;
    then consider m5,mE3 be Element of NAT such that
A47: m5=s2.a5 and
A48: s2.a3=mE3 and
A49: mE3+m5=sm and
A50: m5 <= s1.a7 and

A51: for i be Element of NAT st s1.a3 <= i & i < mE3 holds s2.intpos
    md > s2.intpos i and

A52: m5 = 0 or s2.intpos md <= s2.intpos mE3 by A4,A5,A6,A14,A19,A20,A9,A21
,Lm15;

A53: mE3+m5 <= mE3+s1.a7 by A50,XREAL_1:8;
    then
A54: s1.a3 <= mE3 by A4,A20,A9,A49,XREAL_1:8;
A55: s1.a3+s1.a7 <= mE3+s1.a7 by A4,A20,A9,A49,A50,XREAL_1:8;
    then
A56: s.a3 <= mE3 by A20,XREAL_1:8;
    then mE3 >= 8 by A20,A21,XXREAL_0:2;
    then
A57: mE3 > 6 by XXREAL_0:2;
A58: WH2 is_halting_on s1 by A5,A6,A14,A19,A21,Lm16;
A59: WH2 is_closed_on s1 by A5,A6,A14,A19,A21,Lm16;
    then
A60: WH1 ';' WH2 is_closed_on s by A24,A16,A58,SCMPDS_7:43;
    s2.a1=s1.a1 by A4,A5,A6,A14,A19,A20,A21,A17,A46,Lm15;
    then
A61: s12.a1=s.a1 by A15,A24,A16,A59,A58,SCMPDS_7:49;
    s2.a4=s1.a4 by A4,A5,A6,A14,A19,A20,A21,A17,A46,Lm15;
    then
A62: s12.a4=m4 by A10,A24,A16,A59,A58,SCMPDS_7:49;
    s2.a2=s1.a2 by A4,A5,A6,A14,A19,A20,A21,A17,A46,Lm15;
    then
A63: s12.a2=md by A5,A19,A24,A16,A59,A58,SCMPDS_7:49;
    s2.a=0 by A4,A5,A6,A14,A19,A20,A21,A17,A46,Lm15;
    then
A64: s12.a=0 by A24,A16,A59,A58,SCMPDS_7:49;
A65: s12.a5=m5 by A24,A16,A47,A59,A58,SCMPDS_7:49;
A66: s12.a3=mE3 by A24,A16,A48,A59,A58,SCMPDS_7:49;
A67: WH1 ';' WH2 is_halting_on s by A24,A16,A59,A58,SCMPDS_7:43;
    hence WB3 is_closed_on s & WB3 is_halting_on s by A60,SCPISORT:9;
A68: m4 > 6 by A18,XXREAL_0:2;
A69: m4 > m3+0 by A46,XREAL_1:8;
    then
A70: m4 >= m3+1 by INT_1:20;
    hereby
      per cases;
      suppose
A71:    s12.a5 > 0;
        then IExec(IF3,s12).a=0 by A64,A66,A57,A62,A68,Lm19;
        hence IExec(WB3,s).a=0 by A60,A67,SCPISORT:7;
        IExec(IF3,s12).a1=s12.a1 by A64,A66,A57,A62,A68,A71,Lm19;
        hence IExec(WB3,s).a1=s.a1 by A60,A67,A61,SCPISORT:7;
        IExec(IF3,s12).a2=s12.a2 by A64,A66,A57,A62,A68,A71,Lm19;
        hence s3.a2=md by A60,A67,A63,SCPISORT:7;
        IExec(IF3,s12).a3=s12.a3+1 by A64,A66,A57,A62,A68,A71,Lm19;
        then
A72:    s3.a3=mE3+1 by A60,A67,A66,SCPISORT:7;
        then mE3 < s3.a3 by XREAL_1:31;
        hence s3.a3 >= s.a3 by A20,A54,XXREAL_0:2;
A73:    IExec(IF3,s12).a4=s12.a4-1 by A64,A66,A57,A62,A68,A71,Lm19;
        then
A74:    s3.a4=m4-1 by A60,A67,A62,SCPISORT:7;
        hence s3.a4 <= s.a4 by A3,A23,XREAL_1:148,XXREAL_0:2;
A75:    IExec(IF3,s12).a5=s12.a5-2 by A64,A66,A57,A62,A68,A71,Lm19;
        then
A76:    s3.a5 =s12.a5-2 by A60,A67,SCPISORT:7;
        s12.a5 >=0+1 by A71,INT_1:20;
        then
A77:    s12.a5-2 >= 1-2 by XREAL_1:11;
        then
A78:    s3.a5+1 >= -1+1 by A76,XREAL_1:8;
        thus s3.a4 >= m3 by A70,A74,XREAL_1:21;
        m5 <= s.a5 by A9,A11,A50,XXREAL_0:2;
        then m5-2 < s.a5-0 by XREAL_1:17;
        hence s3.a5 < s.a5 by A24,A16,A47,A59,A58,A76,SCMPDS_7:49;
        thus s3.a5 >= -1 by A60,A67,A75,A77,SCPISORT:7;

        thus s3.a4=s3.a3-1+s3.a5 by A49,A60,A67,A62,A65,A73,A72,A76,SCPISORT:7;

        take n1=mE3;
        take n2=m4;
        n2=n1+(s3.a5+1) by A49,A65,A76;
        then
A79:    n2 >= n1+0 by A78,XREAL_1:8;
        thus n1=s3.a3-1 by A72;
        thus n2=m4+-1+1
          .=s3.a4+1 by A60,A67,A62,A73,SCPISORT:7;
A80:    now
          let i be Element of NAT;
          assume
A81:      i >= 8;
          thus s12.intpos i=s2.intpos i by A24,A16,A59,A58,SCMPDS_7:49
            .=s1.intpos i by A4,A5,A6,A14,A19,A20,A21,A17,A46,A81,Lm15
            .=s.intpos i by A1,A2,A3,A5,A6,A8,A81,Lm9;
        end;
A82:    now
          let i be Element of NAT;
          assume that
A83:      i >= 8 and
A84:      i <>n1 and
A85:      i<> n2;
          thus s3.intpos i=IExec(IF3,s12).intpos i by A60,A67,SCPISORT:7
            .=s12.intpos i by A64,A66,A57,A62,A68,A71,A83,A84,A85,Lm19
            .=s.intpos i by A80,A83;
        end;

        hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds s3.
        intpos i=s.intpos i;

        IExec(IF3,s12).intpos mE3=s12.intpos m4 by A64,A66,A57,A62,A68,A71,Lm19
;

        then
A86:    s3.intpos n1=s12.intpos n2 by A60,A67,SCPISORT:7
          .=s.intpos n2 by A8,A80,NAT_1:12;
        m3 < m3+1 by XREAL_1:31;
        then m3 < n1 by A4,A20,A54,XXREAL_0:2;
        then
A87:    md < n1 by A7,XXREAL_0:2;
        then md < n2 by A79,XXREAL_0:2;
        then
A88:    n2 >= 8 by A6,XXREAL_0:2;
A89:    s3.intpos md=s.intpos md by A6,A82,A87,A79;
        then
A90:    s1.intpos md=s3.intpos md by A1,A2,A3,A5,A6,A8,Lm9;

        IExec(IF3,s12).intpos m4=s12.intpos mE3 by A64,A66,A57,A62,A68,A71,Lm19
;

        then
A91:    s3.intpos n2=s12.intpos n1 by A60,A67,SCPISORT:7
          .=s.intpos n1 by A20,A21,A56,A80,XXREAL_0:2;

        hence
        s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or s.a3 <= n1

& n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A3,A20
,A11,A55,A86,XREAL_1:8;

A92:    s2.intpos md=s1.intpos md by A4,A5,A6,A14,A19,A20,A21,A17,A46,Lm15

          .=s3.intpos md by A1,A2,A3,A5,A6,A8,A89,Lm9;
        hereby
          let i be Element of NAT;
          assume that
A93:      s.a3<=i and
A94:      i <= n1;
A95:      i >= 8 by A20,A21,A93,XXREAL_0:2;
A96:      s1.a3 <= i by A1,A2,A3,A5,A6,A8,A93,Lm9;
          per cases;
          suppose
A97:        i < n1;

            s2.intpos i=s1.intpos i by A4,A5,A6,A14,A19,A20,A21,A17,A46,A95
,Lm15

              .=s.intpos i by A1,A2,A3,A5,A6,A8,A95,Lm9
              .=s3.intpos i by A20,A21,A82,A79,A93,A97,XXREAL_0:2;
            hence s3.intpos md >= s3.intpos i by A51,A92,A96,A97;
          end;
          suppose
            i >= n1;
            then i=n1 by A94,XXREAL_0:1;

            hence
            s3.intpos md >= s3.intpos i by A1,A2,A3,A5,A6,A8,A13,A46,A86,A88
,A90,Lm9;

          end;
        end;
A98:    n1 >= 8 by A6,A87,XXREAL_0:2;
        hereby
          let i be Element of NAT;
          assume that
A99:      n2<=i and
A100:     i <= s.a4;
A101:     i >= 8 by A88,A99,XXREAL_0:2;
          per cases;
          suppose
A102:       n2 < i;
            s1.intpos i=s.intpos i by A1,A2,A3,A5,A6,A8,A101,Lm9
              .=s3.intpos i by A82,A79,A88,A102,XXREAL_0:2;
            hence s3.intpos md <= s3.intpos i by A12,A90,A100,A102;
          end;
          suppose
            n2 >= i;
            then i=n2 by A99,XXREAL_0:1;

            then s3.intpos i=s1.intpos n1 by A1,A2,A3,A5,A6,A8,A91,A98,Lm9

              .=s2.intpos n1 by A4,A5,A6,A14,A19,A20,A21,A17,A46,A98,Lm15;

            hence s3.intpos md <= s3.intpos i by A24,A16,A47,A52,A59,A58,A71
,A92,SCMPDS_7:49;

          end;
        end;
      end;
      suppose
A103:   s12.a5 <= 0;
A104:   DataLoc(s12.a,5)=intpos(0+5) by A64,SCMP_GCD:5;
        thus IExec(WB3,s).a=IExec(IF3,s12).a by A60,A67,SCPISORT:7
          .=0 by A64,A103,A104,SCMPDS_6:98;
        thus IExec(WB3,s).a1=IExec(IF3,s12).a1 by A60,A67,SCPISORT:7
          .= s.a1 by A61,A103,A104,SCMPDS_6:98;
        thus s3.a2=IExec(IF3,s12).a2 by A60,A67,SCPISORT:7
          .= md by A63,A103,A104,SCMPDS_6:98;
A105:   s3.a3=IExec(IF3,s12).a3 by A60,A67,SCPISORT:7
          .= mE3 by A66,A103,A104,SCMPDS_6:98;
        hence s3.a3 >= s.a3 by A4,A9,A49,A53,XREAL_1:8;
A106:   s3.a4=IExec(IF3,s12).a4 by A60,A67,SCPISORT:7
          .= m4 by A62,A103,A104,SCMPDS_6:98;
        hence s3.a4 <= s.a4 by A3,A11,XREAL_1:8;
A107:   s12.a5=0 by A24,A16,A47,A59,A58,A103,SCMPDS_7:49;
        thus s3.a4 >= m3 by A69,A106;
A108:   s3.a5=IExec(IF3,s12).a5 by A60,A67,SCPISORT:7
          .=0 by A104,A107,SCMPDS_6:98;
        hence s3.a5 < s.a5 by A2;
        thus s3.a5 >= -1 by A108;
A109:   m4=m3+mE+1-1
          .=mE3+0-1 by A24,A16,A47,A49,A59,A58,A107,SCMPDS_7:49;
        hence s3.a4=s3.a3-1+s3.a5 by A105,A106,A108;
        take n1=m4;
        take n2=m4+1;
        thus n1=s3.a3-1 by A105,A109;
        thus n2=s3.a4+1 by A106;
A110:   now
          let x;
          thus s3.x=IExec(IF3,s12).x by A60,A67,SCPISORT:7
            .=s12.x by A103,A104,SCMPDS_6:98
            .=s2.x by A24,A16,A59,A58,SCMPDS_7:49;
        end;
A111:   now
          let i be Element of NAT;
          assume
A112:     i >= 8;
          thus s3.intpos i=s2.intpos i by A110
            .=s1.intpos i by A4,A5,A6,A14,A19,A20,A21,A17,A46,A112,Lm15
            .=s.intpos i by A1,A2,A3,A5,A6,A8,A112,Lm9;
        end;

        hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds s3.
        intpos i=s.intpos i;

A113:   m4 < n2 by XREAL_1:31;

        hence
        s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or s.a3 <= n1

& n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A18,A111,
XXREAL_0:2;

        hereby
          let i be Element of NAT;
          assume that
A114:     s.a3<=i and
A115:     i <= n1;
          i < mE3 by A109,A115,XREAL_1:148,XXREAL_0:2;
          then
A116:     s2.intpos md > s2.intpos i by A20,A51,A114;
          s3.intpos md=s2.intpos md by A110;
          hence s3.intpos md >= s3.intpos i by A110,A116;
        end;
        hereby
          let i be Element of NAT;
          assume that
A117:     n2<=i and
A118:     i <= s.a4;
A119:     m4 < i by A113,A117,XXREAL_0:2;
          then
A120:     i >= 8 by A18,XXREAL_0:2;
A121:     s3.intpos md=s2.intpos md by A110
            .=s1.intpos md by A4,A5,A6,A14,A19,A20,A21,A17,A46,Lm15;
          s3.intpos i=s2.intpos i by A110
            .=s1.intpos i by A4,A5,A6,A14,A19,A20,A21,A17,A46,A120,Lm15;
          hence s3.intpos md <= s3.intpos i by A12,A118,A119,A121;
        end;
      end;
    end;
  end;
end;

Lm21: for i be Integer st i >= -1 & i <= 0 holds i=-1 or i=0
proof
  let i be Integer;
  assume that
A1: i >= -1 and
A2: i <= 0;
  per cases;
  suppose
    i <= -1;
    hence thesis by A1,XXREAL_0:1;
  end;
  suppose
    i > -1;
    then i >= -1+1 by INT_1:20;
    hence thesis by A2;
  end;
end;

Lm22: for i1,i2 be Integer,n1,n2,i be Element of NAT st i1 >= -1 & i1 <= 0 &
n2=i2+1 & i2=n1+i1 & i < n2 holds i <= n1

proof
  let i1,i2 be Integer,n1,n2,i be Element of NAT;
  assume that
A1: i1 >= -1 and
A2: i1 <= 0 and
A3: n2=i2+1 and
A4: i2=n1+i1 and
A5: i < n2;
  per cases by A1,A2,Lm21;
  suppose
    i1=0;
    hence thesis by A3,A4,A5,NAT_1:13;
  end;
  suppose
    i1=-1;
    hence thesis by A3,A4,A5;
  end;
end;

Lm23: for i1,i2 be Integer,n1,n2 be Element of NAT st i1 >= -1 & n2=i2+1 & i2=
n1+i1 holds n1 <= n2

proof
  let i1,i2 be Integer,n1,n2 be Element of NAT;
  assume that
A1: i1 >= -1 and
A2: n2=i2+1 and
A3: i2=n1+i1;
  n1+i1 >= n1+ -1 by A1,XREAL_1:8;
  then i2+1 >= n1+ -1+1 by A3,XREAL_1:8;
  hence thesis by A2;
end;

Lm24: for s,s1 be State of SCMPDS,n0,n1,n2,n be Element of NAT,f, f1 be
FinSequence of INT st f is_FinSequence_on s,n0 & f1 is_FinSequence_on s1,n0 &
len f=n & len f1 = n & (for i be Element of NAT st i >= n0+1 & i<>n1 & i<>n2
holds s1.intpos i=s.intpos i) & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.
intpos n2 or n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=s
.intpos n2 & s1.intpos n2=s.intpos n1) holds f,f1 are_fiberwise_equipotent

proof

  let s,s1 be State of SCMPDS,n0,n1,n2,n be Element of NAT, f,f1 be
  FinSequence of INT;

  assume that
A1: f is_FinSequence_on s,n0 and
A2: f1 is_FinSequence_on s1,n0;
  assume that
A3: len f=n and
A4: len f1 = n;
  assume

A5: for i be Element of NAT st i >= n0+1 & i<>n1 & i<>n2 holds s1.intpos
  i=s.intpos i;

  assume that

A6: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or n1 >= n0+1 &

n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=s.intpos n2 & s1.intpos n2=
  s.intpos n1;

  per cases by A6;
  suppose
A7: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
A8: dom f1 = Seg n by A4,FINSEQ_1:def 3;
    now
      let i be Nat;
      reconsider a = i as Element of NAT by ORDINAL1:def 13;
      assume
A9:   i in dom f1;
      then
A10:  1 <= i by A8,FINSEQ_1:3;
      then
A11:  n0+1 <= n0+i by XREAL_1:8;
A12:  i <= n by A8,A9,FINSEQ_1:3;
      per cases;
      suppose
A13:    n0+i<>n1 & n0+i<>n2;
        thus f1.i=s1.intpos (n0+a) by A2,A4,A10,A12,SCPISORT:def 1
          .=s.intpos (n0+a) by A5,A11,A13
          .=f.i by A1,A3,A10,A12,SCPISORT:def 1;
      end;
      suppose
A14:    not (n0+i<>n1 & n0+i<>n2);
        hereby
          per cases by A14;
          suppose
            n0+i=n1;
            hence f1.i=s.intpos (n0+a) by A2,A4,A7,A10,A12,SCPISORT:def 1
              .=f.i by A1,A3,A10,A12,SCPISORT:def 1;
          end;
          suppose
            n0+i=n2;
            hence f1.i=s.intpos (n0+a) by A2,A4,A7,A10,A12,SCPISORT:def 1
              .=f.i by A1,A3,A10,A12,SCPISORT:def 1;
          end;
        end;
      end;
    end;
    hence thesis by A3,A4,FINSEQ_2:10;
  end;
  suppose

A15: n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=
    s.intpos n2 & s1.intpos n2=s.intpos n1;

    then
A16: n1-n0 >= 1 by XREAL_1:21;
    then reconsider m1=n1-n0 as Element of NAT by INT_1:16;
A17: m1 <= len f by A3,A15,XREAL_1:22;
A18: n2-n0 >= 1 by A15,XREAL_1:21;
    then reconsider m2=n2-n0 as Element of NAT by INT_1:16;
A19: m2 <= len f1 by A4,A15,XREAL_1:22;
A20: n2=m2+n0;
A21: n1=m1+n0;
    then
A22: f.m1=s1.intpos n2 by A1,A15,A16,A17,SCPISORT:def 1
      .=f1.m2 by A2,A18,A19,A20,SCPISORT:def 1;
A23: now
      let k be Element of NAT;
      assume that
A24:  k <> m1 and
A25:  k <> m2 and
A26:  1 <= k and
A27:  k <= len f;
A28:  k+n0 <> m1+n0 by A24;
A29:  n0+1 <= n0+k by A26,XREAL_1:8;
A30:  k+n0 <> m2+n0 by A25;
      thus f.k=s.intpos(k+n0) by A1,A26,A27,SCPISORT:def 1
        .=s1.intpos (k+n0) by A5,A28,A30,A29
        .=f1.k by A2,A3,A4,A26,A27,SCPISORT:def 1;
    end;
A31: m2 <= len f by A3,A15,XREAL_1:22;
    then f.m2=s1.intpos n1 by A1,A15,A18,A20,SCPISORT:def 1
      .=f1.m1 by A2,A3,A4,A16,A17,A21,SCPISORT:def 1;
    hence thesis by A3,A4,A16,A18,A17,A31,A22,A23,SCPISORT:4;
  end;
end;

Lm25: for s,s1 be State of SCMPDS,n0,n1,n2 be Element of NAT,c1,c2 be Integer
st (for i be Element of NAT st i >= n0 & i <>n1 & i<> n2 holds s1.intpos i=s.
intpos i) & n1 <= n2 & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1)
holds for i be Element of NAT st i >= n0 & (i < c1 or i > c2) holds s1.intpos i
=s.intpos i

proof
  let s,s1 be State of SCMPDS,n0,n1,n2 be Element of NAT,c1,c2 be Integer;
  assume

A1: for i be Element of NAT st i >= n0 & i<>n1 & i<>n2 holds s1.intpos i
  =s.intpos i;

  assume
A2: n1 <= n2;
  assume that

A3: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or c1 <= n1 & n2
  <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;

  per cases by A3;
  suppose
A4: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
    hereby
      let i be Element of NAT;
      assume that
A5:   i >= n0 and
      i < c1 or i > c2;
      per cases;
      suppose
        i<>n1 & i<>n2;
        hence s1.intpos i=s.intpos i by A1,A5;
      end;
      suppose
A6:     not (i<>n1 & i<>n2);
        hereby
          per cases by A6;
          suppose
            i=n1;
            hence s1.intpos i=s.intpos i by A4;
          end;
          suppose
            i=n2;
            hence s1.intpos i=s.intpos i by A4;
          end;
        end;
      end;
    end;
  end;
  suppose

A7: c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.
    intpos n1;

    hereby
      let i be Element of NAT;
      assume that
A8:   i >= n0 and
A9:   i < c1 or i > c2;
      per cases by A9;
      suppose
        i < c1;
        then i < n1 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
      end;
      suppose
        i > c2;
        then i > n2 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
      end;
    end;
  end;
end;

Lm26: for s be State of SCMPDS,md,m3,n0 be Element of NAT,f,f1 be FinSequence
of INT st s.GBP=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1
& md <= m3 & n0+1 <= s.a3 & s.a4 <= n0+n & f is_FinSequence_on s,n0 & f1
is_FinSequence_on IExec(WH3,s),n0 & n0 >= 7 & len f=n & len f1=n holds IExec(
WH3,s).GBP=0 & IExec(WH3,s).a1=s.a1 & IExec(WH3,s).a2=md & IExec(WH3,s).a4 >=
md & IExec(WH3,s).a4 <= s.a4 & f,f1 are_fiberwise_equipotent & (for i be
Element of NAT st s.a3<=i & i <= IExec(WH3,s).a4 holds IExec(WH3,s).intpos md
>= IExec(WH3,s).intpos i) & (for i be Element of NAT st IExec(WH3,s).a4 < i & i
<= s.a4 holds IExec(WH3,s).intpos md <= IExec(WH3,s).intpos i) & for i be
Element of NAT st i >= n0+1 & (i < s.a3 or i > s.a4) holds IExec(WH3,s).intpos
i = s.intpos i

proof
  set a=GBP;

  let s be State of SCMPDS,md,m3,n0 be Element of NAT, f,f1 be FinSequence of
  INT;

  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a4=m3+s.a5 and
A4: m3=s.a3-1 and
A5: s.a2=md and
A6: md >= n0+1 and
A7: md <= m3 and
A8: n0+1 <= s.a3 and
A9: s.a4 <= n0+n;

  defpred P[Element of NAT] means for t be State of SCMPDS,n3 be Element of

NAT, g,g1 be FinSequence of INT st t.a=0 & t.a5 > 0 & t.a5<= $1+1 & t.a4=n3+t.
  a5 & n3=t.a3-1 & t.a2=md & md <= n3 & n0+1 <= t.a3 & t.a4 <= n0+n & g
  is_FinSequence_on t,n0 & g1 is_FinSequence_on IExec(WH3,t),n0 & len g=n & len

g1=n holds IExec(WH3,t).a=0 & IExec(WH3,t).a1=t.a1 & IExec(WH3,t).a2=md & IExec

(WH3,t).a4 >= md & IExec(WH3,t).a4 <= t.a4 & g,g1 are_fiberwise_equipotent & (
  for i be Element of NAT st t.a3<=i & i <= IExec(WH3,t).a4 holds IExec(WH3,t).

intpos md >= IExec(WH3,t).intpos i) & (for i be Element of NAT st IExec(WH3,t).
  a4 < i & i <= t.a4 holds IExec(WH3,t).intpos md <= IExec(WH3,t).intpos i) & (

for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4) holds IExec(WH3,t
  ).intpos i = t.intpos i);

  assume
A10: f is_FinSequence_on s,n0;
  assume
A11: f1 is_FinSequence_on IExec(WH3,s),n0;
  assume that
A12: n0 >= 7 and
A13: len f=n and
A14: len f1=n;
  n0+1 >= 7+1 by A12,XREAL_1:8;
  then
A15: md >= 8 by A6,XXREAL_0:2;
A16: now
    let k be Element of NAT;
    assume
A17: P[k];
    now

      let t be State of SCMPDS,n3 be Element of NAT, g,g1 be FinSequence of
      INT;

      assume that
A18:  t.a=0 and
A19:  t.a5 > 0 and
A20:  t.a5<= (k+1)+1 and
A21:  t.a4=n3+t.a5 and
A22:  n3=t.a3-1 and
A23:  t.a2=md and
A24:  md <= n3 and
A25:  n0+1 <= t.a3 and
A26:  t.a4 <= n0+n;
      set t1=IExec(WB3,t);
A27:  t1.a4=t1.a3-1+t1.a5 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A28:  now
A29:    DataLoc(t.a,5)=intpos(0+5) by A18,SCMP_GCD:5;
        let v be State of SCMPDS;
        assume that
A30:    v.a4=v.a3-1+v.a5 and
A31:    md <= v.a3-1 and
A32:    v.a2=t.a2 and
A33:    v.a=t.a and
A34:    v.DataLoc(t.a,5) > 0;
        reconsider mm=v.a3-1 as Element of NAT by A31,INT_1:16;
        set Iv=IExec(WB3,v);
A35:    v.a4=mm+v.a5 by A30;
        hence Iv.a=v.a by A15,A18,A23,A31,A32,A33,A34,A29,Lm20;

        thus WB3 is_closed_on v & WB3 is_halting_on v by A15,A18,A23,A31,A32
,A33,A34,A29,A35,Lm20;

        thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A15,A18,A23,A31,A32,A33
,A34,A29,A35,Lm20;

        thus Iv.a4=Iv.a3-1+Iv.a5 by A15,A18,A23,A31,A32,A33,A34,A29,A35,Lm20;

        Iv.a3 >= v.a3 by A15,A18,A23,A31,A32,A33,A34,A29,A35,Lm20;

        then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
        hence md <= Iv.a3-1 by A31,XXREAL_0:2;
        thus Iv.a2=v.a2 by A15,A18,A23,A31,A32,A33,A34,A29,A35,Lm20;
      end;
      t1.a5 < t.a5 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      then t1.a5+1 <= t.a5 by INT_1:20;
      then t1.a5+1 <= (k+1)+1 by A20,XXREAL_0:2;
      then
A36:  t1.a5 <= k+1 by XREAL_1:8;
      set t2=IExec(WH3,t);
      assume
A37:  g is_FinSequence_on t,n0;
      assume
A38:  g1 is_FinSequence_on IExec(WH3,t),n0;
A39:  t1.a=0 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      then
A40:  DataLoc(t1.a,5)=intpos(0+5) by SCMP_GCD:5;
      assume that
A41:  len g=n and
A42:  len g1=n;
A43:  t1.a2=md by A15,A18,A19,A21,A22,A23,A24,Lm20;
A44:  t1.a1=t.a1 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A45:  t1.a3 >= t.a3 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A46:  t1.a4 >= n3 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A47:  DataLoc(t.a,5)=intpos(0+5) by A18,SCMP_GCD:5;
A48:  t1.a4 <= t.a4 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      consider n1,n2 be Element of NAT such that
A49:  n1=t1.a3-1 and
A50:  n2=t1.a4+1 and

A51:  for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds t1.
      intpos i=t.intpos i and

A52:  t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or t.a3 <=
      n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1 and

A53:  for i be Element of NAT st t.a3<=i & i <= n1 holds t1.intpos
      md >= t1.intpos i and

A54:  for i be Element of NAT st n2<=i & i <= t.a4 holds t1.intpos
      md <= t1.intpos i by A15,A18,A19,A21,A22,A23,A24,Lm20;

A55:  t1.a5 >= -1 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      then
A56:  n1 <= n2 by A27,A49,A50,Lm23;
      per cases;
      suppose
A57:    t1.a5 > 0;
        set t3=IExec(WH3,t1);
        consider f3 be FinSequence of INT such that
A58:    len f3=n and

A59:    for i be Element of NAT st 1<=i & i <= len f3 holds f3.i=t1.
        intpos (n0+i) by SCPISORT:2;

A60:    f3 is_FinSequence_on t1,n0 by A59,SCPISORT:def 1;

A61:    t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or n1 >= n0+

1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t1.intpos n1=t.intpos n2 & t1.intpos
        n2=t.intpos n1

        proof
          per cases by A52;
          suppose
            t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose

A62:        t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
            intpos n2=t.intpos n1;

            then
A63:        n2 <= n0+n by A26,XXREAL_0:2;
            n1 >= n0+1 by A25,A62,XXREAL_0:2;
            hence thesis by A56,A62,A63,XXREAL_0:2;
          end;
        end;
A64:    n0+1 <= t1.a3 by A25,A45,XXREAL_0:2;
        t1.a3-1 >= t.a3-1 by A45,XREAL_1:11;
        then
A65:    md <= n1 by A22,A24,A49,XXREAL_0:2;
        now
          let i be Element of NAT;
          assume that
A66:      i >= n0+1 and
A67:      i<>n1 and
A68:      i<>n2;
          n0+1 >= 7+1 by A12,XREAL_1:8;
          hence t1.intpos i=t.intpos i by A51,A66,A67,A68,XXREAL_0:2;
        end;

        then
A69:    g,f3 are_fiberwise_equipotent by A37,A41,A58,A60,A61,Lm24;

A70:    t1.a4 <= n0+n by A26,A48,XXREAL_0:2;
A71:    t2 =t3 by A19,A21,A22,A24,A47,A28,Lm17,Th7;
        consider f4 be FinSequence of INT such that
A72:    len f4=n and

A73:    for i be Element of NAT st 1<=i & i <= len f4 holds f4.i=t3.
        intpos (n0+i) by SCPISORT:2;

A74:    f4 is_FinSequence_on t3,n0 by A73,SCPISORT:def 1;

        hence t2.a=0 by A17,A39,A43,A27,A49,A36,A57,A58,A60,A72,A65,A64,A70,A71
;

        md < t1.a3 by A49,A65,XREAL_1:148,XXREAL_0:2;

        then
A75:    t2.intpos md = t1.intpos md by A6,A17,A39,A43,A27,A49,A36,A57,A58,A60
,A72,A74,A65,A64,A70,A71;

A76:    dom f4 = Seg n by A72,FINSEQ_1:def 3;
        now
          let i be Nat;
          reconsider a = i as Element of NAT by ORDINAL1:def 13;
          assume
A77:      i in dom f4;
          then
A78:      i <= n by A76,FINSEQ_1:3;
A79:      1 <= i by A76,A77,FINSEQ_1:3;
          hence f4.i=t2.intpos (n0+a) by A72,A73,A71,A78
            .=g1.i by A38,A42,A79,A78,SCPISORT:def 1;
        end;
        then
A80:    f4=g1 by A42,A72,FINSEQ_2:10;

        thus t2.a1=t.a1 by A17,A39,A44,A43,A27,A49,A36,A57,A58,A60,A72,A74,A65
,A64,A70,A71;

        thus t2.a2=md by A17,A39,A43,A27,A49,A36,A57,A58,A60,A72,A74,A65,A64
,A70,A71;

        thus t2.a4 >= md by A17,A39,A43,A27,A49,A36,A57,A58,A60,A72,A74,A65,A64
,A70,A71;

        t3.a4 <= t1.a4 by A17,A39,A43,A27,A49,A36,A57,A58,A60,A72,A74,A65,A64
,A70;

        hence t2.a4 <= t.a4 by A48,A71,XXREAL_0:2;

        f3,f4 are_fiberwise_equipotent by A17,A39,A43,A27,A49,A36,A57,A58,A60
,A72,A74,A65,A64,A70;

        hence g,g1 are_fiberwise_equipotent by A69,A80,CLASSES1:84;
A81:    t1.a3=n1+1 by A49;
        hereby
          let i be Element of NAT;
          assume that
A82:      t.a3<=i and
A83:      i <= t2.a4;
A84:      n0+1 <= i by A25,A82,XXREAL_0:2;
          hereby
            per cases;
            suppose
A85:          i < t1.a3;
              then
A86:          i <= n1 by A81,INT_1:20;

              t2.intpos i = t1.intpos i by A17,A39,A43,A27,A49,A36,A57,A58,A60
,A72,A74,A65,A64,A70,A71,A84,A85;

              hence t2.intpos md >= t2.intpos i by A53,A75,A82,A86;
            end;
            suppose
              i >= t1.a3;

              hence
              t2.intpos md >= t2.intpos i by A17,A39,A43,A27,A49,A36,A57,A58
,A60,A72,A74,A65,A64,A70,A71,A83;

            end;
          end;
        end;
        hereby
          let i be Element of NAT;
          assume that
A87:      t2.a4 < i and
A88:      i <= t.a4;
          hereby
            per cases;
            suppose
A89:          i > t1.a4;
              then
A90:          i >= n2 by A50,INT_1:20;
              t1.a4 > n1+0 by A27,A49,A57,XREAL_1:8;
              then n2 > n1+1 by A50,XREAL_1:8;
              then n2 >= n0+1 by A49,A64,XXREAL_0:2;
              then i >= n0+1 by A90,XXREAL_0:2;

              then t2.intpos i = t1.intpos i by A17,A39,A43,A27,A49,A36,A57,A58
,A60,A72,A74,A65,A64,A70,A71,A89;

              hence t2.intpos md <= t2.intpos i by A54,A75,A88,A90;
            end;
            suppose
              i <= t1.a4;

              hence
              t2.intpos md <= t2.intpos i by A17,A39,A43,A27,A49,A36,A57,A58
,A60,A72,A74,A65,A64,A70,A71,A87;

            end;
          end;
        end;
        hereby
          let i be Element of NAT;
          assume that
A91:      i >= n0+1 and
A92:      i < t.a3 or i > t.a4;
          n0+1 >= 7+1 by A12,XREAL_1:8;
          then i >= 8 by A91,XXREAL_0:2;
          then
A93:      t1.intpos i = t.intpos i by A51,A52,A56,A92,Lm25;
          per cases by A92;
          suppose
            i < t.a3;
            then i < t1.a3 by A45,XXREAL_0:2;

            hence
            t2.intpos i =t.intpos i by A17,A39,A43,A27,A49,A36,A57,A58,A60,A72
,A74,A65,A64,A70,A71,A91,A93;

          end;
          suppose
            i > t.a4;
            then i > t1.a4 by A48,XXREAL_0:2;

            hence
            t2.intpos i =t.intpos i by A17,A39,A43,A27,A49,A36,A57,A58,A60,A72
,A74,A65,A64,A70,A71,A91,A93;

          end;
        end;
      end;
      suppose
A94:    t1.a5 <= 0;
A95:    now
          let x;
          thus t2.x =IExec(WH3,t1).x by A19,A21,A22,A24,A47,A28,Lm17,Th7
            .=t1.x by A40,A94,SCMPDS_8:23;
        end;
        hence t2.a=0 by A39;
        thus t2.a1=t.a1 by A44,A95;
        thus t2.a2=md by A43,A95;
        t2.a4 >= n3 by A46,A95;
        hence t2.a4 >= md by A24,XXREAL_0:2;
        thus t2.a4 <= t.a4 by A48,A95;
A96:    now
A97:      n0+1 >= 7+1 by A12,XREAL_1:8;
          let i be Element of NAT;
          assume that
A98:      i >= n0+1 and
A99:      i<>n1 and
A100:     i<>n2;
          thus t2.intpos i=t1.intpos i by A95
            .=t.intpos i by A51,A98,A99,A100,A97,XXREAL_0:2;
        end;

A101:   t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or t.a3 <=
        n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1

        proof
          per cases by A52;
          suppose
            t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis by A95;
          end;
          suppose

            t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
            intpos n2=t.intpos n1;

            hence thesis by A95;
          end;
        end;

        t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or n1 >= n0+

1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t2.intpos n1=t.intpos n2 & t2.intpos
        n2=t.intpos n1

        proof
          per cases by A101;
          suppose
            t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose

A102:       t.a3 <= n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.
            intpos n2=t.intpos n1;

            then
A103:       n2 <= n0+n by A26,XXREAL_0:2;
            n1 >= n0+1 by A25,A102,XXREAL_0:2;
            hence thesis by A56,A102,A103,XXREAL_0:2;
          end;
        end;

        hence g,g1 are_fiberwise_equipotent by A37,A38,A41,A42,A96,Lm24;

A104:   t2.a4=n2-1 by A50,A95;
        hereby
          let i be Element of NAT;
          assume that
A105:     t.a3 <= i and
A106:     i <= t2.a4;
          i < n2 by A104,A106,XREAL_1:148,XXREAL_0:2;
          then i <= n1 by A55,A27,A49,A50,A94,Lm22;
          then t1.intpos md >= t1.intpos i by A53,A105;
          then t2.intpos md >= t1.intpos i by A95;
          hence t2.intpos md >= t2.intpos i by A95;
        end;
        hereby
          let i be Element of NAT;
          assume that
A107:     t2.a4 < i and
A108:     i <= t.a4;
          t2.a4+1=n2 by A50,A95;
          then n2 <= i by A107,INT_1:20;
          then t1.intpos md <= t1.intpos i by A54,A108;
          then t2.intpos md <= t1.intpos i by A95;
          hence t2.intpos md <= t2.intpos i by A95;
        end;

        thus for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4)
        holds t2.intpos i = t.intpos i by A56,A96,A101,Lm25;

      end;
    end;
    hence P[k+1];
  end;
  s.a5 >=1+0 by A2,INT_1:20;
  then reconsider m5=s.a5-1 as Element of NAT by INT_1:16,XREAL_1:50;
A109: s.a5=m5+1;
A110: P[0]
  proof
    let t be State of SCMPDS,n3 be Element of NAT,g,g1 be FinSequence of INT;
    assume that
A111: t.a=0 and
A112: t.a5 > 0 and
A113: t.a5<= 0+1 and
A114: t.a4=n3+t.a5 and
A115: n3=t.a3-1 and
A116: t.a2=md and
A117: md <= n3 and
A118: n0+1 <= t.a3 and
A119: t.a4 <= n0+n;
    set t2=IExec(WH3,t);
    assume
A120: g is_FinSequence_on t,n0;
    set t1=IExec(WB3,t);
    assume
A121: g1 is_FinSequence_on IExec(WH3,t),n0;
A122: t1.a4=t1.a3-1+t1.a5 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    consider n1,n2 be Element of NAT such that
A123: n1=t1.a3-1 and
A124: n2=t1.a4+1 and

A125: for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds t1.
    intpos i=t.intpos i and

A126: t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or t.a3 <= n1
    & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1 and

A127: for i be Element of NAT st t.a3<=i & i <= n1 holds t1.intpos md
    >= t1.intpos i and

A128: for i be Element of NAT st n2<=i & i <= t.a4 holds t1.intpos md
    <= t1.intpos i by A15,A111,A112,A114,A115,A116,A117,Lm20;

A129: t1.a5 >= -1 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    then
A130: n1 <= n2 by A122,A123,A124,Lm23;
    t1.a5 < t.a5 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    then t1.a5+1 <= t.a5 by INT_1:20;
    then t1.a5+1 <= 0+1 by A113,XXREAL_0:2;
    then
A131: t1.a5 <= 0 by XREAL_1:8;
A132: now
A133: DataLoc(t.a,5)=intpos(0+5) by A111,SCMP_GCD:5;
      let v be State of SCMPDS;
      assume that
A134: v.a4=v.a3-1+v.a5 and
A135: md <= v.a3-1 and
A136: v.a2=t.a2 and
A137: v.a=t.a and
A138: v.DataLoc(t.a,5) > 0;
      reconsider mm=v.a3-1 as Element of NAT by A135,INT_1:16;
      set Iv=IExec(WB3,v);
A139: v.a4=mm+v.a5 by A134;
      hence Iv.a=v.a by A15,A111,A116,A135,A136,A137,A138,A133,Lm20;

      thus WB3 is_closed_on v & WB3 is_halting_on v by A15,A111,A116,A135,A136
,A137,A138,A133,A139,Lm20;

      thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A15,A111,A116,A135,A136,A137
,A138,A133,A139,Lm20;

      thus Iv.a4=Iv.a3-1+Iv.a5 by A15,A111,A116,A135,A136,A137,A138,A133,A139
,Lm20;
      Iv.a3 >= v.a3 by A15,A111,A116,A135,A136,A137,A138,A133,A139,Lm20;
      then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
      hence md <= Iv.a3-1 by A135,XXREAL_0:2;
      thus Iv.a2=v.a2 by A15,A111,A116,A135,A136,A137,A138,A133,A139,Lm20;
    end;
A140: DataLoc(t.a,5)=intpos(0+5) by A111,SCMP_GCD:5;
    assume that
A141: len g=n and
A142: len g1=n;
A143: t1.a=0 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    then
A144: DataLoc(t1.a,5)=intpos(0+5) by SCMP_GCD:5;
A145: now
      let x;
      thus t2.x =IExec(WH3,t1).x by A112,A114,A115,A117,A140,A132,Lm17,Th7
        .=t1.x by A144,A131,SCMPDS_8:23;
    end;
    hence t2.a=0 by A143;
    t1.a1=t.a1 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    hence t2.a1=t.a1 by A145;
    t1.a2=md by A15,A111,A112,A114,A115,A116,A117,Lm20;
    hence t2.a2=md by A145;
    t1.a4 >= n3 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    then t2.a4 >= n3 by A145;
    hence t2.a4 >= md by A117,XXREAL_0:2;
    t1.a4 <= t.a4 by A15,A111,A112,A114,A115,A116,A117,Lm20;
    hence t2.a4 <= t.a4 by A145;
A146: now
A147: n0+1 >= 7+1 by A12,XREAL_1:8;
      let i be Element of NAT;
      assume that
A148: i >= n0+1 and
A149: i<>n1 and
A150: i<>n2;
      thus t2.intpos i=t1.intpos i by A145
        .=t.intpos i by A125,A148,A149,A150,A147,XXREAL_0:2;
    end;

A151: t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or t.a3 <= n1 &
    n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1

    proof
      per cases by A126;
      suppose
        t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
        hence thesis by A145;
      end;
      suppose

        t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
        intpos n2=t.intpos n1;

        hence thesis by A145;
      end;
    end;

    t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or n1 >= n0+1 &

n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t2.intpos n1=t.intpos n2 & t2.intpos n2=
    t.intpos n1

    proof
      per cases by A151;
      suppose
        t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
        hence thesis;
      end;
      suppose

A152:   t.a3 <= n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.
        intpos n2=t.intpos n1;

        then
A153:   n2 <= n0+n by A119,XXREAL_0:2;
        n1 >= n0+1 by A118,A152,XXREAL_0:2;
        hence thesis by A130,A152,A153,XXREAL_0:2;
      end;
    end;
    hence g,g1 are_fiberwise_equipotent by A120,A121,A141,A142,A146,Lm24;
A154: t2.a4=n2-1 by A124,A145;
    hereby
      let i be Element of NAT;
      assume that
A155: t.a3 <= i and
A156: i <= t2.a4;
      i < n2 by A154,A156,XREAL_1:148,XXREAL_0:2;
      then i <= n1 by A129,A122,A123,A124,A131,Lm22;
      then t1.intpos md >= t1.intpos i by A127,A155;
      then t2.intpos md >= t1.intpos i by A145;
      hence t2.intpos md >= t2.intpos i by A145;
    end;
    hereby
      let i be Element of NAT;
      assume that
A157: t2.a4 < i and
A158: i <= t.a4;
      t2.a4+1=n2 by A124,A145;
      then n2 <= i by A157,INT_1:20;
      then t1.intpos md <= t1.intpos i by A128,A158;
      then t2.intpos md <= t1.intpos i by A145;
      hence t2.intpos md <= t2.intpos i by A145;
    end;
    thus thesis by A146,A130,A151,Lm25;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A110,A16);
  hence thesis by A1,A3,A4,A5,A7,A8,A9,A10,A11,A13,A14,A109;
end;

Lm27: for s be State of SCMPDS,md,m3,n0 be Element of NAT st s.GBP=0 & s.a4=m3
+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1 & md <= m3 & n0 >= 7 holds WH3
is_closed_on s & WH3 is_halting_on s

proof
  set a=GBP;
  let s be State of SCMPDS,md,m3,n0 be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a4=m3+s.a5 and
A3: m3=s.a3-1 and
A4: s.a2=md and
A5: md >= n0+1 and
A6: md <= m3 and
A7: n0 >= 7;
  n0+1 >= 7+1 by A7,XREAL_1:8;
  then
A8: md >= 8 by A5,XXREAL_0:2;
A9: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:5;
  now
    let v be State of SCMPDS;
    assume that
A10: v.a4=v.a3-1+v.a5 and
A11: md <= v.a3-1 and
A12: v.a2=s.a2 and
A13: v.a=s.a and
A14: v.DataLoc(s.a,5) > 0;
    set Iv=IExec(WB3,v);
    reconsider mm=v.a3-1 as Element of NAT by A11,INT_1:16;
A15: v.a4=mm+v.a5 by A10;
    hence Iv.a=v.a by A1,A4,A8,A9,A11,A12,A13,A14,Lm20;

    thus WB3 is_closed_on v & WB3 is_halting_on v by A1,A4,A8,A9,A11,A12,A13
,A14,A15,Lm20;

    thus Iv.DataLoc(s.a,5) < v.DataLoc(s.a,5) by A1,A4,A8,A9,A11,A12,A13,A14
,A15,Lm20;

    thus Iv.a4=Iv.a3-1+Iv.a5 by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm20;
    Iv.a3 >= v.a3 by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm20;
    then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
    hence md <= Iv.a3-1 by A11,XXREAL_0:2;
    thus Iv.a2=v.a2 by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm20;
  end;
  hence thesis by A2,A3,A6,Lm17,Th7;
end;

Lm28: for s being State of SCMPDS st s.GBP=0 holds IExec(K4,s).GBP=0 & IExec(
K4,s).a1=s.a1 & IExec(K4,s).a2=s.a2 & IExec(K4,s).a3=s.a2+1 & IExec(K4,s).a4=s.
a4 & IExec(K4,s).a5=s.a4-s.a2 & for i be Element of NAT st i >= 8 holds IExec(
K4,s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be State of SCMPDS;

  set t0=Initialized s, t1=IExec(k1 ';' k2 ';' k3 ';' k4,s), t2=IExec(k1 ';'
  k2 ';' k3,s), t3=IExec(k1 ';' k2,s), t4=Exec(k1, t0);

  assume
  s.a=0;
  then
A1: t0.a=0 by SCMPDS_5:40;
  then
A2: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A3: t4.a5=t0.DataLoc(t0.a,4) by SCMPDS_2:59
    .=t0.intpos (0+4) by A1,SCMP_GCD:5
    .=s.a4 by SCMPDS_5:40;
  t0.a4=s.a4 by SCMPDS_5:40;
  then
A4: t4.a4 =s.a4 by A2,AMI_3:52,SCMPDS_2:59;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A5: t4.a1 =s.a1 by A2,AMI_3:52,SCMPDS_2:59;
A6: t4.a =0 by A1,A2,AMI_3:52,SCMPDS_2:59;
  then
A7: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:5;
A8: t3.a=Exec(k2, t4).a by SCMPDS_5:47
    .=0 by A6,A7,AMI_3:52,SCMPDS_2:62;
  then
A9: DataLoc(t3.a,3)=intpos (0+3) by SCMP_GCD:5;
A10: t3.a4=Exec(k2, t4).a4 by SCMPDS_5:47
    .=s.a4 by A4,A7,AMI_3:52,SCMPDS_2:62;
A11: t2.a4 =Exec(k3, t3).a4 by SCMPDS_5:46
    .=s.a4 by A10,A9,AMI_3:52,SCMPDS_2:59;
A12: t0.a2=s.a2 by SCMPDS_5:40;
  then
A13: t4.a2 =s.a2 by A2,AMI_3:52,SCMPDS_2:59;
A14: t3.a5=Exec(k2, t4).a5 by SCMPDS_5:47
    .=t4.a5-t4.DataLoc(t4.a,2) by A7,SCMPDS_2:62
    .=t4.a5-t4.intpos(0+2) by A6,SCMP_GCD:5
    .=s.a4-s.a2 by A12,A2,A3,AMI_3:52,SCMPDS_2:59;
A15: t2.a5 =Exec(k3, t3).a5 by SCMPDS_5:46
    .=s.a4-s.a2 by A14,A9,AMI_3:52,SCMPDS_2:59;
A16: t3.a2=Exec(k2, t4).a2 by SCMPDS_5:47
    .=s.a2 by A13,A7,AMI_3:52,SCMPDS_2:62;
A17: t3.a1=Exec(k2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A5,A7,AMI_3:52,SCMPDS_2:62;
A18: t2.a1 =Exec(k3, t3).a1 by SCMPDS_5:46
    .=s.a1 by A17,A9,AMI_3:52,SCMPDS_2:59;
A19: t2.a =Exec(k3, t3).a by SCMPDS_5:46
    .=0 by A8,A9,AMI_3:52,SCMPDS_2:59;
  then
A20: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
A21: t2.a3 =Exec(k3, t3).a3 by SCMPDS_5:46
    .=t3.DataLoc(t3.a,2) by A9,SCMPDS_2:59
    .=s.a2 by A8,A16,SCMP_GCD:5;
A22: t2.a2 =Exec(k3, t3).a2 by SCMPDS_5:46
    .=s.a2 by A16,A9,AMI_3:52,SCMPDS_2:59;
  thus t1.a =Exec(k4, t2).a by SCMPDS_5:46
    .=0 by A19,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a1 =Exec(k4, t2).a1 by SCMPDS_5:46
    .=s.a1 by A18,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a2 =Exec(k4, t2).a2 by SCMPDS_5:46
    .=s.a2 by A22,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a3 =Exec(k4, t2).a3 by SCMPDS_5:46
    .=s.a2+1 by A21,A20,SCMPDS_2:60;
  thus t1.a4 =Exec(k4, t2).a4 by SCMPDS_5:46
    .=s.a4 by A11,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a5 =Exec(k4, t2).a5 by SCMPDS_5:46
    .=s.a4-s.a2 by A15,A20,AMI_3:52,SCMPDS_2:60;
A23: now
    let i be Element of NAT;
    assume
    i>=8;
    then i > 5 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A2,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A24: now
    let i be Element of NAT;
    assume
A25: i>=8;
    then
A26: i > 5 by XXREAL_0:2;
    thus t3.intpos i=Exec(k2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A7,A26,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A23,A25;
  end;
A27: now
    let i be Element of NAT;
    assume
A28: i>=8;
    then
A29: i > 3 by XXREAL_0:2;
    thus t2.intpos i=Exec(k3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A9,A29,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A24,A28;
  end;
  hereby
    let i be Element of NAT;
    assume
A30: i>=8;
    then
A31: i > 3 by XXREAL_0:2;
    thus t1.intpos i=Exec(k4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A20,A31,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A27,A30;
  end;
end;

theorem Th13:
  for s be State of SCMPDS,md,p0 be Element of NAT st s.GBP=0 & s.
  intpos 2=md & md >= p0+1 & p0 >= 7 holds Partition is_closed_on s & Partition
  is_halting_on s
proof
  set KW=K4 ';' WH3;
  let s be State of SCMPDS,md,n0 be Element of NAT;
  set s2=IExec(K4,s), a=GBP;
  assume that
A1: s.a=0 and
A2: s.a2=md and
A3: md >= n0+1 and
A4: n0 >= 7;
A5: s2.a2=s.a2 by A1,Lm28;
  set m3=md;
  s2.a5=s.a4-s.a2 by A1,Lm28;
  then
A6: s2.a4=m3+s2.a5 by A1,A2,Lm28;
  s2.a3=s.a2+1 by A1,Lm28;
  then
A7: s.a2=s2.a3-1;
A8: s2.a=0 by A1,Lm28;
  then
A9: WH3 is_halting_on s2 by A2,A3,A4,A5,A7,A6,Lm27;
A10: WH3 is_closed_on s2 by A2,A3,A4,A8,A5,A7,A6,Lm27;
  then
A11: KW is_closed_on s by A9,SCPISORT:10;
A12: KW is_halting_on s by A10,A9,SCPISORT:10;
  then
A13: KW ';' j8 is_closed_on s by A11,SCPISORT:11;
A14: KW ';' j8 is_halting_on s by A11,A12,SCPISORT:11;
  then
A15: KW ';' j8 ';' j9 is_halting_on s by A13,SCPISORT:11;
  KW ';' j8 ';' j9 is_closed_on s by A13,A14,SCPISORT:11;
  hence thesis by A15,SCPISORT:11;
end;

theorem Th14:
  for s be State of SCMPDS,md,p0,n be Element of NAT,f,f1 be
FinSequence of INT st s.GBP=0 & s.intpos 4-s.intpos 2 > 0 & s.intpos 2=md & md
  >= p0+1 & s.intpos 4 <= p0+n & p0 >= 7 & f is_FinSequence_on s,p0 & len f=n &
f1 is_FinSequence_on IExec(Partition,s),p0 & len f1=n holds IExec(Partition,s).
GBP=0 & IExec(Partition,s).intpos 1=s.intpos 1 & f,f1 are_fiberwise_equipotent
& ex m4 be Element of NAT st m4=IExec(Partition,s).intpos 4 & md <= m4 & m4 <=
s.intpos 4 & (for i be Element of NAT st md<=i & i < m4 holds IExec(Partition,s
).intpos m4 >= IExec(Partition,s).intpos i) & (for i be Element of NAT st m4 <
  i & i <= s.intpos 4 holds IExec(Partition,s).intpos m4 <= IExec(Partition,s).
  intpos i) & for i be Element of NAT st i >= p0+1 & (i < s.intpos 2 or i > s.
  intpos 4) holds IExec(Partition,s).intpos i = s.intpos i
proof
  set KW=K4 ';' WH3;
  let s be State of SCMPDS,md,n0,n be Element of NAT, f,f1 be FinSequence of
  INT;
  set s1=IExec(Partition,s), s2=IExec(K4,s), s3=IExec(K4 ';' WH3,s), a=GBP;
  assume that
A1: s.a=0 and
A2: s.a4-s.a2 > 0 and
A3: s.a2=md and
A4: md >= n0+1 and
A5: s.a4 <= n0+n and
A6: n0 >= 7;
A7: s2.GBP=0 by A1,Lm28;
A8: s2.a1=s.a1 by A1,Lm28;
A9: n0+1 >= 7+1 by A6,XREAL_1:8;
  then
A10: md >= 8 by A4,XXREAL_0:2;
  then
A11: md > 1 by XXREAL_0:2;
A12: md > 4 by A10,XXREAL_0:2;
A13: md-n0 >= 1 by A4,XREAL_1:21;
  then reconsider n1=md-n0 as Element of NAT by INT_1:16;
A14: md=n0+n1;
A15: s2.a4=s.a4 by A1,Lm28;
  set m3=md;
  s2.a5=s.a4-s.a2 by A1,Lm28;
  then
A16: s2.a4=m3+s2.a5 by A1,A3,Lm28;
  set s4=IExec(WH3,s2);
  consider f3 be FinSequence of INT such that
A17: len f3=n and
A18: for i be Element of NAT st 1<=i & i <= len f3 holds f3.i=s4.intpos(
  n0+i) by SCPISORT:2;
A19: f3 is_FinSequence_on s4,n0 by A18,SCPISORT:def 1;
  md < s.a4 by A2,A3,XREAL_1:49;
  then md < n0+n by A5,XXREAL_0:2;
  then
A20: n1 <= len f3 by A17,XREAL_1:22;
A21: s2.a2=s.a2 by A1,Lm28;
A22: s2.a3=s.a2+1 by A1,Lm28;
  then
A23: s.a2=s2.a3-1;
  then
A24: WH3 is_halting_on s2 by A3,A4,A6,A7,A21,A16,Lm27;
  s.a2 < s2.a3 by A22,XREAL_1:31;
  then
A25: n0+1 <= s2.a3 by A3,A4,XXREAL_0:2;
A26: WH3 is_closed_on s2 by A3,A4,A6,A7,A21,A23,A16,Lm27;
  then
A27: KW is_halting_on s by A24,SCPISORT:10;
  consider f2 be FinSequence of INT such that
A28: len f2=n and
A29: for i be Element of NAT st 1<=i & i <= len f2 holds f2.i=s2.intpos(
  n0+i) by SCPISORT:2;
A30: f2 is_FinSequence_on s2,n0 by A29,SCPISORT:def 1;
  then
A31: f2,f3 are_fiberwise_equipotent by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25
,A28,A17,A19,Lm26;
  s4.a4 > 0 by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19,Lm26;
  then reconsider m4=s4.a4 as Element of NAT by INT_1:16;
A32: s4.a4 >= md by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19,Lm26;
  then
A33: m4-n0 >= md-n0 by XREAL_1:11;
  then reconsider n2=m4-n0 as Element of NAT by A13,INT_1:16;
A34: m4-n0 >= 1 by A13,A33,XXREAL_0:2;
  s4.a2=md by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19,Lm26;
  then
A35: s3.a2=md by A26,A24,SCPISORT:8;
A36: s3.a4 =m4 by A26,A24,SCPISORT:8;
  s4.a=0 by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19,Lm26;
  then
A37: s3.a=0 by A26,A24,SCPISORT:8;
  then
A38: DataLoc(s3.a,6)=intpos(0+6) by SCMP_GCD:5;
  set t2=IExec(KW ';' j8 ';' j9,s), t3=IExec(KW ';' j8,s);
  assume that
A39: f is_FinSequence_on s,n0 and
A40: len f=n;
  assume that
A41: f1 is_FinSequence_on s1,n0 and
A42: len f1=n;
A43: dom f2 = Seg n by A28,FINSEQ_1:def 3;
A44: now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    assume
A45: i in dom f2;
    then
A46: 1 <= i by A43,FINSEQ_1:3;
    then i+n0 >= n0+1 by XREAL_1:8;
    then
A47: n0+i >= 8 by A9,XXREAL_0:2;
A48: i <= n by A43,A45,FINSEQ_1:3;
    hence f2.i=s2.intpos (n0+a) by A28,A29,A46
      .=s.intpos (n0+a) by A1,A47,Lm28
      .=f.i by A39,A40,A46,A48,SCPISORT:def 1;
  end;
A49: KW is_closed_on s by A26,A24,SCPISORT:10;
  then
A50: KW ';' j8 is_closed_on s by A27,SCPISORT:11;
A51: s4.a4 <= s2.a4 by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19
,Lm26;
  then m4 <= n0+n by A5,A15,XXREAL_0:2;
  then
A52: n2 <= len f3 by A17,XREAL_1:22;
A53: t3.a6=Exec(j8,s3).a6 by A49,A27,SCMPDS_7:50
    .=s3.DataLoc(s3.a4,0) by A38,SCMPDS_2:59
    .=s3.intpos(m4+0) by A36,SCMP_GCD:5
    .=s4.intpos m4 by A26,A24,SCPISORT:8;
A54: t3.a4=Exec(j8,s3).a4 by A49,A27,SCMPDS_7:50
    .=m4 by A36,A38,AMI_3:52,SCMPDS_2:59;
  then
A55: DataLoc(t3.a4,0)=intpos(m4+0) by SCMP_GCD:5;
A56: s4.a1=s2.a1 by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19,Lm26;
A57: t3.a1=Exec(j8,s3).a1 by A49,A27,SCMPDS_7:50
    .=s3.a1 by A38,AMI_3:52,SCMPDS_2:59
    .=s.a1 by A8,A56,A26,A24,SCPISORT:8;
A58: s4.a4 >= 8 by A32,A10,XXREAL_0:2;
  then
A59: m4 > 2 by XXREAL_0:2;
A60: t3.a=Exec(j8,s3).a by A49,A27,SCMPDS_7:50
    .=0 by A37,A38,AMI_3:52,SCMPDS_2:59;
A61: t3.a2=Exec(j8,s3).a2 by A49,A27,SCMPDS_7:50
    .=md by A35,A38,AMI_3:52,SCMPDS_2:59;
A62: KW ';' j8 is_halting_on s by A49,A27,SCPISORT:11;
  then
A63: KW ';' j8 ';' j9 is_halting_on s by A50,SCPISORT:11;
  t2.a2=Exec(j9,t3).a2 by A50,A62,SCMPDS_7:50
    .=md by A61,A55,A59,AMI_3:52,SCMPDS_2:59;
  then
A64: DataLoc(t2.a2,0)=intpos(md+0) by SCMP_GCD:5;
A65: m4 > 6 by A58,XXREAL_0:2;
A66: m4 > 1 by A58,XXREAL_0:2;
A67: t2.a6=Exec(j9,t3).a6 by A50,A62,SCMPDS_7:50
    .=s4.intpos m4 by A53,A55,A65,AMI_3:52,SCMPDS_2:59;
A68: t2.a=Exec(j9,t3).a by A50,A62,SCMPDS_7:50
    .=0 by A4,A32,A60,A55,AMI_3:52,SCMPDS_2:59;
A69: KW ';' j8 ';' j9 is_closed_on s by A50,A62,SCPISORT:11;
  then
A70: s1.intpos md=Exec(j0,t2).intpos md by A63,SCMPDS_7:50
    .=t2.DataLoc(t2.a,6) by A64,SCMPDS_2:59
    .=s4.intpos m4 by A68,A67,SCMP_GCD:5;
A71: now
    let i be Element of NAT;
    assume
    i >= 8;
    then
A72: i > 6 by XXREAL_0:2;
    thus t3.intpos i =Exec(j8,s3).intpos i by A49,A27,SCMPDS_7:50
      .=s3.intpos i by A38,A72,AMI_3:52,SCMPDS_2:59
      .=s4.intpos i by A26,A24,SCPISORT:8;
  end;
A73: now
    let i be Element of NAT;
    assume that
A74: i >= 8 and
A75: i <> m4;
    thus t2.intpos i =Exec(j9,t3).intpos i by A50,A62,SCMPDS_7:50
      .=t3.intpos i by A55,A75,AMI_3:52,SCMPDS_2:59
      .=s4.intpos i by A71,A74;
  end;
A76: now
    let i be Element of NAT;
    assume that
A77: i >= 8 and
A78: i <> m4 and
A79: i<>md;
    thus s1.intpos i =Exec(j0,t2).intpos i by A69,A63,SCMPDS_7:50
      .=t2.intpos i by A64,A79,AMI_3:52,SCMPDS_2:59
      .=s4.intpos i by A73,A77,A78;
  end;
A80: now
    let k be Element of NAT;
    assume that
A81: k<>n1 and
A82: k<>n2 and
A83: 1<=k and
A84: k <= len f3;
A85: k+n0<>md by A81;
A86: k+n0 >= n0+1 by A83,XREAL_1:8;
A87: k+n0<>m4 by A82;
    thus f3.k=s4.intpos(n0+k) by A18,A83,A84
      .=s1.intpos(n0+k) by A9,A76,A85,A87,A86,XXREAL_0:2
      .=f1.k by A41,A42,A17,A83,A84,SCPISORT:def 1;
  end;
A88: m4=n0+n2;
  then
A89: f3.n2=s1.intpos md by A18,A70,A34,A52
    .=f1.n1 by A41,A42,A17,A13,A20,A14,SCPISORT:def 1;
A90: t2.a1=Exec(j9,t3).a1 by A50,A62,SCMPDS_7:50
    .=s.a1 by A57,A55,A66,AMI_3:52,SCMPDS_2:59;
  thus s1.a=Exec(j0,t2).a by A69,A63,SCMPDS_7:50
    .=0 by A4,A68,A64,AMI_3:52,SCMPDS_2:59;
  thus s1.a1=Exec(j0,t2).a1 by A69,A63,SCMPDS_7:50
    .=s.a1 by A90,A64,A11,AMI_3:52,SCMPDS_2:59;
A91: m4 > 4 by A58,XXREAL_0:2;
A92: t2.a4=Exec(j9,t3).a4 by A50,A62,SCMPDS_7:50
    .=m4 by A54,A55,A91,AMI_3:52,SCMPDS_2:59;
A93: t2.intpos m4=Exec(j9,t3).intpos m4 by A50,A62,SCMPDS_7:50
    .=t3.DataLoc(t3.a2,0) by A55,SCMPDS_2:59
    .=t3.intpos (md+0) by A61,SCMP_GCD:5
    .=s4.intpos md by A4,A9,A71,XXREAL_0:2;
A94: now
    per cases;
    suppose
      m4=md;
      hence s1.intpos m4=s4.intpos md by A70;
    end;
    suppose
A95:  m4<>md;
      thus s1.intpos m4=Exec(j0,t2).intpos m4 by A69,A63,SCMPDS_7:50
        .=s4.intpos md by A93,A64,A95,AMI_3:52,SCMPDS_2:59;
    end;
  end;
  then f3.n1=s1.intpos m4 by A18,A13,A20,A14
    .=f1.n2 by A41,A42,A17,A34,A52,A88,SCPISORT:def 1;
  then f3,f1 are_fiberwise_equipotent by A42,A17,A13,A20,A34,A52,A89,A80,
SCPISORT:4;
  then f2,f1 are_fiberwise_equipotent by A31,CLASSES1:84;
  hence f,f1 are_fiberwise_equipotent by A40,A28,A44,FINSEQ_2:10;
  take m4;
  thus s1.a4=Exec(j0,t2).a4 by A69,A63,SCMPDS_7:50
    .=m4 by A92,A64,A12,AMI_3:52,SCMPDS_2:59;
A96: m3=s2.a3-1 by A3,A22;
  hence md <= m4 by A2,A3,A4,A5,A6,A7,A21,A15,A16,A25,A28,A30,A17,A19,Lm26;
  thus m4 <= s.a4 by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19,Lm26
;
A97: s2.a3=md+1 by A1,A3,Lm28;
  hereby
    let i be Element of NAT;
    assume that
A98: md<=i and
A99: i < m4;
    per cases;
    suppose
A100: i=md;
      then s2.a3 <= m4 by A97,A99,INT_1:20;
      hence
      s1.intpos m4 >= s1.intpos i by A2,A3,A4,A5,A6,A7,A21,A15,A96,A16,A25,A28
,A30,A17,A19,A70,A94,A100,Lm26;
    end;
    suppose
A101: i<>md;
      then md < i by A98,XXREAL_0:1;
      then s2.a3 <= i by A3,A22,INT_1:20;
      then s4.intpos md >= s4.intpos i by A2,A3,A4,A5,A6,A7,A21,A15,A96,A16,A25
,A28,A30,A17,A19,A99,Lm26;
      hence s1.intpos m4 >= s1.intpos i by A10,A94,A76,A98,A101,XXREAL_0:2;
    end;
  end;
  hereby
    let i be Element of NAT;
    assume that
A102: m4 < i and
A103: i <= s.a4;
A104: md < i by A32,A102,XXREAL_0:2;
    s4.intpos md <= s4.intpos i by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28
,A30,A17,A19,A102,A103,Lm26;
    hence s1.intpos m4 <= s1.intpos i by A10,A94,A76,A104,XXREAL_0:2;
  end;
  hereby
    let i be Element of NAT;
    assume that
A105: i >= n0+1 and
A106: i < s.a2 or i > s.a4;
A107: i >= 8 by A9,A105,XXREAL_0:2;
A108: now
      per cases by A106;
      case
A109:   i < s.a2;
        s.a2 < s2.a3 by A22,XREAL_1:31;
        hence i < s2.a3 by A109,XXREAL_0:2;
      end;
      case
        i > s.a4;
        hence i > s2.a4 by A1,Lm28;
      end;
    end;
    i<>md & i<>m4
    proof
      per cases by A106;
      suppose
        i< s.a2;
        hence thesis by A2,A3,A4,A5,A6,A7,A21,A15,A23,A16,A25,A28,A30,A17,A19
,Lm26;
      end;
      suppose
        i > s.a4;
        hence thesis by A15,A32,A51,XXREAL_0:2;
      end;
    end;
    hence s1.intpos i = s4.intpos i by A9,A76,A105,XXREAL_0:2
      .=s2.intpos i by A2,A3,A4,A5,A6,A7,A21,A15,A96,A16,A25,A28,A30,A17,A19
,A105,A108,Lm26
      .=s.intpos i by A1,A107,Lm28;
  end;
end;

theorem
  Partition is No-StopCode shiftable;

Lm29: for s being State of SCMPDS,p0,n being Element of NAT holds card
QuickSort(n,p0)=57 & (p0 >= 7 implies QuickSort(n,p0) is_halting_on s & ex f,g
be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 & len g = n & g
is_FinSequence_on IExec(QuickSort(n,p0),s),p0 & f,g are_fiberwise_equipotent &
g is_non_decreasing_on 1,n)

proof
  set b1=DataLoc(0,1);
  reconsider Pt=Partition as No-StopCode shiftable Program of SCMPDS;
  let s be State of SCMPDS,p0,n be Element of NAT;
  set pn=p0+n;

  set l1= (GBP,2):=(SBP,pn+1), l2= SubFrom(GBP,2,SBP,pn), l3= (GBP,2):=(SBP,pn

), l4= (GBP,4):=(SBP,pn+1), l5= (SBP,pn+3):=(SBP,pn+1), l6= (SBP,pn+1):=(GBP,4)
  , l7= (SBP,pn+2):=(GBP,4), l8= AddTo(SBP,pn+1,-1), l9= AddTo(SBP,pn+2,1), l0=
  AddTo(GBP,1,2), lb= Load AddTo(GBP,1,-2), L5= l5 ';' l6 ';' l7 ';' l8 ';' l9

';' l0, TR= l3 ';' l4 ';' Pt ';' L5, IF4= if>0(GBP,2,TR,lb), WB4= l1 ';' l2 ';'
  IF4, WH4= while>0(GBP,1,WB4);

  set m1= GBP:=0, m2= SBP:=1, m3= (SBP,pn):=(p0+1), m4= (SBP,pn+1):=pn, M4= m1
  ';' m2 ';' m3 ';' m4;

  set s1=IExec(M4,s), a=GBP;
A1: 7+n >= 7 by NAT_1:11;
A2: card L5= card (l5 ';' l6 ';' l7 ';' l8 ';' l9 )+1 by SCMP_GCD:8
    .= card (l5 ';' l6 ';' l7 ';' l8)+1+1 by SCMP_GCD:8
    .= 4+1+1 by Th4;
A3: card WB4=card (l1 ';' l2) + card IF4 by SCMPDS_4:45
    .=2+card IF4 by SCMP_GCD:9
    .=2+(card TR +card lb +2) by SCMPDS_6:79
    .=2+(card TR +1 +2) by SCMPDS_5:6
    .=2+(card (l3 ';' l4 ';' Partition)+ card L5+1+2) by SCMPDS_4:45
    .=2+(card (l3 ';' l4) + card Partition + card L5+1+2) by SCMPDS_4:45
    .=2+(2+ 38 + card L5+1+2) by Th12,SCMP_GCD:9
    .=51 by A2;
  thus card QuickSort(n,p0)=card M4 + card WH4 by SCMPDS_4:45
    .=4 + card WH4 by Th4
    .=4 + (51+2) by A3,SCMPDS_8:17
    .=57;
  assume
A4: p0 >= 7;
  then pn >= 7+n by XREAL_1:8;
  then
A5: pn >= 7 by A1,XXREAL_0:2;

A6: for t be State of SCMPDS,m1 be Element of NAT st t.a=0 & t.SBP=m1 holds

IExec(l3 ';' l4, t).a2=t.intpos(m1+pn) & IExec(l3 ';' l4, t).a4=t.intpos(m1+pn+
  1) & for i be Element of NAT st i <> 2 & i <> 4 holds IExec(l3 ';' l4, t).
  intpos i=t.intpos i

  proof
    let t be State of SCMPDS,m1 be Element of NAT;
    set t0=Initialized t, t2=IExec(l3 ';' l4, t), t3=Exec(l3, t0), mp=m1+pn;
    assume that
A7: t.a=0 and
A8: t.SBP=m1;
A9: t0.a =0 by A7,SCMPDS_5:40;
    then
A10: DataLoc(t0.a,2)=intpos (0+2) by SCMP_GCD:5;
    then t3.a=0 by A9,AMI_3:52,SCMPDS_2:59;
    then
A11: DataLoc(t3.a,4)=intpos (0+4) by SCMP_GCD:5;
A12: t0.SBP =m1 by A8,SCMPDS_5:40;
    then
A13: t3.SBP=m1 by A10,AMI_3:52,SCMPDS_2:59;
    mp >= 0+7 by A5,XREAL_1:9;
    then mp+1 >= 7+1 by XREAL_1:8;
    then mp+1 > 2 by XXREAL_0:2;
    then
A14: t3.intpos(mp+1)=t0.intpos(mp+1) by A10,AMI_3:52,SCMPDS_2:59
      .=t.intpos(mp+1) by SCMPDS_5:40;
A15: t3.a2=t0.DataLoc(t0.SBP,pn) by A10,SCMPDS_2:59
      .=t0.intpos mp by A12,SCMP_GCD:5
      .=t.intpos mp by SCMPDS_5:40;
    thus t2.a2=Exec(l4, t3).a2 by SCMPDS_5:47
      .=t.intpos mp by A15,A11,AMI_3:52,SCMPDS_2:59;
    thus t2.a4=Exec(l4, t3).a4 by SCMPDS_5:47
      .=t3.DataLoc(t3.SBP,pn+1) by A11,SCMPDS_2:59
      .=t.intpos(mp+1) by A13,A14,SCMP_GCD:5;
    hereby
      let i be Element of NAT;
      assume that
A16:  i<>2 and
A17:  i <> 4;
      thus t2.intpos i =Exec(l4, t3).intpos i by SCMPDS_5:47
        .=t3.intpos i by A11,A17,AMI_3:52,SCMPDS_2:59
        .=t0.intpos i by A10,A16,AMI_3:52,SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
    end;
  end;

A18: for t being State of SCMPDS,m,m1 be Element of NAT st t.a=0 & t.SBP=m1 &

m1=m+1 holds IExec(L5,t).a=0 & IExec(L5,t).SBP=m1+2 & IExec(L5,t).intpos (m1+pn

)=t.intpos (m1+pn) & IExec(L5,t).intpos (m1+pn+1)=t.a4-1 & IExec(L5,t).intpos (
  m1+pn+2)=t.a4+1 & IExec(L5,t).intpos (m1+pn+3)=t.intpos (m1+pn+1) & for i be
  Element of NAT st i >= 8 & i < m1+pn holds IExec(L5,t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS,m,m1 be Element of NAT;
    assume that
A19: t.a=0 and
A20: t.SBP=m1 and
A21: m1=m+1;

    set t0=Initialized t, t1=IExec(L5,t), t2=IExec(l5 ';' l6 ';' l7 ';' l8 ';'

l9,t), t3=IExec(l5 ';' l6 ';' l7 ';' l8,t), t4=IExec(l5 ';' l6 ';' l7, t), t5=
    IExec(l5 ';' l6, t), t6=Exec(l5, t0), mp=m1+pn;

A22: mp+3 <> mp+1;
    m1 >= 1 by A21,NAT_1:11;
    then
A23: mp >= 1+7 by A5,XREAL_1:9;
    then
A24: mp+1 >= 8+1 by XREAL_1:8;
    then
A25: mp+1 > 4 by XXREAL_0:2;
A26: mp+1 > 1 by A24,XXREAL_0:2;
A27: mp+0 <> mp+2;
A28: mp > 1 by A23,XXREAL_0:2;
A29: mp+1 <> mp+2;
A30: t0.SBP =m1 by A20,SCMPDS_5:40;
    then
A31: DataLoc(t0.SBP,pn+3)=intpos (mp+3) by SCMP_GCD:5;
A32: now
      let i be Element of NAT;
      assume
      i<>mp+3;
      hence t6.intpos i=t0.intpos i by A31,AMI_3:52,SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
    end;
    mp+0 <> mp+3;
    then
A33: t6.intpos mp=t.intpos mp by A32;
A34: mp+1 <> mp+2;
A35: mp+3 <> mp+2;
A36: mp+3 >= 8+3 by A23,XREAL_1:8;
    then
A37: mp+3 > 1 by XXREAL_0:2;
    mp+3 > 1 by A36,XXREAL_0:2;
    then
A38: t6.SBP=m1 by A20,A32;
    then
A39: DataLoc(t6.SBP,pn+1)=intpos (mp+1) by SCMP_GCD:5;
A40: now
      let i be Element of NAT;
      assume
A41:  i<>mp+1;
      thus t5.intpos i=Exec(l6, t6).intpos i by SCMPDS_5:47
        .=t6.intpos i by A39,A41,AMI_3:52,SCMPDS_2:59;
    end;
    mp+1 > 1 by A24,XXREAL_0:2;
    then
A42: t5.SBP=m1 by A38,A40;
    then
A43: DataLoc(t5.SBP,pn+2)=intpos (mp+2) by SCMP_GCD:5;
A44: now
      let i be Element of NAT;
      assume
A45:  i<>mp+2;
      thus t4.intpos i=Exec(l7, t5).intpos i by SCMPDS_5:46
        .=t5.intpos i by A43,A45,AMI_3:52,SCMPDS_2:59;
    end;
    t6.intpos (mp+3)=t0.DataLoc(t0.SBP,pn+1) by A31,SCMPDS_2:59
      .=t0.intpos(m1+(pn+1)) by A30,SCMP_GCD:5
      .=t.intpos (mp+1) by SCMPDS_5:40;
    then t5.intpos(mp+3)=t.intpos(mp+1) by A40,A22;
    then
A46: t4.intpos(mp+3)=t.intpos(mp+1) by A44,A35;
A47: mp+3 > 4 by A36,XXREAL_0:2;
    then
A48: t6.a4=t.a4 by A32;
A49: mp+2 >= 8+2 by A23,XREAL_1:8;
    then
A50: mp+2 > 1 by XXREAL_0:2;
    mp+2 > 1 by A49,XXREAL_0:2;
    then
A51: t4.SBP=m1 by A42,A44;
    then
A52: DataLoc(t4.SBP,pn+1)=intpos (mp+1) by SCMP_GCD:5;
A53: now
      let i be Element of NAT;
      assume
A54:  i<>mp+1;
      thus t3.intpos i=Exec(l8, t4).intpos i by SCMPDS_5:46
        .=t4.intpos i by A52,A54,AMI_3:52,SCMPDS_2:60;
    end;
    m1+pn+1 > 1 by A24,XXREAL_0:2;
    then
A55: t3.SBP=m1 by A51,A53;
    then
A56: DataLoc(t3.SBP,pn+2)=intpos (mp+2) by SCMP_GCD:5;
A57: now
      let i be Element of NAT;
      assume
A58:  i<>mp+2;
      thus t2.intpos i=Exec(l9, t3).intpos i by SCMPDS_5:46
        .=t3.intpos i by A56,A58,AMI_3:52,SCMPDS_2:60;
    end;
A59: t6.a=0 by A19,A32;
    then
A60: t5.a=0 by A40;
    then t4.a=0 by A44;
    then t3.a=0 by A53;
    then
A61: t2.a=0 by A57;
    then
A62: DataLoc(t2.a,1)=intpos (0+1) by SCMP_GCD:5;
    mp+2 > 1 by A49,XXREAL_0:2;
    then
A63: t2.SBP=m1 by A55,A57;
A64: now
      let i be Element of NAT;
      assume
      i<>1;
      then
A65:  intpos i <> DataLoc(t2.a,1) by A61,AMI_3:52,SCMP_GCD:5;
      thus t1.intpos i=Exec(l0, t2).intpos i by SCMPDS_5:46
        .=t2.intpos i by A65,SCMPDS_2:60;
    end;
    hence t1.a=0 by A61;
A66: mp+0 <> mp+2;
    mp+0 <> mp+1;
    then t5.intpos mp=t.intpos mp by A33,A40;
    then
A67: t4.intpos mp=t.intpos mp by A44,A66;
    thus t1.SBP=Exec(l0, t2).SBP by SCMPDS_5:46
      .=m1+2 by A63,A62,SCMPDS_2:60;
    mp+0 <> mp+1;
    then t3.intpos mp=t.intpos mp by A67,A53;
    then t2.intpos mp=t.intpos mp by A57,A27;
    hence t1.intpos mp=t.intpos mp by A64,A28;
A68: mp+1 <> mp+2;
    t4.intpos(mp+2)=Exec(l7, t5).intpos(mp+2) by SCMPDS_5:46
      .=t5.DataLoc(t5.GBP,4) by A43,SCMPDS_2:59
      .=t5.intpos(0+4) by A60,SCMP_GCD:5
      .=t.a4 by A48,A40,A25;
    then
A69: t3.intpos(mp+2)=t.a4 by A53,A29;
    t5.intpos (mp+1)=Exec(l6, t6).intpos(mp+1) by SCMPDS_5:47
      .=t6.DataLoc(t6.GBP,4) by A39,SCMPDS_2:59
      .=t6.intpos(0+4) by A59,SCMP_GCD:5
      .=t.a4 by A32,A47;
    then
A70: t4.intpos (mp+1)=t.a4 by A44,A68;
    t3.intpos(mp+1)=Exec(l8, t4).intpos(mp+1) by SCMPDS_5:46
      .=t.a4+-1 by A70,A52,SCMPDS_2:60
      .=t.a4-1;
    then t2.intpos(mp+1)=t.a4-1 by A57,A34;
    hence t1.intpos(mp+1)=t.a4-1 by A64,A26;
    t2.intpos(mp+2)=Exec(l9, t3).intpos(mp+2) by SCMPDS_5:46
      .=t.a4+1 by A69,A56,SCMPDS_2:60;
    hence t1.intpos(mp+2)=t.a4+1 by A64,A50;
A71: mp+3 <> mp+2;
    mp+3 <> mp+1;
    then t3.intpos(mp+3)=t.intpos(mp+1) by A46,A53;
    then t2.intpos(mp+3)=t.intpos(mp+1) by A57,A71;
    hence t1.intpos(mp+3)=t.intpos(mp+1) by A64,A37;
    hereby
A72:  mp <= mp+3 by NAT_1:11;
A73:  mp <= mp+2 by NAT_1:11;
A74:  mp <= mp+1 by NAT_1:11;
      let i be Element of NAT;
      assume that
A75:  i >= 8 and
A76:  i < mp;
      i > 1 by A75,XXREAL_0:2;
      hence t1.intpos i=t2.intpos i by A64
        .=t3.intpos i by A57,A76,A73
        .=t4.intpos i by A53,A76,A74
        .=t5.intpos i by A44,A76,A73
        .=t6.intpos i by A40,A76,A74
        .=t.intpos i by A32,A76,A72;
    end;
  end;

A77: for t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer, f1,

f2 be FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md & md

>= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn & f1 is_FinSequence_on t,

p0 & len f1=n & f2 is_FinSequence_on IExec(TR,t),p0 & len f2=n holds IExec(TR,t
  ).a=0 & IExec(TR,t).a1=m1+2 & md=IExec(TR,t).intpos(m1+pn) & n4=IExec(TR,t).
  intpos (m1+pn+3) & (for j be Element of NAT st 1<=j & j<m1 holds IExec(TR,t).
  intpos(pn+j)=t.intpos(pn+j)) & f1,f2 are_fiberwise_equipotent & ex m4 be

Element of NAT st md <= m4 & m4 <= n4 & m4-1=IExec(TR,t).intpos (m1+pn+1) & m4+
  1=IExec(TR,t).intpos (m1+pn+2) & (for i be Element of NAT st md<=i & i < m4

holds IExec(TR,t).intpos m4 >= IExec(TR,t).intpos i) & (for i be Element of NAT

st m4 < i & i <= n4 holds IExec(TR,t).intpos m4 <= IExec(TR,t).intpos i) & for
  j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n holds IExec(TR,t).
  intpos j = t.intpos j

  proof

    let t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer, f1,f2 be
    FinSequence of INT;

    set t1=IExec(TR,t), lPt=l3 ';' l4 ';' Pt, t2=IExec(lPt,t), t4=IExec(l3 ';'
    l4, t), mp=m1+pn;

    set tp=IExec(Pt,t4);
    assume that
A78: t.a=0 and
A79: t.SBP=m1 and
A80: m1=m+1 and
A81: t.intpos mp=md and
A82: md >= p0+1 and
A83: n4=t.intpos (mp+1) and
A84: n4-md > 0 and
A85: n4 <= pn;
A86: t4.a=0 by A6,A78,A79;
    assume that
A87: f1 is_FinSequence_on t,p0 and
A88: len f1=n;
A89: p0+1 >= 7+1 by A4,XREAL_1:8;
    now
      let i be Element of NAT;
      assume that
A90:  1 <= i and
A91:  i <= len f1;
      p0+i >= p0+1 by A90,XREAL_1:8;
      then
A92:  p0+i >= 8 by A89,XXREAL_0:2;
      then
A93:  p0+i > 2 by XXREAL_0:2;
A94:  p0+i > 4 by A92,XXREAL_0:2;
      thus f1.i=t.intpos(p0+i) by A87,A90,A91,SCPISORT:def 1
        .=t4.intpos(p0+i) by A6,A78,A79,A93,A94;
    end;
    then
A95: f1 is_FinSequence_on t4,p0 by SCPISORT:def 1;
A96: t4.a4=n4 by A6,A78,A79,A83;
A97: t4.a4=t.intpos(mp+1) by A6,A78,A79;
A98: t4.a2=t.intpos mp by A6,A78,A79;
    then
A99: Pt is_closed_on t4 by A4,A81,A82,A86,Th13;
A100: Pt is_halting_on t4 by A4,A81,A82,A98,A86,Th13;
    then
A101: lPt is_closed_on t by A99,SCPISORT:10;
    assume that
A102: f2 is_FinSequence_on IExec(TR,t),p0 and
A103: len f2=n;
    consider f4 be FinSequence of INT such that
A104: len f4=n and

A105: for i be Element of NAT st 1<=i & i <= len f4 holds f4.i=tp.
    intpos (p0+i) by SCPISORT:2;

A106: f4 is_FinSequence_on tp,p0 by A105,SCPISORT:def 1;
    then consider m4 be Element of NAT such that
A107: m4=tp.a4 and
A108: md <= m4 and
A109: m4 <= t4.a4 and

A110: for i be Element of NAT st md<=i & i < m4 holds tp.intpos m4 >=
    tp.intpos i and

A111: for i be Element of NAT st m4 < i & i <= t4.a4 holds tp.intpos
    m4 <= tp.intpos i and

A112: for i be Element of NAT st i >= p0+1 & (i < t4.a2 or i > t4.a4)
    holds tp.intpos i = t4.intpos i by A4,A81,A82,A83,A84,A85,A88,A98,A97,A86
,A95,A104,Th14;

    tp.a=0 by A4,A81,A82,A83,A84,A85,A88,A98,A97,A86,A95,A104,A106,Th14;

    then
A113: t2.a=0 by A99,A100,SCPISORT:8;
A114: lPt is_halting_on t by A99,A100,SCPISORT:10;

    tp.a1=t4.a1 by A4,A81,A82,A83,A84,A85,A88,A98,A97,A86,A95,A104,A106,Th14;

    then
A115: t2.SBP=t4.a1 by A99,A100,SCPISORT:8
      .=m1 by A6,A78,A79;
    then
A116: IExec(L5,t2).intpos mp=t2.intpos mp by A18,A80,A113;
    IExec(L5,t2).a=0 by A18,A80,A113,A115;
    hence t1.a=0 by A101,A114,SCPISORT:7;
    IExec(L5,t2).SBP=m1+2 by A18,A80,A113,A115;
    hence t1.a1=m1+2 by A101,A114,SCPISORT:7;
A117: IExec(L5,t2).intpos (mp+3)=t2.intpos (mp+1) by A18,A80,A113,A115;
A118: IExec(L5,t2).intpos (mp+2)=t2.a4+1 by A18,A80,A113,A115;
A119: IExec(L5,t2).intpos (mp+1)=t2.a4-1 by A18,A80,A113,A115;
A120: 1+pn > pn by XREAL_1:31;
A121: m1 >= 1 by A80,NAT_1:11;
    then mp >= 1+pn by XREAL_1:8;
    then
A122: mp > pn by A120,XXREAL_0:2;
    then
A123: mp > t4.a4 by A85,A96,XXREAL_0:2;
    then
A124: m4 < mp by A109,XXREAL_0:2;
A125: dom f2 = Seg n by A103,FINSEQ_1:def 3;
A126: now
      let i be Nat;
      reconsider a = i as Element of NAT by ORDINAL1:def 13;
      assume
A127: i in dom f2;
      then
A128: 1 <= i by A125,FINSEQ_1:3;
      then p0+i >= p0+1 by XREAL_1:8;
      then
A129: p0+i >= 8 by A89,XXREAL_0:2;
A130: i <= n by A125,A127,FINSEQ_1:3;
      then p0+i <= pn by XREAL_1:8;
      then
A131: p0+i < mp by A122,XXREAL_0:2;
      thus f2.i = t1.intpos(p0+a) by A102,A103,A128,A130,SCPISORT:def 1
        .=IExec(L5,t2).intpos(p0+a) by A101,A114,SCPISORT:7
        .=t2.intpos (p0+a) by A18,A80,A113,A115,A129,A131
        .=tp.intpos (p0+a) by A99,A100,SCPISORT:8
        .=f4.i by A104,A105,A128,A130;
    end;
A132: mp >= 1+7 by A5,A121,XREAL_1:9;
    then
A133: mp > 4 by XXREAL_0:2;
A134: mp+1 > mp by XREAL_1:31;
    then
A135: mp+1 > t4.a4 by A123,XXREAL_0:2;
A136: pn >= p0 by NAT_1:11;
    then
A137: mp >= p0+1 by A121,XREAL_1:9;
    then
A138: mp+1 >= p0+1 by A134,XXREAL_0:2;
A139: mp+1 >= 8+1 by A132,XREAL_1:8;
    then
A140: mp+1 > 4 by XXREAL_0:2;
    mp > 2 by A132,XXREAL_0:2;
    hence md=t4.intpos mp by A6,A78,A79,A81,A133
      .=tp.intpos mp by A112,A137,A123
      .=IExec(L5,t2).intpos mp by A99,A100,A116,SCPISORT:8
      .=t1.intpos mp by A101,A114,SCPISORT:7;
    mp+1 > 2 by A139,XXREAL_0:2;
    hence n4=t4.intpos (mp+1) by A6,A78,A79,A83,A140
      .=tp.intpos (mp+1) by A112,A138,A135
      .=IExec(L5,t2).intpos (mp+3) by A99,A100,A117,SCPISORT:8
      .=t1.intpos (mp+3) by A101,A114,SCPISORT:7;
    hereby
      let j be Element of NAT;
      assume that
A141: 1<=j and
A142: j<m1;
A143: pn+j < mp by A142,XREAL_1:8;
      pn+j >= pn+1 by A141,XREAL_1:8;
      then pn+j > pn by A120,XXREAL_0:2;
      then
A144: pn+j > t4.a4 by A85,A96,XXREAL_0:2;
A145: pn+j >= p0+1 by A136,A141,XREAL_1:9;
A146: pn+j >= 1+7 by A5,A141,XREAL_1:9;
      then
A147: pn+j > 2 by XXREAL_0:2;
A148: pn+j > 4 by A146,XXREAL_0:2;
      thus t1.intpos(pn+j)=IExec(L5,t2).intpos(pn+j) by A101,A114,SCPISORT:7
        .=t2.intpos (pn+j) by A18,A80,A113,A115,A146,A143
        .=tp.intpos (pn+j) by A99,A100,SCPISORT:8
        .=t4.intpos (pn+j) by A112,A145,A144
        .=t.intpos(pn+j) by A6,A78,A79,A147,A148;
    end;

    f1,f4 are_fiberwise_equipotent by A4,A81,A82,A83,A84,A85,A88,A98,A97,A86
,A95,A104,A106,Th14;

    hence f1,f2 are_fiberwise_equipotent by A103,A104,A126,FINSEQ_2:10;
    take m4;
    thus md <= m4 & m4 <= n4 by A6,A78,A79,A83,A108,A109;
    thus m4-1=t2.a4-1 by A107,A99,A100,SCPISORT:8
      .=t1.intpos (mp+1) by A101,A114,A119,SCPISORT:7;
    thus m4+1=t2.a4+1 by A107,A99,A100,SCPISORT:8
      .=t1.intpos (mp+2) by A101,A114,A118,SCPISORT:7;
A149: md >= 8 by A82,A89,XXREAL_0:2;
    then
A150: m4 >= 8 by A108,XXREAL_0:2;
    hereby
A151: tp.intpos m4=t2.intpos m4 by A99,A100,SCPISORT:8
        .=IExec(L5,t2).intpos m4 by A18,A80,A113,A115,A124,A150
        .=t1.intpos m4 by A101,A114,SCPISORT:7;
      let i be Element of NAT;
      assume that
A152: md<=i and
A153: i < m4;
A154: i < mp by A124,A153,XXREAL_0:2;
A155: i >= 8 by A149,A152,XXREAL_0:2;
      tp.intpos i=t2.intpos i by A99,A100,SCPISORT:8
        .=IExec(L5,t2).intpos i by A18,A80,A113,A115,A154,A155
        .=t1.intpos i by A101,A114,SCPISORT:7;
      hence t1.intpos m4 >= t1.intpos i by A110,A152,A153,A151;
    end;
    hereby
A156: tp.intpos m4=t2.intpos m4 by A99,A100,SCPISORT:8
        .=IExec(L5,t2).intpos m4 by A18,A80,A113,A115,A124,A150
        .=t1.intpos m4 by A101,A114,SCPISORT:7;
      let i be Element of NAT;
      assume that
A157: m4 < i and
A158: i <= n4;
A159: i < mp by A83,A97,A123,A158,XXREAL_0:2;
      i >= md by A108,A157,XXREAL_0:2;
      then
A160: i >= 8 by A149,XXREAL_0:2;
      tp.intpos i=t2.intpos i by A99,A100,SCPISORT:8
        .=IExec(L5,t2).intpos i by A18,A80,A113,A115,A159,A160
        .=t1.intpos i by A101,A114,SCPISORT:7;
      hence t1.intpos m4 <= t1.intpos i by A96,A111,A157,A158,A156;
    end;
    hereby
      let j be Element of NAT;
      assume that
A161: p0+1<=j & j<md or n4<j & j <= pn;
A162: now
        per cases by A161;
        suppose
A163:     p0+1<=j & j<md;

          hence j >= p0+1 & (j < t4.a2 or j > t4.a4) by A6,A78,A79,A81;

          md < mp by A108,A124,XXREAL_0:2;
          hence j < mp by A163,XXREAL_0:2;
        end;
        suppose
A164:     n4<j & j <= pn;
          n4 >= md by A96,A108,A109,XXREAL_0:2;
          then j >= md by A164,XXREAL_0:2;
          hence j >= p0+1 by A82,XXREAL_0:2;
          thus j < t4.a2 or j > t4.a4 by A6,A78,A79,A83,A164;
          thus j < mp by A122,A164,XXREAL_0:2;
        end;
      end;
      then
A165: j >= 8 by A89,XXREAL_0:2;
      then
A166: j > 2 by XXREAL_0:2;
A167: j > 4 by A165,XXREAL_0:2;
      thus t1.intpos j=IExec(L5,t2).intpos j by A101,A114,SCPISORT:7
        .=t2.intpos j by A18,A80,A113,A115,A162,A165
        .=tp.intpos j by A99,A100,SCPISORT:8
        .=t4.intpos j by A112,A162
        .=t.intpos j by A6,A78,A79,A166,A167;
    end;
  end;

A168: for t be State of SCMPDS,m be Element of NAT st t.a=0 & t.SBP=m holds
  IExec(l1 ';' l2,t).a2=t.intpos (m+pn+1)-t.intpos (m+pn) & for i be Element of
  NAT st i <> 2 holds IExec(l1 ';' l2,t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS,m be Element of NAT;
    assume that
A169: t.a=0 and
A170: t.SBP=m;
    set t0=Initialized t, t1=IExec(l1 ';' l2, t), t2=Exec(l1, t0), mp=m+pn;
A171: t0.a =0 by A169,SCMPDS_5:40;
    then
A172: DataLoc(t0.a,2)=intpos (0+2) by SCMP_GCD:5;
    then t2.a=0 by A171,AMI_3:52,SCMPDS_2:59;
    then
A173: DataLoc(t2.a,2)=intpos (0+2) by SCMP_GCD:5;
A174: t0.SBP =m by A170,SCMPDS_5:40;
    then
A175: t2.SBP=m by A172,AMI_3:52,SCMPDS_2:59;
    mp >= 0+7 by A5,XREAL_1:9;
    then mp > 2 by XXREAL_0:2;
    then
A176: t2.intpos mp=t0.intpos mp by A172,AMI_3:52,SCMPDS_2:59
      .=t.intpos mp by SCMPDS_5:40;
A177: t2.a2=t0.DataLoc(t0.SBP,pn+1) by A172,SCMPDS_2:59
      .=t0.intpos (m+(pn+1)) by A174,SCMP_GCD:5
      .=t.intpos (mp+1) by SCMPDS_5:40;
    thus t1.a2=Exec(l2, t2).a2 by SCMPDS_5:47
      .=t2.a2-t2.DataLoc(t2.SBP,pn) by A173,SCMPDS_2:62
      .=t.intpos (mp+1)-t.intpos mp by A175,A177,A176,SCMP_GCD:5;
    hereby
      let i be Element of NAT;
      assume
A178: i <> 2;
      thus t1.intpos i=Exec(l2, t2).intpos i by SCMPDS_5:47
        .=t2.intpos i by A173,A178,AMI_3:52,SCMPDS_2:62
        .=t0.intpos i by A172,A178,AMI_3:52,SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
    end;
  end;
A179: pn+1 >= 7+1 by A5,XREAL_1:8;

A180: for t be State of SCMPDS,m be Element of NAT st t.a=0 & t.SBP=m & t.

intpos (m+pn+1) <= t.intpos (m+pn) holds IExec(WB4,t).a=0 & IExec(WB4,t).a1=m-2
  & (for j be Element of NAT st 1<=j & j<m holds IExec(WB4,t).intpos(pn+j)=t.
  intpos(pn+j)) & for j be Element of NAT st 1<=j & j <= n holds IExec(WB4,t).
  intpos (p0+j) = t.intpos (p0+j)

  proof
    let t be State of SCMPDS,m be Element of NAT;
    set mp=m+pn, t1=IExec(l1 ';' l2,t);
    assume that
A181: t.a=0 and
A182: t.SBP=m and
A183: t.intpos (mp+1) <= t.intpos mp;
A184: t1.a1=m by A168,A181,A182;
A185: t1.a2=t.intpos (mp+1)-t.intpos mp by A168,A181,A182;
    then
A186: t1.a2 <= 0 by A183,XREAL_1:49;
    set li=AddTo(GBP,1,-2), t0=Initialized t1;
A187: lb is_halting_on t1 by SCMPDS_6:35;
A188: t1.a=0 by A168,A181,A182;
    then
A189: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
A190: t0.a=0 by A188,SCMPDS_5:40;
    then
A191: DataLoc(t0.a,1)=intpos (0+1) by SCMP_GCD:5;
A192: lb is_closed_on t1 by SCMPDS_6:34;
    then
A193: IF4 is_halting_on t1 by A189,A186,A187,SCMPDS_6:83;
A194: IF4 is_closed_on t1 by A189,A186,A192,A187,SCMPDS_6:83;
A195: now
      let x;
      thus IExec(WB4,t).x = IExec(IF4,t1).x by A194,A193,SCPISORT:8
        .=IExec(lb,t1).x by A183,A185,A189,SCMPDS_6:88,XREAL_1:49
        .=Exec(li,t0).x by SCMPDS_5:45;
    end;
A196: now
      let i be Element of NAT;
      assume
      i <> 1;
      then
A197: intpos i <> DataLoc(t0.a,1) by A190,AMI_3:52,SCMP_GCD:5;
      thus IExec(WB4,t).intpos i=Exec(li,t0).intpos i by A195
        .=t0.intpos i by A197,SCMPDS_2:60
        .=t1.intpos i by SCMPDS_5:40;
    end;
    hence IExec(WB4,t).a=0 by A188;
    thus IExec(WB4,t).a1=Exec(li,t0).a1 by A195
      .=t0.a1+-2 by A191,SCMPDS_2:60
      .=t0.a1-2
      .=m-2 by A184,SCMPDS_5:40;
    hereby
      let j be Element of NAT;
      assume that
A198: 1<=j and
      j<m;
      pn+j >= pn+1 by A198,XREAL_1:8;
      then
A199: pn+j >= 8 by A179,XXREAL_0:2;
      then
A200: pn+j > 2 by XXREAL_0:2;
      pn+j > 1 by A199,XXREAL_0:2;
      hence IExec(WB4,t).intpos(pn+j)=t1.intpos(pn+j) by A196
        .=t.intpos(pn+j) by A168,A181,A182,A200;
    end;
    hereby
      let j be Element of NAT;
      assume that
A201: 1<=j and
      j<=n;
A202: p0+1 >= 7+1 by A4,XREAL_1:8;
      p0+j >= p0+1 by A201,XREAL_1:8;
      then
A203: p0+j >= 8 by A202,XXREAL_0:2;
      then
A204: p0+j > 2 by XXREAL_0:2;
      p0+j > 1 by A203,XXREAL_0:2;
      hence IExec(WB4,t).intpos(p0+j)=t1.intpos(p0+j) by A196
        .=t.intpos(p0+j) by A168,A181,A182,A204;
    end;
  end;

A205: for t be State of SCMPDS,m1,md be Element of NAT st t.a=0 & t.SBP=m1 &
  t.intpos(m1+pn)=md & md >= p0+1 & t.intpos(m1+pn+1)-md > 0 holds TR
  is_closed_on t & TR is_halting_on t

  proof
    let t be State of SCMPDS,m1,md be Element of NAT;
    set lPt=l3 ';' l4 ';' Pt, t2=IExec(l3 ';' l4, t), mp=m1+pn;
    assume that
A206: t.a=0 and
A207: t.SBP=m1 and
A208: t.intpos mp=md and
A209: md >= p0+1 and
    t.intpos (mp+1)-md > 0;
A210: t2.a=0 by A6,A206,A207;
A211: t2.a2=t.intpos mp by A6,A206,A207;
    then
A212: Pt is_halting_on t2 by A4,A208,A209,A210,Th13;
A213: Pt is_closed_on t2 by A4,A208,A209,A211,A210,Th13;
    then
A214: lPt is_halting_on t by A212,SCPISORT:10;
    lPt is_closed_on t by A213,A212,SCPISORT:10;
    hence thesis by A214,SCPISORT:9;
  end;

A215: for t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer, f1,

f2 be FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md & md

>= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn & f1 is_FinSequence_on t,

p0 & len f1=n & f2 is_FinSequence_on IExec(WB4,t),p0 & len f2=n holds IExec(WB4

,t).a=0 & IExec(WB4,t).a1=m1+2 & md=IExec(WB4,t).intpos(m1+pn) & n4=IExec(WB4,t

).intpos (m1+pn+3) & (for j be Element of NAT st (1<=j & j<m1) holds IExec(WB4,
  t).intpos(pn+j)=t.intpos(pn+j)) & f1,f2 are_fiberwise_equipotent & ex m4 be

Element of NAT st md <= m4 & m4 <= n4 & m4-1=IExec(WB4,t).intpos (m1+pn+1) & m4
  +1=IExec(WB4,t).intpos (m1+pn+2) & (for i be Element of NAT st md<=i & i < m4
  holds IExec(WB4,t).intpos m4 >= IExec(WB4,t).intpos i) & (for i be Element of

NAT st m4 < i & i <= n4 holds IExec(WB4,t).intpos m4 <= IExec(WB4,t).intpos i)

& for j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n holds IExec(WB4
  ,t).intpos j = t.intpos j

  proof

    let t be State of SCMPDS,m,m1,md be Element of NAT,n4 be Integer, f1,f2 be
    FinSequence of INT;

    set mp=m1+pn, t1=IExec(l1 ';' l2,t);
    assume that
A216: t.a=0 and
A217: t.SBP=m1 and
A218: m1=m+1 and
A219: t.intpos mp=md and
A220: md >= p0+1 and
A221: n4=t.intpos (mp+1) and
A222: n4-md > 0 and
A223: n4 <= pn;
A224: t1.a2 > 0 by A168,A216,A217,A219,A221,A222;
A225: mp >= 0+7 by A5,XREAL_1:9;
    then mp > 2 by XXREAL_0:2;
    then
A226: t1.intpos mp=md by A168,A216,A217,A219;
    assume that
A227: f1 is_FinSequence_on t,p0 and
A228: len f1=n;
A229: p0+1>= 7+1 by A4,XREAL_1:8;
    now
      let i be Element of NAT;
      assume that
A230: 1 <= i and
A231: i <= len f1;
      p0+i >= p0+1 by A230,XREAL_1:8;
      then p0+i >= 8 by A229,XXREAL_0:2;
      then
A232: p0+i > 2 by XXREAL_0:2;
      thus f1.i=t.intpos(p0+i) by A227,A230,A231,SCPISORT:def 1
        .= t1.intpos(p0+i) by A168,A216,A217,A232;
    end;
    then
A233: f1 is_FinSequence_on t1,p0 by SCPISORT:def 1;
    mp+1 >= 7+1 by A225,XREAL_1:8;
    then mp+1 > 2 by XXREAL_0:2;
    then
A234: n4=t1.intpos (mp+1) by A168,A216,A217,A221;
A235: t1.a=0 by A168,A216,A217;
    then
A236: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
A237: t1.SBP=m1 by A168,A216,A217;
    then
A238: TR is_halting_on t1 by A205,A220,A222,A226,A234,A235;
A239: TR is_closed_on t1 by A205,A220,A222,A237,A226,A234,A235;
    then
A240: IF4 is_halting_on t1 by A236,A224,A238,SCMPDS_6:82;
    assume that
A241: f2 is_FinSequence_on IExec(WB4,t),p0 and
A242: len f2=n;
A243: IF4 is_closed_on t1 by A236,A224,A239,A238,SCMPDS_6:82;
A244: now
      let x;
      thus IExec(WB4,t).x = IExec(IF4,t1).x by A243,A240,SCPISORT:8
        .=IExec(TR,t1).x by A236,A224,A239,A238,Th1;
    end;
    now
      let i be Element of NAT;
      assume that
A245: 1 <= i and
A246: i <= len f2;
      thus f2.i=IExec(WB4,t).intpos(p0+i) by A241,A245,A246,SCPISORT:def 1
        .= IExec(TR,t1).intpos(p0+i) by A244;
    end;
    then
A247: f2 is_FinSequence_on IExec(TR,t1),p0 by SCPISORT:def 1;

    then IExec(TR,t1).a=0 by A77,A218,A220,A222,A223,A228,A242,A237,A226,A234
,A235,A233;

    hence IExec(WB4,t).a=0 by A244;
    consider m4 be Element of NAT such that
A248: md <= m4 and
A249: m4 <= n4 and
A250: m4-1=IExec(TR,t1).intpos (mp+1) and
A251: m4+1=IExec(TR,t1).intpos (mp+2) and

A252: for i be Element of NAT st md<=i & i < m4 holds IExec(TR,t1).
    intpos m4 >= IExec(TR,t1).intpos i and

A253: for i be Element of NAT st m4 < i & i <= n4 holds IExec(TR,t1).
    intpos m4 <= IExec(TR,t1).intpos i and

A254: for j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n

holds IExec(TR,t1).intpos j = t1.intpos j by A77,A218,A220,A222,A223,A228,A242
,A237,A226,A234,A235,A233,A247;

    IExec(TR,t1).a1=m1+2 by A77,A218,A220,A222,A223,A228,A242,A237,A226,A234
,A235,A233,A247;

    hence IExec(WB4,t).a1=m1+2 by A244;

    md=IExec(TR,t1).intpos mp by A77,A218,A220,A222,A223,A228,A242,A237,A226
,A234,A235,A233,A247;

    hence md=IExec(WB4,t).intpos mp by A244;

    n4=IExec(TR,t1).intpos (mp+3) by A77,A218,A220,A222,A223,A228,A242,A237
,A226,A234,A235,A233,A247;

    hence n4=IExec(WB4,t).intpos (mp+3) by A244;
    hereby
      let j be Element of NAT;
      assume that
A255: 1<=j and
A256: j<m1;
      pn+j >= pn+1 by A255,XREAL_1:8;
      then pn+j >= 8 by A179,XXREAL_0:2;
      then
A257: pn+j > 2 by XXREAL_0:2;
      thus IExec(WB4,t).intpos(pn+j)=IExec(TR,t1).intpos(pn+j) by A244

        .=t1.intpos(pn+j) by A77,A218,A220,A222,A223,A228,A242,A237,A226,A234
,A235,A233,A247,A255,A256

        .=t.intpos(pn+j) by A168,A216,A217,A257;
    end;

    thus f1,f2 are_fiberwise_equipotent by A77,A218,A220,A222,A223,A228,A242
,A237,A226,A234,A235,A233,A247;

    take m4;
    thus md <= m4 & m4 <= n4 by A248,A249;
    thus m4-1=IExec(WB4,t).intpos (mp+1) by A244,A250;
    thus m4+1=IExec(WB4,t).intpos (mp+2) by A244,A251;
    hereby
      let i be Element of NAT;
      assume that
A258: md<=i and
A259: i < m4;
      IExec(TR,t1).intpos m4 >= IExec(TR,t1).intpos i by A252,A258,A259;
      then IExec(WB4,t).intpos m4 >= IExec(TR,t1).intpos i by A244;
      hence IExec(WB4,t).intpos m4 >= IExec(WB4,t).intpos i by A244;
    end;
    hereby
      let i be Element of NAT;
      assume that
A260: m4 < i and
A261: i <= n4;
      IExec(TR,t1).intpos m4 <= IExec(TR,t1).intpos i by A253,A260,A261;
      then IExec(WB4,t).intpos m4 <= IExec(TR,t1).intpos i by A244;
      hence IExec(WB4,t).intpos m4 <= IExec(WB4,t).intpos i by A244;
    end;
    hereby
      let j be Element of NAT;
      assume that
A262: p0+1<=j & j<md or n4<j & j <= p0+n;
      now
        per cases by A262;
        suppose
          p0+1<=j & j<md;
          hence p0+1<=j;
        end;
        suppose
          n4<j & j <= p0+n;
          then j >= m4 by A249,XXREAL_0:2;
          then j >= md by A248,XXREAL_0:2;
          hence j >= p0+1 by A220,XXREAL_0:2;
        end;
      end;
      then j >= 8 by A229,XXREAL_0:2;
      then
A263: j > 2 by XXREAL_0:2;
      thus IExec(WB4,t).intpos j = IExec(TR,t1).intpos j by A244
        .=t1.intpos j by A254,A262
        .=t.intpos j by A168,A216,A217,A263;
    end;
  end;
  consider f be FinSequence of INT such that
A264: len f=n and
A265: f is_FinSequence_on s,p0 by SCPISORT:3;
A266: pn+2 >= 7+2 by A5,XREAL_1:8;

A267: s1.a=0 & s1.a1=1 & s1.intpos(pn+1)=p0+1 & s1.intpos(pn+2)=pn & for i
  be Element of NAT st i >= 8 & i <= pn holds s1.intpos i=s.intpos i

  proof

    set t0=Initialized s, t2=IExec(m1 ';' m2 ';' m3,s), t3=IExec(m1 ';' m2,s),
    t4=Exec(m1, t0);

A268: t4.a =0 by SCMPDS_2:57;
A269: t3.a=Exec(m2, t4).a by SCMPDS_5:47
      .=0 by A268,SCMPDS_2:57,SCMP_GCD:7;
A270: t3.SBP=Exec(m2, t4).SBP by SCMPDS_5:47
      .=1 by SCMPDS_2:57;
    then
A271: DataLoc(t3.SBP,pn)=intpos (pn+1) by SCMP_GCD:5;
A272: t2.a=Exec(m3,t3).a by SCMPDS_5:46
      .=0 by A269,A271,AMI_3:52,SCMPDS_2:58;
A273: t2.intpos (pn+1)=Exec(m3,t3).intpos (pn+1) by SCMPDS_5:46
      .=p0+1 by A271,SCMPDS_2:58;
A274: pn+2 > 1 by A266,XXREAL_0:2;
A275: pn+1 > 1 by A179,XXREAL_0:2;
A276: t2.SBP=Exec(m3,t3).SBP by SCMPDS_5:46
      .=1 by A270,A271,A275,AMI_3:52,SCMPDS_2:58;
    then
A277: DataLoc(t2.SBP,pn+1)=intpos (pn+(1+1)) by SCMP_GCD:5;
    thus s1.a=Exec(m4,t2).a by SCMPDS_5:46
      .=0 by A272,A277,AMI_3:52,SCMPDS_2:58;
    thus s1.a1=Exec(m4,t2).SBP by SCMPDS_5:46
      .=1 by A276,A277,A274,AMI_3:52,SCMPDS_2:58;
A278: pn+2 > pn+1 by XREAL_1:8;
    thus s1.intpos (pn+1)=Exec(m4,t2).intpos (pn+1) by SCMPDS_5:46
      .=p0+1 by A273,A277,A278,AMI_3:52,SCMPDS_2:58;
    thus s1.intpos (pn+2)=Exec(m4,t2).intpos (pn+2) by SCMPDS_5:46
      .=pn by A277,SCMPDS_2:58;
A279: now
      let i be Element of NAT;
      assume
      i >= 8;
      hence t4.intpos i =t0.intpos i by AMI_3:52,SCMPDS_2:57
        .=s.intpos i by SCMPDS_5:40;
    end;
A280: now
      let i be Element of NAT;
      assume
A281: i >= 8;
      then
A282: i > 1 by XXREAL_0:2;
      thus t3.intpos i =Exec(m2, t4).intpos i by SCMPDS_5:47
        .=t4.intpos i by A282,AMI_3:52,SCMPDS_2:57
        .=s.intpos i by A279,A281;
    end;
A283: now
      let i be Element of NAT;
      assume that
A284: i >= 8 and
A285: i <=pn;
A286: pn+1 > pn by XREAL_1:31;
      thus t2.intpos i =Exec(m3, t3).intpos i by SCMPDS_5:46
        .=t3.intpos i by A271,A285,A286,AMI_3:52,SCMPDS_2:58
        .=s.intpos i by A280,A284;
    end;
    hereby
A287: pn+2 > pn+0 by XREAL_1:8;
      let i be Element of NAT;
      assume that
A288: i >= 8 and
A289: i <=pn;
      thus s1.intpos i =Exec(m4, t2).intpos i by SCMPDS_5:46
        .=t2.intpos i by A277,A289,A287,AMI_3:52,SCMPDS_2:58
        .=s.intpos i by A283,A288,A289;
    end;
  end;
  now
A290: p0+1 >= 7+1 by A4,XREAL_1:8;
    let i be Element of NAT;
    assume that
A291: 1 <= i and
A292: i <= len f;
A293: p0+i <= pn by A264,A292,XREAL_1:8;
    p0+i >= p0+1 by A291,XREAL_1:8;
    then
A294: p0+i >= 8 by A290,XXREAL_0:2;
    thus f.i=s.intpos(p0+i) by A265,A291,A292,SCPISORT:def 1
      .=s1.intpos(p0+i) by A267,A294,A293;
  end;
  then
A295: f is_FinSequence_on s1,p0 by SCPISORT:def 1;
  consider g be FinSequence of INT such that
A296: len g=n and
A297: g is_FinSequence_on IExec(QuickSort(n,p0),s),p0 by SCPISORT:3;
A298: b1=intpos(0+1) by SCMP_GCD:5;

A299: for t be State of SCMPDS,m,md be Element of NAT st t.a=0 & t.SBP=m & t
  .intpos(m+pn)=md & (md >= p0+1 or t.intpos(m+pn+1)-md <= 0) holds WB4
  is_closed_on t & WB4 is_halting_on t

  proof
    let t be State of SCMPDS,m,md be Element of NAT;
    set mp=m+pn, t1=IExec(l1 ';' l2,t);
    assume that
A300: t.a=0 and
A301: t.SBP=m and
A302: t.intpos mp=md and
A303: md >= p0+1 or t.intpos(mp+1)-md <= 0;
A304: t1.a2=t.intpos (mp+1)-t.intpos mp by A168,A300,A301;
A305: t1.a=0 by A168,A300,A301;
    then
A306: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
    per cases;
    suppose
A307: t1.DataLoc(t1.a,2) > 0;
A308: mp >= 0+7 by A5,XREAL_1:9;
      then mp+1 >= 7+1 by XREAL_1:8;
      then mp+1 > 2 by XXREAL_0:2;
      then
A309: t1.intpos(mp+1)-md > 0 by A168,A300,A301,A302,A304,A306,A307;
A310: t1.SBP=m by A168,A300,A301;
      mp > 2 by A308,XXREAL_0:2;
      then
A311: t1.intpos mp=md by A168,A300,A301,A302;

      then
A312: TR is_halting_on t1 by A205,A168,A300,A301,A302,A303,A305,A306,A307,A310
,A309;

A313: TR is_closed_on t1 by A205,A168,A300,A301,A302,A303,A305,A306,A307,A310
,A311,A309;

      then
A314: IF4 is_halting_on t1 by A307,A312,SCMPDS_6:82;
      IF4 is_closed_on t1 by A307,A313,A312,SCMPDS_6:82;
      hence thesis by A314,SCPISORT:10;
    end;
    suppose
A315: t1.DataLoc(t1.a,2) <= 0;
A316: lb is_halting_on t1 by SCMPDS_6:35;
A317: lb is_closed_on t1 by SCMPDS_6:34;
      then
A318: IF4 is_halting_on t1 by A315,A316,SCMPDS_6:83;
      IF4 is_closed_on t1 by A315,A317,A316,SCMPDS_6:83;
      hence thesis by A318,SCPISORT:10;
    end;
  end;
A319: now

    let t be State of SCMPDS,f1,f2 be FinSequence of INT, k1,k2,y1,yn be
    Element of NAT;

    set mm=2*k1+1, md=p0+y1, n4=p0+yn;
    assume that
A320: t.a=0 and
A321: mm=t.b1 and
A322: k2=pn+2*k1+1 and
A323: md=t.intpos k2 and
A324: n4=t.intpos(k2+1) and
A325: 1 <= y1 & yn <= n or y1 >= yn;
    set mp=mm+pn;
A326: md=t.intpos mp by A322,A323;
    now
      per cases by A325;
      case
        1 <= y1 & yn <= n;
        hence p0+1 <= md by XREAL_1:8;
      end;
      case
        y1 >= yn;
        then md >= t.intpos (mp+1) by A322,A324,XREAL_1:8;
        hence t.intpos (mp+1) -md <= 0 by XREAL_1:49;
      end;
    end;

    hence WB4 is_closed_on t & WB4 is_halting_on t by A299,A298,A320,A321,A326;

    consider f3 be FinSequence of INT such that
A327: len f3=n and

A328: for i be Element of NAT st 1<=i & i <= len f3 holds f3.i=t.
    intpos( p0+i) by SCPISORT:2;

    consider f4 be FinSequence of INT such that
A329: len f4=n and

A330: for i be Element of NAT st 1<=i & i <= len f4 holds f4.i=IExec(
    WB4,t).intpos(p0+i) by SCPISORT:2;

A331: f4 is_FinSequence_on IExec(WB4,t),p0 by A330,SCPISORT:def 1;
A332: f3 is_FinSequence_on t,p0 by A328,SCPISORT:def 1;
    hereby
      per cases;
      suppose
        t.intpos (mp+1) <= t.intpos mp;

        hence
        IExec(WB4,t).a=t.a & for j be Element of NAT st 1<=j & j<mm holds
        IExec(WB4,t).intpos(pn+j)=t.intpos(pn+j) by A180,A298,A320,A321;

      end;
      suppose
A333:   t.intpos (mp+1) > t.intpos mp;
        then
A334:   n4-md > 0 by A322,A323,A324,XREAL_1:52;
A335:   n4 <= pn by A322,A323,A324,A325,A333,XREAL_1:8;
        p0+1 <= md by A322,A323,A324,A325,A333,XREAL_1:8;

        hence
        IExec(WB4,t).a=t.a & for j be Element of NAT st 1<=j & j<mm holds

IExec(WB4,t).intpos(pn+j)=t.intpos(pn+j) by A215,A298,A320,A321,A322,A324,A326
,A327,A332,A329,A331,A334,A335;

      end;
    end;
    hereby
      assume
      y1>=yn;
      then
A336: t.intpos (mp+1) <= t.intpos mp by A322,A323,A324,XREAL_1:8;
      hence IExec(WB4,t).b1=2*k1+1-2 by A180,A298,A320,A321
        .=2*k1-1;

      thus for j be Element of NAT st 1<=j & j <= n holds IExec(WB4,t).intpos
      (p0+j) = t.intpos (p0+j) by A180,A298,A320,A321,A336;

    end;
A337: k2=mp by A322;
    hereby
      assume
A338: y1<yn;
      then
A339: p0+1 <= md by A325,XREAL_1:8;
      n4 > md by A338,XREAL_1:8;
      then
A340: n4-md > 0 by XREAL_1:52;
A341: n4 <= pn by A325,A338,XREAL_1:8;

      hence
      IExec(WB4,t).b1=2*k1+1+2 by A215,A298,A320,A321,A322,A324,A326,A327,A332
,A329,A331,A340,A339

        .=2*k1+3;
      consider m4 be Element of NAT such that
A342: md <= m4 and
A343: m4 <= n4 and
A344: m4-1=IExec(WB4,t).intpos (mp+1) and
A345: m4+1=IExec(WB4,t).intpos (mp+2) and

A346: for i be Element of NAT st md<=i & i < m4 holds IExec(WB4,t).
      intpos m4 >= IExec(WB4,t).intpos i and

A347: for i be Element of NAT st m4 < i & i <= n4 holds IExec(WB4,t)
      . intpos m4 <= IExec(WB4,t).intpos i and

A348: for j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n

holds IExec(WB4,t).intpos j = t.intpos j by A215,A298,A320,A321,A322,A323,A324
,A327,A332,A329,A331,A340,A339,A341;

      hereby
        let j be Element of NAT;
        assume
        1<=j & j<y1 or yn<j & j <= n;

        then p0+1<=p0+j & p0+j<md or n4<p0+j & p0+j <= p0+n by XREAL_1:8;

        hence IExec(WB4,t).intpos(p0+j) = t.intpos (p0+j) by A348;
      end;
      m4-p0 >= y1 by A342,XREAL_1:21;
      then reconsider ym=m4-p0 as Element of NAT by INT_1:16;
      take ym;
      m4=p0+ym;
      hence y1 <= ym & ym <= yn by A342,A343,XREAL_1:8;

      thus md=IExec(WB4,t).intpos k2 by A215,A298,A320,A321,A323,A324,A337,A327
,A332,A329,A331,A340,A339,A341;

      thus p0+ym-1=IExec(WB4,t).intpos (k2+1) by A322,A344;
      thus p0+ym+1=IExec(WB4,t).intpos (k2+2) by A322,A345;

      thus n4=IExec(WB4,t).intpos (k2+3) by A215,A298,A320,A321,A323,A324,A337
,A327,A332,A329,A331,A340,A339,A341;

      hereby
        let j be Element of NAT;
        assume that
A349:   y1 <= j and
A350:   j < ym;
A351:   p0+j < p0+ym by A350,XREAL_1:8;
        p0+y1 <= p0+j by A349,XREAL_1:8;

        hence
        IExec(WB4,t).intpos (p0+j) <= IExec(WB4,t).intpos (p0+ym) by A346,A351;

      end;
      hereby
        let j be Element of NAT;
        assume that
A352:   ym < j and
A353:   j <= yn;
A354:   p0+j <= p0+yn by A353,XREAL_1:8;
        p0+ym < p0+j by A352,XREAL_1:8;

        hence
        IExec(WB4,t).intpos (p0+j) >= IExec(WB4,t).intpos (p0+ym) by A347,A354;

      end;
    end;
    hereby
      assume that
A355: f1 is_FinSequence_on t,p0 and
A356: f2 is_FinSequence_on IExec(WB4,t),p0 and
A357: len f1=n and
A358: len f2=n;
      per cases;
      suppose
A359:   t.intpos (mp+1) <= t.intpos mp;
A360:   dom f1 = Seg n by A357,FINSEQ_1:def 3;
        now
          let i be Nat;
          reconsider a = i as Element of NAT by ORDINAL1:def 13;
          assume
A361:     i in dom f1;
          then
A362:     1 <= i by A360,FINSEQ_1:3;
A363:     i <= n by A360,A361,FINSEQ_1:3;
          hence f1.i = t.intpos(p0+a) by A355,A357,A362,SCPISORT:def 1

            .=IExec(WB4,t).intpos(p0+a) by A180,A298,A320,A321,A359,A362,A363

            .=f2.i by A356,A358,A362,A363,SCPISORT:def 1;
        end;
        hence f1,f2 are_fiberwise_equipotent by A357,A358,FINSEQ_2:10;
      end;
      suppose
A364:   t.intpos (mp+1) > t.intpos mp;
        then
A365:   n4-md > 0 by A322,A323,A324,XREAL_1:52;
A366:   n4 <= pn by A322,A323,A324,A325,A364,XREAL_1:8;
        p0+1 <= md by A322,A323,A324,A325,A364,XREAL_1:8;

        hence
        f1,f2 are_fiberwise_equipotent by A215,A298,A320,A321,A322,A324,A326
,A355,A356,A357,A358,A365,A366;

      end;
    end;
  end;
A367: s1.intpos(pn+1+1)=pn by A267;
  then
A368: WH4 is_closed_on s1 by A3,A298,A319,A267,Lm6;
A369: WH4 is_halting_on s1 by A3,A298,A319,A267,A367,Lm6;
  hence QuickSort(n,p0) is_halting_on s by A368,SCPISORT:10;
  take f,g;

  thus len f=n & f is_FinSequence_on s,p0 & len g=n & g is_FinSequence_on
  IExec(QuickSort(n,p0),s),p0 by A264,A265,A296,A297;

  now
    let i be Element of NAT;
    assume that
A370: 1 <= i and
A371: i <= len g;
    thus g.i=IExec(M4 ';' WH4,s).intpos(p0+i) by A297,A370,A371,SCPISORT:def 1
      .=IExec(WH4,s1).intpos(p0+i) by A369,A368,SCPISORT:8;
  end;
  then g is_FinSequence_on IExec(WH4,s1),p0 by SCPISORT:def 1;
  hence thesis by A3,A298,A319,A267,A367,A264,A296,A295,Lm4;
end;

begin :: The Basic Property of Quick Sort and Its Correctness

theorem
  card QuickSort(n,p0)=57 by Lm29;

theorem
  for p0,n being Element of NAT st p0 >= 7 holds QuickSort(n,p0) is
  parahalting
proof
  let p0,n be Element of NAT;
  assume
  p0 >= 7;
  then for s be State of SCMPDS holds QuickSort(n,p0) is_halting_on s by Lm29;
  hence thesis by SCMPDS_6:35;
end;

theorem
  for s being State of SCMPDS,p0,n being Element of NAT st p0 >= 7 holds
ex f,g be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 & len g = n
  & g is_FinSequence_on IExec(QuickSort(n,p0),s),p0 & f,g
  are_fiberwise_equipotent & g is_non_decreasing_on 1,n by Lm29;

