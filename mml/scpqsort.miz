:: Quick Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMPDS_2, SUBSET_1, FSM_1, SCMPDS_4, AMI_1, TURING_1,
      SCMFSA8A, SCMFSA_7, AMI_3, INT_1, SCMFSA8B, CARD_1, ARYTM_3, FUNCT_1,
      XXREAL_0, UNIALG_2, SCMFSA7B, SCMFSA6B, RELAT_1, FUNCT_4, AMI_2,
      SCMFSA_9, ARYTM_1, VALUED_1, TARSKI, GRAPHSP, CIRCUIT2,
      MSUALG_1, NAT_1, FUNCOP_1, CARD_3, SCMPDS_8, FINSEQ_1,
      GRAPH_2, SCPISORT, SCMP_GCD, CLASSES1, SCPQSORT, ORDINAL1,
      SCMNORM, SCMFSA6C, PBOOLE;
 notations TARSKI, XBOOLE_0, FUNCT_2, SUBSET_1, CARD_1, NUMBERS, XXREAL_0,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, PBOOLE,
      VALUED_1, XCMPLX_0, RECDEF_1, INT_1,
      NAT_1, STRUCT_0,
      EXTPRO_1, AMI_2, FUNCT_7, SCMPDS_2, SCMPDS_4,
      SCMPDS_5,
      SCMPDS_6, SCMP_GCD, CARD_3, FINSEQ_1, SCMPDS_8, GRAPH_2, CLASSES1,
      COMPOS_1, SCPISORT;
 constructors REAL_1, RECDEF_1, NEWTON, MESFUNC1, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT, CLASSES1, GRAPH_2,
      VALUED_1, AMI_2, SCMPDS_1, PRE_POLY, AMISTD_1, AMISTD_2, SCMPDS_7,
      PBOOLE, AMISTD_5;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMPDS_8,
      ORDINAL1, VALUED_0, VALUED_1, RELAT_1, COMPOS_1, AFINSQ_1,
      EXTPRO_1, FUNCT_4, FUNCT_7, FUNCOP_1, PRE_POLY, PBOOLE, SCMPDS_3;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMPDS_2, SCMP_GCD, COMPOS_1, EXTPRO_1, SCPISORT;::, SCMPDS_4;
 definitions TARSKI, FUNCT_7, XBOOLE_0,
      FUNCOP_1, NAT_1, AFINSQ_1, FUNCT_4;
 theorems AMI_3, NAT_1, TARSKI, FUNCT_4, SCMPDS_2, FUNCT_7, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_7, SCMPDS_8, FINSEQ_1, FINSEQ_2, RFINSEQ,
      SCPISORT, XBOOLE_1, XREAL_1, XXREAL_0, GRAPH_2, AMI_2,
      ORDINAL1, CLASSES1, SCMPDS_6, SCMP_GCD, INT_1, COMPOS_1, AFINSQ_1,
      EXTPRO_1, PBOOLE, AMISTD_2;
 schemes NAT_1, SCMPDS_8;

begin :: The Several Properties of "while" Program and Finite Sequence

reserve x for Int_position,
  n,p0 for Element of NAT;

Lm1: for s being State of SCMPDS, I,J being shiftable Program of SCMPDS, n
being Element of NAT holds I ';' Goto n ';' J is shiftable

proof

  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, n be Element
  of NAT;

  I ';' Goto n ';' J = I ';' Load (goto n) ';' J by SCMPDS_6:def 1;
  hence thesis;
end;

registration
  let I,J be shiftable Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> shiftable;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I + 2), G =Goto (card J+1);
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS by Lm1;
    if>0(a,k1,I,J) = i ';' I ';' G ';' J by SCMPDS_6:def 5
      .=i ';' (I ';' G) ';' J by SCMPDS_4:50
      .=i ';' IJ by SCMPDS_4:50
      .=Load i ';' IJ by SCMPDS_4:def 4;
    hence thesis;
  end;
end;

reserve P,Q,V for (the Instructions of SCMPDS)-valued ManySortedSet of NAT;

theorem Th1: :: see SCMPDS_6:87
  for s being State of SCMPDS,I being halt-free shiftable Program
  of SCMPDS, J being shiftable Program of SCMPDS,a,b be Int_position,k1 being
  Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s,P & I is_halting_on s,P
   holds
  IExec(if>0(a,k1,I,J),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a,b be Int_position,k1 be Integer;
  assume that
A1: s.DataLoc(s.a,k1)>0 and
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
A4: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  IExec(if>0(a,k1,I,J),P,s) = IExec(I,P,s) +*
   Start-At((card I+card J+2),SCMPDS)
   by A1,A2,A3,SCMPDS_6:84;
  hence thesis by A4,FUNCT_4:12;
end;
set A = NAT, D = SCM-Data-Loc;

Lm2: for a be Int_position,i be Integer,I be Program of SCMPDS holds while>0(a
,i,I)= ((a,i)<=0_goto (card I +2)) ';' (I ';' goto -(card I+1))

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2), i2=goto -(card I+1);
  thus while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
    .= i1 ';' (I ';' i2) by SCMPDS_4:51;
end;

Lm3: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A1: while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
    .= i1 ';' I ';' Load i2 by SCMPDS_4:def 5
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

theorem Th2:
  for s,sm be State of SCMPDS,I be halt-free shiftable Program of
  SCMPDS, a be Int_position,i be Integer, m be Element of NAT st card I>0 & I
  is_closed_on s,P & I is_halting_on s,P & s.DataLoc(s.a,i) > 0 &
   m=LifeSpan(P +* stop I,Initialize s)+2 &
 sm=Comput(P +* stop while>0(a,i,I),Initialize s,m)
 holds DataPart sm = DataPart IExec(I,P,s) &
   Initialize sm=sm
proof
  let s,sm be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a
  be Int_position,i be Integer,m be Element of NAT;
  set b=DataLoc(s.a,i);
  set WH =while>0(a,i,I), iWH= stop WH, IsI= stop I;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  set s2 = Initialize s, P2 = P +* stop I,
  s3 = Initialize s, P3 = P +* stop WH,
  s4 = Comput(P3,s3,1), P4 = P3;
  assume that
A3: card I>0 and
A4: I is_closed_on s,P and
A5: I is_halting_on s,P and
A6: s.b > 0 and
A7: m=LifeSpan(P2,s2)+2 and
A8: sm= Comput(P3,s3,m);
A9: IsI c= P2 by FUNCT_4:26;
B9: Start-At(0,SCMPDS) c= s2 by FUNCT_4:26;
A10: iWH c= P3 by FUNCT_4:26;
  WH c= iWH by  AFINSQ_1:78;
  then
A11: WH c= P3 by A10,XBOOLE_1:1;
  Shift(I,1) c= WH by Lm3;
  then Shift(I,1) c= P3 by A11,XBOOLE_1:1;
  then
A12: Shift(I,1) c= P4;
A13: WH = i1 ';' (I ';' i2) by Lm2;
A14: Comput(P3,s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A13,SCMPDS_6:22;
  set m2=LifeSpan(P2,s2), s5= Comput(P4, s4,m2), P5 = P4,
  l1=
(card I + 1);
A15: IC s3 = 0 by COMPOS_1:def 16;
TT:   not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
   not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
   then
A16: s3.DataLoc(s3.a,i)= s3.b by FUNCT_4:12
    .= s.b by TT,FUNCT_4:12;
  set m3=m2 +1;
  set s6= Comput(P3, s3,m3), P6 = P3;
A17: s6=s5 by EXTPRO_1:5;
  set s7= Comput(P3,s3,m3+1);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A18: l1 in dom WH by SCMPDS_8:18;
A19: dom ProgramPart s = A by COMPOS_1:34;
A20: I is_closed_on s2,P2 by A4,SCMPDS_6:38;
  now
    let x;
    thus s2.x = s3.x
      .= s4.x by A14,SCMPDS_2:68;
  end;
  then
A22: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A23: P2 halts_on s2 by A5,SCMPDS_6:def 3;
  P2 = P2+*stop I by A9,FUNCT_4:104;
  then P2+*stop I halts_on Initialize s2
     by A5,SCMPDS_6:def 3;
  then
A25: I is_halting_on s2,P2 by SCMPDS_6:def 3;
A26: IC s4 = s4.IC SCMPDS
    .= succ  0 by A6,A15,A14,A16,SCMPDS_2:68
    .= 0+1;
  then DataPart Comput(P2, s2,m2) = DataPart s5 by A3,A9,B9,A25,A20
,A22,A12,SCMPDS_7:36;
  then
A27: DataPart s5 = DataPart(Result(P2,s2)) by A23,EXTPRO_1:23
    .= DataPart(Result(P2,s2) +* s | A) by A19,AMI_2:29,FUNCT_4:76
,SCMPDS_2:100
    .= DataPart IExec(I,P,s) by SCMPDS_4:def 8;
A28: IC s5=l1 by A9,B9,A25,A20,A26,A22,A12,SCMPDS_7:36;
  then
A29: CurInstr(P6,s6)=P5.l1 by A17,PBOOLE:158
    .=P4.l1
    .=P3.l1
    .=WH.l1 by A18,A11,GRFUNC_1:8
    .=i2 by SCMPDS_8:19;
A30: s7 = Following(P3,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A29;
  now
    let x;
    thus sm.x=s6.x by A7,A8,A30,SCMPDS_2:66
      .=s5.x by EXTPRO_1:5;
  end;
  hence DataPart sm = DataPart IExec(I,P,s) by A27,SCMPDS_4:23;
  IC s7=s7.IC SCMPDS
    .=ICplusConst(s6,0-(card I+1)) by A30,SCMPDS_2:66
    .= 0 by A28,A17,SCMPDS_7:1;
  hence thesis by A7,A8,COMPOS_1:84;
end;

theorem Th3:
  for s be State of SCMPDS,I be Program of SCMPDS st for t be State
  of SCMPDS, Q st DataPart t = DataPart s holds I is_halting_on t,Q holds I
  is_closed_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: for t be State of SCMPDS,Q st DataPart t = DataPart s holds I
  is_halting_on t,Q;
  set pI=stop I, sI=Initialize s, PI = P +* pI;
  defpred X[Nat] means not IC Comput(PI,sI,$1) in dom pI;
A2: for a be Int_position holds s.a = sI.a
   proof let a be Int_position;
      not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
    hence thesis by FUNCT_4:12;
   end;
  assume not I is_closed_on s,P;
  then ex k be Element of NAT st X[k] by SCMPDS_6:def 2;
  then
A4: ex k be Nat st X[k];
  consider n be Nat such that
A5: X[n] and
A6: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A4);
  reconsider n as Element of NAT by ORDINAL1:def 13;
  set s2 = Comput(PI,sI,n), P2 = PI,
  Ig = ((IC s2,succ IC s2) --> (goto 1,goto -1)),
s0 = sI,
s1 = s2,
t1= sI, t2= t1, t3= s2, t4= t3;
  reconsider P0 = PI +* Ig as
   (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
  reconsider P1 = P2 +* Ig as
   (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
  reconsider P3 = PI +* (IC s2,goto 1)
      as (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
    reconsider P4 = P3 +* (succ IC s2,goto -1)
      as (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
U:   P0 = P4 by FUNCT_7:141;
B9: not succ IC s2 in dom stop I by A5,AFINSQ_1:77;
A11: NPP s0 = NPP sI;
A13: for m be Element of NAT st m < n holds IC( Comput(PI, sI,m))
in dom
  pI by A6;
A17: stop I c= PI by  FUNCT_4:26;
  not IC s2 in dom pI by A5;
  then pI c= P3 by FUNCT_4:26,FUNCT_7:91;
  then pI c= P4 by B9,FUNCT_7:91;
  then
A18: stop I c= P0 by U;
  then NPP Comput(P0,s0,n) = NPP s2 by A11,A17,A13,SCMPDS_4:67;
  then
XX: NPP Comput(P0,s0,n) = NPP s1;
  DataPart s0 = DataPart sI
    .= DataPart s by A2,SCMPDS_4:23;
  then I is_halting_on s0,P0 by A1;
  then
A20: P0+*pI halts_on Initialize s0
   by SCMPDS_6:def 3;
A21: not P0 halts_on s1 by SCMPDS_4:66;
   P0 +* pI=P0 by A18,FUNCT_4:104;
   then P0 halts_on Comput(P0,s0,n) by A20,EXTPRO_1:22;
   then P0 halts_on s1 by XX,AMISTD_2:69;
  hence contradiction by A21;
end;

theorem Th4:
  for i1,i2,i3,i4 be Instruction of SCMPDS holds card (i1 ';' i2
  ';' i3 ';' i4)=4
proof
  let x1,x2,x3,x4 be Instruction of SCMPDS;
  thus card (x1 ';' x2 ';' x3 ';' x4)=card (x1 ';' x2 ';' x3)+1 by SCMP_GCD:8
    .=card (x1 ';' x2 )+1+1 by SCMP_GCD:8
    .=2+1+1 by SCMP_GCD:9
    .=4;
end;

theorem Th5:
  for s being State of SCMPDS,I being halt-free shiftable Program
  of SCMPDS, a,x,y be Int_position, i,c be Integer st card I > 0 & s.x >= c+s.
DataLoc(s.a,i) &
(for t be State of SCMPDS,Q st t.x >= c+t.DataLoc(s.a,i) & t.y=s
.y & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q &
I is_halting_on t,Q & IExec(I,Q,t).DataLoc(s.a,i) < t.DataLoc(s.a,i)
 & IExec(I,Q,t).x
  >= c+IExec(I,Q,t).DataLoc(s.a,i) & IExec(I,Q,t).y=t.y)
 holds while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P &
 (s.DataLoc(s.a,i) > 0 implies
  IExec(while>0(a,i,I),P,s) =IExec(while>0(a,i,I),P,IExec(I,P,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,x1,
  y1 be Int_position, i,c be Integer;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume s.x1 >= c+s.b;
  then
A2: for x st x in {x1} holds s.x >= c+s.b by TARSKI:def 1;
  assume
A3: for t be State of SCMPDS,Q st t.x1 >= c+t.b & t.y1=s.y1 & t.a=s.a & t.
b > 0 holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).b < t.b
  & IExec(I,Q,t).x1 >= c+IExec(I,Q,t).b & IExec(I,Q,t).y1=t.y1;
  now
    let t be State of SCMPDS, Q;
    assume that
A4: for x st x in {x1} holds t.x >= c+t.b and
A5: for x st x in {y1} holds t.x=s.x and
A6: t.a=s.a and
A7: t.b > 0;
    y1 in {y1} by TARSKI:def 1;
    then
A8: t.y1=s.y1 by A5;
    x1 in {x1} by TARSKI:def 1;
    then
A9: t.x1 >= c+t.b by A4;
    hence
    IExec(I,Q,t).a=t.a & I is_closed_on t,Q
     & I is_halting_on t,Q & IExec(I,Q,t).
    b < t.b by A3,A6,A7,A8;
    hereby
      let x;
      assume
A10:  x in {x1};
      IExec(I,Q,t).x1 >= c+IExec(I,Q,t).b by A3,A6,A7,A9,A8;
      hence IExec(I,Q,t).x >= c+IExec(I,Q,t).b by A10,TARSKI:def 1;
    end;
    hereby
      let x;
      assume
A11:  x in {y1};
      hence IExec(I,Q,t).x=IExec(I,Q,t).y1 by TARSKI:def 1
        .=t.y1 by A3,A6,A7,A9,A8
        .=t.x by A11,TARSKI:def 1;
    end;
  end;
  hence thesis by A1,A2,SCMPDS_8:27;
end;

theorem Th6:
  for s being State of SCMPDS,I being halt-free shiftable Program
  of SCMPDS, a,x,y be Int_position, i,c be Integer st s.x >= c & (
for t be State of SCMPDS,Q
 st t.x >= c & t.y=s.y & t.a=s.a & t.DataLoc(s.a,i) > 0
  holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q
   & I is_halting_on t,Q & IExec(I,Q,t).
DataLoc(s.a,i) < t.DataLoc(s.a,i) & IExec(I,Q,t).x >= c
 & IExec(I,Q,t).y=t.y) holds
while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P
 & ( s.DataLoc(s.
  a,i) > 0
   implies IExec(while>0(a,i,I),P,s) =IExec(while>0(a,i,I),P,IExec(I,P,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer;
  set b=DataLoc(s.a,i);
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x >= c & t.y=s.y;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b <= 0 implies f.s =0) & (s.b > 0
  implies f.s=s.b) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = f.$1;
A3: for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
  proof
    let t be State of SCMPDS;
    thus F(Dstate t)=0 implies t.b <= 0
    proof
      assume
A4:   F(Dstate t)=0;
      assume t.b > 0;
      then (Dstate t).b > 0 by SCMPDS_8:4;
      hence contradiction by A2,A4;
    end;
    assume t.b <= 0;
    then (Dstate t).b <= 0 by SCMPDS_8:4;
    hence thesis by A2;
  end;
  then
A5: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
  assume
A6: s.x >= c;
A7: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    thus t.x >= c by A6,SCMPDS_8:4;
    thus thesis by SCMPDS_8:4;
  end;
  assume
A8: for t be State of SCMPDS,Q st t.x >= c & t.y=s.y & t.a=s.a & t.b > 0
holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).b <
  t.b & IExec(I,Q,t).x >= c & IExec(I,Q,t).y=t.y;
A9: now
    let t be State of SCMPDS, Q;
    assume that
A10: P[Dstate t] and
A11: t.a=s.a and
A12: t.b > 0;
    set It=IExec(I,Q,t), t2=Dstate It, t1=Dstate t;
A13: t.y=s.y by A10,SCMPDS_8:4;
A14: t.x >= c by A10,SCMPDS_8:4;
    hence
    IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
     by A8,A11,A12,A13;
    thus F(t2) < F(t1)
    proof
      t1.b > 0 by A12,SCMPDS_8:4;
      then
A15:  F(t1)=t1.b by A2
        .=t.b by SCMPDS_8:4;
      assume
A16:  F(t2) >= F(t1);
      then It.b > 0 by A3,A12,A15;
      then t2.b > 0 by SCMPDS_8:4;
      then F(t2)=t2.b by A2
        .=It.b by SCMPDS_8:4;
      hence contradiction by A8,A11,A12,A14,A13,A16,A15;
    end;
    thus P[Dstate It]
    proof
      take v=Dstate It;
      thus v=Dstate It;
      It.x >= c by A8,A11,A12,A14,A13;
      hence v.x >= c by SCMPDS_8:4;
      It.y=t.y by A8,A11,A12,A14,A13;
      hence thesis by A13,SCMPDS_8:4;
    end;
  end;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s,P & while>0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 3(A5,A7,A9);
  hence while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P;
  assume
A17: s.b > 0;
  (F(s)=F(s) or P[s]) & IExec(while>0(a,i,I),P,s)
   = IExec(while>0(a,i,I),P,IExec(I,P,s)) from SCMPDS_8:sch 4(A17,A5,A7,A9);
  hence thesis;
end;

theorem Th7:
  for s being State of SCMPDS,I being halt-free shiftable Program
of SCMPDS, a,x1,x2,x3,x4 be Int_position, i,c,md be Integer st s.
x4=s.x3-c+s.x1 & md <= s.x3-c &
 (for t be State of SCMPDS,Q st t.x4=t.x3-c+t.x1 &
md <= t.x3-c & t.x2=s.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I,Q,t).a=t.
  a & I is_closed_on t,Q & I is_halting_on t,Q
   & IExec(I,Q,t).DataLoc(s.a,i) < t.
DataLoc(s.a,i) & IExec(I,Q,t).x4=IExec(I,Q,t).x3-c+IExec(I,Q,t).x1
 & md <= IExec(I,Q,t)
.x3-c & IExec(I,Q,t).x2=t.x2) holds while>0(a,i,I) is_closed_on s,P
 & while>0(a,i,I
  ) is_halting_on s,P & ( s.DataLoc(s.a,i) > 0
   implies IExec(while>0(a,i,I),P,s) =
  IExec(while>0(a,i,I),P,IExec(I,P,s)) )
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,x1,
  x2,x3,x4 be Int_position, i,c,md be Integer;
  set b=DataLoc(s.a,i);
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x4=t.x3-c+t.x1 & md
  <= t.x3-c & t.x2=s.x2;
  assume that
A2: s.x4=s.x3-c+s.x1 and
A3: md <= s.x3-c;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4: for s be State of SCMPDS holds (s.b <= 0 implies f.s =0) & (s.b > 0
  implies f.s=s.b) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = f.$1;
A5: for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
  proof
    let t be State of SCMPDS;
    thus F(Dstate t)=0 implies t.b <= 0
    proof
      assume
A6:   F(Dstate t)=0;
      assume t.b > 0;
      then (Dstate t).b > 0 by SCMPDS_8:4;
      hence contradiction by A4,A6;
    end;
    assume t.b <= 0;
    then (Dstate t).b <= 0 by SCMPDS_8:4;
    hence thesis by A4;
  end;
  then
A7: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
  assume
A8: for t be State of SCMPDS,Q st t.x4=t.x3-c+t.x1 & md <= t.x3-c & t.x2=s
.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,Q,t).a=t.a
 & I is_closed_on t,Q
& I is_halting_on t,Q & IExec(I,Q,t).DataLoc(s.a,i) < t.DataLoc(s.a,i)
 & IExec(I,Q,t)
.x4=IExec(I,Q,t).x3-c+IExec(I,Q,t).x1 & md <= IExec(I,Q,t).x3-c
 & IExec(I,Q,t).x2=t.x2;
A9: now
    let t be State of SCMPDS, Q;
    assume that
A10: P[Dstate t] and
A11: t.a=s.a and
A12: t.b > 0;
    set It=IExec(I,Q,t), t2=Dstate It, t1=Dstate t;
    consider v be State of SCMPDS such that
A13: v=Dstate t and
A14: v.x4=v.x3-c+v.x1 and
A15: md <= v.x3-c and
A16: v.x2=s.x2 by A10;
A17: t.x2=s.x2 by A13,A16,SCMPDS_8:4;
    t.x4=v.x3-c+v.x1 by A13,A14,SCMPDS_8:4;
    then t.x4=t.x3-c+v.x1 by A13,SCMPDS_8:4;
    then
A18: t.x4=t.x3-c+t.x1 by A13,SCMPDS_8:4;
A19: md <= t.x3-c by A13,A15,SCMPDS_8:4;
    hence
    IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
     by A8,A11,A12,A18
,A17;
    thus F(t2) < F(t1)
    proof
      t1.b > 0 by A12,SCMPDS_8:4;
      then
A20:  F(t1)=t1.b by A4
        .=t.b by SCMPDS_8:4;
      assume
A21:  F(t2) >= F(t1);
      then It.b > 0 by A5,A12,A20;
      then t2.b > 0 by SCMPDS_8:4;
      then F(t2)=t2.b by A4
        .=It.b by SCMPDS_8:4;
      hence contradiction by A8,A11,A12,A18,A19,A17,A21,A20;
    end;
    thus P[Dstate It]
    proof
      take v=Dstate It;
      thus v=Dstate It;
      It.x4=It.x3-c+It.x1 by A8,A11,A12,A18,A19,A17;
      then v.x4=It.x3-c+It.x1 by SCMPDS_8:4;
      then v.x4=v.x3-c+It.x1 by SCMPDS_8:4;
      hence v.x4=v.x3-c+v.x1 by SCMPDS_8:4;
      md <= It.x3-c by A8,A11,A12,A18,A19,A17;
      hence md <= v.x3-c by SCMPDS_8:4;
      It.x2=t.x2 by A8,A11,A12,A18,A19,A17;
      hence thesis by A17,SCMPDS_8:4;
    end;
  end;
A22: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    t.x4=s.x3-c+s.x1 by A2,SCMPDS_8:4;
    then t.x4=t.x3-c+s.x1 by SCMPDS_8:4;
    hence t.x4=t.x3-c+t.x1 by SCMPDS_8:4;
    thus md <= t.x3-c by A3,SCMPDS_8:4;
    thus thesis by SCMPDS_8:4;
  end;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s,P & while>0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 3(A7,A22,A9);
  hence while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P;
  assume
A23: s.b > 0;
  (F(s)=F(s) or P[s]) & IExec(while>0(a,i,I),P,s) = IExec(while>0(a,i,I),P,
  IExec(I,P,s)) from SCMPDS_8:sch 4(A23,A7,A22,A9);
  hence thesis;
end;

theorem Th8:
  for f being FinSequence of INT,m,k1,k,n be Element of NAT st k1=k
  -1 & f is_non_decreasing_on m,k1 & f is_non_decreasing_on k+1,n & (for i be
  Element of NAT st m <= i & i < k holds f.i <= f.k) & (for i be Element of NAT
  st k < i & i <= n holds f.k <= f.i) holds f is_non_decreasing_on m,n
proof
  let f be FinSequence of INT,m,k1,k,n be Element of NAT;
  assume that
A1: k1=k-1;
  assume
A2: f is_non_decreasing_on m,k1;
  assume
A3: f is_non_decreasing_on k+1,n;
  assume
A4: for i be Element of NAT st m <= i & i < k holds f.i <= f.k;
  assume
A5: for i be Element of NAT st k < i & i <= n holds f.k <= f.i;
  now
    let i,j be Element of NAT;
    assume that
A6: m <= i and
A7: i <= j and
A8: j <= n;
    per cases by XXREAL_0:1;
    suppose
      j < k;
      then j+1 <= k by INT_1:20;
      then j <= k1 by A1,XREAL_1:21;
      hence f.i <= f.j by A2,A6,A7,GRAPH_2:def 13;
    end;
    suppose
A9:   j = k;
      hereby
        per cases;
        suppose
          i=j;
          hence f.i <= f.j;
        end;
        suppose
          i<>j;
          then i<j by A7,XXREAL_0:1;
          hence f.i <= f.j by A4,A6,A9;
        end;
      end;
    end;
    suppose
A10:  j > k;
      hereby
        per cases by XXREAL_0:1;
        suppose
          i < k;
          then
A11:      f.k >= f.i by A4,A6;
          f.j >= f.k by A5,A8,A10;
          hence f.i <= f.j by A11,XXREAL_0:2;
        end;
        suppose
A12:      i = k;
          hereby
            per cases;
            suppose
              i=j;
              hence f.i <= f.j;
            end;
            suppose
              i<>j;
              then i<j by A7,XXREAL_0:1;
              hence f.i <= f.j by A5,A8,A12;
            end;
          end;
        end;
        suppose
          i > k;
          then i >= k+1 by INT_1:20;
          hence f.i <= f.j by A3,A7,A8,GRAPH_2:def 13;
        end;
      end;
    end;
  end;
  hence thesis by GRAPH_2:def 13;
end;

Lm4: for s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,f,g be FinSequence of INT,m,n,m1 be Element of
NAT st card I> 0 & s.a=c & len f=n & len g=n & f is_FinSequence_on s,m & g
is_FinSequence_on IExec(while>0(a,i,I),P,s),m & 1=s.DataLoc(c,i)
 & m1=m+n+1 & m+1
=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be State of SCMPDS,Q
 for f1,f2 be
FinSequence of INT,k1,k2,y1, yn be Element of NAT st t.a=c & 2*k1+1=t.DataLoc(c
,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & (1 <= y1 & yn <=
n or y1 >= yn) holds I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).a=t.a &
(for j be Element of NAT st (1<=j & j<2*k1+1)
 holds IExec(I,Q,t).intpos(m+n+j)=t.
intpos(m+n+j)) & (y1>=yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1-1 & (for j be
Element of NAT st (1<=j & j <= n)
 holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j
))) & (y1<yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1+3
 & (for j be Element of NAT
st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos(m+j) = t.intpos (m+
j)) & (ex ym be Element of NAT st y1 <= ym & ym <= yn
 & m+y1=IExec(I,Q,t).intpos
k2 & m+ym-1=IExec(I,Q,t).intpos (k2+1) & m+ym+1=IExec(I,Q,t).intpos (k2+2)
 & m+yn=
IExec(I,Q,t).intpos (k2+3) &
 (for j be Element of NAT st y1 <= j & j < ym holds
IExec(I,Q,t).intpos (m+j) <= IExec(I,Q,t).intpos (m+ym)) &
 (for j be Element of NAT
st ym < j & j <= yn holds IExec(I,Q,t).intpos (m+j)
 >= IExec(I,Q,t).intpos (m+ym)))
) & (f1 is_FinSequence_on t,m
 & f2 is_FinSequence_on IExec(I,Q,t),m & len f1=n &
len f2=n implies f1,f2 are_fiberwise_equipotent)) holds while>0(a,i,I)
is_halting_on s,P & f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n

proof

  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,f,g be FinSequence of INT, m,n,m1 be Element of
  NAT;

  set b=DataLoc(c,i);
  assume that
A1: card I>0 and
A2: s.a=c and
A3: len f=n and
A4: len g=n;
  set WH =while>0(a,i,I), sWH=stop WH;
  assume
A5: f is_FinSequence_on s,m;

  defpred P[Element of NAT] means
   for t be State of SCMPDS,Q
   for f1 be FinSequence of INT, k1,k2,y1,yn be Element of NAT
    st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
     (1 <= y1 & yn <= n or y1 >= yn) &
     m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & yn-y1<=$1 &
     f1 is_FinSequence_on t,m & len f1=n
   ex k be Element of NAT,f2 be FinSequence of INT
    st Initialize Comput(Q+*sWH,Initialize t,k)
          = Comput(Q+*sWH,Initialize t,k) &
    f2 is_FinSequence_on
     Comput(Q+*sWH,Initialize t,k),m & len f2=n &
    f1,f2 are_fiberwise_equipotent &
    f2 is_non_decreasing_on y1,yn &
    (for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
      holds f2.j= t.intpos(m+j)) &
    (for j be Element of NAT st y1>=yn & 1<=j & j<= n
     holds f2.j= t.intpos(m+j)) &
    (for j be Element of NAT st 1<=j & j<2*k1+1
     holds Comput(Q+*sWH,Initialize t,k).intpos(m+n+j)=t.intpos(m+n+j)) &
    Comput(Q+*sWH,Initialize t,k).b=t.b-2 &
    Comput(Q+*sWH,Initialize t,k).a=c;

  assume
A6: g is_FinSequence_on IExec(while>0(a,i,I),P,s),m;
  assume
A7: 1=s.b;
  assume that
A8: m1=m+n+1 and
A9: m+1=s.intpos m1 and
A10: m+n=s.intpos(m1+1);
A11: m1=m+n+2*0+1 by A8;
  assume

A12: for t be State of SCMPDS,Q
 for f1,f2 be FinSequence of INT, k1,k2,y1,yn

be Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+

yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
 holds I is_closed_on t,Q & I

is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Element of NAT
 st (1<=j & j<2*k1+1)
  holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn
 implies IExec(I,Q,t).b=2*k1-1 & for j be Element of NAT st 1<=j & j <= n
 holds IExec(I,Q,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,Q,t).b=2*k1+3 & (for j be

Element of NAT st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=
  IExec(I,Q,t).intpos k2 & m+ym-1=IExec(I,Q,t).intpos (k2+1)
   & m+ym+1=IExec(I,Q,t).

intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3) &
 (for j be Element of NAT st y1

<= j & j < ym holds IExec(I,Q,t).intpos(m+j) <= IExec(I,Q,t).intpos(m+ym))
 & for j

be Element of NAT st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >= IExec(I,Q,t).intpos(m+ym) )
  & (f1 is_FinSequence_on t,m
 & f2 is_FinSequence_on IExec(I,Q,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

A13: P[0]
  proof
    let t be State of SCMPDS,Q;
    let f1 be FinSequence of INT,k1,k2,y1,yn be Element of NAT;
    assume that
A14: t.a=c and
A15: 2*k1+1=t.b and
A16: k2=m+n+2*k1+1 and
A17: 1 <= y1 & yn <= n or y1 >= yn and
A18: m+y1=t.intpos k2 and
A19: m+yn=t.intpos(k2+1) and
A20: yn-y1<=0 and
A21: f1 is_FinSequence_on t,m and
A22: len f1=n;
A23: I is_halting_on t,Q by A12,A14,A15,A16,A17,A18,A19;
    take k=LifeSpan(Q+*stop I,Initialize t)+2;
    set tk= Comput(Q+*sWH,Initialize t,k);
A24: I is_closed_on t,Q by A12,A14,A15,A16,A17,A18,A19;
    then
A25: DataPart tk = DataPart IExec(I,Q,t) by A1,A14,A15,A23,Th2;
    consider f2 be FinSequence of INT such that
A26: len f2=n and

A27: for i be Element of NAT st 1<=i & i <= len f2
 holds f2.i=IExec(I,Q,t) .intpos(m+i) by SCPISORT:2;

    take f2;
    thus Initialize tk =tk by A1,A14,A15,A24,A23,Th2;
    now
      let i be Element of NAT;
      assume that
A28:  1<=i and
A29:  i <= len f2;
      thus f2.i=IExec(I,Q,t).intpos(m+i) by A27,A28,A29
        .=tk.intpos(m+i) by A25,SCMPDS_4:23;
    end;
    hence f2 is_FinSequence_on tk,m by SCPISORT:def 1;
    thus len f2=n by A26;
    f2 is_FinSequence_on IExec(I,Q,t),m by A27,SCPISORT:def 1;

    hence
    f1,f2 are_fiberwise_equipotent by A12,A14,A15,A16,A17,A18,A19,A21,A22,A26;

    thus f2 is_non_decreasing_on y1,yn by A20,GRAPH_2:67,XREAL_1:52;

    thus for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
    holds f2.j= t.intpos(m+j) by A20,XREAL_1:52;

    hereby
      let j be Element of NAT;
      assume that
A30:  y1>=yn and
A31:  1<=j and
A32:  j<= n;
      thus f2.j=IExec(I,Q,t).intpos (m+j) by A26,A27,A31,A32
        .=t.intpos(m+j) by A12,A14,A15,A16,A18,A19,A30,A31,A32;
    end;
    hereby
      let j be Element of NAT;
      assume that
A33:  1<=j and
A34:  j<2*k1+1;
      thus tk.intpos(m+n+j)=IExec(I,Q,t).intpos(m+n+j) by A25,SCMPDS_4:23
        .=t.intpos(m+n+j) by A12,A14,A15,A16,A17,A18,A19,A33,A34;
    end;

    y1>=yn implies IExec(I,Q,t).b=2*k1-1 & for j be Element of NAT st 1<=j

& j <= n holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j)
 by A12,A14,A15,A16,A18
,A19;

    hence tk.b=t.b-2 by A15,A20,A25,SCMPDS_4:23,XREAL_1:52;
    IExec(I,Q,t).a=t.a by A12,A14,A15,A16,A17,A18,A19;
    hence thesis by A14,A25,SCMPDS_4:23;
  end;
A35: now
    let k be Element of NAT;
    assume
A36: P[k];
    P[k+1]
    proof
      let t be State of SCMPDS,Q;
      let f1 be FinSequence of INT, k1,k2,y1,yn be Element of NAT;
      assume that
A37:  t.a=c and
A38:  2*k1+1=t.b and
A39:  k2=m+n+2*k1+1 and
A40:  1 <= y1 & yn <= n or y1 >= yn and
A41:  m+y1=t.intpos k2 and
A42:  m+yn=t.intpos(k2+1) and
A43:  yn-y1<=k+1 and
A44:  f1 is_FinSequence_on t,m and
A45:  len f1=n;
      per cases;
      suppose
        yn-y1<=0;

        hence
        ex kk be Element of NAT,f2 be FinSequence of INT st
         Initialize Comput(Q+*sWH,Initialize t,kk)
    = Comput(Q+*sWH,Initialize t,kk) &
    f2 is_FinSequence_on
     Comput(Q+*sWH,Initialize t,kk),m &
    len f2=n & f1,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on

y1,yn & (for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n) holds

f2.j= t.intpos(m+j)) & (for j be Element of NAT st y1>=yn & 1<=j & j<= n holds

f2.j= t.intpos(m+j)) & (for j be Element of NAT st (1<=j & j<2*k1+1) holds

Comput(Q+*sWH,Initialize t,kk).intpos(m+n+j)
=t.intpos(m+n+j)) &
 Comput(Q+*sWH,Initialize t,kk).b=
 t.b-2 & Comput(Q+*sWH,Initialize t,kk).a=c
  by A13,A37,A38,A39,A40,A41,A42,A44,A45;

      end;
      suppose
A46:    yn-y1>0;
        set m1=LifeSpan(Q+*stop I,Initialize t)+2;
        set t1= Comput(Q+*sWH,Initialize t,m1),
            Q1 = Q+*sWH;
A47:    I is_halting_on t,Q by A12,A37,A38,A39,A40,A41,A42;
        y1-1 >= 0 by A40,A46,XREAL_1:49,50;
        then reconsider y0=y1-1 as Element of NAT by INT_1:16;
        set jj=2*k1+1;
A48:    yn-y1-1 <= k+1-1 by A43,XREAL_1:11;
A49:    yn <= y1+(k+1) by A43,XREAL_1:22;
        consider f2 be FinSequence of INT such that
A50:    len f2=n and

A51:    for i be Element of NAT st 1<=i & i <= len f2 holds f2.i=t1.
        intpos( m+i) by SCPISORT:2;

A52:    f2 is_FinSequence_on t1,m by A51,SCPISORT:def 1;
        set It=IExec(I,Q,t);

A53:    y1<yn implies It.b=2*k1+3 & (for j be Element of NAT st 1<=j & j

<y1 or yn<j & j <= n holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j))
 & ex ym

be Element of NAT st y1 <= ym & ym <= yn & m+y1=It.intpos k2 & m+ym-1=It.intpos

(k2+1) & m+ym+1=It.intpos (k2+2) & m+yn=It.intpos (k2+3) & (for j be Element of

NAT st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos(m+j) <= IExec(I,Q,t).intpos(m+ym)

) & for j be Element of NAT st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >=
        IExec(I,Q,t).intpos(m+ym) by A12,A37,A38,A39,A40,A41,A42;

        then consider ym be Element of NAT such that
A54:    y1 <= ym and
A55:    ym <= yn and
A56:    m+y1=It.intpos k2 and
A57:    m+ym-1=It.intpos (k2+1) and
A58:    m+ym+1=It.intpos (k2+2) and
A59:    m+yn=It.intpos (k2+3) and

A60:    for j be Element of NAT st y1 <= j & j < ym holds IExec(I,Q,t).
        intpos(m+j) <= IExec(I,Q,t).intpos(m+ym) and

A61:    for j be Element of NAT st ym < j & j <= yn holds IExec(I,Q,t).
        intpos(m+j) >= IExec(I,Q,t).intpos(m+ym) by A46,XREAL_1:49;

A62:    I is_closed_on t,Q by A12,A37,A38,A39,A40,A41,A42;
        then
A63:    DataPart t1 = DataPart IExec(I,Q,t) by A1,A37,A38,A47,Th2;
        then
A64:    t1.b=2*k1+3 by A46,A53,SCMPDS_4:23,XREAL_1:49;
A65:    ym >= 1 by A40,A46,A54,XREAL_1:49,XXREAL_0:2;
        then reconsider yc=ym-1 as Element of NAT by INT_1:16,XREAL_1:50;
A66:    yc <= yn by A55,XREAL_1:148,XXREAL_0:2;
        then
A67:    yc <= n by A40,A46,XREAL_1:49,XXREAL_0:2;
A68:    t1.b=2*(k1+1)+1 by A46,A53,A63,SCMPDS_4:23,XREAL_1:49;
        IExec(I,Q,t).a=t.a by A12,A37,A38,A39,A40,A41,A42;
        then
A69:    t1.a=c by A37,A63,SCMPDS_4:23;
        set k3=m+n+2*(k1+1)+1, yd=ym+1;
A70:    yd > ym by XREAL_1:31;
        then
A71:    yd >= y1 by A54,XXREAL_0:2;
        then
A72:    yd >= 1 by A40,A46,XREAL_1:49,XXREAL_0:2;
A73:    t1.intpos(k3+1)=m+yn by A39,A63,A59,SCMPDS_4:23;
        ym+(1+k) >= y1+(1+k) by A54,XREAL_1:8;
        then yn <= yd+k by A49,XXREAL_0:2;
        then
A74:    yn-yd<=k by XREAL_1:22;
        t1.intpos k3=m+yd by A39,A63,A58,SCMPDS_4:23;
        then consider kl be Element of NAT,f3 be FinSequence of INT such that
A75:    Initialize Comput(Q1+*sWH,Initialize t1,kl)
        = Comput(Q1+*sWH,Initialize t1,kl) and
A76:    f3 is_FinSequence_on Comput(Q1+*sWH,
             Initialize t1,kl),m and
A77:    len f3=n and
A78:    f2,f3 are_fiberwise_equipotent and
A79:    f3 is_non_decreasing_on yd,yn and

A80:    for j be Element of NAT st yd<yn & (1<=j & j<yd or yn<j & j<=
        n) holds f3.j= t1.intpos(m+j) and

A81:    for j be Element of NAT st yd>=yn & 1<=j & j<= n holds f3.j=
        t1. intpos(m+j) and

A82:    for j be Element of NAT st 1<=j & j<2*(k1+1)+1 holds
        Comput(Q1+*sWH,Initialize t1,kl).
               intpos(m+n+j)
        =t1.intpos(m+n+j)
and
A83:    Comput(Q1+*sWH,Initialize t1,kl).b=t1.b-2
 and

A84:    Comput(Q1+*sWH,Initialize t1,kl).a
          =c by A36,A40,A46,A69,A68,A72,A73,A74,A50,A52,XREAL_1:49;
A85: Q1+*sWH+*sWH = Q1+*sWH by  FUNCT_4:99;

        set t2= Comput(Q1+*sWH,Initialize t1,kl),
            Q2 = Q1+*sWH;
A86:    2*k1+3=2*(k1+1)+1;
        then jj < 2*(k1+1)+1 by XREAL_1:8;
        then
A87:    t2.intpos k2=t1.intpos(m+n+jj) by A39,A82,NAT_1:11
          .=m+y1 by A39,A63,A56,SCMPDS_4:23;
A88:    ym <= n by A40,A46,A55,XREAL_1:49,XXREAL_0:2;
A89:    now
          per cases;
          suppose
            yd<yn;
            hence f3.ym= t1.intpos(m+ym) by A70,A80,A65;
          end;
          suppose
            yd>=yn;
            hence f3.ym= t1.intpos(m+ym) by A81,A65,A88;
          end;
        end;
A90:    now
          let i be Element of NAT;
          assume that
A91:      1<=i and
A92:      i<=ym;
A93:      i<=n by A88,A92,XXREAL_0:2;
A94:      i<yd by A70,A92,XXREAL_0:2;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.i= t1.intpos(m+i) by A80,A91,A94;
            end;
            suppose
              yd>=yn;
              hence f3.i= t1.intpos(m+i) by A81,A91,A93;
            end;
          end;
          hence f3.i=f2.i by A50,A51,A91,A93;
        end;
        yc <= yn-1 by A55,XREAL_1:11;
        then yc-y1 <= yn-1-y1 by XREAL_1:11;
        then
A95:    yc-y1<=k by A48,XXREAL_0:2;
A96:    yc < yd by A70,XREAL_1:148,XXREAL_0:2;
        set jj=2*k1+2;
        jj >= 2 by NAT_1:11;
        then
A97:    jj >= 1 by XXREAL_0:2;
        jj < 2*(k1+1)+1 by A86,XREAL_1:8;
        then t2.intpos (k2+1)=t1.intpos(m+n+jj) by A39,A82,A97
          .=m+yc by A39,A63,A57,SCMPDS_4:23;
        then consider km be Element of NAT,f4 be FinSequence of INT such that
A98:    Initialize Comput(Q2+*sWH,Initialize t2,km)
          = Comput(Q2+*sWH,Initialize t2,km) and
A99:    f4 is_FinSequence_on Comput(Q2+*sWH,Initialize t2,km),m and
A100:    len f4=n and
A101:   f3,f4 are_fiberwise_equipotent and
A102:   f4 is_non_decreasing_on y1,yc and

A103:   for j be Element of NAT st y1<yc & (1<=j & j<y1 or yc<j & j
        <= n) holds f4.j= t2.intpos(m+j) and

A104:   for j be Element of NAT st y1>=yc & 1<=j & j<= n holds f4.j=
        t2. intpos(m+j) and

A105:   for j be Element of NAT st 1<=j & j<2*k1+1
 holds Comput(Q2+*sWH,Initialize t2,km).
            intpos(m+n+j)=t2.intpos(m+n+j) and
A106:   Comput(Q2+*sWH,Initialize t2,km).
              b=t2.b-2 and

A107:   Comput(Q2+*sWH,Initialize t2,km).a
       =c by A36,A39,A40,A46,A64,A76,A77,A83,A84,A67,A87,A95,XREAL_1:49;

A108:   now
          let i be Element of NAT;
          assume that
A109:     yc<i and
A110:     i<=len f4;
A111:     1+0 <= i by A109,INT_1:20;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.i= t2.intpos(m+i) by A100,A103,A109,A110;
            end;
            suppose
              y1>=yc;
              hence f4.i= t2.intpos(m+i) by A100,A104,A110,A111;
            end;
          end;
          hence f4.i=f3.i by A76,A77,A100,A110,A111,SCPISORT:def 1;
        end;
        then f4.ym=f3.ym by A100,A88,XREAL_1:148;
        then
A112:   f4.ym=IExec(I,Q,t).intpos(m+ym) by A63,A89,SCMPDS_4:23;
A113:   now
          let i be Element of NAT;
          assume that
A114:     yn<i and
A115:     i<=len f3;
A116:     1+0<=i by A114,INT_1:20;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.i= t1.intpos(m+i) by A77,A80,A114,A115;
            end;
            suppose
              yd>=yn;
              hence f3.i= t1.intpos(m+i) by A77,A81,A115,A116;
            end;
          end;
          hence f3.i=f2.i by A50,A51,A77,A115,A116;
        end;
A117:   now
          let i be Element of NAT;
          assume that
A118:     ym < i and
A119:     i <= yn;
          consider j be Element of NAT such that
A120:     ym<j and
A121:     j<=yn and

A122:     f3.i=f2.j by A40,A46,A55,A77,A78,A90,A113,A118,A119,RFINSEQ:45
,XREAL_1:49;

A123:     yc < i by A118,XREAL_1:148,XXREAL_0:2;
A124:     1<=j by A65,A120,XXREAL_0:2;
A125:     j<=len f2 by A40,A46,A50,A121,XREAL_1:49,XXREAL_0:2;
          i<=len f4 by A40,A46,A100,A119,XREAL_1:49,XXREAL_0:2;
          then f4.i=f2.j by A108,A123,A122
            .=t1.intpos(m+j) by A51,A124,A125
            .=IExec(I,Q,t).intpos(m+j) by A63,SCMPDS_4:23;
          hence f4.ym <= f4.i by A61,A112,A120,A121;
        end;
A126:   yn>y1 by A46,XREAL_1:49;
A127:   now
          let i be Element of NAT;
          assume that
A128:     1<=i and
A129:     i<=y0;
          i-1 < y1-1 by A129,XREAL_1:148,XXREAL_0:2;
          then
A130:     i<y1 by XREAL_1:11;
          y1 <= n by A40,A126,XXREAL_0:2;
          then
A131:     i<=n by A130,XXREAL_0:2;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.i= t2.intpos(m+i) by A103,A128,A130;
            end;
            suppose
              y1>=yc;
              hence f4.i= t2.intpos(m+i) by A104,A128,A131;
            end;
          end;
          hence f4.i=f3.i by A76,A77,A128,A131,SCPISORT:def 1;
        end;
A132:   y0 <= yc by A54,XREAL_1:11;
A133:   now
          let i be Element of NAT;
          assume that
A134:     y1 <= i and
A135:     i < ym;
          i+1 <= ym by A135,INT_1:20;
          then
A136:     i<=yc by XREAL_1:21;
          y0 < i by A134,XREAL_1:148,XXREAL_0:2;
          then consider j be Element of NAT such that
A137:     y0<j and
A138:     j<=yc and

A139:     f4.i=f3.j by A67,A100,A101,A132,A127,A108,A136,RFINSEQ:45;

A140:     1+0 <= j by A137,INT_1:20;
A141:     j<= n by A67,A138,XXREAL_0:2;
A142:     j<yd by A96,A138,XXREAL_0:2;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.j= t1.intpos(m+j) by A80,A140,A142;
            end;
            suppose
              yd>=yn;
              hence f3.j= t1.intpos(m+j) by A81,A140,A141;
            end;
          end;
          then
A143:     f4.i=IExec(I,Q,t).intpos(m+j) by A63,A139,SCMPDS_4:23;
A144:     j < ym by A138,XREAL_1:148,XXREAL_0:2;
          y1-1+1 <= j by A137,INT_1:20;
          hence f4.i <= f4.ym by A60,A112,A144,A143;
        end;
        take mm=m1+(kl+km);
        set tm=Comput(Q+*sWH,Initialize t,mm);
        take f4;
A145: Q1+*sWH = Q+*sWH by FUNCT_4:99;
        Initialize t1 =t1 by A1,A37,A38,A62,A47,Th2;
        then
A146:   tm = Comput(Q+*sWH,Initialize t1,kl+km) by EXTPRO_1:5
         .= Comput(Q1+*sWH,Initialize t1,kl+km)
            by A145
          .= Comput(Q2+*sWH,Initialize t2,km)
          by A75,A85,EXTPRO_1:5;
        hence Initialize tm =tm by A98;
        thus f4 is_FinSequence_on tm,m by A99,A146;
        thus len f4=n by A100;
        now
          let i be Element of NAT;
          assume that
A147:     1<=i and
A148:     i <= len f2;
          thus f2.i=t1.intpos(m+i) by A51,A147,A148
            .=IExec(I,Q,t).intpos(m+i) by A63,SCMPDS_4:23;
        end;
        then f2 is_FinSequence_on IExec(I,Q,t),m by SCPISORT:def 1;

        then f1,f2 are_fiberwise_equipotent by A12,A37,A38,A39,A40,A41,A42,A44
,A45,A50;

        then f1,f3 are_fiberwise_equipotent by A78,CLASSES1:84;
        hence f1,f4 are_fiberwise_equipotent by A101,CLASSES1:84;
A149:   now
          let j be Element of NAT;
          assume that
A150:     yd<=j and
A151:     j<=yn;
A152:     1<=j by A72,A150,XXREAL_0:2;
A153:     j <= n by A40,A46,A151,XREAL_1:49,XXREAL_0:2;
A154:     yc < j by A96,A150,XXREAL_0:2;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.j=t2.intpos(m+j) by A103,A153,A154;
            end;
            suppose
              y1>=yc;
              hence f4.j=t2.intpos(m+j) by A104,A153,A152;
            end;
          end;
          hence f4.j=f3.j by A76,A77,A153,A152,SCPISORT:def 1;
        end;
        now
          let i,j be Element of NAT;
          assume that
A155:     yd <= i and
A156:     i <= j and
A157:     j <= yn;
          yd <= j by A155,A156,XXREAL_0:2;
          then
A158:     f4.j=f3.j by A149,A157;
          i <= yn by A156,A157,XXREAL_0:2;
          then f4.i=f3.i by A149,A155;
          hence f4.i <= f4.j by A79,A155,A156,A157,A158,GRAPH_2:def 13;
        end;
        then f4 is_non_decreasing_on yd,yn by GRAPH_2:def 13;
        hence f4 is_non_decreasing_on y1,yn by A102,A133,A117,Th8;

        thus for j be Element of NAT st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
        holds f4.j= t.intpos(m+j)

        proof
          let j be Element of NAT;
          assume that
A159:     y1<yn and
A160:     1<=j & j<y1 or yn<j & j<= n;
A161:     1<=j & j<= n
          proof
            per cases by A160;
            suppose
A162:         1<=j & j<y1;
              then j<yn by A159,XXREAL_0:2;
              hence thesis by A40,A46,A162,XREAL_1:49,XXREAL_0:2;
            end;
            suppose
A163:         yn<j & j<=n;
              then y1 < j by A159,XXREAL_0:2;
              hence thesis by A40,A46,A163,XREAL_1:49,XXREAL_0:2;
            end;
          end;
A164:     1<=j & j<yd or yn<j & j<= n
          proof
            per cases by A160;
            suppose
              1<=j & j<y1;
              hence thesis by A71,XXREAL_0:2;
            end;
            suppose
              yn<j & j<=n;
              hence thesis;
            end;
          end;
A165:     now
            per cases;
            suppose
              yd<yn;
              hence f3.j=t1.intpos(m+j) by A80,A164;
            end;
            suppose
              yd>=yn;
              hence f3.j=t1.intpos(m+j) by A81,A161;
            end;
          end;
A166:     1<=j & j<y1 or yc<j & j<= n
          proof
            per cases by A160;
            suppose
              1<=j & j<y1;
              hence thesis;
            end;
            suppose
              yn<j & j<=n;
              hence thesis by A66,XXREAL_0:2;
            end;
          end;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.j=t2.intpos(m+j) by A103,A166;
            end;
            suppose
              y1>=yc;
              hence f4.j=t2.intpos(m+j) by A104,A161;
            end;
          end;
          hence f4.j=f3.j by A76,A77,A161,SCPISORT:def 1
            .=IExec(I,Q,t).intpos(m+j) by A63,A165,SCMPDS_4:23
            .=t.intpos(m+j) by A12,A37,A38,A39,A40,A41,A42,A159,A160;
        end;

        thus for j be Element of NAT st y1>=yn & 1<=j & j<= n holds f4.j=t.
        intpos(m+j) by A46,XREAL_1:49;

        hereby
          let j be Element of NAT;
          assume that
A167:     1<=j and
A168:     j<2*k1+1;
          2*k1+1 < 2*(k1+1)+1 by A86,XREAL_1:8;
          then
A169:     j < 2*(k1+1)+1 by A168,XXREAL_0:2;
          thus tm.intpos(m+n+j)=t2.intpos(m+n+j) by A105,A146,A167,A168
            .=t1.intpos(m+n+j) by A82,A167,A169
            .=IExec(I,Q,t).intpos(m+n+j) by A63,SCMPDS_4:23
            .=t.intpos(m+n+j) by A12,A37,A38,A39,A40,A41,A42,A167,A168;
        end;
        thus tm.b=t.b-2 by A38,A64,A83,A106,A146;
        thus tm.a=c by A107,A146;
      end;
    end;
    hence P[k+1];
  end;
A170: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A35);

  ex k be Element of NAT,f2 be FinSequence of INT st
   Initialize Comput(P+*sWH,Initialize s,k)
   = Comput(P+*sWH,Initialize s,k) &
   f2 is_FinSequence_on Comput(P+*sWH,Initialize s,k),m &

len f2=n & f,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n & (for j

be Element of NAT st 1<n & (1<=j & j<1 or n<j & j<= n) holds f2.j= s.intpos(m+j

)) & (for j be Element of NAT st 1>=n & 1<=j & j<= n holds f2.j= s.intpos(m+j))
  & (for j be Element of NAT st (1<=j & j<2*0+1) holds
   Comput(P+*sWH,Initialize s,k).

intpos(m+n+j)=s.intpos(m+n+j)) &
Comput(P+*sWH,Initialize s,k).b=s.b-2 &
Comput(P+*sWH,Initialize s,k).a=c

  proof
    per cases;
    suppose
      n-1<=0;
      hence thesis by A2,A3,A5,A7,A9,A10,A13,A11;
    end;
    suppose
      n-1>0;
      then reconsider nn=n-1 as Element of NAT by INT_1:16;
      P[nn] by A170;
      hence thesis by A2,A3,A5,A7,A9,A10,A11;
    end;
  end;
  then consider k be Element of NAT,f2 be FinSequence of INT such that
A171: Initialize Comput(P+*sWH,Initialize s,k)
= Comput(P+*sWH,Initialize s,k) and
A172: f2 is_FinSequence_on
    Comput(P+*sWH,Initialize s,k),m and
A173: len f2=n and
A174: f,f2 are_fiberwise_equipotent and
A175: f2 is_non_decreasing_on 1,n and
A176: Comput(P+*sWH,Initialize s,k).b=s.b-2 and
A177: Comput(P+*sWH,Initialize s,k).a=c;
  set sk= Comput(P+*sWH,Initialize s,k),
      s1 = Initialize sk, P1 = P+*sWH+*sWH,
      s2 = Comput(P1,s1,1), P2 = P1;
A179: IC s1 = 0 by COMPOS_1:def 16;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A180: card WH=card I+2 by SCMPDS_8:17;
  then
A181: (card I+2) in dom sWH by SCMPDS_6:25;
A182: dom g = Seg n by A4,FINSEQ_1:def 3;
  sWH c= P1 by FUNCT_4:26;
  then sWH c= P2;
  then
A183: P2.(card I+2) = sWH.(card I+2) by A181,GRFUNC_1:8
    .=halt SCMPDS by A180,SCMPDS_6:25;
A184: WH = i1 ';' (I ';' i2 ) by Lm2;
A185: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A184,SCMPDS_6:22;
  IC s2 = s2.IC SCMPDS
    .= ICplusConst(s1,(card I+2)) by A7,A171,A176,A177,A185,SCMPDS_2:68
    .= 0+(card I+2) by A179,SCMPDS_6:23;
  then
A187: CurInstr(P2,s2) = halt SCMPDS by A183,PBOOLE:158;
 P+*sWH+*sWH = P+*sWH by  FUNCT_4:99;
 then
A188: s2= Comput(P+*sWH,Initialize s,k+1) by A171,EXTPRO_1:5;
A189:   P+*sWH = P2 by  FUNCT_4:99;
  then
A190: P+*sWH halts_on Initialize s
 by A187,A188,EXTPRO_1:30;
  hence WH is_halting_on s,P by SCMPDS_6:def 3;
A191: Result(P+*sWH,Initialize s)=s2
 by A187,A188,A190,A189,EXTPRO_1:def 8;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    set xi=intpos (m+a);
A192: dom ProgramPart s = A by COMPOS_1:34;
A193: not xi in dom (s | A) by A192,SCMPDS_2:53;
    assume
A194: i in dom g;
    then
A195: 1 <= i by A182,FINSEQ_1:3;
A196: i <= n by A182,A194,FINSEQ_1:3;
    IExec(WH,P,s)=s2 +* s | A by A191,SCMPDS_4:def 8;
    hence g.i=(s2 +* s | A).xi by A4,A6,A195,A196,SCPISORT:def 1
      .=s2.xi by A193,FUNCT_4:12
      .=s1.xi by A185,SCMPDS_2:68
      .=f2.i by A171,A172,A173,A195,A196,SCPISORT:def 1;
  end;
  hence thesis by A4,A173,A174,A175,FINSEQ_2:10;
end;

Lm5: for s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,m,n,m1 be Element of NAT st card I> 0 & s.a=c &
1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be State of SCMPDS,Q
  for f1,f2 be FinSequence of INT, k1,k2,y1,yn be Element of NAT st t
.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos
(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I
is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Element of NAT
 st (1<=j & j<2*k1
+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn
 implies IExec(I,Q,t).DataLoc(c,i)=2*k1-1
  & (for j be Element of NAT st (1<=j & j <= n) holds IExec
(I,Q,t).intpos (m+j) = t.intpos (m+j))) & (y1<yn
 implies IExec(I,Q,t).DataLoc(c,i)=
2*k1+3 & (for j be Element of NAT st 1<=j & j<y1 or yn<j & j <= n holds
IExec(I,Q,t).intpos(m+j) = t.intpos (m+j))
 & (ex ym be Element of NAT st y1 <= ym
& ym <= yn & m+y1=IExec(I,Q,t).intpos k2
 & m+ym-1=IExec(I,Q,t).intpos (k2+1) & m+ym
+1=IExec(I,Q,t).intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Element
of NAT st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos (m+j) <= IExec(I,Q,t).intpos (
m+ym)) & (for j be Element of NAT st ym < j & j <= yn
 holds IExec(I,Q,t).intpos (
m+j) >= IExec(I,Q,t).intpos (m+ym)))) & (f1 is_FinSequence_on t,m & f2
is_FinSequence_on IExec(I,Q,t),m & len f1=n & len f2=n implies f1,f2
are_fiberwise_equipotent)) holds while>0(a,i,I) is_halting_on s,P

proof

  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,m,n,m1 be Element of NAT;

  set b=DataLoc(c,i);
  assume that
A1: card I>0 and
A2: s.a=c;
  consider f be FinSequence of INT such that
A3: len f=n and

A4: for i be Element of NAT st 1<=i & i <= len f holds f.i=s.intpos(m+i)
  by SCPISORT:2;

A5: f is_FinSequence_on s,m by A4,SCPISORT:def 1;
  set ss=IExec(while>0(a,i,I),P,s);
  assume
A6: 1=s.b;
  consider g be FinSequence of INT such that
A7: len g=n and

A8: for i be Element of NAT st 1<=i & i <= len g holds g.i=ss.intpos(m+
  i ) by SCPISORT:2;

A9: g is_FinSequence_on ss,m by A8,SCPISORT:def 1;
  assume that
A10: m1=m+n+1 and
A11: m+1=s.intpos m1 and
A12: m+n=s.intpos(m1+1);
  assume
  for t be State of SCMPDS,Q
  for f1,f2 be FinSequence of INT, k1,k2,y1,yn be

Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=
  t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I

is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Element of NAT
 st (1<=j & j<2*k1

+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j))
 & (y1>=yn implies IExec(I,Q,t).b=2*k1-1
  & for j be Element of NAT st 1<=j & j <= n
 holds IExec(I,Q,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,Q,t).b=2*k1+3 & (for j be

Element of NAT st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=
  IExec(I,Q,t).intpos k2 & m+ym-1=IExec(I,Q,t).intpos (k2+1)
   & m+ym+1=IExec(I,Q,t).

intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Element of NAT st y1

<= j & j < ym
 holds IExec(I,Q,t).intpos(m+j) <= IExec(I,Q,t).intpos(m+ym)) & for j

be Element of NAT st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >= IExec(I,Q,t).intpos(m+ym) )
  & (f1 is_FinSequence_on t,m
 & f2 is_FinSequence_on IExec(I,Q,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

  hence thesis by A1,A2,A6,A10,A11,A12,A3,A5,A7,A9,Lm4;
end;

Lm6: for s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,m,n,m1 be Element of NAT st card I> 0 & s.a=c &
1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be State of SCMPDS,Q
  for f1,f2 be FinSequence of INT, k1,k2,y1,yn be Element of NAT st t
.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos
(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I
is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Element of NAT
 st (1<=j & j<2*k1
+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j))
 & (y1>=yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1-1
  & (for j be Element of NAT st (1<=j & j <= n) holds IExec
(I,Q,t).intpos (m+j) = t.intpos (m+j)))
 & (y1<yn implies IExec(I,Q,t).DataLoc(c,i)=
2*k1+3 & (for j be Element of NAT st 1<=j & j<y1 or yn<j & j <= n holds
IExec(I,Q,t).intpos(m+j) = t.intpos (m+j))
 & (ex ym be Element of NAT st y1 <= ym
& ym <= yn & m+y1=IExec(I,Q,t).intpos k2
 & m+ym-1=IExec(I,Q,t).intpos (k2+1) & m+ym
+1=IExec(I,Q,t).intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Element
of NAT st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos (m+j) <= IExec(I,Q,t).intpos (
m+ym)) & (for j be Element of NAT st ym < j & j <= yn
 holds IExec(I,Q,t).intpos (
m+j) >= IExec(I,Q,t).intpos (m+ym)))) & (f1 is_FinSequence_on t,m & f2
is_FinSequence_on IExec(I,Q,t),m & len f1=n & len f2=n implies f1,f2
are_fiberwise_equipotent)) holds while>0(a,i,I) is_halting_on s,P
 & while>0(a,i,I
) is_closed_on s,P

proof

  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,m,n,m1 be Element of NAT;

  set b=DataLoc(c,i);
  assume
A1: card I>0;
  assume
A2: s.a=c;
  assume
A3: 1=s.b;
  assume that
A4: m1=m+n+1 and
A5: m+1=s.intpos m1 and
A6: m+n=s.intpos(m1+1);
  assume

A7: for t be State of SCMPDS,Q
   for f1,f2 be FinSequence of INT, k1,k2,y1,yn be

Element of NAT st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=
  t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I

is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Element of NAT
 st (1<=j & j<2*k1

+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j))
 & (y1>=yn implies IExec(I,Q,t).b=2*k1-1
  & for j be Element of NAT st 1<=j & j <= n
 holds IExec(I,Q,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,Q,t).b=2*k1+3 & (for j be

Element of NAT st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Element of NAT st y1 <= ym & ym <= yn & m+y1=
  IExec(I,Q,t).intpos k2 & m+ym-1=IExec(I,Q,t).intpos (k2+1)
   & m+ym+1=IExec(I,Q,t).

intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Element of NAT st y1

<= j & j < ym holds IExec(I,Q,t).intpos(m+j) <= IExec(I,Q,t).intpos(m+ym))
 & for j

be Element of NAT st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >= IExec(I,Q,t).intpos(m+ym) )
  & (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,Q,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);

A8: now
    let v be State of SCMPDS;
    let V;
    assume
A9: DataPart v = DataPart s;
    then
A10: 1 =v.b by A3,SCMPDS_4:23;
A11: m+n =v.intpos (m1+1) by A6,A9,SCMPDS_4:23;
A12: m+1 =v.intpos m1 by A5,A9,SCMPDS_4:23;
    v.a =c by A2,A9,SCMPDS_4:23;
    hence while>0(a,i,I) is_halting_on v,V by A1,A4,A7,A10,A12,A11,Lm5;
  end;
  hence while>0(a,i,I) is_halting_on s,P;
  thus thesis by A8,Th3;
end;

begin :: Program Partition is to split a sequence into a "smaller" and

::       a "larger" subsequence
:: a5=a7=length  a2=mid(x[1]), a3=x[2], a4=x[n], a6=save

definition
  func Partition -> Program of SCMPDS equals
  ((GBP,5):=(GBP,4) ';' SubFrom(GBP
,5,GBP,2) ';' (GBP,3):=(GBP,2) ';' AddTo(GBP,3,1)) ';' while>0(GBP,5, while>0(
  GBP,5, (GBP,7):=(GBP,5) ';' AddTo(GBP,5,-1) ';' (GBP,6):=(intpos 4,0) ';'
SubFrom(GBP,6,intpos 2,0) ';' if>0(GBP,6, AddTo(GBP,4,-1) ';' AddTo(GBP,7,-1),
Load (GBP,5):=0 ) ) ';' while>0(GBP,7, (GBP,5):=(GBP,7) ';' AddTo(GBP,7,-1) ';'
(GBP,6):=(intpos 2,0) ';' SubFrom(GBP,6,intpos 3,0) ';' if>0(GBP,6, AddTo(GBP,3
,1) ';' AddTo(GBP,5,-1), Load (GBP,7):=0 ) ) ';' if>0(GBP,5,((GBP,6):=(intpos 4
,0) ';' (intpos 4,0):=(intpos 3,0) ';' (intpos 3,0):=(GBP,6) ';' AddTo(GBP,5,-2
  ) ';' AddTo(GBP,3,1)) ';' AddTo(GBP,4,-1) ) ) ';' (GBP,6):=(intpos 4,0) ';' (
  intpos 4,0):=(intpos 2,0) ';' (intpos 2,0):=(GBP,6);
  coherence;
end;

begin :: The Construction of Quick Sort

:: a0=global, a1=stack, a2=stack depth

definition
  let n,p0 be Element of NAT;
  func QuickSort(n,p0) -> Program of SCMPDS equals
  ((GBP:=0) ';' (SBP:=1) ';'
(SBP,p0+n):=(p0+1) ';' (SBP,p0+n+1):=(p0+n)) ';' while>0(GBP,1, (GBP,2):=(SBP,
  p0+n+1) ';' SubFrom(GBP,2,SBP,p0+n) ';' if>0(GBP,2, (GBP,2):=(SBP,p0+n) ';' (
GBP,4):=(SBP,p0+n+1) ';' Partition ';' (((SBP,p0+n+3):=(SBP,p0+n+1) ';' (SBP,p0
  +n+1):=(GBP,4) ';' (SBP,p0+n+2):=(GBP,4) ';' AddTo(SBP,p0+n+1,-1)) ';' AddTo(
  SBP,p0+n+2,1) ';' AddTo(GBP,1,2)), Load AddTo(GBP,1,-2) ) );
  coherence;
end;

set i1= (GBP,7):=(GBP,5), i2= AddTo(GBP,5,-1), i3= (GBP,6):=(intpos 4,0), i4=
SubFrom(GBP,6,intpos 2,0), i5= AddTo(GBP,4,-1), i6= AddTo(GBP,7,-1), i7= Load (
GBP,5):=0, IF1= if>0(GBP,6,i5 ';' i6,i7), WB1= i1 ';' i2 ';' i3 ';' i4 ';' IF1,
WH1= while>0(GBP,5,WB1), j1= (GBP,5):=(GBP,7), j2= AddTo(GBP,7,-1), j3= (GBP,6)
:=(intpos 2,0), j4= SubFrom(GBP,6,intpos 3,0), j5= AddTo(GBP,3,1), j6= AddTo(
GBP,5,-1), j7= Load (GBP,7):=0, IF2= if>0(GBP,6,j5 ';' j6, j7), WB2= j1 ';' j2
';' j3 ';' j4 ';' IF2,
WH2= while>0(GBP,7,WB2),
k1 = (GBP,5):=(GBP,4), k2 =
SubFrom(GBP,5,GBP,2), k3 = (GBP,3):=(GBP,2), k4 = AddTo(GBP,3,1), K4 = k1 ';'
k2 ';' k3 ';' k4, k5 = (GBP,6):=(intpos 4,0), k6 = (intpos 4,0):=(intpos 3,0),
k7 = (intpos 3,0):=(GBP,6), k8 = AddTo(GBP,5,-2), k9 = AddTo(GBP,3,1), k0 =
AddTo(GBP,4,-1), IF3= if>0(GBP,5, k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0), WB3=
WH1 ';' WH2 ';' IF3, WH3= while>0(GBP,5,WB3), j8 = (GBP,6):=(intpos 4,0), j9 =
(intpos 4,0):=(intpos 2,0), j0 = (intpos 2,0):=(GBP,6);

set a1=intpos 1, a2=intpos 2, a3=intpos 3, a4=intpos 4, a5=intpos 5, a6=intpos
6, a7=intpos 7;

Lm7: card WB1=9
proof
  thus card WB1= card (i1 ';' i2 ';' i3 ';' i4) + card IF1 by AFINSQ_1:20
    .= 4+card IF1 by Th4
    .= 4+(card (i5 ';' i6)+card i7+2) by SCMPDS_6:79
    .= 4+(2+card i7+2) by SCMP_GCD:9
    .= 4+(2+1+2) by SCMPDS_5:6
    .= 9;
end;

Lm8:
 for s being 0-started State of SCMPDS,
md,me be Element of NAT st s.a2=md & s.a4=me
& md >= 8 & me >= 8 & s.GBP=0
 holds IExec(WB1,P,s).GBP=0 &
  IExec(WB1,P,s).a1=s.a1 &
  IExec(WB1,P,s).a2=s.a2 &
  IExec(WB1,P,s).a3=s.a3 &
  (for i be Element of NAT st i >= 8
   holds IExec(WB1,P,s).intpos i=s.intpos i) &
    (s.intpos md < s.intpos me implies
      IExec(WB1,P,s).a5=s.a5-1 &
      IExec(WB1,P,s).a4=s.a4-1 &
      IExec(WB1,P,s).a7=s.a5-1) &
    (s.intpos md >= s.intpos me implies
      IExec(WB1,P,s).a5=0 &
      IExec(WB1,P,s).a4=s.a4 &
      IExec(WB1,P,s).a7=s.a5)

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,me be Element of NAT;
  assume that
A1: s.a2=md and
A2: s.a4=me and
A3: md >= 8 and
A4: me >= 8 and
A5: s.a=0;

  set t0=Initialize s, Q0 = P,
  t1=IExec(i1 ';' i2 ';' i3 ';' i4,P,s),
      Q1 = P,
      t2=IExec(i1 ';' i2 ';' i3,P,s), t3=IExec(i1 ';' i2,P,s),
      Q2 = P,
      t4=Exec(i1, t0), Q4 = Q0;

A6: t0.a=0 by A5,SCMPDS_5:40;
  then
A7: DataLoc(t0.a,7)=intpos (0+7) by SCMP_GCD:5;
  then
A8: t4.a =0 by A6,AMI_3:52,SCMPDS_2:59;
  then
A9: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:5;
  t0.a4=me by A2,SCMPDS_5:40;
  then
A10: t4.a4 =me by A7,AMI_3:52,SCMPDS_2:59;
A11: t3.a4 =Exec(i2, t4).a4 by SCMPDS_5:47
    .=me by A10,A9,AMI_3:52,SCMPDS_2:60;
  then
A12: DataLoc(t3.a4,0)=intpos (me+0) by SCMP_GCD:5;
A13: t3.a =Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A8,A9,AMI_3:52,SCMPDS_2:60;
  then
A14: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:5;
  t0.a2=md by A1,SCMPDS_5:40;
  then
A15: t4.a2 =md by A7,AMI_3:52,SCMPDS_2:59;
A16: t3.a2 =Exec(i2, t4).a2 by SCMPDS_5:47
    .=md by A15,A9,AMI_3:52,SCMPDS_2:60;
A17: t0.a5=s.a5 by SCMPDS_5:40;
  then
A18: t4.a5 =s.a5 by A7,AMI_3:52,SCMPDS_2:59;
  set t01=Initialize t1, ii7= (GBP,5):=0, t5=Exec(i5,t01);
U: Initialize t01 = t01;
A19: t2.a2 =Exec(i3, t3).a2 by SCMPDS_5:46
    .=md by A16,A14,AMI_3:52,SCMPDS_2:59;
A20: t2.a =Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A13,A14,AMI_3:52,SCMPDS_2:59;
  then
A21: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:5;
  DataLoc(t0.a,5)=intpos (0+5) by A6,SCMP_GCD:5;
  then
A22: t4.a7 =s.a5 by A17,A7,SCMPDS_2:59;
A23: t3.a7 =Exec(i2, t4).a7 by SCMPDS_5:47
    .=s.a5 by A22,A9,AMI_3:52,SCMPDS_2:60;
A24: t2.a7 =Exec(i3, t3).a7 by SCMPDS_5:46
    .=s.a5 by A23,A14,AMI_3:52,SCMPDS_2:59;
  t1.a7 =Exec(i4, t2).a7 by SCMPDS_5:46
    .=s.a5 by A24,A21,AMI_3:52,SCMPDS_2:62;
  then
A25: t01.a7=s.a5 by SCMPDS_5:40;
  t1.a2 =Exec(i4, t2).a2 by SCMPDS_5:46
    .=md by A19,A21,AMI_3:52,SCMPDS_2:62;
  then
A26: t01.a2=s.a2 by A1,SCMPDS_5:40;
A27: now
    let i be Element of NAT;
    assume i>=8;
    then i > 7 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A7,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A28: now
    let i be Element of NAT;
    assume
A29: i>=8;
    then
A30: i > 5 by XXREAL_0:2;
    thus t3.intpos i =Exec(i2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A9,A30,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A27,A29;
  end;
A31: now
    let i be Element of NAT;
    assume
A32: i>=8;
    then
A33: i > 6 by XXREAL_0:2;
    thus t2.intpos i=Exec(i3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A14,A33,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A28,A32;
  end;
A34: now
    let i be Element of NAT;
    assume
A35: i>=8;
    then
A36: i > 6 by XXREAL_0:2;
    thus t1.intpos i=Exec(i4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A21,A36,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A31,A35;
  end;
  t0.a3=s.a3 by SCMPDS_5:40;
  then
A37: t4.a3 =s.a3 by A7,AMI_3:52,SCMPDS_2:59;
A38: t3.a3 =Exec(i2, t4).a3 by SCMPDS_5:47
    .=s.a3 by A37,A9,AMI_3:52,SCMPDS_2:60;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A39: t4.a1 =s.a1 by A7,AMI_3:52,SCMPDS_2:59;
A40: t3.a1 =Exec(i2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A39,A9,AMI_3:52,SCMPDS_2:60;
A41: t2.a1 =Exec(i3, t3).a1 by SCMPDS_5:46
    .=s.a1 by A40,A14,AMI_3:52,SCMPDS_2:59;
  t1.a1 =Exec(i4, t2).a1 by SCMPDS_5:46
    .=s.a1 by A41,A21,AMI_3:52,SCMPDS_2:62;
  then
A42: t01.a1=s.a1 by SCMPDS_5:40;
A43: t2.a3 =Exec(i3, t3).a3 by SCMPDS_5:46
    .=s.a3 by A38,A14,AMI_3:52,SCMPDS_2:59;
  t1.a3 =Exec(i4, t2).a3 by SCMPDS_5:46
    .=s.a3 by A43,A21,AMI_3:52,SCMPDS_2:62;
  then
A44: t01.a3=s.a3 by SCMPDS_5:40;
A45: t1.a =Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A20,A21,AMI_3:52,SCMPDS_2:62;
  then
A46: t01.a=0 by SCMPDS_5:40;
  then
A47: DataLoc(t01.a,5)=intpos(0+5) by SCMP_GCD:5;
  a3<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A48: t5.a3=s.a3 by A44,SCMPDS_2:60;
  a2<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A49: t5.a2=s.a2 by A26,SCMPDS_2:60;
  a<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A50: t5.a=0 by A46,SCMPDS_2:60;
  then
A51: DataLoc(t5.a,7)=intpos(0+7) by SCMP_GCD:5;
A52: t2.a6 =Exec(i3, t3).a6 by SCMPDS_5:46
    .=t3.intpos me by A14,A12,SCMPDS_2:59
    .=s.intpos me by A4,A28;
  t1.a6 =Exec(i4, t2).a6 by SCMPDS_5:46
    .=t2.a6-t2.DataLoc(t2.a2,0) by A21,SCMPDS_2:62
    .=t2.a6-t2.intpos(md+0) by A19,SCMP_GCD:5
    .=s.intpos me - s.intpos md by A3,A52,A31;
  then
A53: t1.DataLoc(t1.a,6)=s.intpos me - s.intpos md by A45,SCMP_GCD:5;
  a1<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
  then
A54: t5.a1=s.a1 by A42,SCMPDS_2:60;
A55: IExec(i5 ';' i6,Q1, Initialize t1) = IExec(i5 ';' i6,Q1, t1)
             by SCMPDS_5:48;
A56: now
    per cases;
    suppose
A57:  t1.DataLoc(t1.a,6) <= 0;
      hence IExec(IF1,Q1,t1).a=IExec(i7,Q1,t1).a by SCMPDS_6:88
        .=Exec(ii7,t01).a by SCMPDS_5:45
        .=0 by A46,A47,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF1,Q1,t1).a1=IExec(i7,Q1,t1).a1 by A57,SCMPDS_6:88
        .=Exec(ii7,t01).a1 by SCMPDS_5:45
        .=s.a1 by A42,A47,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF1,Q1,t1).a2=IExec(i7,Q1,t1).a2 by A57,SCMPDS_6:88
        .=Exec(ii7,t01).a2 by SCMPDS_5:45
        .=s.a2 by A26,A47,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF1,Q1,t1).a3=IExec(i7,Q1,t1).a3 by A57,SCMPDS_6:88
        .=Exec(ii7,t01).a3 by SCMPDS_5:45
        .=s.a3 by A44,A47,AMI_3:52,SCMPDS_2:58;
      hereby
        let i be Element of NAT;
        assume
A58:    i>=8;
        then
A59:    i > 5 by XXREAL_0:2;
        thus IExec(WB1,P,s).intpos i=IExec(IF1,Q1,t1).intpos i by SCMPDS_5:39
          .=IExec(i7,Q1,t1).intpos i by A57,SCMPDS_6:88
          .=Exec(ii7,t01).intpos i by SCMPDS_5:45
          .=t01.intpos i by A47,A59,AMI_3:52,SCMPDS_2:58
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A34,A58;
      end;
    end;
    suppose
A60:  t1.DataLoc(t1.a,6) > 0;
      thus IExec(IF1,Q1,t1).a=IExec(i5 ';' i6,Q1,t1).a by A60,SCMPDS_6:87
        .=Exec(i6,t5).a by A55,SCMPDS_5:47,U
        .=0 by A50,A51,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF1,Q1,t1).a1=IExec(i5 ';' i6,Q1,t1).a1 by A60,SCMPDS_6:87
        .=Exec(i6,t5).a1 by A55,SCMPDS_5:47,U
        .=s.a1 by A54,A51,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF1,Q1,t1).a2=IExec(i5 ';' i6,Q1,t1).a2 by A60,SCMPDS_6:87
        .=Exec(i6,t5).a2 by A55,SCMPDS_5:47,U
        .=s.a2 by A49,A51,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF1,Q1,t1).a3=IExec(i5 ';' i6,Q1,t1).a3 by A60,SCMPDS_6:87
        .=Exec(i6,t5).a3 by A55,SCMPDS_5:47,U
        .=s.a3 by A48,A51,AMI_3:52,SCMPDS_2:60;
      hereby
        let i be Element of NAT;
        assume
A61:    i>=8;
        then
A62:    i > 7 by XXREAL_0:2;
        i > 4 by A61,XXREAL_0:2;
        then
A63:    intpos i<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
        thus IExec(WB1,P,s).intpos i=IExec(IF1,Q1,t1).intpos i by SCMPDS_5:39
          .=IExec(i5 ';' i6,Q1,t1).intpos i by A60,SCMPDS_6:87
          .=Exec(i6,t5).intpos i by A55,SCMPDS_5:47,U
          .=t5.intpos i by A51,A62,AMI_3:52,SCMPDS_2:60
          .=t01.intpos i by A63,SCMPDS_2:60
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A34,A61;
      end;
    end;
  end;

  hence
  IExec(WB1,P,s).a=0 & IExec(WB1,P,s).a1=s.a1
   & IExec(WB1,P,s).a2=s.a2 & IExec(WB1,P,s).a3=s.a3 by SCMPDS_5:39;

  thus for i be Element of NAT st i >= 8 holds IExec(WB1,P,s).intpos i=s.intpos
  i by A56;

A64: t3.a5 =Exec(i2, t4).a5 by SCMPDS_5:47
    .=t4.a5+ -1 by A9,SCMPDS_2:60
    .=s.a5-1 by A18;
A65: t2.a5 =Exec(i3, t3).a5 by SCMPDS_5:46
    .=s.a5-1 by A64,A14,AMI_3:52,SCMPDS_2:59;
  t1.a5 =Exec(i4, t2).a5 by SCMPDS_5:46
    .=s.a5-1 by A65,A21,AMI_3:52,SCMPDS_2:62;
  then
A66: t01.a5=s.a5-1 by SCMPDS_5:40;
A67: t2.a4 =Exec(i3, t3).a4 by SCMPDS_5:46
    .=me by A11,A14,AMI_3:52,SCMPDS_2:59;
  t1.a4 =Exec(i4, t2).a4 by SCMPDS_5:46
    .=me by A67,A21,AMI_3:52,SCMPDS_2:62;
  then
A68: t01.a4=s.a4 by A2,SCMPDS_5:40;
A69: DataLoc(t01.a,4)=intpos(0+4) by A46,SCMP_GCD:5;
  hereby
A70: a5<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
    assume
A71: s.intpos md < s.intpos me;
    thus IExec(WB1,P,s).a5=IExec(IF1,Q1,t1).a5 by SCMPDS_5:39
      .=IExec(i5 ';' i6,Q1,t1).a5 by A53,A71,SCMPDS_6:87,XREAL_1:52
      .=Exec(i6,t5).a5 by A55,SCMPDS_5:47,U
      .=t5.a5 by A51,AMI_3:52,SCMPDS_2:60
      .=s.a5-1 by A66,A70,SCMPDS_2:60;
    thus IExec(WB1,P,s).a4=IExec(IF1,Q1,t1).a4 by SCMPDS_5:39
      .=IExec(i5 ';' i6,Q1,t1).a4 by A53,A71,SCMPDS_6:87,XREAL_1:52
      .=Exec(i6,t5).a4 by A55,SCMPDS_5:47,U
      .=t5.a4 by A51,AMI_3:52,SCMPDS_2:60
      .=t01.a4+-1 by A69,SCMPDS_2:60
      .=s.a4-1 by A68;
A72: a7<>DataLoc(t01.a,4) by A46,AMI_3:52,SCMP_GCD:5;
    thus IExec(WB1,P,s).a7=IExec(IF1,Q1,t1).a7 by SCMPDS_5:39
      .=IExec(i5 ';' i6,Q1,t1).a7 by A53,A71,SCMPDS_6:87,XREAL_1:52
      .=Exec(i6,t5).a7 by A55,SCMPDS_5:47,U
      .=t5.a7+ -1 by A51,SCMPDS_2:60
      .=t5.a7-1
      .=s.a5-1 by A25,A72,SCMPDS_2:60;
  end;
  hereby
    assume
A73: s.intpos md >= s.intpos me;
    thus IExec(WB1,P,s).a5=IExec(IF1,Q1,t1).a5 by SCMPDS_5:39
      .=IExec(i7,Q1,t1).a5 by A53,A73,SCMPDS_6:88,XREAL_1:49
      .=Exec(ii7,t01).a5 by SCMPDS_5:45
      .=0 by A47,SCMPDS_2:58;
    thus IExec(WB1,P,s).a4=IExec(IF1,Q1,t1).a4 by SCMPDS_5:39
      .=IExec(i7,Q1,t1).a4 by A53,A73,SCMPDS_6:88,XREAL_1:49
      .=Exec(ii7,t01).a4 by SCMPDS_5:45
      .=s.a4 by A47,A68,AMI_3:52,SCMPDS_2:58;
    thus IExec(WB1,P,s).a7=IExec(IF1,Q1,t1).a7 by SCMPDS_5:39
      .=IExec(i7,Q1,t1).a7 by A53,A73,SCMPDS_6:88,XREAL_1:49
      .=Exec(ii7,t01).a7 by SCMPDS_5:45
      .=s.a5 by A25,A47,AMI_3:52,SCMPDS_2:58;
  end;
end;

Lm9: for s being 0-started State of SCMPDS,
m4,md be Element of NAT st s.GBP=0 & s.a5 > 0
& s.a4=m4+s.a5 & m4>=8 & s.a2=md & md >= 8
 holds IExec(WH1,P,s).GBP=0 & IExec(WH1,P,s).a1=s.a1
  & IExec(WH1,P,s).a5=0 & IExec(WH1,P,s).a2=s.a2 & IExec(WH1,P,s).a3=s.a3 &
(for i be Element of NAT st i >= 8 holds IExec(WH1,P,s).intpos i=s.intpos i)
 & ex mE be Element of NAT st mE=IExec(WH1,P,s).a7
 & IExec(WH1,P,s).a4=m4+mE & mE <= s.a5
& (for i be Element of NAT st m4+mE < i & i <=s.a4
 holds IExec(WH1,P,s).intpos md
< IExec(WH1,P,s).intpos i) &
 (mE = 0 or IExec(WH1,P,s).intpos md >= IExec(WH1,P,s).intpos(m4+mE))

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m4,md be Element of NAT;
  assume that
A1: s.GBP=0 and
A2: s.a5 > 0 and
A3: s.a4=m4+s.a5 and
A4: m4>=8 and
A5: s.a2=md and
A6: md >= 8;
  s.a5 >=1+0 by A2,INT_1:20;
  then reconsider m5=s.a5-1 as Element of NAT by INT_1:16,XREAL_1:50;
A7: s.a5=m5+1;

  defpred P[Element of NAT] means
   for t being State of SCMPDS,Q st t.a=0 & t.a5 =$1+1 &
    t.a4=m4+t.a5 & t.a2=md holds IExec(WH1,Q,t).a=0
 & IExec(WH1,Q,t).a1=t.a1 &
  IExec(WH1,Q,t).a5=0 & IExec(WH1,Q,t).a2=t.a2 & IExec(WH1,Q,t).a3=t.a3
   & (for i be
  Element of NAT st i >= 8 holds IExec(WH1,Q,t).intpos i=t.intpos i) & ex mE be
  Element of NAT st mE=IExec(WH1,Q,t).a7
   & IExec(WH1,Q,t).a4=m4+mE & mE <= t.a5 & (

for i be Element of NAT st m4+mE < i & i <=t.a4
 holds IExec(WH1,Q,t).intpos md <

IExec(WH1,Q,t).intpos i) &
 (mE=0 or IExec(WH1,Q,t).intpos md >= IExec(WH1,Q,t).intpos
  (m4+mE));

A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      set me=m4+(k+1+1);
      let t be State of SCMPDS;
      let Q;
      set b=DataLoc(t.a,5);
      assume that
A10:  t.a=0 and
A11:  t.a5 =(k+1)+1 and
A12:  t.a4=m4+t.a5 and
A13:  t.a2=md;
      set It=IExec(WB1,Q,t), IT = Q;
A14:   It=IExec(WB1,Q,Initialize t) by SCMPDS_5:48;
A15:   t.a = (Initialize t).a by SCMPDS_5:40;
A16:   t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A17:   t.a2 = (Initialize t).a2 by SCMPDS_5:40;
A18:   t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A19:   t.a4 = (Initialize t).a4 by SCMPDS_5:40;
A20:   t.a5 = (Initialize t).a5 by SCMPDS_5:40;
A21:   t.intpos md = (Initialize t).intpos md by SCMPDS_5:40;
A22:   t.intpos me = (Initialize t).intpos me by SCMPDS_5:40;
A23:  me>=m4 by NAT_1:11;
      then
A24:  me>=8 by A4,XXREAL_0:2;
      then
A25:  It.a1=t.a1 by A6,A10,A11,A12,A13,Lm8,A14,A16,A17,A19,A15;
A26:  t.intpos md >= t.intpos me implies It.a5=0 & It.a4=t.a4 & It.a7=t.
      a5 by A6,A10,A11,A12,A13,A24,Lm8,A14,A17,A19,A20,A15,A21,A22;

A27:  b=intpos (0+5) by A10,SCMP_GCD:5;
A28:  now
        let v be State of SCMPDS;
        let V;
        assume that
A29:    v.a4 >= m4+v.b and
A30:    v.a2=t.a2 and
A31:    v.a=t.a and
A32:    v.b > 0;
A33:    m4+v.b>m4+0 by A32,XREAL_1:8;
        then reconsider ME=v.a4 as Element of NAT by A29,INT_1:16;
A34:     IExec(WB1,V,v) = IExec(WB1,V,Initialize v) by SCMPDS_5:48;
A35:     v.intpos md = (Initialize v).intpos md by SCMPDS_5:40;
A36:     v.intpos ME = (Initialize v).intpos ME by SCMPDS_5:40;
A37:     v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A38:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A39:     v.a5 = (Initialize v).a5 by SCMPDS_5:40;
A40:     v.a = (Initialize v).a by SCMPDS_5:40;
        v.a4 >=m4 by A29,A33,XXREAL_0:2;
        then
A41:    ME >= 8 by A4,XXREAL_0:2;
        then
A42:    v.intpos md < v.intpos ME implies IExec(WB1,V,v).a5=v.a5-1 &
        IExec(WB1,V,v).a4=v.a4-1 & IExec(WB1,V,v).a7=v.a5-1
        by A6,A10,A13,A30,A31,Lm8,A34,A35,A36,A37,A39,A40,A38;

        thus IExec(WB1,V,v).a=v.a
        by A6,A10,A13,A30,A31,A41,Lm8,A34,A37,A40,A38;
        thus WB1 is_closed_on v,V & WB1 is_halting_on v,V by SCMPDS_6:34,35;

A43:    v.intpos md >= v.intpos ME implies IExec(WB1,V,v).a5=0 & IExec(WB1,
        V,v).a4 =v.a4 & IExec(WB1,V,v).a7=v.a5
        by A6,A10,A13,A30,A31,A41,Lm8,A34,A35,A36,A37,A39,A40,A38;

        hereby
          per cases;
          suppose
A44:        v.intpos md < v.intpos ME;
            hence IExec(WB1,V,v).b < v.b by A27,A42,XREAL_1:148;
            m4+v.b-1=m4+IExec(WB1,V,v).b by A27,A42,A44;

            hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b by A29,A42,A44,
XREAL_1:11;

          end;
          suppose
A45:        v.intpos md >= v.intpos ME;

            hence IExec(WB1,V,v).b < v.b
            by A6,A10,A13,A27,A30,A31,A32,A41,Lm8,A34,A35,A36,A37,A40,A38;

            m4+IExec(WB1,V,v).b < m4+v.b by A27,A32,A43,A45,XREAL_1:8;

            hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b by A29,A43,A45,
XXREAL_0:2;

          end;
        end;
        thus IExec(WB1,V,v).a2=v.a2
        by A6,A10,A13,A30,A31,A41,Lm8,A34,A37,A40,A38;
      end;
A46:  It.a3=t.a3 by A6,A10,A11,A12,A13,A24,Lm8,A14,A17,A19,A15,A18;

A47:  t.intpos md < t.intpos me implies It.a5=t.a5-1 & It.a4=t.a4-1 & It.
      a7= t.a5-1 by A6,A10,A11,A12,A13,A24,Lm8,A14,A17,A19,A20,A15,A21,A22;

A48:  It.a=0 by A6,A10,A11,A12,A13,A24,Lm8,A14,A17,A19,A15;
      then
A49:  DataLoc(It.a,5)=intpos(0+5) by SCMP_GCD:5;
A50:  It.a2=t.a2 by A6,A10,A11,A12,A13,A24,Lm8,A14,A17,A19,A15;
      per cases;
      suppose
A51:    t.intpos md < t.intpos me;
        then
A52:    It.a4=m4+It.a5 by A12,A47;
        then consider mE be Element of NAT such that
A53:    mE=IExec(WH1,IT,It).a7 and
A54:    IExec(WH1,IT,It).a4=m4+mE and
A55:    mE <= It.a5 and

A56:    for i be Element of NAT st m4+mE < i & i <=It.a4 holds IExec(
        WH1,IT,It).intpos md < IExec(WH1,IT,It).intpos i and

A57:    mE=0 or IExec(WH1,IT,It).intpos md >= IExec(WH1,IT,It).intpos (m4+
        mE) by A9,A11,A12,A13,A48,A50,A47,A26;

A58:    IExec(WH1,Q,t)=IExec(WH1,IT,It) by A11,A12,A27,A28,Lm7,Th5;
        hence IExec(WH1,Q,t).a=0 by A9,A11,A12,A13,A48,A50,A47,A26,A52;

        thus IExec(WH1,Q,t).a1=t.a1
         by A9,A11,A12,A13,A48,A25,A50,A47,A26,A52,A58;

        thus IExec(WH1,Q,t).a5=0 by A9,A11,A12,A13,A48,A50,A47,A26,A52,A58;
        thus IExec(WH1,Q,t).a2=t.a2 by A9,A11,A12,A13,A48,A50,A47,A26,A52,A58;

        thus IExec(WH1,Q,t).a3=t.a3
         by A9,A11,A12,A13,A48,A50,A46,A47,A26,A52,A58
;

A59:    now
          let i be Element of NAT;
A60:       t.intpos i = (Initialize t).intpos i by SCMPDS_5:40;
          assume
A61:      i >= 8;

          hence IExec(WH1,Q,t).intpos i=It.intpos i
           by A9,A11,A12,A13,A48,A50,A47
,A26,A52,A58

            .=t.intpos i by A6,A10,A11,A12,A13,A24,A61,Lm8,A14,A17,A19,A15,A60;
        end;

        hence for i be Element of NAT st i >= 8
         holds IExec(WH1,Q,t).intpos i=t.
        intpos i;

        take mE;
        thus mE=IExec(WH1,Q,t).a7 by A11,A12,A27,A28,A53,Lm7,Th5;
        thus IExec(WH1,Q,t).a4=m4+mE by A11,A12,A27,A28,A54,Lm7,Th5;
        thus mE <= t.a5 by A47,A51,A55,XREAL_1:148,XXREAL_0:2;
A62:    It.a4=t.a4-1 by A6,A10,A11,A12,A13,A24,A51,Lm8,A14,A17,A19,A15,A21,A22;
        hereby
          let i be Element of NAT;
          assume that
A63:      m4+mE < i and
A64:      i <=t.a4;
          per cases;
          suppose
A65:        i=t.a4;

            IExec(WH1,Q,t).intpos me =t.intpos me by A4,A23,A59,XXREAL_0:2;

            hence IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i
             by A6,A11,A12
,A51,A59,A65;

          end;
          suppose
            i<>t.a4;
            then i < t.a4 by A64,XXREAL_0:1;
            then i+1 <= t.a4 by INT_1:20;
            then i <= It.a4 by A62,XREAL_1:21;

            hence
            IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i by A58,A56,A63;

          end;
        end;

        thus mE=0 or IExec(WH1,Q,t).intpos md >= IExec(WH1,Q,t).intpos (m4+mE)
         by
A58,A57;

      end;
      suppose
A66:    t.intpos md >= t.intpos me;
A67:    now
          let x;
          thus IExec(WH1,Q,t).x =IExec(WH1,IT,It).x by A11,A12,A27,A28,Lm7,Th5
            .=It.x by A26,A49,A66,SCMPDS_8:23;
        end;
        hence IExec(WH1,Q,t).a=0 by A48;
        thus IExec(WH1,Q,t).a1=t.a1 by A25,A67;
        thus IExec(WH1,Q,t).a5=0 by A26,A66,A67;
        thus IExec(WH1,Q,t).a2=t.a2 by A50,A67;
        thus IExec(WH1,Q,t).a3=t.a3 by A46,A67;
A68:    now
          let i be Element of NAT;
A69:       t.intpos i = (Initialize t).intpos i by SCMPDS_5:40;
          assume
A70:      i >= 8;
          thus IExec(WH1,Q,t).intpos i=It.intpos i by A67
            .=t.intpos i by A6,A10,A11,A12,A13,A24,A70,Lm8,A14,A17,A19,A15,A69;
        end;

        hence for i be Element of NAT st i >= 8
         holds IExec(WH1,Q,t).intpos i=t.
        intpos i;

        take ME=k+1+1;
        thus IExec(WH1,Q,t).a7=ME by A11,A26,A66,A67;
        thus IExec(WH1,Q,t).a4=m4+ME by A11,A12,A26,A66,A67;
        thus ME <= t.a5 by A11;

        thus for i be Element of NAT st m4+ME < i & i <=t.a4
         & not IExec(WH1,Q,t
        ).intpos md < IExec(WH1,Q,t).intpos i holds contradiction by A11,A12;

        IExec(WH1,Q,t).intpos me=t.intpos me by A4,A23,A68,XXREAL_0:2;

        hence ME=0 or IExec(WH1,Q,t).intpos md
         >= IExec(WH1,Q,t).intpos (m4+ME) by
A6,A66,A68;

      end;
    end;
    hence P[k+1];
  end;
  now
    set me=m4+1;
    let t be State of SCMPDS;
    let Q;
    set It=IExec(WB1,Q,t), IT = Q;
A71:   It=IExec(WB1,Q,Initialize t) by SCMPDS_5:48;
A72:   t.a = (Initialize t).a by SCMPDS_5:40;
A73:   t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A74:   t.a2 = (Initialize t).a2 by SCMPDS_5:40;
A75:   t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A76:   t.a4 = (Initialize t).a4 by SCMPDS_5:40;
A77:   t.a5 = (Initialize t).a5 by SCMPDS_5:40;
A78:   t.intpos md = (Initialize t).intpos md by SCMPDS_5:40;
A79:   t.intpos me = (Initialize t).intpos me by SCMPDS_5:40;
    set b=DataLoc(t.a,5);
    assume that
A80: t.a=0 and
A81: t.a5 =0+1 and
A82: t.a4=m4+t.a5 and
A83: t.a2=md;
A84: me>=m4 by NAT_1:11;
    then
A85: me>=8 by A4,XXREAL_0:2;

    then
A86: t.intpos md < t.intpos me implies It.a5=t.a5-1 & It.a4=t.a4-1 & It.a7
    = t.a5-1 by A6,A80,A81,A82,A83,Lm8,A71,A74,A76,A77,A72,A78,A79;

A87: t.intpos md >= t.intpos me implies It.a5=0 & It.a4=t.a4 & It.a7=t.a5
    by A6,A80,A81,A82,A83,A85,Lm8,A71,A74,A76,A77,A72,A78,A79;

A88: b=intpos (0+5) by A80,SCMP_GCD:5;
A89: now
      let v be State of SCMPDS,V;
      assume that
A90:  v.a4 >= m4+v.b and
A91:  v.a2=t.a2 and
A92:  v.a=t.a and
A93:  v.b > 0;
A94:  m4+v.b>m4+0 by A93,XREAL_1:8;
      then reconsider ME=v.a4 as Element of NAT by A90,INT_1:16;
A95:     IExec(WB1,V,v) = IExec(WB1,V,Initialize v) by SCMPDS_5:48;
A96:     v.intpos md = (Initialize v).intpos md by SCMPDS_5:40;
A97:     v.intpos ME = (Initialize v).intpos ME by SCMPDS_5:40;
A98:     v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A99:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A100:     v.a5 = (Initialize v).a5 by SCMPDS_5:40;
A101:     v.a = (Initialize v).a by SCMPDS_5:40;
      v.a4 >=m4 by A90,A94,XXREAL_0:2;
      then
A102:  ME >= 8 by A4,XXREAL_0:2;

      then
A103:  v.intpos md < v.intpos ME implies IExec(WB1,V,v).a5=v.a5-1 &
     IExec(WB1,V,v ).a4=v.a4-1 & IExec(WB1,V,v).a7=v.a5-1
       by A6,A80,A83,A91,A92,Lm8,A95
,A96,A97,A98,A100,A101,A99;

      thus IExec(WB1,V,v).a=v.a
       by A6,A80,A83,A91,A92,A102,Lm8,A95,A98,A101,A99;
      thus WB1 is_closed_on v,V & WB1 is_halting_on v,V by SCMPDS_6:34,35;

A104:  v.intpos md >= v.intpos ME implies IExec(WB1,V,v).a5=0 & IExec(WB1,V,v)
      .a4 =v.a4 & IExec(WB1,V,v).a7=v.a5 by A6,A80,A83,A91,A92,A102,Lm8,A95,A96
,A97,A98,A100,A101,A99;

      hereby
        per cases;
        suppose
A105:      v.intpos md < v.intpos ME;
          hence IExec(WB1,V,v).b < v.b by A88,A103,XREAL_1:148;
          m4+v.b-1=m4+IExec(WB1,V,v).b by A88,A103,A105;

          hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b by A90,A103,A105,
XREAL_1:11;

        end;
        suppose
A106:      v.intpos md >= v.intpos ME;
          hence IExec(WB1,V,v).b < v.b
           by A6,A80,A83,A88,A91,A92,A93,A102,Lm8,A95
,A96,A97,A98,A101,A99;
          m4+IExec(WB1,V,v).b < m4+v.b by A88,A93,A104,A106,XREAL_1:8;

          hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b by A90,A104,A106,
XXREAL_0:2;

        end;
      end;
      thus IExec(WB1,V,v).a2=v.a2
       by A6,A80,A83,A91,A92,A102,Lm8,A95,A98,A101,A99
;
    end;
A107: It.a=0 by A6,A80,A81,A82,A83,A85,Lm8,A71,A74,A76,A72;
    then
A108: It.DataLoc(It.a,5)=0 by A81,A86,A87,SCMP_GCD:5;
A109: now
      let x;
      thus IExec(WH1,Q,t).x =IExec(WH1,IT,It).x by A81,A82,A88,A89,Lm7,Th5
        .=It.x by A108,SCMPDS_8:23;
    end;
    hence IExec(WH1,Q,t).a=0 by A107;
    It.a1=t.a1 by A6,A80,A81,A82,A83,A85,Lm8,A71,A73,A74,A76,A72;
    hence IExec(WH1,Q,t).a1=t.a1 by A109;
    thus IExec(WH1,Q,t).a5=0 by A81,A86,A87,A109;
    It.a2=t.a2 by A6,A80,A81,A82,A83,A85,Lm8,A71,A74,A76,A72;
    hence IExec(WH1,Q,t).a2=t.a2 by A109;
    It.a3=t.a3 by A6,A80,A81,A82,A83,A85,Lm8,A71,A74,A76,A72,A75;
    hence IExec(WH1,Q,t).a3=t.a3 by A109;
A110: now
      let i be Element of NAT;
      assume
A111:  i >= 8;
A112:       t.intpos i = (Initialize t).intpos i by SCMPDS_5:40;
      thus IExec(WH1,Q,t).intpos i=It.intpos i by A109
        .=t.intpos i by A6,A80,A81,A82,A83,A85,A111,Lm8,A71,A74,A76,A72,A112;
    end;

    hence for i be Element of NAT st i >= 8 holds IExec(WH1,Q,t).intpos i=t.
    intpos i;

A113: IExec(WH1,Q,t).intpos me=t.intpos me by A4,A84,A110,XXREAL_0:2;
    hereby
      per cases;
      suppose
A114:    t.intpos md < t.intpos me;
        take ME=0;
        thus IExec(WH1,Q,t).a7=ME by A81,A86,A109,A114;
        thus IExec(WH1,Q,t).a4=m4+ME by A81,A82,A86,A109,A114;
        thus ME <= t.a5 by A81;
        hereby
          let i be Element of NAT;
          assume that
A115:      m4+ME < i and
A116:      i <=t.a4;
          m4+1 <= i by A115,INT_1:20;
          then i=m4+1 by A81,A82,A116,XXREAL_0:1;

          hence IExec(WH1,Q,t).intpos md
           < IExec(WH1,Q,t).intpos i by A6,A110,A113
,A114;

        end;
        thus ME=0 or IExec(WH1,Q,t).intpos md
         >= IExec(WH1,Q,t).intpos (m4+ ME );
      end;
      suppose
A117:    t.intpos md >= t.intpos me;
        take ME=1;
        thus IExec(WH1,Q,t).a7=ME by A81,A87,A109,A117;
        thus IExec(WH1,Q,t).a4=m4+ME by A81,A82,A87,A109,A117;
        thus ME <= t.a5 by A81;

        thus for i be Element of NAT st m4+ME < i & i <=t.a4
         holds IExec(WH1,Q,t
        ).intpos md < IExec(WH1,Q,t).intpos i by A81,A82;

        thus ME=0 or IExec(WH1,Q,t).intpos md
         >= IExec(WH1,Q,t).intpos (m4+ME) by
A6,A110,A113,A117;

      end;
    end;
  end;
  then
A118: P[0];
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A118,A8);
  hence thesis by A1,A3,A5,A7;
end;

Lm10: for s being 0-started State of SCMPDS,
 m4,md be Element of NAT st s.GBP=0 & s.a4=m4
+s.a5 & m4>=8 & s.a2=md & md >= 8
 holds WH1 is_closed_on s,P & WH1 is_halting_on s,P

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m4,md be Element of NAT;
  assume that
A1: s.GBP=0 and
A2: s.a4=m4+s.a5 and
A3: m4>=8 and
A4: s.a2=md and
A5: md >= 8;
  set b=DataLoc(s.a,5);
A6: b=intpos (0+5) by A1,SCMP_GCD:5;
  now
    let v be State of SCMPDS, V;
    assume that
A7: v.a4 >= m4+v.b and
A8: v.a2=s.a2 and
A9: v.a=s.a and
A10: v.b > 0;
A11: m4+v.b>m4+0 by A10,XREAL_1:8;
    then reconsider ME=v.a4 as Element of NAT by A7,INT_1:16;
A12:     IExec(WB1,V,v) = IExec(WB1,V,Initialize v) by SCMPDS_5:48;
A13:     v.intpos md = (Initialize v).intpos md by SCMPDS_5:40;
A14:     v.intpos ME = (Initialize v).intpos ME by SCMPDS_5:40;
A15:     v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A16:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A17:     v.a5 = (Initialize v).a5 by SCMPDS_5:40;
A18:     v.a = (Initialize v).a by SCMPDS_5:40;
    v.a4 >=m4 by A7,A11,XXREAL_0:2;
    then
A19: ME >= 8 by A3,XXREAL_0:2;

    then
A20: v.intpos md < v.intpos ME implies IExec(WB1,V,v).a5=v.a5-1 & IExec(WB1,
    V,v) .a4=v.a4-1 & IExec(WB1,V,v).a7=v.a5-1
     by A1,A4,A5,A8,A9,Lm8,A12,A13,A14,A15,A17,A18,A16;

    thus IExec(WB1,V,v).a=v.a by A1,A4,A5,A8,A9,A19,Lm8,A12,A15,A18,A16;
    thus WB1 is_closed_on v,V & WB1 is_halting_on v,V by SCMPDS_6:34,35;

A21: v.intpos md >= v.intpos ME implies IExec(WB1,V,v).a5=0 & IExec(WB1,V,v).
    a4= v.a4 & IExec(WB1,V,v).a7=v.a5 by A1,A4,A5,A8,A9,A19,Lm8,A12,A13,A14,A15
,A17,A18,A16;

    hereby
      per cases;
      suppose
A22:    v.intpos md < v.intpos ME;
        hence IExec(WB1,V,v).b < v.b by A6,A20,XREAL_1:148;
        m4+v.b-1=m4+IExec(WB1,V,v).b by A6,A20,A22;

        hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b
         by A7,A20,A22,XREAL_1:11;

      end;
      suppose
A23:    v.intpos md >= v.intpos ME;
        hence IExec(WB1,V,v).b < v.b
         by A1,A4,A5,A6,A8,A9,A10,A19,Lm8,A12,A13,A14
,A15,A18,A16;
        m4+IExec(WB1,V,v).b < m4+v.b by A6,A10,A21,A23,XREAL_1:8;

        hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b
         by A7,A21,A23,XXREAL_0:2;

      end;
    end;
    thus IExec(WB1,V,v).a2=v.a2 by A1,A4,A5,A8,A9,A19,Lm8,A12,A15,A18,A16;
  end;
  hence thesis by A2,A6,Lm7,Th5;
end;

Lm11: card WH1=11
proof
  thus card WH1=9+2 by Lm7,SCMPDS_8:17
    .=11;
end;

Lm12: card WB2=9
proof
  thus card WB2= card (j1 ';' j2 ';' j3 ';' j4) + card IF2 by AFINSQ_1:20
    .= 4+card IF2 by Th4
    .= 4+(card (j5 ';' j6) +card j7+2) by SCMPDS_6:79
    .= 4+(2+card j7+2) by SCMP_GCD:9
    .= 4+(2+1+2) by SCMPDS_5:6
    .= 9;
end;

Lm13: card WH2=11
proof
  thus card WH2= 9+2 by Lm12,SCMPDS_8:17
    .=11;
end;

Lm14: for s being 0-started State of SCMPDS,
md,me be Element of NAT st s.a2=md & s.a3=me
& md >= 8 & me >= 8 & s.GBP=0 holds IExec(WB2,P,s).GBP=0
 & IExec(WB2,P,s).a1=s.a1 &
IExec(WB2,P,s).a2=s.a2 & IExec(WB2,P,s).a4=s.a4
 & (for i be Element of NAT st i >=
8 holds IExec(WB2,P,s).intpos i=s.intpos i)
 & (s.intpos md > s.intpos me implies
IExec(WB2,P,s).a7=s.a7-1 & IExec(WB2,P,s).a3=s.a3+1
 & IExec(WB2,P,s).a5=s.a7-1) & (s.
intpos md <= s.intpos me implies IExec(WB2,P,s).a7=0 & IExec(WB2,P,s).a3=s.a3 &
IExec(WB2,P,s).a5=s.a7)

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,me be Element of NAT;
  assume that
A1: s.a2=md and
A2: s.a3=me and
A3: md >= 8 and
A4: me >= 8 and
A5: s.a=0;

  set t0=Initialize s, t1=IExec(j1 ';' j2 ';' j3 ';' j4,P,s),
     Q1 = P,
     t2=IExec(j1 ';' j2 ';' j3,P,s), t3=IExec(j1 ';' j2,P,s),
     t4=Exec(j1, t0);
A6: IExec(j5 ';' j6,Q1,t1) = IExec(j5 ';' j6,Q1,Initialize t1) by SCMPDS_5:48;

A7: t0.a=0 by A5,SCMPDS_5:40;
  then
A8: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A9: t4.a =0 by A7,AMI_3:52,SCMPDS_2:59;
  then
A10: DataLoc(t4.a,7)=intpos (0+7) by SCMP_GCD:5;
  t0.a2=md by A1,SCMPDS_5:40;
  then
A11: t4.a2 =md by A8,AMI_3:52,SCMPDS_2:59;
A12: t3.a2 =Exec(j2, t4).a2 by SCMPDS_5:47
    .=md by A11,A10,AMI_3:52,SCMPDS_2:60;
  then
A13: DataLoc(t3.a2,0)=intpos (md+0) by SCMP_GCD:5;
A14: t3.a =Exec(j2, t4).a by SCMPDS_5:47
    .=0 by A9,A10,AMI_3:52,SCMPDS_2:60;
  then
A15: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:5;
  t0.a3=me by A2,SCMPDS_5:40;
  then
A16: t4.a3 =me by A8,AMI_3:52,SCMPDS_2:59;
A17: t3.a3 =Exec(j2, t4).a3 by SCMPDS_5:47
    .=me by A16,A10,AMI_3:52,SCMPDS_2:60;
A18: t0.a7=s.a7 by SCMPDS_5:40;
  then
A19: t4.a7 =s.a7 by A8,AMI_3:52,SCMPDS_2:59;
  set t01=Initialize t1, jj7= (GBP,7):=0, t5=Exec(j5,t01);
U: Initialize t01 = t01;
A20: t2.a3 =Exec(j3, t3).a3 by SCMPDS_5:46
    .=me by A17,A15,AMI_3:52,SCMPDS_2:59;
A21: t2.a =Exec(j3, t3).a by SCMPDS_5:46
    .=0 by A14,A15,AMI_3:52,SCMPDS_2:59;
  then
A22: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:5;
  t0.a4=s.a4 by SCMPDS_5:40;
  then
A23: t4.a4 =s.a4 by A8,AMI_3:52,SCMPDS_2:59;
A24: t3.a4 =Exec(j2, t4).a4 by SCMPDS_5:47
    .=s.a4 by A23,A10,AMI_3:52,SCMPDS_2:60;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A25: t4.a1 =s.a1 by A8,AMI_3:52,SCMPDS_2:59;
A26: t3.a1 =Exec(j2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A25,A10,AMI_3:52,SCMPDS_2:60;
A27: t2.a1 =Exec(j3, t3).a1 by SCMPDS_5:46
    .=s.a1 by A26,A15,AMI_3:52,SCMPDS_2:59;
  t1.a1 =Exec(j4, t2).a1 by SCMPDS_5:46
    .=s.a1 by A27,A22,AMI_3:52,SCMPDS_2:62;
  then
A28: t01.a1=s.a1 by SCMPDS_5:40;
A29: t2.a4 =Exec(j3, t3).a4 by SCMPDS_5:46
    .=s.a4 by A24,A15,AMI_3:52,SCMPDS_2:59;
  t1.a4 =Exec(j4, t2).a4 by SCMPDS_5:46
    .=s.a4 by A29,A22,AMI_3:52,SCMPDS_2:62;
  then
A30: t01.a4=s.a4 by SCMPDS_5:40;
A31: t1.a =Exec(j4, t2).a by SCMPDS_5:46
    .=0 by A21,A22,AMI_3:52,SCMPDS_2:62;
  then
A32: t01.a=0 by SCMPDS_5:40;
  then
A33: DataLoc(t01.a,7)=intpos(0+7) by SCMP_GCD:5;
  DataLoc(t0.a,7)=intpos (0+7) by A7,SCMP_GCD:5;
  then
A34: t4.a5 =s.a7 by A18,A8,SCMPDS_2:59;
A35: t3.a5 =Exec(j2, t4).a5 by SCMPDS_5:47
    .=s.a7 by A34,A10,AMI_3:52,SCMPDS_2:60;
A36: t2.a5 =Exec(j3, t3).a5 by SCMPDS_5:46
    .=s.a7 by A35,A15,AMI_3:52,SCMPDS_2:59;
  t1.a5 =Exec(j4, t2).a5 by SCMPDS_5:46
    .=s.a7 by A36,A22,AMI_3:52,SCMPDS_2:62;
  then
A37: t01.a5=s.a7 by SCMPDS_5:40;
A38: t2.a2 =Exec(j3, t3).a2 by SCMPDS_5:46
    .=md by A12,A15,AMI_3:52,SCMPDS_2:59;
  t1.a2 =Exec(j4, t2).a2 by SCMPDS_5:46
    .=md by A38,A22,AMI_3:52,SCMPDS_2:62;
  then
A39: t01.a2=s.a2 by A1,SCMPDS_5:40;
  a4<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
  then
A40: t5.a4=s.a4 by A30,SCMPDS_2:60;
  a2<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
  then
A41: t5.a2=s.a2 by A39,SCMPDS_2:60;
  a<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
  then
A42: t5.a=0 by A32,SCMPDS_2:60;
  then
A43: DataLoc(t5.a,5)=intpos(0+5) by SCMP_GCD:5;
A44: now
    let i be Element of NAT;
    assume i>=8;
    then i > 5 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A8,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A45: now
    let i be Element of NAT;
    assume
A46: i>=8;
    then
A47: i > 7 by XXREAL_0:2;
    thus t3.intpos i =Exec(j2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A10,A47,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A44,A46;
  end;
A48: now
    let i be Element of NAT;
    assume
A49: i>=8;
    then
A50: i > 6 by XXREAL_0:2;
    thus t2.intpos i=Exec(j3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A15,A50,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A45,A49;
  end;
A51: now
    let i be Element of NAT;
    assume
A52: i>=8;
    then
A53: i > 6 by XXREAL_0:2;
    thus t1.intpos i=Exec(j4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A22,A53,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A48,A52;
  end;
A54: t2.a6 =Exec(j3, t3).a6 by SCMPDS_5:46
    .=t3.intpos md by A15,A13,SCMPDS_2:59
    .=s.intpos md by A3,A45;
  t1.a6 =Exec(j4, t2).a6 by SCMPDS_5:46
    .=t2.a6-t2.DataLoc(t2.a3,0) by A22,SCMPDS_2:62
    .=t2.a6-t2.intpos(me+0) by A20,SCMP_GCD:5
    .=s.intpos md - s.intpos me by A4,A54,A48;
  then
A55: t1.DataLoc(t1.a,6)=s.intpos md - s.intpos me by A31,SCMP_GCD:5;
  a1<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
  then
A56: t5.a1=s.a1 by A28,SCMPDS_2:60;
A57: now
    per cases;
    suppose
A58:  t1.DataLoc(t1.a,6) <= 0;
      hence IExec(IF2,Q1,t1).a=IExec(j7,Q1,t1).a by SCMPDS_6:88
        .=Exec(jj7,t01).a by SCMPDS_5:45
        .=0 by A32,A33,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF2,Q1,t1).a1=IExec(j7,Q1,t1).a1 by A58,SCMPDS_6:88
        .=Exec(jj7,t01).a1 by SCMPDS_5:45
        .=s.a1 by A28,A33,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF2,Q1,t1).a2=IExec(j7,Q1,t1).a2 by A58,SCMPDS_6:88
        .=Exec(jj7,t01).a2 by SCMPDS_5:45
        .=s.a2 by A39,A33,AMI_3:52,SCMPDS_2:58;
      thus IExec(IF2,Q1,t1).a4=IExec(j7,Q1,t1).a4 by A58,SCMPDS_6:88
        .=Exec(jj7,t01).a4 by SCMPDS_5:45
        .=s.a4 by A30,A33,AMI_3:52,SCMPDS_2:58;
      hereby
        let i be Element of NAT;
        assume
A59:    i>=8;
        then
A60:    i > 7 by XXREAL_0:2;
        thus IExec(WB2,P,s).intpos i=IExec(IF2,Q1,t1).intpos i by SCMPDS_5:39
          .=IExec(j7,Q1,t1).intpos i by A58,SCMPDS_6:88
          .=Exec(jj7,t01).intpos i by SCMPDS_5:45
          .=t01.intpos i by A33,A60,AMI_3:52,SCMPDS_2:58
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A51,A59;
      end;
    end;
    suppose
A61:  t1.DataLoc(t1.a,6) > 0;
      hence IExec(IF2,Q1,t1).a=IExec(j5 ';' j6,Q1,t1).a by SCMPDS_6:87
        .=Exec(j6,t5).a
         by A6,SCMPDS_5:47,U
        .=0 by A42,A43,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF2,Q1,t1).a1=IExec(j5 ';' j6,Q1,t1).a1 by A61,SCMPDS_6:87
        .=Exec(j6,t5).a1 by A6,SCMPDS_5:47,U
        .=s.a1 by A56,A43,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF2,Q1,t1).a2=IExec(j5 ';' j6,Q1,t1).a2 by A61,SCMPDS_6:87
        .=Exec(j6,t5).a2 by A6,SCMPDS_5:47,U
        .=s.a2 by A41,A43,AMI_3:52,SCMPDS_2:60;
      thus IExec(IF2,Q1,t1).a4=IExec(j5 ';' j6,Q1,t1).a4 by A61,SCMPDS_6:87
        .=Exec(j6,t5).a4 by A6,SCMPDS_5:47,U
        .=s.a4 by A40,A43,AMI_3:52,SCMPDS_2:60;
      hereby
        let i be Element of NAT;
        assume
A62:    i>=8;
        then
A63:    i > 5 by XXREAL_0:2;
        i > 3 by A62,XXREAL_0:2;
        then
A64:    intpos i<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
        thus IExec(WB2,P,s).intpos i=IExec(IF2,Q1,t1).intpos i by SCMPDS_5:39
          .=IExec(j5 ';' j6,Q1,t1).intpos i by A61,SCMPDS_6:87
          .=Exec(j6,t5).intpos i by A6,SCMPDS_5:47,U
          .=t5.intpos i by A43,A63,AMI_3:52,SCMPDS_2:60
          .=t01.intpos i by A64,SCMPDS_2:60
          .=t1.intpos i by SCMPDS_5:40
          .=s.intpos i by A51,A62;
      end;
    end;
  end;

  hence
  IExec(WB2,P,s).a=0 & IExec(WB2,P,s).a1=s.a1 & IExec(WB2,P,s).a2=s.a2
   & IExec(
  WB2,P,s).a4=s.a4 by SCMPDS_5:39;

  thus for i be Element of NAT st i >= 8 holds IExec(WB2,P,s).intpos i=s.intpos
  i by A57;

A65: t3.a7 =Exec(j2, t4).a7 by SCMPDS_5:47
    .=t4.a7+ -1 by A10,SCMPDS_2:60
    .=s.a7-1 by A19;
A66: t2.a7 =Exec(j3, t3).a7 by SCMPDS_5:46
    .=s.a7-1 by A65,A15,AMI_3:52,SCMPDS_2:59;
  t1.a7 =Exec(j4, t2).a7 by SCMPDS_5:46
    .=s.a7-1 by A66,A22,AMI_3:52,SCMPDS_2:62;
  then
A67: t01.a7=s.a7-1 by SCMPDS_5:40;
  t1.a3 =Exec(j4, t2).a3 by SCMPDS_5:46
    .=me by A20,A22,AMI_3:52,SCMPDS_2:62;
  then
A68: t01.a3=s.a3 by A2,SCMPDS_5:40;
A69: DataLoc(t01.a,3)=intpos(0+3) by A32,SCMP_GCD:5;
  hereby
A70: a7<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
    assume
A71: s.intpos md > s.intpos me;
    thus IExec(WB2,P,s).a7=IExec(IF2,Q1,t1).a7 by SCMPDS_5:39
      .=IExec(j5 ';' j6,Q1,t1).a7 by A55,A71,SCMPDS_6:87,XREAL_1:52
      .=Exec(j6,t5).a7 by A6,SCMPDS_5:47,U
      .=t5.a7 by A43,AMI_3:52,SCMPDS_2:60
      .=s.a7-1 by A67,A70,SCMPDS_2:60;
    thus IExec(WB2,P,s).a3=IExec(IF2,Q1,t1).a3 by SCMPDS_5:39
      .=IExec(j5 ';' j6,Q1,t1).a3 by A55,A71,SCMPDS_6:87,XREAL_1:52
      .=Exec(j6,t5).a3 by A6,SCMPDS_5:47,U
      .=t5.a3 by A43,AMI_3:52,SCMPDS_2:60
      .=s.a3+1 by A69,A68,SCMPDS_2:60;
A72: a5<>DataLoc(t01.a,3) by A32,AMI_3:52,SCMP_GCD:5;
    thus IExec(WB2,P,s).a5=IExec(IF2,Q1,t1).a5 by SCMPDS_5:39
      .=IExec(j5 ';' j6,Q1,t1).a5 by A55,A71,SCMPDS_6:87,XREAL_1:52
      .=Exec(j6,t5).a5 by A6,SCMPDS_5:47,U
      .=t5.a5+ -1 by A43,SCMPDS_2:60
      .=t5.a5-1
      .=s.a7-1 by A37,A72,SCMPDS_2:60;
  end;
  hereby
    assume
A73: s.intpos md <= s.intpos me;
    thus IExec(WB2,P,s).a7=IExec(IF2,Q1,t1).a7 by SCMPDS_5:39
      .=IExec(j7,Q1,t1).a7 by A55,A73,SCMPDS_6:88,XREAL_1:49
      .=Exec(jj7,t01).a7 by SCMPDS_5:45
      .=0 by A33,SCMPDS_2:58;
    thus IExec(WB2,P,s).a3=IExec(IF2,Q1,t1).a3 by SCMPDS_5:39
      .=IExec(j7,Q1,t1).a3 by A55,A73,SCMPDS_6:88,XREAL_1:49
      .=Exec(jj7,t01).a3 by SCMPDS_5:45
      .=s.a3 by A33,A68,AMI_3:52,SCMPDS_2:58;
    thus IExec(WB2,P,s).a5=IExec(IF2,Q1,t1).a5 by SCMPDS_5:39
      .=IExec(j7,Q1,t1).a5 by A55,A73,SCMPDS_6:88,XREAL_1:49
      .=Exec(jj7,t01).a5 by SCMPDS_5:45
      .=s.a7 by A37,A33,AMI_3:52,SCMPDS_2:58;
  end;
end;

Lm15: for s being 0-started State of SCMPDS,
m3,md be Element of NAT st s.GBP=0 & s.a7 >
0 & s.a3+s.a7=m3 & s.a3>=8 & s.a2=md & md >= 8
 holds IExec(WH2,P,s).GBP=0 & IExec(WH2,P,s).a1=s.a1 &
 IExec(WH2,P,s).a7=0 & IExec(WH2,P,s).a2=s.a2 & IExec(WH2,P,s).a4=s.a4 &
 (for i be Element of NAT st i >= 8 holds IExec(WH2,P,s).intpos i=s.intpos i)
& ex m5,mE3 be Element of NAT st m5=IExec(WH2,P,s).a5
 & IExec(WH2,P,s).a3=mE3 & mE3
+m5=m3 & m5 <= s.a7 & (for i be Element of NAT st s.a3 <= i & i < mE3 holds
IExec(WH2,P,s).intpos md > IExec(WH2,P,s).intpos i)
 & (m5 = 0 or IExec(WH2,P,s).
intpos md <= IExec(WH2,P,s).intpos mE3)

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m3,md be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a7 > 0 and
A3: s.a3+s.a7=m3 and
A4: s.a3>=8 and
A5: s.a2=md and
A6: md >= 8;
  s.a7 >=1+0 by A2,INT_1:20;
  then reconsider m7=s.a7-1 as Element of NAT by INT_1:16,XREAL_1:50;
A7: s.a7=m7+1;

  defpred P[Element of NAT] means
   for t being State of SCMPDS,Q st t.a=0 & t.a7

=$1+1 & t.a3+t.a7=m3 & t.a3>=8 & t.a2=md
 holds IExec(WH2,Q,t).a=0 & IExec(WH2,Q,t).
  a1=t.a1 & IExec(WH2,Q,t).a7=0 & IExec(WH2,Q,t).a2=t.a2
   & IExec(WH2,Q,t).a4=t.a4 & (

for i be Element of NAT st i >= 8
 holds IExec(WH2,Q,t).intpos i=t.intpos i) & ex

m5,mE3 be Element of NAT st m5=IExec(WH2,Q,t).a5
 & IExec(WH2,Q,t).a3=mE3 & mE3+m5=

m3 & m5 <= t.a7 & (for i be Element of NAT st t.a3 <= i & i < mE3
 holds IExec(WH2,Q,t).intpos md > IExec(WH2,Q,t).intpos i)
 & (m5=0 or IExec(WH2,Q,t).intpos md <=
  IExec(WH2,Q,t).intpos mE3);

A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      let t be State of SCMPDS;
      let Q;
      set b=DataLoc(t.a,7);
      assume that
A10:  t.a=0 and
A11:  t.a7 =(k+1)+1 and
A12:  t.a3+t.a7=m3 and
A13:  t.a3>=8 and
A14:  t.a2=md;
      reconsider me=t.a3 as Element of NAT by A13,INT_1:16;
      set It=IExec(WB2,Q,t), IT = Q;
A15:   It=IExec(WB2,Q,Initialize t) by SCMPDS_5:48;
A16:   t.a = (Initialize t).a by SCMPDS_5:40;
A17:   t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A18:   t.a2 = (Initialize t).a2 by SCMPDS_5:40;
A19:   t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A20:   t.a4 = (Initialize t).a4 by SCMPDS_5:40;
A21:   t.a7 = (Initialize t).a7 by SCMPDS_5:40;
A22:   t.intpos md = (Initialize t).intpos md by SCMPDS_5:40;
A23:   t.intpos me = (Initialize t).intpos me by SCMPDS_5:40;

A24:  t.intpos md > t.intpos me implies It.a7=t.a7-1 & It.a3=t.a3+1 & It.
      a5= t.a7-1 by A6,A10,A13,A14,Lm14,A16,A15,A18,A22,A23,A19,A21;

A25:  b=intpos (0+7) by A10,SCMP_GCD:5;
A26:  now
        let v be State of SCMPDS;
        let V;
        assume that
A27:    v.a3 >= 8 and
A28:    v.a2=t.a2 and
A29:    v.a=t.a and
A30:    v.b > 0;
        reconsider ME=v.a3 as Element of NAT by A27,INT_1:16;
A31:     IExec(WB2,V,v) = IExec(WB2,V,Initialize v) by SCMPDS_5:48;
A32:     v.intpos md = (Initialize v).intpos md by SCMPDS_5:40;
A33:     v.intpos ME = (Initialize v).intpos ME by SCMPDS_5:40;
A34:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A35:     v.a3 = (Initialize v).a3 by SCMPDS_5:40;
A36:     v.a7 = (Initialize v).a7 by SCMPDS_5:40;
A37:     v.a = (Initialize v).a by SCMPDS_5:40;
A38:    ME=v.a3;
        hence IExec(WB2,V,v).a=v.a
         by A6,A10,A14,A27,A28,A29,Lm14,A31,A37,A34,A35
;
        thus WB2 is_closed_on v,V & WB2 is_halting_on v,V by SCMPDS_6:34,35;

A39:    v.intpos md > v.intpos ME implies IExec(WB2,V,v).a7=v.a7-1
 & IExec(WB2,V,v).a3=v.a3+1
  & IExec(WB2,V,v).a5=v.a7-1 by A6,A10,A14,A27,A28,A29,Lm14,A31
,A32,A33,A37,A34,A35,A36;

        hereby
          per cases;
          suppose
A40:        v.intpos md > v.intpos ME;
            hence IExec(WB2,V,v).b < v.b by A25,A39,XREAL_1:148;
A41:        v.a3 +1 > v.a3 by XREAL_1:31;
            IExec(WB2,V,v).a3=v.a3+1 by A6,A10,A14,A27,A28,A29,A40,Lm14,A31,A32
,A33,A37,A34,A35;
            hence IExec(WB2,V,v).a3 >= 8 by A27,A41,XXREAL_0:2;
          end;
          suppose
A42:        v.intpos md <= v.intpos ME;

            hence IExec(WB2,V,v).b < v.b by A6,A10,A14,A25,A27,A28,A29,A30,Lm14
,A31,A32,A33,A37,A34,A35;

            thus IExec(WB2,V,v).a3 >= 8 by A6,A10,A14,A27,A28,A29,A42,Lm14,A31
,A32,A33,A37,A34,A35;
          end;
        end;
        thus IExec(WB2,V,v).a2=v.a2 by A6,A10,A14,A27,A28,A29,A38,Lm14,A31,A37
,A34,A35;
      end;

A43:  t.intpos md <= t.intpos me implies It.a7=0 & It.a3=t.a3 & It.a5=t.
      a7 by A6,A10,A13,A14,Lm14,A15,A18,A22,A23,A19,A21,A16;

A44:  me=t.a3;
      then
A45:  It.a=0 by A6,A10,A13,A14,Lm14,A15,A18,A19,A16;
      then
A46:  DataLoc(It.a,7)=intpos(0+7) by SCMP_GCD:5;
A47:  It.a1=t.a1 by A6,A10,A13,A14,A44,Lm14,A15,A17,A18,A19,A16;
A48:  It.a4=t.a4 by A6,A10,A13,A14,A44,Lm14,A15,A18,A20,A19,A16;
A49:  It.a2=t.a2 by A6,A10,A13,A14,A44,Lm14,A15,A18,A19,A16;
      per cases;
      suppose
A50:    t.intpos md > t.intpos me;
        then t.a3 < It.a3 by A24,XREAL_1:31;
        then
A51:    It.a3 >= 8 by A13,XXREAL_0:2;
A52:    It.a3+It.a7=m3 by A12,A24,A50;
        then consider m5,mE3 be Element of NAT such that
A53:    m5=IExec(WH2,IT,It).a5 and
A54:    IExec(WH2,IT,It).a3=mE3 and
A55:    mE3+m5=m3 and
A56:    m5 <= It.a7 and

A57:    for i be Element of NAT st It.a3 <= i & i < mE3 holds IExec(
        WH2,IT,It ).intpos md > IExec(WH2,IT,It).intpos i and

A58:    m5=0 or IExec(WH2,IT,It).intpos md <= IExec(WH2,IT,It).intpos mE3
        by A9,A11,A12,A14,A45,A49,A24,A43,A51;

A59:    IExec(WH2,Q,t)=IExec(WH2,IT,It) by A11,A13,A25,A26,Lm12,Th6;
        hence IExec(WH2,Q,t).a=0 by A9,A11,A12,A14,A45,A49,A24,A43,A51,A52;

        thus IExec(WH2,Q,t).a1=t.a1
         by A9,A11,A12,A14,A45,A47,A49,A24,A43,A51,A52
,A59;

        thus IExec(WH2,Q,t).a7=0 by A9,A11,A12,A14,A45,A49,A24,A43,A51,A52,A59;

        thus IExec(WH2,Q,t).a2=t.a2
         by A9,A11,A12,A14,A45,A49,A24,A43,A51,A52,A59
;

        thus IExec(WH2,Q,t).a4=t.a4
         by A9,A11,A12,A14,A45,A49,A48,A24,A43,A51,A52
,A59;

A60:    now
          let i be Element of NAT;
A61: t.intpos i = (Initialize t).intpos i by SCMPDS_5:40;
          assume
A62:      i >= 8;

          hence IExec(WH2,Q,t).intpos i=It.intpos i
           by A9,A11,A12,A14,A45,A49,A24
,A43,A51,A52,A59

            .=t.intpos i by A6,A10,A13,A14,A44,A62,Lm14,A15,A18,A19,A61,A16;
        end;

        hence for i be Element of NAT st i >= 8
         holds IExec(WH2,Q,t).intpos i=t.
        intpos i;

        take m5;
        take mE3;
        thus m5=IExec(WH2,Q,t).a5 by A11,A13,A25,A26,A53,Lm12,Th6;
        thus IExec(WH2,Q,t).a3=mE3 by A11,A13,A25,A26,A54,Lm12,Th6;
        thus mE3+m5=m3 by A55;
        thus m5 <= t.a7 by A24,A50,A56,XREAL_1:148,XXREAL_0:2;
A63:    It.a3=t.a3+1 by A6,A10,A13,A14,A50,Lm14,A15,A18,A22,A23,A19,A16;
        hereby
          let i be Element of NAT;
          assume that
A64:      t.a3 <= i and
A65:      i < mE3;
          per cases;
          suppose
A66:        i=t.a3;
            IExec(WH2,Q,t).intpos me =t.intpos me by A13,A60;

            hence IExec(WH2,Q,t).intpos md
             > IExec(WH2,Q,t).intpos i by A6,A50,A60
,A66;

          end;
          suppose
            i<>t.a3;
            then t.a3 < i by A64,XXREAL_0:1;
            then It.a3 <= i by A63,INT_1:20;

            hence
            IExec(WH2,Q,t).intpos md > IExec(WH2,Q,t).intpos i by A59,A57,A65;

          end;
        end;

        thus m5=0 or IExec(WH2,Q,t).intpos md
         <= IExec(WH2,Q,t).intpos mE3 by A59
,A58;

      end;
      suppose
A67:    t.intpos md <= t.intpos me;
A68:    now
          let x;
          thus IExec(WH2,Q,t).x =IExec(WH2,IT,It).x by A11,A13,A25,A26,Lm12,Th6
            .=It.x by A43,A46,A67,SCMPDS_8:23;
        end;
        hence IExec(WH2,Q,t).a=0 by A45;
        thus IExec(WH2,Q,t).a1=t.a1 by A47,A68;
        thus IExec(WH2,Q,t).a7=0 by A43,A67,A68;
        thus IExec(WH2,Q,t).a2=t.a2 by A49,A68;
        thus IExec(WH2,Q,t).a4=t.a4 by A48,A68;
A69:    now
          let i be Element of NAT;
A70: t.intpos i = (Initialize t).intpos i by SCMPDS_5:40;
          assume
A71:      i >= 8;
          thus IExec(WH2,Q,t).intpos i=It.intpos i by A68
            .=t.intpos i by A6,A10,A13,A14,A44,A71,Lm14,A70,A15,A18,A19,A16;
        end;

        hence for i be Element of NAT st i >= 8
         holds IExec(WH2,Q,t).intpos i=t.
        intpos i;

        take m5=k+1+1;
        take mE3=me;
        thus IExec(WH2,Q,t).a5=m5 by A11,A43,A67,A68;
        thus IExec(WH2,Q,t).a3=mE3 by A43,A67,A68;
        thus mE3+m5=m3 by A11,A12;
        thus m5 <= t.a7 by A11;

        thus for i be Element of NAT st t.a3 <= i & i < mE3
         holds IExec(WH2,Q,t)
        .intpos md > IExec(WH2,Q,t).intpos i;

        IExec(WH2,Q,t).intpos me=t.intpos me by A13,A69;

        hence m5=0 or IExec(WH2,Q,t).intpos md
         <= IExec(WH2,Q,t).intpos mE3 by A6
,A67,A69;

      end;
    end;
    hence P[k+1];
  end;
  now
    let t be State of SCMPDS;
    let Q;
    set b=DataLoc(t.a,7);
    assume that
A72: t.a=0 and
A73: t.a7 =0+1 and
A74: t.a3+t.a7=m3 and
A75: t.a3>=8 and
A76: t.a2=md;
    reconsider me=t.a3 as Element of NAT by A75,INT_1:16;
    set It=IExec(WB2,Q,t), IT = Q;
A77:   It=IExec(WB2,Q,Initialize t) by SCMPDS_5:48;
A78:   t.a = (Initialize t).a by SCMPDS_5:40;
A79:   t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A80:   t.a2 = (Initialize t).a2 by SCMPDS_5:40;
A81:   t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A82:   t.a4 = (Initialize t).a4 by SCMPDS_5:40;
A83:   t.a7 = (Initialize t).a7 by SCMPDS_5:40;
A84:   t.intpos md = (Initialize t).intpos md by SCMPDS_5:40;
A85:   t.intpos me = (Initialize t).intpos me by SCMPDS_5:40;

A86: t.intpos md > t.intpos me implies It.a7=t.a7-1 & It.a3=t.a3+1 & It.a5
    = t.a7-1 by A6,A72,A75,A76,Lm14,A77,A80,A84,A85,A81,A83,A78;

A87: b=intpos (0+7) by A72,SCMP_GCD:5;
A88: now
      let v be State of SCMPDS, V;
      assume that
A89:  v.a3 >= 8 and
A90:  v.a2=t.a2 and
A91:  v.a=t.a and
A92:  v.b > 0;
      reconsider ME=v.a3 as Element of NAT by A89,INT_1:16;
A93:  ME=v.a3;
A94:     IExec(WB2,V,v) = IExec(WB2,V,Initialize v) by SCMPDS_5:48;
A95:     v.intpos md = (Initialize v).intpos md by SCMPDS_5:40;
A96:     v.intpos ME = (Initialize v).intpos ME by SCMPDS_5:40;
A97:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A98:     v.a3 = (Initialize v).a3 by SCMPDS_5:40;
A99:     v.a7 = (Initialize v).a7 by SCMPDS_5:40;
A100:     v.a = (Initialize v).a by SCMPDS_5:40;
      thus IExec(WB2,V,v).a=v.a by A6,A72,A76,A89,A90,A91,Lm14,A94,A96,A100,A97
,A98;
      thus WB2 is_closed_on v,V & WB2 is_halting_on v,V by SCMPDS_6:34,35;

A101:  v.intpos md > v.intpos ME implies IExec(WB2,V,v).a7=v.a7-1 & IExec(

WB2,V,v) .a3=v.a3+1
 & IExec(WB2,V,v).a5=v.a7-1 by A6,A72,A76,A89,A90,A91,Lm14,A94
,A95,A96,A100,A97,A98,A99;

      hereby
        per cases;
        suppose
A102:      v.intpos md > v.intpos ME;
          hence IExec(WB2,V,v).b < v.b by A87,A101,XREAL_1:148;
A103:      v.a3 +1 > v.a3 by XREAL_1:31;
          IExec(WB2,V,v).a3=v.a3+1 by A6,A72,A76,A89,A90,A91,A102,Lm14,A94,A95
,A96,A100,A97,A98;
          hence IExec(WB2,V,v).a3 >= 8 by A89,A103,XXREAL_0:2;
        end;
        suppose
A104:      v.intpos md <= v.intpos ME;
          hence IExec(WB2,V,v).b < v.b
           by A6,A72,A76,A87,A89,A90,A91,A92,Lm14,A94
,A95,A96,A100,A97,A98;
          thus IExec(WB2,V,v).a3 >= 8
           by A6,A72,A76,A89,A90,A91,A104,Lm14,A94,A95
,A96,A100,A97,A98;
        end;
      end;
      thus IExec(WB2,V,v).a2=v.a2
       by A6,A72,A76,A89,A90,A91,A93,Lm14,A94,A100,A97
,A98;
    end;

A105: t.intpos md <= t.intpos me implies It.a7=0 & It.a3=t.a3 & It.a5=t.a7
    by A6,A72,A75,A76,Lm14,A77,A80,A84,A85,A81,A83,A78;

A106: me=t.a3;
    then
A107: It.a=0 by A6,A72,A75,A76,Lm14,A77,A80,A81,A78;
    then
A108: It.DataLoc(It.a,7)=0 by A73,A86,A105,SCMP_GCD:5;
A109: now
      let x;
      thus IExec(WH2,Q,t).x =IExec(WH2,IT,It).x by A73,A75,A87,A88,Lm12,Th6
        .=It.x by A108,SCMPDS_8:23;
    end;
    hence IExec(WH2,Q,t).a=0 by A107;
    It.a1=t.a1 by A6,A72,A75,A76,A106,Lm14,A77,A79,A80,A81,A78;
    hence IExec(WH2,Q,t).a1=t.a1 by A109;
    thus IExec(WH2,Q,t).a7=0 by A73,A86,A105,A109;
    It.a2=t.a2 by A6,A72,A75,A76,A106,Lm14,A77,A80,A81,A78;
    hence IExec(WH2,Q,t).a2=t.a2 by A109;
    It.a4=t.a4 by A6,A72,A75,A76,A106,Lm14,A77,A80,A82,A81,A78;
    hence IExec(WH2,Q,t).a4=t.a4 by A109;
A110: now
      let i be Element of NAT;
      assume
A111:  i >= 8;
A112: t.intpos i = (Initialize t).intpos i by SCMPDS_5:40;
      thus IExec(WH2,Q,t).intpos i=It.intpos i by A109
        .=t.intpos i by A6,A72,A75,A76,A106,A111,Lm14,A77,A80,A81,A78,A112;
    end;

    hence for i be Element of NAT st i >= 8 holds IExec(WH2,Q,t).intpos i=t.
    intpos i;

A113: IExec(WH2,Q,t).intpos me=t.intpos me by A75,A110;
    hereby
      per cases;
      suppose
A114:    t.intpos md > t.intpos me;
        take m5=0;
        take mE3=m3;
        thus IExec(WH2,Q,t).a5=m5 by A73,A86,A109,A114;
        thus IExec(WH2,Q,t).a3 =mE3 by A73,A74,A86,A109,A114;
        thus mE3+m5=m3;
        thus m5 <= t.a7 by A73;
        hereby
          let i be Element of NAT;
          assume that
A115:      t.a3 <= i and
A116:      i < mE3;
          i <= me by A73,A74,A116,NAT_1:13;
          then i=t.a3 by A115,XXREAL_0:1;

          hence IExec(WH2,Q,t).intpos md
           > IExec(WH2,Q,t).intpos i by A6,A110,A113
,A114;

        end;
        thus m5=0 or IExec(WH2,Q,t).intpos md <= IExec(WH2,Q,t).intpos mE3;
      end;
      suppose
A117:    t.intpos md <= t.intpos me;
        take m5=1;
        take mE3=me;
        thus IExec(WH2,Q,t).a5=m5 by A73,A105,A109,A117;
        thus IExec(WH2,Q,t).a3=mE3 by A105,A109,A117;
        thus mE3+m5=m3 by A73,A74;
        thus m5 <= t.a7 by A73;

        thus for i be Element of NAT st t.a3 <= i
         & i < mE3 holds IExec(WH2,Q,t)
        .intpos md > IExec(WH2,Q,t).intpos i;

        thus m5=0 or IExec(WH2,Q,t).intpos md
         <= IExec(WH2,Q,t).intpos mE3 by A6
,A110,A113,A117;

      end;
    end;
  end;
  then
A118: P[0];
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A118,A8);
  hence thesis by A1,A3,A4,A5,A7;
end;

Lm16: for s being State of SCMPDS,md be Element of NAT st s.GBP=0 & s.a3>=8 &
s.a2=md & md >= 8 holds WH2 is_closed_on s,P & WH2 is_halting_on s,P

proof
  set a=GBP;
  let s be State of SCMPDS,md be Element of NAT;
  set b=DataLoc(s.a,7);
  assume that
A1: s.a=0 and
A2: s.a3>=8 and
A3: s.a2=md and
A4: md >= 8;
A5: b=intpos (0+7) by A1,SCMP_GCD:5;
  now
    let v be State of SCMPDS, V;
    assume that
A6: v.a3 >= 8 and
A7: v.a2=s.a2 and
A8: v.a=s.a and
A9: v.b > 0;
A10:     IExec(WB2,V,v) = IExec(WB2,V,Initialize v) by SCMPDS_5:48;
A11:     v.intpos md = (Initialize v).intpos md by SCMPDS_5:40;
A12:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A13:     v.a3 = (Initialize v).a3 by SCMPDS_5:40;
A14:     v.a7 = (Initialize v).a7 by SCMPDS_5:40;
A15:     v.a = (Initialize v).a by SCMPDS_5:40;
    reconsider ME=v.a3 as Element of NAT by A6,INT_1:16;
A16:     v.intpos ME = (Initialize v).intpos ME by SCMPDS_5:40;
A17: ME=v.a3;
    hence IExec(WB2,V,v).a=v.a by A1,A3,A4,A6,A7,A8,Lm14,A10,A15,A12,A13;
    thus WB2 is_closed_on v,V & WB2 is_halting_on v,V by SCMPDS_6:34,35;

A18: v.intpos md > v.intpos ME implies IExec(WB2,V,v).a7=v.a7-1 & IExec(WB2,
    V,v) .a3=v.a3+1
     & IExec(WB2,V,v).a5=v.a7-1 by A1,A3,A4,A6,A7,A8,Lm14,A10,A11
,A16,A15,A12,A13,A14;

    hereby
      per cases;
      suppose
A19:    v.intpos md > v.intpos ME;
        hence IExec(WB2,V,v).b < v.b by A5,A18,XREAL_1:148;
A20:    v.a3 +1 > v.a3 by XREAL_1:31;
        IExec(WB2,V,v).a3=v.a3+1 by A1,A3,A4,A6,A7,A8,A19,Lm14,A10,A11,A16,A15
,A12,A13;
        hence IExec(WB2,V,v).a3 >= 8 by A6,A20,XXREAL_0:2;
      end;
      suppose
A21:    v.intpos md <= v.intpos ME;
        hence IExec(WB2,V,v).b < v.b
         by A1,A3,A4,A5,A6,A7,A8,A9,Lm14,A10,A11,A16
,A15,A12,A13;
        thus IExec(WB2,V,v).a3 >= 8
         by A1,A3,A4,A6,A7,A8,A21,Lm14,A10,A11,A16,A15
,A12,A13;
      end;
    end;
    thus IExec(WB2,V,v).a2=v.a2 by A1,A3,A4,A6,A7,A8,A17,Lm14,A10,A15,A12,A13;
  end;
  hence thesis by A2,Lm12,Th6;
end;

Lm17: card WB3=29
proof
  thus card WB3=card (WH1 ';' WH2 )+card IF3 by AFINSQ_1:20
    .=11+ 11+card IF3 by Lm11,Lm13,AFINSQ_1:20
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0)+1) by SCMPDS_6:89
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9)+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6 ';' k7 ';' k8)+1+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6 ';' k7)+1+1+1+1) by SCMP_GCD:8
    .=22+(card (k5 ';' k6)+1+1+1+1+1) by SCMP_GCD:8
    .=22+(2+1+1+1+1+1) by SCMP_GCD:9
    .=29;
end;

Lm18: card WH3=31
proof
  thus card WH3=29+2 by Lm17,SCMPDS_8:17
    .=31;
end;

begin :: The Basic Property of Partition Program

canceled 3;

theorem Th12:
  card Partition=38
proof
  thus card Partition=card (K4 ';' WH3 ';' j8 ';' j9)+1 by SCMP_GCD:8
    .=card (K4 ';' WH3 ';' j8)+1+1 by SCMP_GCD:8
    .=card (K4 ';' WH3)+1+1+1 by SCMP_GCD:8
    .=card K4+card WH3+1+1+1 by AFINSQ_1:20
    .=4+31+1+1+1 by Lm18,Th4
    .=38;
end;

Lm19: for s be 0-started State of SCMPDS,
m3,m4 be Element of NAT st s.GBP=0 & s.a5 > 0 &
s.a3=m3 & s.a4=m4 & m3>6 & m4 > 6
 holds IExec(IF3,P,s).GBP=0 & IExec(IF3,P,s).a1=s.
a1 & IExec(IF3,P,s).a2=s.a2 & IExec(IF3,P,s).intpos m3=s.intpos m4
 & IExec(IF3,P,s).
intpos m4=s.intpos m3 & IExec(IF3,P,s).a3=s.a3+1
 & IExec(IF3,P,s).a4=s.a4-1 &
 IExec(IF3,P,s).a5=s.a5-2 &
  for i be Element of NAT st i >= 8 & i <> m3 & i <> m4 holds
IExec(IF3,P,s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m3,m4 be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a3=m3 and
A4: s.a4=m4 and
A5: m3 > 6 and
A6: m4 > 6;
A7: m4 > 3 by A6,XXREAL_0:2;

  set x=intpos m3, y=intpos m4, t0=Initialize s, t1=IExec(k5 ';' k6 ';' k7

';' k8 ';' k9 ';' k0,P,s),
t2=IExec(k5 ';' k6 ';' k7 ';' k8 ';' k9,P,s), t3=IExec(

k5 ';' k6 ';' k7 ';' k8,P,s),
t4=IExec(k5 ';' k6 ';' k7,P,s), t5=IExec(k5 ';' k6,P,s)
  , t6=Exec(k5,t0);

A8: t0.a=0 by A1,SCMPDS_5:40;
  then
A9: DataLoc(t0.a,6)=intpos (0+6) by SCMP_GCD:5;
  then
A10: t6.a =0 by A8,AMI_3:52,SCMPDS_2:59;
A11: t0.a4=m4 by A4,SCMPDS_5:40;
  then
A12: t6.a4 =m4 by A9,AMI_3:52,SCMPDS_2:59;
  then
A13: DataLoc(t6.a4,0)=intpos (m4+0) by SCMP_GCD:5;
A14: t5.a =Exec(k6, t6).a by SCMPDS_5:47
    .=0 by A6,A10,A13,AMI_3:52,SCMPDS_2:59;
A15: t6.a6 =t0.DataLoc(t0.a4,0) by A9,SCMPDS_2:59
    .=t0.intpos(m4+0) by A11,SCMP_GCD:5
    .=s.y by SCMPDS_5:40;
  t5.a6 =Exec(k6, t6).a6 by SCMPDS_5:47
    .=s.y by A6,A15,A13,AMI_3:52,SCMPDS_2:59;
  then
A16: t5.DataLoc(t5.a,6)=s.y by A14,SCMP_GCD:5;
  t0.a3=m3 by A3,SCMPDS_5:40;
  then
A17: t6.a3 =m3 by A9,AMI_3:52,SCMPDS_2:59;
A18: t5.a3 =Exec(k6, t6).a3 by SCMPDS_5:47
    .=m3 by A7,A17,A13,AMI_3:52,SCMPDS_2:59;
  then
A19: DataLoc(t5.a3,0)=intpos (m3+0) by SCMP_GCD:5;
A20: t0.x=s.x by SCMPDS_5:40;
A21: t5.y=Exec(k6, t6).y by SCMPDS_5:47
    .=t6.DataLoc(t6.a3,0) by A13,SCMPDS_2:59
    .=t6.intpos(m3+0) by A17,SCMP_GCD:5
    .=s.x by A5,A20,A9,AMI_3:52,SCMPDS_2:59;
A22: now
    per cases;
    suppose
A23:  y<>DataLoc(t5.a3,0);
      thus t4.y =Exec(k7, t5).y by SCMPDS_5:46
        .=s.x by A21,A23,SCMPDS_2:59;
    end;
    suppose
A24:  y=DataLoc(t5.a3,0);
      thus t4.y =Exec(k7, t5).y by SCMPDS_5:46
        .=s.x by A19,A16,A24,SCMPDS_2:59;
    end;
  end;
  t0.a2=s.a2 by SCMPDS_5:40;
  then
A25: t6.a2 =s.a2 by A9,AMI_3:52,SCMPDS_2:59;
A26: m4 > 2 by A6,XXREAL_0:2;
A27: m3 > 5 by A5,XXREAL_0:2;
A28: t4.a =Exec(k7, t5).a by SCMPDS_5:46
    .=0 by A5,A14,A19,AMI_3:52,SCMPDS_2:59;
  then
A29: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:5;
A30: t3.a =Exec(k8, t4).a by SCMPDS_5:46
    .=0 by A28,A29,AMI_3:52,SCMPDS_2:60;
  then
A31: a<>DataLoc(t3.a,3) by AMI_3:52,SCMP_GCD:5;
A32: m3 > 3 by A5,XXREAL_0:2;
  then
A33: x<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A34: t4.a3 =Exec(k7, t5).a3 by SCMPDS_5:46
    .=m3 by A32,A18,A19,AMI_3:52,SCMPDS_2:59;
A35: t3.a3 =Exec(k8, t4).a3 by SCMPDS_5:46
    .=m3 by A34,A29,AMI_3:52,SCMPDS_2:60;
A36: DataLoc(t3.a,3)=intpos (0+3) by A30,SCMP_GCD:5;
A37: t2.a3 =Exec(k9, t3).a3 by SCMPDS_5:46
    .=m3+1 by A35,A36,SCMPDS_2:60;
A38: m3 > 2 by A5,XXREAL_0:2;
A39: m4 > 5 by A6,XXREAL_0:2;
A40: t5.a2 =Exec(k6, t6).a2 by SCMPDS_5:47
    .=s.a2 by A25,A13,A26,AMI_3:52,SCMPDS_2:59;
A41: t4.x=Exec(k7, t5).x by SCMPDS_5:46
    .=s.y by A19,A16,SCMPDS_2:59;
A42: t3.x =Exec(k8, t4).x by SCMPDS_5:46
    .=s.y by A27,A41,A29,AMI_3:52,SCMPDS_2:60;
A43: t2.x =Exec(k9, t3).x by SCMPDS_5:46
    .=s.y by A42,A33,SCMPDS_2:60;
A44: t3.y =Exec(k8, t4).y by SCMPDS_5:46
    .=s.x by A39,A22,A29,AMI_3:52,SCMPDS_2:60;
A45: y<>DataLoc(t3.a,3) by A7,A30,AMI_3:52,SCMP_GCD:5;
A46: t2.y =Exec(k9, t3).y by SCMPDS_5:46
    .=s.x by A44,A45,SCMPDS_2:60;
A47: t4.a2 =Exec(k7, t5).a2 by SCMPDS_5:46
    .=s.a2 by A40,A19,A38,AMI_3:52,SCMPDS_2:59;
A48: t3.a2 =Exec(k8, t4).a2 by SCMPDS_5:46
    .=s.a2 by A47,A29,AMI_3:52,SCMPDS_2:60;
A49: a2<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A50: t2.a2 =Exec(k9, t3).a2 by SCMPDS_5:46
    .=s.a2 by A48,A49,SCMPDS_2:60;
A51: m4 > 1 by A6,XXREAL_0:2;
A52: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:5;
  t0.a5=s.a5 by SCMPDS_5:40;
  then
A53: t6.a5 =s.a5 by A9,AMI_3:52,SCMPDS_2:59;
A54: t5.a5 =Exec(k6, t6).a5 by SCMPDS_5:47
    .=s.a5 by A39,A53,A13,AMI_3:52,SCMPDS_2:59;
A55: t4.a5 =Exec(k7, t5).a5 by SCMPDS_5:46
    .=s.a5 by A27,A54,A19,AMI_3:52,SCMPDS_2:59;
A56: t3.a5 =Exec(k8, t4).a5 by SCMPDS_5:46
    .=t4.a5+-2 by A29,SCMPDS_2:60
    .=s.a5-2 by A55;
A57: a5<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A58: t2.a5 =Exec(k9, t3).a5 by SCMPDS_5:46
    .=s.a5-2 by A56,A57,SCMPDS_2:60;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A59: t6.a1 =s.a1 by A9,AMI_3:52,SCMPDS_2:59;
A60: m3 > 1 by A5,XXREAL_0:2;
A61: t2.a =Exec(k9, t3).a by SCMPDS_5:46
    .=0 by A30,A31,SCMPDS_2:60;
  then
A62: a<>DataLoc(t2.a,4) by AMI_3:52,SCMP_GCD:5;
A63: m4 > 4 by A6,XXREAL_0:2;
  then
A64: y<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A65: m3 > 4 by A5,XXREAL_0:2;
  then
A66: x<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A67: a4<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A68: t5.a4 =Exec(k6, t6).a4 by SCMPDS_5:47
    .=m4 by A63,A12,A13,AMI_3:52,SCMPDS_2:59;
A69: t4.a4 =Exec(k7, t5).a4 by SCMPDS_5:46
    .=m4 by A65,A68,A19,AMI_3:52,SCMPDS_2:59;
A70: t3.a4 =Exec(k8, t4).a4 by SCMPDS_5:46
    .=m4 by A69,A29,AMI_3:52,SCMPDS_2:60;
A71: t2.a4 =Exec(k9, t3).a4 by SCMPDS_5:46
    .=m4 by A70,A67,SCMPDS_2:60;
A72: a3<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A73: t5.a1 =Exec(k6, t6).a1 by SCMPDS_5:47
    .=s.a1 by A59,A13,A51,AMI_3:52,SCMPDS_2:59;
A74: t4.a1 =Exec(k7, t5).a1 by SCMPDS_5:46
    .=s.a1 by A73,A19,A60,AMI_3:52,SCMPDS_2:59;
A75: t3.a1 =Exec(k8, t4).a1 by SCMPDS_5:46
    .=s.a1 by A74,A29,AMI_3:52,SCMPDS_2:60;
A76: a1<>DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
A77: t2.a1 =Exec(k9, t3).a1 by SCMPDS_5:46
    .=s.a1 by A75,A76,SCMPDS_2:60;
A78: a1<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t1.a =Exec(k0, t2).a by SCMPDS_5:46
    .=0 by A61,A62,SCMPDS_2:60;
  hence IExec(IF3,P,s).a=0 by A2,A52,SCMPDS_6:97;
  t1.a1 =Exec(k0, t2).a1 by SCMPDS_5:46
    .=s.a1 by A77,A78,SCMPDS_2:60;
  hence IExec(IF3,P,s).a1=s.a1 by A2,A52,SCMPDS_6:97;
A79: a2<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t1.a2 =Exec(k0, t2).a2 by SCMPDS_5:46
    .=s.a2 by A50,A79,SCMPDS_2:60;
  hence IExec(IF3,P,s).a2=s.a2 by A2,A52,SCMPDS_6:97;
  t1.x =Exec(k0, t2).x by SCMPDS_5:46
    .=s.y by A43,A66,SCMPDS_2:60;
  hence IExec(IF3,P,s).x=s.y by A2,A52,SCMPDS_6:97;
  t1.y =Exec(k0, t2).y by SCMPDS_5:46
    .=s.x by A46,A64,SCMPDS_2:60;
  hence IExec(IF3,P,s).y=s.x by A2,A52,SCMPDS_6:97;
A80: DataLoc(t2.a,4)=intpos (0+4) by A61,SCMP_GCD:5;
  t1.a3 =Exec(k0, t2).a3 by SCMPDS_5:46
    .=m3+1 by A37,A72,SCMPDS_2:60;
  hence IExec(IF3,P,s).a3=s.a3+1 by A2,A3,A52,SCMPDS_6:97;
  t1.a4 =Exec(k0, t2).a4 by SCMPDS_5:46
    .=t2.a4+-1 by A80,SCMPDS_2:60
    .=s.a4-1 by A4,A71;
  hence IExec(IF3,P,s).a4=s.a4-1 by A2,A52,SCMPDS_6:97;
A81: a5<>DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t1.a5 =Exec(k0, t2).a5 by SCMPDS_5:46
    .=s.a5-2 by A58,A81,SCMPDS_2:60;
  hence IExec(IF3,P,s).a5=s.a5-2 by A2,A52,SCMPDS_6:97;
A82: now
    let i be Element of NAT;
    assume that
A83: i >= 8 and
    i <> m3 and
    i <> m4;
    i > 6 by A83,XXREAL_0:2;
    hence t6.intpos i =t0.intpos i by A9,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A84: now
    let i be Element of NAT;
    assume that
A85: i >= 8 and
A86: i <> m3 and
A87: i <> m4;
    thus t5.intpos i =Exec(k6, t6).intpos i by SCMPDS_5:47
      .=t6.intpos i by A13,A87,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A82,A85,A86,A87;
  end;
A88: now
    let i be Element of NAT;
    assume that
A89: i >= 8 and
A90: i <> m3 and
A91: i <> m4;
    thus t4.intpos i =Exec(k7, t5).intpos i by SCMPDS_5:46
      .=t5.intpos i by A19,A90,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A84,A89,A90,A91;
  end;
A92: now
    let i be Element of NAT;
    assume that
A93: i >= 8 and
A94: i <> m3 and
A95: i <> m4;
A96: i > 5 by A93,XXREAL_0:2;
    thus t3.intpos i =Exec(k8, t4).intpos i by SCMPDS_5:46
      .=t4.intpos i by A29,A96,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A88,A93,A94,A95;
  end;
A97: now
    let i be Element of NAT;
    assume that
A98: i >= 8 and
A99: i <> m3 and
A100: i <> m4;
    i > 3 by A98,XXREAL_0:2;
    then
A101: intpos i <> DataLoc(t3.a,3) by A30,AMI_3:52,SCMP_GCD:5;
    thus t2.intpos i =Exec(k9, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A101,SCMPDS_2:60
      .=s.intpos i by A92,A98,A99,A100;
  end;
A102: now
    let i be Element of NAT;
    assume that
A103: i >= 8 and
A104: i <> m3 and
A105: i <> m4;
    i > 4 by A103,XXREAL_0:2;
    then
A106: intpos i <> DataLoc(t2.a,4) by A61,AMI_3:52,SCMP_GCD:5;
    thus t1.intpos i =Exec(k0, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A106,SCMPDS_2:60
      .=s.intpos i by A97,A103,A104,A105;
  end;
  hereby
    let i be Element of NAT;
    assume that
A107: i >= 8 and
A108: i <> m3 and
A109: i <> m4;
    thus IExec(IF3,P,s).intpos i = t1.intpos i by A2,A52,SCMPDS_6:97
      .=s.intpos i by A102,A107,A108,A109;
  end;
end;

Lm20: for s be 0-started State of SCMPDS,
md,m3 be Element of NAT st s.GBP=0 & s.a5 > 0 &
s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= 8 & md <= m3
 holds WB3 is_closed_on s,P
  & WB3 is_halting_on s,P & IExec(WB3,P,s).GBP=0 & IExec(WB3,P,s).a1=s.a1
 & IExec(WB3,P
,s).a2=md & IExec(WB3,P,s).a3 >= s.a3
 & IExec(WB3,P,s).a4 <= s.a4 & IExec(WB3,P,s).a4
>= m3 & IExec(WB3,P,s).a5 < s.a5 & IExec(WB3,P,s).a5 >= -1
 & IExec(WB3,P,s).a4=IExec(
WB3,P,s).a3-1+IExec(WB3,P,s).a5
 & ex n1,n2 be Element of NAT st n1=IExec(WB3,P,s).a3-
1 & n2=IExec(WB3,P,s).a4+1
 & (for i be Element of NAT st i >= 8 & i <>n1 & i<> n2
holds IExec(WB3,P,s).intpos i=s.intpos i)
 & (IExec(WB3,P,s).intpos n1=s.intpos n1 &
IExec(WB3,P,s).intpos n2=s.intpos n2 or n1 >= s.a3
 & n2 <= s.a4 & IExec(WB3,P,s).
intpos n1=s.intpos n2 & IExec(WB3,P,s).intpos n2=s.intpos n1)
 & (for i be Element
of NAT st s.a3<=i & i <= n1
 holds IExec(WB3,P,s).intpos md >= IExec(WB3,P,s).intpos
i) & for i be Element of NAT st n2<=i & i <= s.a4
 holds IExec(WB3,P,s).intpos md
<= IExec(WB3,P,s).intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,m3 be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a4=m3+s.a5 and
A4: m3=s.a3-1 and
A5: s.a2=md and
A6: md >= 8 and
A7: md <= m3;
  set s1=IExec(WH1,P,s), P1 = P;
A8: s1.a = (Initialize s1).a by SCMPDS_5:40;
A9: s1.a1 = (Initialize s1).a1 by SCMPDS_5:40;
A10: s1.a2 = (Initialize s1).a2 by SCMPDS_5:40;
A11: s1.a3 = (Initialize s1).a3 by SCMPDS_5:40;
A12: s1.a4 = (Initialize s1).a4 by SCMPDS_5:40;
A13: s1.a7 = (Initialize s1).a7 by SCMPDS_5:40;
A14: m3 >= 8 by A6,A7,XXREAL_0:2;
  then consider mE be Element of NAT such that
A15: mE=s1.a7 and
A16: s1.a4=m3+mE and
A17: mE <= s.a5 and

A18: for i be Element of NAT st m3+mE < i & i <=s.a4 holds s1.intpos md
  < s1.intpos i and

A19: mE = 0 or s1.intpos md >= s1.intpos(m3+mE) by A1,A2,A3,A5,A6,Lm9;

A20: s1.a=0 by A1,A2,A3,A5,A6,A14,Lm9;
A21: s1.a1=s.a1 by A1,A2,A3,A5,A6,A14,Lm9;
A22: WH1 is_halting_on s,P by A1,A3,A5,A6,A14,Lm10;

  set s2=IExec(WH2,P1,s1), sm=m3+1+mE,
     s12=IExec(WH1 ';' WH2,P,s), s3=IExec(WB3,P,s), P12 = P, P3 = P,
  m4=m3+mE;
A23: s12.a = (Initialize s12).a by SCMPDS_5:40;
A24: s12.a1 = (Initialize s12).a1 by SCMPDS_5:40;
A25: s12.a2 = (Initialize s12).a2 by SCMPDS_5:40;
A26: s12.a3 = (Initialize s12).a3 by SCMPDS_5:40;
A27: s12.a4 = (Initialize s12).a4 by SCMPDS_5:40;
A28: s12.a5 = (Initialize s12).a5 by SCMPDS_5:40;
A29: s1.a3+s1.a7=sm by A1,A2,A3,A4,A5,A6,A14,A15,Lm9;
A30: m4 >= 8 by A14,NAT_1:12;
A31: s1.a2=s.a2 by A1,A2,A3,A5,A6,A14,Lm9;
A32: s1.a3=s.a3 by A1,A2,A3,A5,A6,A14,Lm9;
  s1.a3=m3+1 by A1,A2,A3,A4,A5,A6,A14,Lm9;
  then m3 < s1.a3 by XREAL_1:31;
  then
A33: s1.a3 >= 8 by A14,XXREAL_0:2;
A34: s1.a5=0 by A1,A2,A3,A5,A6,A14,Lm9;
A35: m3+mE <= m3+s.a5 by A17,XREAL_1:8;
A36: WH1 is_closed_on s,P by A1,A3,A5,A6,A14,Lm10;
A37: s2=IExec(WH2,P1,Initialize s1) by SCMPDS_5:48;
  per cases;
  suppose
A38: mE <= 0;
A39: DataLoc(s1.a,7)=intpos(0+7) by A20,SCMP_GCD:5;
    then
A40: WH2 is_halting_on s1,P1 by A15,A38,SCMPDS_8:20;
A41: WH2 is_closed_on s1,P1 by A15,A38,A39,SCMPDS_8:20;
    then
A42: s12.a5=s2.a5 by A36,A22,A40,SCMPDS_7:49
      .=0 by A34,A15,A38,A39,SCMPDS_8:23;
A43: s12.a=s2.a by A36,A22,A41,A40,SCMPDS_7:49
      .=0 by A20,A15,A38,A39,SCMPDS_8:23;
    then
A44: DataLoc(s12.a,5)=intpos(0+5) by SCMP_GCD:5;
A45: WH1 ';' WH2 is_halting_on s,P by A36,A22,A41,A40,SCMPDS_7:43;
A46: WH1 ';' WH2 is_closed_on s,P by A36,A22,A41,A40,SCMPDS_7:43;
    hence WB3 is_closed_on s,P & WB3 is_halting_on s,P by A45,SCPISORT:9;
    thus IExec(WB3,P,s).a=IExec(IF3,P12,s12).a by A46,A45,SCPISORT:7
      .=0 by A43,A42,A44,SCMPDS_6:98;
    thus IExec(WB3,P,s).a1=IExec(IF3,P12,s12).a1 by A46,A45,SCPISORT:7
      .= s12.a1 by A42,A44,SCMPDS_6:98
      .= s2.a1 by A36,A22,A41,A40,SCMPDS_7:49
      .= s.a1 by A21,A15,A38,A39,SCMPDS_8:23;
    thus s3.a2=IExec(IF3,P12,s12).a2 by A46,A45,SCPISORT:7
      .= s12.a2 by A42,A44,SCMPDS_6:98
      .= s2.a2 by A36,A22,A41,A40,SCMPDS_7:49
      .= md by A5,A31,A15,A38,A39,SCMPDS_8:23;
A47: s3.a3=IExec(IF3,P12,s12).a3 by A46,A45,SCPISORT:7
      .= s12.a3 by A42,A44,SCMPDS_6:98
      .= s2.a3 by A36,A22,A41,A40,SCMPDS_7:49
      .= s.a3 by A32,A15,A38,A39,SCMPDS_8:23;
    hence s3.a3 >= s.a3;
A48: s3.a4=IExec(IF3,P12,s12).a4 by A46,A45,SCPISORT:7
      .= s12.a4 by A42,A44,SCMPDS_6:98
      .= s2.a4 by A36,A22,A41,A40,SCMPDS_7:49
      .= m4 by A15,A16,A38,A39,SCMPDS_8:23;
    hence s3.a4 <= s.a4 by A3,A17,XREAL_1:8;
    thus s3.a4 >= m3 by A48,NAT_1:12;
A49: s3.a5=IExec(IF3,P12,s12).a5 by A46,A45,SCPISORT:7
      .=0 by A42,A44,SCMPDS_6:98;
    hence s3.a5 < s.a5 by A2;
    thus s3.a5 >= -1 by A49;
    thus s3.a4=s3.a3-1+s3.a5 by A4,A38,A47,A48,A49;
    take n1=m4;
    take n2=m4+1;
A50: mE=0 by A38;
    hence n1=s3.a3-1 by A4,A47;
    thus n2=s3.a4+1 by A48;
A51: now
      let x;
      thus s3.x=IExec(IF3,P12,s12).x by A46,A45,SCPISORT:7
        .=s12.x by A42,A44,SCMPDS_6:98
        .=s2.x by A36,A22,A41,A40,SCMPDS_7:49;
    end;
A52: now
      let i be Element of NAT;
      assume
A53:  i >= 8;
      thus s3.intpos i=s2.intpos i by A51
        .=s1.intpos i by A15,A38,A39,SCMPDS_8:23
        .=s.intpos i by A1,A2,A3,A5,A6,A14,A53,Lm9;
    end;

    hence
    for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds s3.intpos i
    =s.intpos i;

A54: m4 < n2 by XREAL_1:31;

    hence s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or n1 >= s.a3 &

n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A30,A52,
XXREAL_0:2;

    thus for i be Element of NAT st s.a3<=i & i <= n1 holds s3.intpos md >= s3
    .intpos i by A4,A50,XREAL_1:148,XXREAL_0:2;

    hereby
A55:  s3.intpos md=s2.intpos md by A51
        .=s1.intpos md by A15,A38,A39,SCMPDS_8:23;
      let i be Element of NAT;
      assume that
A56:  n2<=i and
A57:  i <= s.a4;
A58:  s3.intpos i=s2.intpos i by A51
        .=s1.intpos i by A15,A38,A39,SCMPDS_8:23;
      m4 < i by A54,A56,XXREAL_0:2;
      hence s3.intpos md <= s3.intpos i by A18,A57,A55,A58;
    end;
  end;
  suppose
A59: mE > 0;
  then consider m5,mE3 be Element of NAT such that
A60: m5=s2.a5 and
A61: s2.a3=mE3 and
A62: mE3+m5=sm and
A63: m5 <= (Initialize s1).a7 and
A64: (for i be Element of NAT st (Initialize s1).a3 <= i & i < mE3 holds
    s2.intpos md > s2.intpos i) and
A65: (m5 = 0 or s2.intpos
 md <= s2.intpos mE3) by A4,A5,A6,A15,A20,A31,A32,A33,A37,Lm15,A8,A10,A13,A11;
A66: mE3+m5 <= mE3+s1.a7 by A63,A13,XREAL_1:8;
    then
A67: s1.a3 <= mE3 by A4,A32,A15,A62,XREAL_1:8;
A68: s1.a3+s1.a7 <= mE3+s1.a7 by A4,A32,A15,A62,A63,A13,XREAL_1:8;
    then
A69: s.a3 <= mE3 by A32,XREAL_1:8;
    then mE3 >= 8 by A32,A33,XXREAL_0:2;
    then
A70: mE3 > 6 by XXREAL_0:2;
A71: WH2 is_halting_on s1,P1 by A5,A6,A20,A31,A33,Lm16;
A72: WH2 is_closed_on s1,P1 by A5,A6,A20,A31,A33,Lm16;
    then
A73: WH1 ';' WH2 is_closed_on s,P by A36,A22,A71,SCMPDS_7:43;
    s2.a1=s1.a1 by A4,A5,A6,A20,A31,A32,A33,A29,A59,Lm15,A8,A9,A10,A11,A13,A37;
    then
A74: s12.a1=s.a1 by A21,A36,A22,A72,A71,SCMPDS_7:49;
    s2.a4=s1.a4 by A4,A5,A6,A20,A31,A32,A33,A29,A59,Lm15,A8,A10,A11,A12,A13,A37
;
    then
A75: s12.a4=m4 by A16,A36,A22,A72,A71,SCMPDS_7:49;
    s2.a2=s1.a2 by A4,A5,A6,A20,A31,A32,A33,A29,A59,Lm15,A8,A10,A11,A13,A37;
    then
A76: s12.a2=md by A5,A31,A36,A22,A72,A71,SCMPDS_7:49;
    s2.a=0 by A4,A5,A6,A20,A31,A32,A33,A29,A59,Lm15,A8,A10,A11,A13,A37;
    then
A77: s12.a=0 by A36,A22,A72,A71,SCMPDS_7:49;
A78: s12.a5=m5 by A36,A22,A60,A72,A71,SCMPDS_7:49;
A79: s12.a3=mE3 by A36,A22,A61,A72,A71,SCMPDS_7:49;
A80: WH1 ';' WH2 is_halting_on s,P by A36,A22,A72,A71,SCMPDS_7:43;
    hence WB3 is_closed_on s,P & WB3 is_halting_on s,P by A73,SCPISORT:9;
A81: m4 > 6 by A30,XXREAL_0:2;
A82: m4 > m3+0 by A59,XREAL_1:8;
    then
A83: m4 >= m3+1 by INT_1:20;
A84: IExec(IF3,P12,s12) = IExec(IF3,P12,Initialize s12) by SCMPDS_5:48;
    hereby
      per cases;
      suppose
A85:    s12.a5 > 0;
        then IExec(IF3,P12,s12).a=0
         by A77,A79,A70,A75,A81,Lm19,A23,A26,A27,A28,A84
;
        hence IExec(WB3,P,s).a=0 by A73,A80,SCPISORT:7;
        IExec(IF3,P12,s12).a1=s12.a1
         by A77,A79,A70,A75,A81,A85,Lm19,A23,A24,A26
,A27,A28,A84;
        hence IExec(WB3,P,s).a1=s.a1 by A73,A80,A74,SCPISORT:7;
        IExec(IF3,P12,s12).a2=s12.a2
         by A77,A79,A70,A75,A81,A85,Lm19,A23,A25,A26
,A27,A28,A84;
        hence s3.a2=md by A73,A80,A76,SCPISORT:7;
        IExec(IF3,P12,s12).a3=s12.a3+1
         by A77,A79,A70,A75,A81,A85,Lm19,A23,A26,A27
,A28,A84;
        then
A86:    s3.a3=mE3+1 by A73,A80,A79,SCPISORT:7;
        then mE3 < s3.a3 by XREAL_1:31;
        hence s3.a3 >= s.a3 by A32,A67,XXREAL_0:2;
A87:    IExec(IF3,P12,s12).a4=s12.a4-1
 by A77,A79,A70,A75,A81,A85,Lm19,A23,A26,A27
,A28,A84;
        then
A88:    s3.a4=m4-1 by A73,A80,A75,SCPISORT:7;
        hence s3.a4 <= s.a4 by A3,A35,XREAL_1:148,XXREAL_0:2;
A89:    IExec(IF3,P12,s12).a5=s12.a5-2
 by A77,A79,A70,A75,A81,A85,Lm19,A23,A26,A27
,A28,A84;
        then
A90:    s3.a5 =s12.a5-2 by A73,A80,SCPISORT:7;
        s12.a5 >=0+1 by A85,INT_1:20;
        then
A91:    s12.a5-2 >= 1-2 by XREAL_1:11;
        then
A92:    s3.a5+1 >= -1+1 by A90,XREAL_1:8;
        thus s3.a4 >= m3 by A83,A88,XREAL_1:21;
        m5 <= s.a5 by A15,A17,A63,A13,XXREAL_0:2;
        then m5-2 < s.a5-0 by XREAL_1:17;
        hence s3.a5 < s.a5 by A36,A22,A60,A72,A71,A90,SCMPDS_7:49;
        thus s3.a5 >= -1 by A73,A80,A89,A91,SCPISORT:7;

        thus s3.a4=s3.a3-1+s3.a5 by A62,A73,A80,A75,A78,A87,A86,A90,SCPISORT:7;

        take n1=mE3;
        take n2=m4;
        n2=n1+(s3.a5+1) by A62,A78,A90;
        then
A93:    n2 >= n1+0 by A92,XREAL_1:8;
        thus n1=s3.a3-1 by A86;
        thus n2=m4+-1+1
          .=s3.a4+1 by A73,A80,A75,A87,SCPISORT:7;
A94:    now
          let i be Element of NAT;
A95:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:40;
          assume
A96:      i >= 8;
          thus s12.intpos i=s2.intpos i by A36,A22,A72,A71,SCMPDS_7:49
            .=s1.intpos i by A4,A5,A6,A20,A31,A32,A33,A29,A59,A96,Lm15,A8,A10
,A11,A13,A37,A95
            .=s.intpos i by A1,A2,A3,A5,A6,A14,A96,Lm9;
        end;
A97:    now
          let i be Element of NAT;
          assume that
A98:      i >= 8 and
A99:      i <>n1 and
A100:      i<> n2;
A101: s12.intpos i = (Initialize s12).intpos i by SCMPDS_5:40;
          thus s3.intpos i=IExec(IF3,P12,s12).intpos i by A73,A80,SCPISORT:7
            .=s12.intpos i by A77,A79,A70,A75,A81,A85,A98,A99,A100,Lm19,A23,A26
,A27,A28,A84,A101
            .=s.intpos i by A94,A98;
        end;

        hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds s3.
        intpos i=s.intpos i;
A102: s12.intpos m4 = (Initialize s12).intpos m4 by SCMPDS_5:40;

        IExec(IF3,P12,s12).intpos mE3=s12.intpos m4
         by A77,A79,A70,A75,A81,A85,Lm19
,A23,A26,A27,A28,A84,A102;

        then
A103:    s3.intpos n1=s12.intpos n2 by A73,A80,SCPISORT:7
          .=s.intpos n2 by A14,A94,NAT_1:12;
        m3 < m3+1 by XREAL_1:31;
        then m3 < n1 by A4,A32,A67,XXREAL_0:2;
        then
A104:    md < n1 by A7,XXREAL_0:2;
        then md < n2 by A93,XXREAL_0:2;
        then
A105:    n2 >= 8 by A6,XXREAL_0:2;
A106:    s3.intpos md=s.intpos md by A6,A97,A104,A93;
        then
A107:    s1.intpos md=s3.intpos md by A1,A2,A3,A5,A6,A14,Lm9;
A108: s12.intpos mE3 = (Initialize s12).intpos mE3 by SCMPDS_5:40;

        IExec(IF3,P12,s12).intpos m4=s12.intpos mE3
         by A77,A79,A70,A75,A81,A85,Lm19
,A23,A26,A27,A28,A84,A108;

        then
A109:    s3.intpos n2=s12.intpos n1 by A73,A80,SCPISORT:7
          .=s.intpos n1 by A32,A33,A69,A94,XXREAL_0:2;

        hence
        s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or s.a3 <= n1

& n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A3,A32
,A17,A68,A103,XREAL_1:8;
A110:      s1.intpos md = (Initialize s1).intpos md by SCMPDS_5:40;
A111:    s2.intpos md=s1.intpos md by A4,A5,A6,A20,A31,A32,A33,A29,A59,Lm15,A8
,A10,A11,A13,A37,A110

          .=s3.intpos md by A1,A2,A3,A5,A6,A14,A106,Lm9;
        hereby
          let i be Element of NAT;
          assume that
A112:      s.a3<=i and
A113:      i <= n1;
A114:      i >= 8 by A32,A33,A112,XXREAL_0:2;
A115:      s1.a3 <= i by A1,A2,A3,A5,A6,A14,A112,Lm9;
          per cases;
          suppose
A116:        i < n1;
A117:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:40;
            s2.intpos i=s1.intpos i by A4,A5,A6,A20,A31,A32,A33,A29,A59,A114,A8
,A10,A11,A13,A37,A117,Lm15

              .=s.intpos i by A1,A2,A3,A5,A6,A14,A114,Lm9
              .=s3.intpos i by A32,A33,A97,A93,A112,A116,XXREAL_0:2;
            hence s3.intpos md >= s3.intpos i by A64,A111,A115,A116,A11;
          end;
          suppose
            i >= n1;
            then i=n1 by A113,XXREAL_0:1;

            hence
            s3.intpos md >= s3.intpos i by A1,A2,A3,A5,A6,A14,A19,A59,A103,A105
,A107,Lm9;

          end;
        end;
A118:    n1 >= 8 by A6,A104,XXREAL_0:2;
        hereby
          let i be Element of NAT;
          assume that
A119:      n2<=i and
A120:     i <= s.a4;
A121:     i >= 8 by A105,A119,XXREAL_0:2;
A122:      s1.intpos n1 = (Initialize s1).intpos n1 by SCMPDS_5:40;
          per cases;
          suppose
A123:       n2 < i;
            s1.intpos i=s.intpos i by A1,A2,A3,A5,A6,A14,A121,Lm9
              .=s3.intpos i by A97,A93,A105,A123,XXREAL_0:2;
            hence s3.intpos md <= s3.intpos i by A18,A107,A120,A123;
          end;
          suppose
            n2 >= i;
            then i=n2 by A119,XXREAL_0:1;

            then s3.intpos i=s1.intpos n1 by A1,A2,A3,A5,A6,A14,A109,A118,Lm9

              .=s2.intpos n1 by A4,A5,A6,A20,A31,A32,A33,A29,A59,A118,Lm15,A8
,A10,A11,A13,A37,A122;

            hence s3.intpos md <= s3.intpos i by A36,A22,A60,A65,A72,A71,A85
,A111,SCMPDS_7:49;

          end;
        end;
      end;
      suppose
A124:   s12.a5 <= 0;
A125:   DataLoc(s12.a,5)=intpos(0+5) by A77,SCMP_GCD:5;
        thus IExec(WB3,P,s).a=IExec(IF3,P12,s12).a by A73,A80,SCPISORT:7
          .=0 by A77,A124,A125,SCMPDS_6:98;
        thus IExec(WB3,P,s).a1=IExec(IF3,P12,s12).a1 by A73,A80,SCPISORT:7
          .= s.a1 by A74,A124,A125,SCMPDS_6:98;
        thus s3.a2=IExec(IF3,P12,s12).a2 by A73,A80,SCPISORT:7
          .= md by A76,A124,A125,SCMPDS_6:98;
A126:   s3.a3=IExec(IF3,P12,s12).a3 by A73,A80,SCPISORT:7
          .= mE3 by A79,A124,A125,SCMPDS_6:98;
        hence s3.a3 >= s.a3 by A4,A15,A62,A66,XREAL_1:8;
A127:   s3.a4=IExec(IF3,P12,s12).a4 by A73,A80,SCPISORT:7
          .= m4 by A75,A124,A125,SCMPDS_6:98;
        hence s3.a4 <= s.a4 by A3,A17,XREAL_1:8;
A128:   s12.a5=0 by A36,A22,A60,A72,A71,A124,SCMPDS_7:49;
        thus s3.a4 >= m3 by A82,A127;
A129:   s3.a5=IExec(IF3,P12,s12).a5 by A73,A80,SCPISORT:7
          .=0 by A125,A128,SCMPDS_6:98;
        hence s3.a5 < s.a5 by A2;
        thus s3.a5 >= -1 by A129;
A130:   m4=m3+mE+1-1
          .=mE3+0-1 by A36,A22,A60,A62,A72,A71,A128,SCMPDS_7:49;
        hence s3.a4=s3.a3-1+s3.a5 by A126,A127,A129;
        take n1=m4;
        take n2=m4+1;
        thus n1=s3.a3-1 by A126,A130;
        thus n2=s3.a4+1 by A127;
A131:   now
          let x;
          thus s3.x=IExec(IF3,P12,s12).x by A73,A80,SCPISORT:7
            .=s12.x by A124,A125,SCMPDS_6:98
            .=s2.x by A36,A22,A72,A71,SCMPDS_7:49;
        end;
A132:   now
          let i be Element of NAT;
          assume
A133:     i >= 8;
A134:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:40;
          thus s3.intpos i=s2.intpos i by A131
            .=s1.intpos i by A4,A5,A6,A20,A31,A32,A33,A29,A59,A133,Lm15,A8,A10
,A11,A13,A37,A134
            .=s.intpos i by A1,A2,A3,A5,A6,A14,A133,Lm9;
        end;

        hence for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds s3.
        intpos i=s.intpos i;

A135:   m4 < n2 by XREAL_1:31;

        hence
        s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or s.a3 <= n1

& n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A30,A132,
XXREAL_0:2;

        hereby
          let i be Element of NAT;
          assume that
A136:     s.a3<=i and
A137:     i <= n1;
          i < mE3 by A130,A137,XREAL_1:148,XXREAL_0:2;
          then
A138:     s2.intpos md > s2.intpos i by A32,A64,A136,A11;
          s3.intpos md=s2.intpos md by A131;
          hence s3.intpos md >= s3.intpos i by A131,A138;
        end;
        hereby
          let i be Element of NAT;
          assume that
A139:     n2<=i and
A140:     i <= s.a4;
A141:     m4 < i by A135,A139,XXREAL_0:2;
          then
A142:     i >= 8 by A30,XXREAL_0:2;
A143:      s1.intpos md = (Initialize s1).intpos md by SCMPDS_5:40;
A144:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:40;
A145:     s3.intpos md=s2.intpos md by A131
            .=s1.intpos md by A4,A5,A6,A20,A31,A32,A33,A29,A59,Lm15,A8,A10,A11
,A13,A37,A143;
          s3.intpos i=s2.intpos i by A131
            .=s1.intpos i by A4,A5,A6,A20,A31,A32,A33,A29,A59,A142,Lm15,A8,A10
,A11,A13,A37,A144;
          hence s3.intpos md <= s3.intpos i by A18,A140,A141,A145;
        end;
      end;
    end;
  end;
end;

Lm21: for i be Integer st i >= -1 & i <= 0 holds i=-1 or i=0
proof
  let i be Integer;
  assume that
A1: i >= -1 and
A2: i <= 0;
  per cases;
  suppose
    i <= -1;
    hence thesis by A1,XXREAL_0:1;
  end;
  suppose
    i > -1;
    then i >= -1+1 by INT_1:20;
    hence thesis by A2;
  end;
end;

Lm22: for i1,i2 be Integer,n1,n2,i be Element of NAT st i1 >= -1 & i1 <= 0 &
n2=i2+1 & i2=n1+i1 & i < n2 holds i <= n1

proof
  let i1,i2 be Integer,n1,n2,i be Element of NAT;
  assume that
A1: i1 >= -1 and
A2: i1 <= 0 and
A3: n2=i2+1 and
A4: i2=n1+i1 and
A5: i < n2;
  per cases by A1,A2,Lm21;
  suppose
    i1=0;
    hence thesis by A3,A4,A5,NAT_1:13;
  end;
  suppose
    i1=-1;
    hence thesis by A3,A4,A5;
  end;
end;

Lm23: for i1,i2 be Integer,n1,n2 be Element of NAT st i1 >= -1 & n2=i2+1 & i2=
n1+i1 holds n1 <= n2

proof
  let i1,i2 be Integer,n1,n2 be Element of NAT;
  assume that
A1: i1 >= -1 and
A2: n2=i2+1 and
A3: i2=n1+i1;
  n1+i1 >= n1+ -1 by A1,XREAL_1:8;
  then i2+1 >= n1+ -1+1 by A3,XREAL_1:8;
  hence thesis by A2;
end;

Lm24: for s,s1 be State of SCMPDS,n0,n1,n2,n be Element of NAT,f, f1 be
FinSequence of INT st f is_FinSequence_on s,n0 & f1 is_FinSequence_on s1,n0 &
len f=n & len f1 = n & (for i be Element of NAT st i >= n0+1 & i<>n1 & i<>n2
holds s1.intpos i=s.intpos i) & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.
intpos n2 or n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=s
.intpos n2 & s1.intpos n2=s.intpos n1) holds f,f1 are_fiberwise_equipotent

proof

  let s,s1 be State of SCMPDS,n0,n1,n2,n be Element of NAT, f,f1 be
  FinSequence of INT;

  assume that
A1: f is_FinSequence_on s,n0 and
A2: f1 is_FinSequence_on s1,n0;
  assume that
A3: len f=n and
A4: len f1 = n;
  assume

A5: for i be Element of NAT st i >= n0+1 & i<>n1 & i<>n2 holds s1.intpos
  i=s.intpos i;

  assume that

A6: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or n1 >= n0+1 &

n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=s.intpos n2 & s1.intpos n2=
  s.intpos n1;

  per cases by A6;
  suppose
A7: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
A8: dom f1 = Seg n by A4,FINSEQ_1:def 3;
    now
      let i be Nat;
      reconsider a = i as Element of NAT by ORDINAL1:def 13;
      assume
A9:   i in dom f1;
      then
A10:  1 <= i by A8,FINSEQ_1:3;
      then
A11:  n0+1 <= n0+i by XREAL_1:8;
A12:  i <= n by A8,A9,FINSEQ_1:3;
      per cases;
      suppose
A13:    n0+i<>n1 & n0+i<>n2;
        thus f1.i=s1.intpos (n0+a) by A2,A4,A10,A12,SCPISORT:def 1
          .=s.intpos (n0+a) by A5,A11,A13
          .=f.i by A1,A3,A10,A12,SCPISORT:def 1;
      end;
      suppose
A14:    not (n0+i<>n1 & n0+i<>n2);
        hereby
          per cases by A14;
          suppose
            n0+i=n1;
            hence f1.i=s.intpos (n0+a) by A2,A4,A7,A10,A12,SCPISORT:def 1
              .=f.i by A1,A3,A10,A12,SCPISORT:def 1;
          end;
          suppose
            n0+i=n2;
            hence f1.i=s.intpos (n0+a) by A2,A4,A7,A10,A12,SCPISORT:def 1
              .=f.i by A1,A3,A10,A12,SCPISORT:def 1;
          end;
        end;
      end;
    end;
    hence thesis by A3,A4,FINSEQ_2:10;
  end;
  suppose

A15: n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=
    s.intpos n2 & s1.intpos n2=s.intpos n1;

    then
A16: n1-n0 >= 1 by XREAL_1:21;
    then reconsider m1=n1-n0 as Element of NAT by INT_1:16;
A17: m1 <= len f by A3,A15,XREAL_1:22;
A18: n2-n0 >= 1 by A15,XREAL_1:21;
    then reconsider m2=n2-n0 as Element of NAT by INT_1:16;
A19: m2 <= len f1 by A4,A15,XREAL_1:22;
A20: n2=m2+n0;
A21: n1=m1+n0;
    then
A22: f.m1=s1.intpos n2 by A1,A15,A16,A17,SCPISORT:def 1
      .=f1.m2 by A2,A18,A19,A20,SCPISORT:def 1;
A23: now
      let k be Element of NAT;
      assume that
A24:  k <> m1 and
A25:  k <> m2 and
A26:  1 <= k and
A27:  k <= len f;
A28:  k+n0 <> m1+n0 by A24;
A29:  n0+1 <= n0+k by A26,XREAL_1:8;
A30:  k+n0 <> m2+n0 by A25;
      thus f.k=s.intpos(k+n0) by A1,A26,A27,SCPISORT:def 1
        .=s1.intpos (k+n0) by A5,A28,A30,A29
        .=f1.k by A2,A3,A4,A26,A27,SCPISORT:def 1;
    end;
A31: m2 <= len f by A3,A15,XREAL_1:22;
    then f.m2=s1.intpos n1 by A1,A15,A18,A20,SCPISORT:def 1
      .=f1.m1 by A2,A3,A4,A16,A17,A21,SCPISORT:def 1;
    hence thesis by A3,A4,A16,A18,A17,A31,A22,A23,SCPISORT:4;
  end;
end;

Lm25: for s,s1 be State of SCMPDS,n0,n1,n2 be Element of NAT,c1,c2 be Integer
st (for i be Element of NAT st i >= n0 & i <>n1 & i<> n2 holds s1.intpos i=s.
intpos i) & n1 <= n2 & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1)
holds for i be Element of NAT st i >= n0 & (i < c1 or i > c2) holds s1.intpos i
=s.intpos i

proof
  let s,s1 be State of SCMPDS,n0,n1,n2 be Element of NAT,c1,c2 be Integer;
  assume

A1: for i be Element of NAT st i >= n0 & i<>n1 & i<>n2 holds s1.intpos i
  =s.intpos i;

  assume
A2: n1 <= n2;
  assume that

A3: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or c1 <= n1 & n2
  <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;

  per cases by A3;
  suppose
A4: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
    hereby
      let i be Element of NAT;
      assume that
A5:   i >= n0 and
      i < c1 or i > c2;
      per cases;
      suppose
        i<>n1 & i<>n2;
        hence s1.intpos i=s.intpos i by A1,A5;
      end;
      suppose
A6:     not (i<>n1 & i<>n2);
        hereby
          per cases by A6;
          suppose
            i=n1;
            hence s1.intpos i=s.intpos i by A4;
          end;
          suppose
            i=n2;
            hence s1.intpos i=s.intpos i by A4;
          end;
        end;
      end;
    end;
  end;
  suppose

A7: c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.
    intpos n1;

    hereby
      let i be Element of NAT;
      assume that
A8:   i >= n0 and
A9:   i < c1 or i > c2;
      per cases by A9;
      suppose
        i < c1;
        then i < n1 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
      end;
      suppose
        i > c2;
        then i > n2 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
      end;
    end;
  end;
end;

Lm26: for s be 0-started State of SCMPDS,
  md,m3,n0 be Element of NAT,f,f1 be FinSequence
of INT st s.GBP=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1
& md <= m3 & n0+1 <= s.a3 & s.a4 <= n0+n & f is_FinSequence_on s,n0 & f1
is_FinSequence_on IExec(WH3,P,s),n0 & n0 >= 7 & len f=n & len f1=n holds
 IExec(WH3,P,s).GBP=0 & IExec(WH3,P,s).a1=s.a1 &
 IExec(WH3,P,s).a2=md &
 IExec(WH3,P,s).a4 >= md &
 IExec(WH3,P,s).a4 <= s.a4 &
 f,f1 are_fiberwise_equipotent &
 (for i be Element of NAT st s.a3<=i & i <= IExec(WH3,P,s).a4
   holds IExec(WH3,P,s).intpos md >= IExec(WH3,P,s).intpos i) &
 (for i be Element of NAT st IExec(WH3,P,s).a4 < i & i <= s.a4
   holds IExec(WH3,P,s).intpos md <= IExec(WH3,P,s).intpos i) &
 for i be Element of NAT st i >= n0+1 & (i < s.a3 or i > s.a4)
   holds IExec(WH3,P,s).intpos i = s.intpos i

proof
  set a=GBP;

  let s be 0-started State of SCMPDS,
      md,m3,n0 be Element of NAT, f,f1 be FinSequence of INT;

  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a4=m3+s.a5 and
A4: m3=s.a3-1 and
A5: s.a2=md and
A6: md >= n0+1 and
A7: md <= m3 and
A8: n0+1 <= s.a3 and
A9: s.a4 <= n0+n;

  defpred P[Element of NAT] means
   for t be 0-started State of SCMPDS,Q
   for n3 be Element of

NAT, g,g1 be FinSequence of INT st t.a=0 & t.a5 > 0 & t.a5<= $1+1 & t.a4=n3+t.
  a5 & n3=t.a3-1 & t.a2=md & md <= n3 & n0+1 <= t.a3 & t.a4 <= n0+n & g
  is_FinSequence_on t,n0 & g1 is_FinSequence_on IExec(WH3,Q,t),n0 & len g=n
   & len

g1=n holds IExec(WH3,Q,t).a=0 & IExec(WH3,Q,t).a1=t.a1
 & IExec(WH3,Q,t).a2=md & IExec

(WH3,Q,t).a4 >= md & IExec(WH3,Q,t).a4 <= t.a4
 & g,g1 are_fiberwise_equipotent & (
  for i be Element of NAT st t.a3<=i & i <= IExec(WH3,Q,t).a4
   holds IExec(WH3,Q,t).

intpos md >= IExec(WH3,Q,t).intpos i)
 & (for i be Element of NAT st IExec(WH3,Q,t).
  a4 < i & i <= t.a4
   holds IExec(WH3,Q,t).intpos md <= IExec(WH3,Q,t).intpos i) & (

for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4)
 holds IExec(WH3,Q,t).intpos i = t.intpos i);

  assume
A10: f is_FinSequence_on s,n0;
  assume
A11: f1 is_FinSequence_on IExec(WH3,P,s),n0;
  assume that
A12: n0 >= 7 and
A13: len f=n and
A14: len f1=n;
  n0+1 >= 7+1 by A12,XREAL_1:8;
  then
A15: md >= 8 by A6,XXREAL_0:2;
A16: now
    let k be Element of NAT;
    assume
A17: P[k];
    now

      let t be 0-started State of SCMPDS,
          n3 be Element of NAT, g,g1 be FinSequence of INT;
      let Q;
      assume that
A18:  t.a=0 and
A19:  t.a5 > 0 and
A20:  t.a5<= (k+1)+1 and
A21:  t.a4=n3+t.a5 and
A22:  n3=t.a3-1 and
A23:  t.a2=md and
A24:  md <= n3 and
A25:  n0+1 <= t.a3 and
A26:  t.a4 <= n0+n;
      set t1=IExec(WB3,Q,t), Q1 = Q;
A27: t1.a=(Initialize t1).a by SCMPDS_5:40;
A28: t1.a1=(Initialize t1).a1 by SCMPDS_5:40;
A29: t1.a2=(Initialize t1).a2 by SCMPDS_5:40;
A30: t1.a3=(Initialize t1).a3 by SCMPDS_5:40;
A31: t1.a4=(Initialize t1).a4 by SCMPDS_5:40;
A32: t1.a5=(Initialize t1).a5 by SCMPDS_5:40;
A33:  t1.a4=t1.a3-1+t1.a5 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A34:  now
A35:    DataLoc(t.a,5)=intpos(0+5) by A18,SCMP_GCD:5;
        let v be State of SCMPDS;
        let V;
        assume that
A36:    v.a4=v.a3-1+v.a5 and
A37:    md <= v.a3-1 and
A38:    v.a2=t.a2 and
A39:    v.a=t.a and
A40:    v.DataLoc(t.a,5) > 0;
        reconsider mm=v.a3-1 as Element of NAT by A37,INT_1:16;
        set Iv=IExec(WB3,V,v);
A41: Iv=IExec(WB3,V,Initialize v) by SCMPDS_5:48;
A42:     v.a = (Initialize v).a by SCMPDS_5:40;
A43:     v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A44:     v.a3 = (Initialize v).a3 by SCMPDS_5:40;
A45:     v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A46:     v.a5 = (Initialize v).a5 by SCMPDS_5:40;
A47:    v.a4=mm+v.a5 by A36;
        hence Iv.a=v.a
         by A15,A18,A23,A37,A38,A39,A40,A35,Lm20,A42,A43,A44,A45,A46,A41;

         WB3 is_closed_on Initialize v,V & WB3 is_halting_on Initialize v,V
           by A15,A18,A23,A37,A38,A39,A40,A35,A47,Lm20,A42,A43,A44,A45,A46;
        hence WB3 is_closed_on v,V & WB3 is_halting_on v,V by SCMPDS_6:139,140;

        thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A15,A18,A23,A37,A38,A39
,A40,A35,A47,Lm20,A42,A43,A44,A45,A46,A41;

        thus Iv.a4=Iv.a3-1+Iv.a5 by A15,A18,A23,A37,A38,A39,A40,A35,A47,Lm20
,A42,A43,A44,A45,A46,A41;

        Iv.a3 >= v.a3 by A15,A18,A23,A37,A38,A39,A40,A35,A47,Lm20,A42,A43,A44
,A45,A46,A41;

        then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
        hence md <= Iv.a3-1 by A37,XXREAL_0:2;
        thus Iv.a2=v.a2 by A15,A18,A23,A37,A38,A39,A40,A35,A47,Lm20,A42,A43,A44
,A45,A46,A41;
      end;
      t1.a5 < t.a5 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      then t1.a5+1 <= t.a5 by INT_1:20;
      then t1.a5+1 <= (k+1)+1 by A20,XXREAL_0:2;
      then
A48:  t1.a5 <= k+1 by XREAL_1:8;
      set t2=IExec(WH3,Q,t);
      assume
A49:  g is_FinSequence_on t,n0;
      assume
A50:  g1 is_FinSequence_on IExec(WH3,Q,t),n0;
A51:  t1.a=0 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      then
A52:  DataLoc(t1.a,5)=intpos(0+5) by SCMP_GCD:5;
      assume that
A53:  len g=n and
A54:  len g1=n;
A55:  t1.a2=md by A15,A18,A19,A21,A22,A23,A24,Lm20;
A56:  t1.a1=t.a1 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A57:  t1.a3 >= t.a3 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A58:  t1.a4 >= n3 by A15,A18,A19,A21,A22,A23,A24,Lm20;
A59:  DataLoc(t.a,5)=intpos(0+5) by A18,SCMP_GCD:5;
A60:  t1.a4 <= t.a4 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      consider n1,n2 be Element of NAT such that
A61:  n1=t1.a3-1 and
A62:  n2=t1.a4+1 and

A63:  for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds t1.
      intpos i=t.intpos i and

A64:  t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or t.a3 <=
      n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1 and

A65:  for i be Element of NAT st t.a3<=i & i <= n1 holds t1.intpos
      md >= t1.intpos i and

A66:  for i be Element of NAT st n2<=i & i <= t.a4 holds t1.intpos
      md <= t1.intpos i by A15,A18,A19,A21,A22,A23,A24,Lm20;

A67:  t1.a5 >= -1 by A15,A18,A19,A21,A22,A23,A24,Lm20;
      then
A68:  n1 <= n2 by A33,A61,A62,Lm23;
      per cases;
      suppose
A69:    t1.a5 > 0;
        set t3=IExec(WH3,Q1,t1);
A70: t3=IExec(WH3,Q1,Initialize t1) by SCMPDS_5:48;
        consider f3 be FinSequence of INT such that
A71:    len f3=n and

A72:    for i be Element of NAT st 1<=i & i <= len f3 holds f3.i=t1.
        intpos (n0+i) by SCPISORT:2;

A73:    f3 is_FinSequence_on t1,n0 by A72,SCPISORT:def 1;
A74:    f3 is_FinSequence_on Initialize t1,n0
        proof let i be Element of NAT;
         assume 1 <= i & i <= len f3;
          then f3.i=t1.intpos(n0+i) by A72;
         hence f3.i=(Initialize t1).intpos(n0+i) by SCMPDS_5:40;
        end;

A75:    t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or n1 >= n0+

1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t1.intpos n1=t.intpos n2 & t1.intpos
        n2=t.intpos n1

        proof
          per cases by A64;
          suppose
            t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose

A76:        t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
            intpos n2=t.intpos n1;

            then
A77:        n2 <= n0+n by A26,XXREAL_0:2;
            n1 >= n0+1 by A25,A76,XXREAL_0:2;
            hence thesis by A68,A76,A77,XXREAL_0:2;
          end;
        end;
A78:    n0+1 <= t1.a3 by A25,A57,XXREAL_0:2;
        t1.a3-1 >= t.a3-1 by A57,XREAL_1:11;
        then
A79:    md <= n1 by A22,A24,A61,XXREAL_0:2;
        now
          let i be Element of NAT;
          assume that
A80:      i >= n0+1 and
A81:      i<>n1 and
A82:      i<>n2;
          n0+1 >= 7+1 by A12,XREAL_1:8;
          hence t1.intpos i=t.intpos i by A63,A80,A81,A82,XXREAL_0:2;
        end;

        then
A83:    g,f3 are_fiberwise_equipotent by A49,A53,A71,A73,A75,Lm24;


A84:    t1.a4 <= n0+n by A26,A60,XXREAL_0:2;
A85:    t2 =t3 by A19,A21,A22,A24,A59,A34,Lm17,Th7;
        consider f4 be FinSequence of INT such that
A86:    len f4=n and

A87:    for i be Element of NAT st 1<=i & i <= len f4 holds f4.i=t3.
        intpos (n0+i) by SCPISORT:2;
A88:    f4 is_FinSequence_on t3,n0
         proof let i be Element of NAT;
          assume 1 <= i & i <= len f4;
          hence f4.i=t3.intpos(n0+i) by A87;
         end;
        thus t2.a=0 by A17,A33,A48,A51,A55,A61,A69,A71,A74,A85,A86,A88,A79,A78
,A84,A27,A29,A30,A31,A32,A70;

for i be Element of NAT st i >= n0+1 &
(i < t1.a3 or i > t1.a4)
  holds t2.intpos i
   = (Initialize t1).intpos i
    by A17,A33,A48,A51,A55,A61,A69,A71,A74,A78,A79,A84,A85,A86,A88,A27,A29,A30
,A31,A32,A70;
then
A89:
(md < t1.a3 or md > t1.a4)
  implies t2.intpos md
   = (Initialize t1).intpos md by A6;

A90:   md < t1.a3 by A61,A79,XREAL_1:148,XXREAL_0:2;
A91:    dom f4 = Seg n by A86,FINSEQ_1:def 3;
        now
          let i be Nat;
          reconsider a = i as Element of NAT by ORDINAL1:def 13;
          assume
A92:      i in dom f4;
          then
A93:      i <= n by A91,FINSEQ_1:3;
A94:      1 <= i by A91,A92,FINSEQ_1:3;
          hence f4.i=t2.intpos (n0+a) by A86,A87,A85,A93
            .=g1.i by A50,A54,A94,A93,SCPISORT:def 1;
        end;
        then
A95:    f4=g1 by A54,A86,FINSEQ_2:10;

        thus t2.a1=t.a1 by A17,A51,A56,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79
,A78,A84,A85,A27,A28,A29,A30,A31,A32,A70;

        thus t2.a2=md by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78
,A84,A85,A27,A29,A30,A31,A32,A70;

        thus t2.a4 >= md by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78
,A84,A85,A27,A29,A30,A31,A32,A70;

        t3.a4 <= t1.a4 by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78
,A84,A27,A29,A30,A31,A32,A70;

        hence t2.a4 <= t.a4 by A60,A85,XXREAL_0:2;

        f3,f4 are_fiberwise_equipotent by A17,A51,A55,A33,A61,A48,A69,A71,A74
,A86,A88,A79,A78,A84,A27,A29,A30,A31,A32,A70;

        hence g,g1 are_fiberwise_equipotent by A83,A95,CLASSES1:84;
A96:    t1.a3=n1+1 by A61;
        hereby
          let i be Element of NAT;
          assume that
A97:      t.a3<=i and
A98:      i <= t2.a4;
A99:     t1.intpos i = (Initialize t1).intpos i by SCMPDS_5:40;
A100:      n0+1 <= i by A25,A97,XXREAL_0:2;
          hereby
            per cases;
            suppose
A101:          i < t1.a3;
              then
A102:          i <= n1 by A96,INT_1:20;

A103:       t2.intpos i = t1.intpos i by A17,A51,A55,A33,A61,A48,A69,A71,A74
,A86,A88,A79,A78,A84,A85,A100,A101,A99,A27,A29,A30,A31,A32,A70;
     t1.intpos md = (Initialize t1).intpos md by SCMPDS_5:40;

     then       t2.intpos md = t1.intpos md by A90,A89;
              hence t2.intpos md >= t2.intpos i by A65,A97,A102,A103;
            end;
            suppose
A104:           i >= t1.a3;

              thus
              t2.intpos md >= t2.intpos i by A17,A51,A55,A33,A61,A48,A69,A71
,A74,A86,A88,A79,A78,A84,A85,A98,A104,A27,A29,A30,A31,A32,A70;

            end;
          end;
        end;
        hereby
          let i be Element of NAT;
          assume that
A105:      t2.a4 < i and
A106:      i <= t.a4;
A107:     t1.intpos i = (Initialize t1).intpos i by SCMPDS_5:40;
          hereby
            per cases;
            suppose
A108:          i > t1.a4;
              then
A109:          i >= n2 by A62,INT_1:20;
              t1.a4 > n1+0 by A33,A61,A69,XREAL_1:8;
              then n2 > n1+1 by A62,XREAL_1:8;
              then n2 >= n0+1 by A61,A78,XXREAL_0:2;
              then i >= n0+1 by A109,XXREAL_0:2;

              then
A110:           t2.intpos i = t1.intpos i
         by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78,A84,A85,A108
,A27,A29,A30,A31,A32,A70,A107;

     t1.intpos md = (Initialize t1).intpos md by SCMPDS_5:40;

     then       t2.intpos md = t1.intpos md by A90,A89;
              hence t2.intpos md <= t2.intpos i by A66,A106,A109,A110;
            end;
            suppose
A111:         i <= t1.a4;
              thus
              t2.intpos md <= t2.intpos i
        by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78,A84,A85,A105
,A111,A27,A29,A30,A31,A32,A70;
            end;
          end;
        end;
        hereby
          let i be Element of NAT;
A112:     t1.intpos i = (Initialize t1).intpos i by SCMPDS_5:40;
          assume that
A113:      i >= n0+1 and
A114:      i < t.a3 or i > t.a4;
          n0+1 >= 7+1 by A12,XREAL_1:8;
          then
A115:         i >= 8 by A113,XXREAL_0:2;
          then
A116:      t1.intpos i = t.intpos i by A63,A64,A68,A114,Lm25;
          per cases by A114;
          suppose
            i < t.a3;
            then i < t1.a3 by A57,XXREAL_0:2;

            hence
            t2.intpos i = t1.intpos i
         by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78,A84,A85,A113
,A27,A29,A30,A31,A32,A70,A112
            .= t.intpos i by A63,A64,A68,A114,Lm25,A115;

          end;
          suppose
            i > t.a4;
            then i > t1.a4 by A60,XXREAL_0:2;
            hence
            t2.intpos i =t1.intpos i
        by A17,A51,A55,A33,A61,A48,A69,A71,A74,A86,A88,A79,A78,A84,A85,A113,A27
,A29,A30,A31,A32,A70,A112
           .=t.intpos i by A116;
          end;
        end;
      end;
      suppose
A117:    t1.a5 <= 0;
A118:    now
          let x;
          thus t2.x =IExec(WH3,Q1,t1).x by A19,A21,A22,A24,A59,A34,Lm17,Th7
            .=t1.x by A52,A117,SCMPDS_8:23;
        end;
        hence t2.a=0 by A51;
        thus t2.a1=t.a1 by A56,A118;
        thus t2.a2=md by A55,A118;
        t2.a4 >= n3 by A58,A118;
        hence t2.a4 >= md by A24,XXREAL_0:2;
        thus t2.a4 <= t.a4 by A60,A118;
A119:    now
A120:      n0+1 >= 7+1 by A12,XREAL_1:8;
          let i be Element of NAT;
          assume that
A121:      i >= n0+1 and
A122:      i<>n1 and
A123:     i<>n2;
          thus t2.intpos i=t1.intpos i by A118
            .=t.intpos i by A63,A121,A122,A123,A120,XXREAL_0:2;
        end;

A124:   t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or t.a3 <=
        n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1

        proof
          per cases by A64;
          suppose
            t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis by A118;
          end;
          suppose

            t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
            intpos n2=t.intpos n1;

            hence thesis by A118;
          end;
        end;

        t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or n1 >= n0+

1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t2.intpos n1=t.intpos n2 & t2.intpos
        n2=t.intpos n1

        proof
          per cases by A124;
          suppose
            t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose

A125:       t.a3 <= n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.
            intpos n2=t.intpos n1;

            then
A126:       n2 <= n0+n by A26,XXREAL_0:2;
            n1 >= n0+1 by A25,A125,XXREAL_0:2;
            hence thesis by A68,A125,A126,XXREAL_0:2;
          end;
        end;

        hence g,g1 are_fiberwise_equipotent by A49,A50,A53,A54,A119,Lm24;

A127:   t2.a4=n2-1 by A62,A118;
        hereby
          let i be Element of NAT;
          assume that
A128:     t.a3 <= i and
A129:     i <= t2.a4;
          i < n2 by A127,A129,XREAL_1:148,XXREAL_0:2;
          then i <= n1 by A67,A33,A61,A62,A117,Lm22;
          then t1.intpos md >= t1.intpos i by A65,A128;
          then t2.intpos md >= t1.intpos i by A118;
          hence t2.intpos md >= t2.intpos i by A118;
        end;
        hereby
          let i be Element of NAT;
          assume that
A130:     t2.a4 < i and
A131:     i <= t.a4;
          t2.a4+1=n2 by A62,A118;
          then n2 <= i by A130,INT_1:20;
          then t1.intpos md <= t1.intpos i by A66,A131;
          then t2.intpos md <= t1.intpos i by A118;
          hence t2.intpos md <= t2.intpos i by A118;
        end;

        thus for i be Element of NAT st i >= n0+1 & (i < t.a3 or i > t.a4)
        holds t2.intpos i = t.intpos i by A68,A119,A124,Lm25;

      end;
    end;
    hence P[k+1];
  end;
  s.a5 >=1+0 by A2,INT_1:20;
  then reconsider m5=s.a5-1 as Element of NAT by INT_1:16,XREAL_1:50;
A132: s.a5=m5+1;
A133: P[0 qua Element of NAT]
  proof
    let t be 0-started State of SCMPDS, Q;
    let n3 be Element of NAT,g,g1 be FinSequence of INT;
    assume that
A134: t.a=0 and
A135: t.a5 > 0 and
A136: t.a5<= 0+1 and
A137: t.a4=n3+t.a5 and
A138: n3=t.a3-1 and
A139: t.a2=md and
A140: md <= n3 and
A141: n0+1 <= t.a3 and
A142: t.a4 <= n0+n;
    set t2=IExec(WH3,Q,t), Q2 = Q;
    assume
A143: g is_FinSequence_on t,n0;
    set t1=IExec(WB3,Q,t), Q1 = Q;
    assume
A144: g1 is_FinSequence_on IExec(WH3,Q,t),n0;
A145: t1.a4=t1.a3-1+t1.a5 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    consider n1,n2 be Element of NAT such that
A146: n1=t1.a3-1 and
A147: n2=t1.a4+1 and

A148: for i be Element of NAT st i >= 8 & i <>n1 & i<> n2 holds t1.
    intpos i=t.intpos i and

A149: t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or t.a3 <= n1
    & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1 and

A150: for i be Element of NAT st t.a3<=i & i <= n1 holds t1.intpos md
    >= t1.intpos i and

A151: for i be Element of NAT st n2<=i & i <= t.a4 holds t1.intpos md
    <= t1.intpos i by A15,A134,A135,A137,A138,A139,A140,Lm20;

A152: t1.a5 >= -1 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    then
A153: n1 <= n2 by A145,A146,A147,Lm23;
    t1.a5 < t.a5 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    then t1.a5+1 <= t.a5 by INT_1:20;
    then t1.a5+1 <= 0+1 by A136,XXREAL_0:2;
    then
A154: t1.a5 <= 0 by XREAL_1:8;
A155: now
A156: DataLoc(t.a,5)=intpos(0+5) by A134,SCMP_GCD:5;
      let v be State of SCMPDS;
      let V;
      assume that
A157: v.a4=v.a3-1+v.a5 and
A158: md <= v.a3-1 and
A159: v.a2=t.a2 and
A160: v.a=t.a and
A161: v.DataLoc(t.a,5) > 0;
A162:   v.a = (Initialize v).a by SCMPDS_5:40;
A163:   v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A164:   v.a3 = (Initialize v).a3 by SCMPDS_5:40;
A165:   v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A166:   v.a5 = (Initialize v).a5 by SCMPDS_5:40;
      reconsider mm=v.a3-1 as Element of NAT by A158,INT_1:16;
      set Iv=IExec(WB3,V,v);
A167: Iv=IExec(WB3,V,Initialize v) by SCMPDS_5:48;
A168: v.a4=mm+v.a5 by A157;
      hence Iv.a=v.a by A15,A134,A139,A158,A159,A160,A161,A156,Lm20,A167,A162
,A163,A164,A165,A166;

       WB3 is_closed_on Initialize v,V & WB3 is_halting_on Initialize v,V
        by A15,A134,A139,A158,A159,A160,A161,A156,A168,Lm20,A162,A163,A164,A165
,A166;
      hence WB3 is_closed_on v,V & WB3 is_halting_on v,V by SCMPDS_6:139,140;

      thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A15,A134,A139,A158,A159,A160
,A161,A156,A168,Lm20,A167,A162,A163,A164,A165,A166;

      thus Iv.a4=Iv.a3-1+Iv.a5 by A15,A134,A139,A158,A159,A160,A161,A156,A168
,Lm20,A167,A162,A163,A164,A165,A166;
      Iv.a3 >= v.a3 by A15,A134,A139,A158,A159,A160,A161,A156,A168,Lm20,A167
,A162,A163,A164,A165,A166;
      then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
      hence md <= Iv.a3-1 by A158,XXREAL_0:2;
      thus Iv.a2=v.a2 by A15,A134,A139,A158,A159,A160,A161,A156,A168,Lm20,A167
,A162,A163,A164,A165,A166;
    end;
A169: DataLoc(t.a,5)=intpos(0+5) by A134,SCMP_GCD:5;
    assume that
A170: len g=n and
A171: len g1=n;
A172: t1.a=0 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    then
A173: DataLoc(t1.a,5)=intpos(0+5) by SCMP_GCD:5;
A174: now
      let x;
      thus t2.x =IExec(WH3,Q1,t1).x
       by A135,A137,A138,A140,A169,A155,Lm17,Th7
        .=t1.x by A173,A154,SCMPDS_8:23;
    end;
    hence t2.a=0 by A172;
    t1.a1=t.a1 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    hence t2.a1=t.a1 by A174;
    t1.a2=md by A15,A134,A135,A137,A138,A139,A140,Lm20;
    hence t2.a2=md by A174;
    t1.a4 >= n3 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    then t2.a4 >= n3 by A174;
    hence t2.a4 >= md by A140,XXREAL_0:2;
    t1.a4 <= t.a4 by A15,A134,A135,A137,A138,A139,A140,Lm20;
    hence t2.a4 <= t.a4 by A174;
A175: now
A176: n0+1 >= 7+1 by A12,XREAL_1:8;
      let i be Element of NAT;
      assume that
A177: i >= n0+1 and
A178: i<>n1 and
A179: i<>n2;
      thus t2.intpos i=t1.intpos i by A174
        .=t.intpos i by A148,A177,A178,A179,A176,XXREAL_0:2;
    end;

A180: t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or t.a3 <= n1 &
    n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1

    proof
      per cases by A149;
      suppose
        t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
        hence thesis by A174;
      end;
      suppose

        t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
        intpos n2=t.intpos n1;

        hence thesis by A174;
      end;
    end;

    t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or n1 >= n0+1 &

n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t2.intpos n1=t.intpos n2 & t2.intpos n2=
    t.intpos n1

    proof
      per cases by A180;
      suppose
        t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
        hence thesis;
      end;
      suppose

A181:   t.a3 <= n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.
        intpos n2=t.intpos n1;

        then
A182:   n2 <= n0+n by A142,XXREAL_0:2;
        n1 >= n0+1 by A141,A181,XXREAL_0:2;
        hence thesis by A153,A181,A182,XXREAL_0:2;
      end;
    end;
    hence g,g1 are_fiberwise_equipotent by A143,A144,A170,A171,A175,Lm24;
A183: t2.a4=n2-1 by A147,A174;
    hereby
      let i be Element of NAT;
      assume that
A184: t.a3 <= i and
A185: i <= t2.a4;
      i < n2 by A183,A185,XREAL_1:148,XXREAL_0:2;
      then i <= n1 by A152,A145,A146,A147,A154,Lm22;
      then t1.intpos md >= t1.intpos i by A150,A184;
      then t2.intpos md >= t1.intpos i by A174;
      hence t2.intpos md >= t2.intpos i by A174;
    end;
    hereby
      let i be Element of NAT;
      assume that
A186: t2.a4 < i and
A187: i <= t.a4;
      t2.a4+1=n2 by A147,A174;
      then n2 <= i by A186,INT_1:20;
      then t1.intpos md <= t1.intpos i by A151,A187;
      then t2.intpos md <= t1.intpos i by A174;
      hence t2.intpos md <= t2.intpos i by A174;
    end;
    thus thesis by A175,A153,A180,Lm25;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A133,A16);
  hence thesis by A1,A3,A4,A5,A7,A8,A9,A10,A11,A13,A14,A132;
end;

Lm27: for s be State of SCMPDS,md,m3,n0 be Element of NAT st s.GBP=0 & s.a4=m3
+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1 & md <= m3 & n0 >= 7 holds WH3
is_closed_on s,P & WH3 is_halting_on s,P

proof
  set a=GBP;
  let s be State of SCMPDS,md,m3,n0 be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a4=m3+s.a5 and
A3: m3=s.a3-1 and
A4: s.a2=md and
A5: md >= n0+1 and
A6: md <= m3 and
A7: n0 >= 7;
  n0+1 >= 7+1 by A7,XREAL_1:8;
  then
A8: md >= 8 by A5,XXREAL_0:2;
A9: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:5;
  now
    let v be State of SCMPDS;
    let V;
    assume that
A10: v.a4=v.a3-1+v.a5 and
A11: md <= v.a3-1 and
A12: v.a2=s.a2 and
A13: v.a=s.a and
A14: v.DataLoc(s.a,5) > 0;
    set Iv=IExec(WB3,V,v);
A15:   v.a = (Initialize v).a by SCMPDS_5:40;
A16:   v.a2 = (Initialize v).a2 by SCMPDS_5:40;
A17:   v.a3 = (Initialize v).a3 by SCMPDS_5:40;
A18:   v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A19:   v.a5 = (Initialize v).a5 by SCMPDS_5:40;
A20: Iv=IExec(WB3,V,Initialize v) by SCMPDS_5:48;
    reconsider mm=v.a3-1 as Element of NAT by A11,INT_1:16;
A21: v.a4=mm+v.a5 by A10;
    hence Iv.a=v.a by A1,A4,A8,A9,A11,A12,A13,A14,Lm20,A20,A15,A16,A17,A18,A19;

     WB3 is_closed_on Initialize v,V & WB3 is_halting_on Initialize v,V
     by A1,A4,A8,A9,A11,A12,A13,A14,A21,Lm20,A15,A16,A17,A18,A19;
    hence WB3 is_closed_on v,V & WB3 is_halting_on v,V by SCMPDS_6:139,140;

    thus Iv.DataLoc(s.a,5) < v.DataLoc(s.a,5) by A1,A4,A8,A9,A11,A12,A13,A14
,A21,Lm20,A20,A15,A16,A17,A18,A19;

    thus Iv.a4=Iv.a3-1+Iv.a5 by A1,A4,A8,A9,A11,A12,A13,A14,A21,Lm20,A20,A15
,A16,A17,A18,A19;
    Iv.a3 >= v.a3 by A1,A4,A8,A9,A11,A12,A13,A14,A21,Lm20,A20,A15,A16,A17,A18
,A19;
    then Iv.a3-1 >= v.a3-1 by XREAL_1:11;
    hence md <= Iv.a3-1 by A11,XXREAL_0:2;
    thus Iv.a2=v.a2 by A1,A4,A8,A9,A11,A12,A13,A14,A21,Lm20,A20,A15,A16,A17,A18
,A19;
  end;
  hence thesis by A2,A3,A6,Lm17,Th7;
end;

Lm28: for s being 0-started State of SCMPDS
 st s.GBP=0 holds IExec(K4,P,s).GBP=0 & IExec(K4,P,s).a1=s.a1
  & IExec(K4,P,s).a2=s.a2 & IExec(K4,P,s).a3=s.a2+1 & IExec(K4,P,s).a4=s.
a4 & IExec(K4,P,s).a5=s.a4-s.a2
 & for i be Element of NAT st i >= 8 holds IExec(K4,P,s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS;

  set t0=Initialize s, t1=IExec(k1 ';' k2 ';' k3 ';' k4,P,s),
  t2=IExec(k1 ';'
  k2 ';' k3,P,s), t3=IExec(k1 ';' k2,P,s), t4=Exec(k1, t0);

  assume s.a=0;
  then
A1: t0.a=0 by SCMPDS_5:40;
  then
A2: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A3: t4.a5=t0.DataLoc(t0.a,4) by SCMPDS_2:59
    .=t0.intpos (0+4) by A1,SCMP_GCD:5
    .=s.a4 by SCMPDS_5:40;
  t0.a4=s.a4 by SCMPDS_5:40;
  then
A4: t4.a4 =s.a4 by A2,AMI_3:52,SCMPDS_2:59;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A5: t4.a1 =s.a1 by A2,AMI_3:52,SCMPDS_2:59;
A6: t4.a =0 by A1,A2,AMI_3:52,SCMPDS_2:59;
  then
A7: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:5;
A8: t3.a=Exec(k2, t4).a by SCMPDS_5:47
    .=0 by A6,A7,AMI_3:52,SCMPDS_2:62;
  then
A9: DataLoc(t3.a,3)=intpos (0+3) by SCMP_GCD:5;
A10: t3.a4=Exec(k2, t4).a4 by SCMPDS_5:47
    .=s.a4 by A4,A7,AMI_3:52,SCMPDS_2:62;
A11: t2.a4 =Exec(k3, t3).a4 by SCMPDS_5:46
    .=s.a4 by A10,A9,AMI_3:52,SCMPDS_2:59;
A12: t0.a2=s.a2 by SCMPDS_5:40;
  then
A13: t4.a2 =s.a2 by A2,AMI_3:52,SCMPDS_2:59;
A14: t3.a5=Exec(k2, t4).a5 by SCMPDS_5:47
    .=t4.a5-t4.DataLoc(t4.a,2) by A7,SCMPDS_2:62
    .=t4.a5-t4.intpos(0+2) by A6,SCMP_GCD:5
    .=s.a4-s.a2 by A12,A2,A3,AMI_3:52,SCMPDS_2:59;
A15: t2.a5 =Exec(k3, t3).a5 by SCMPDS_5:46
    .=s.a4-s.a2 by A14,A9,AMI_3:52,SCMPDS_2:59;
A16: t3.a2=Exec(k2, t4).a2 by SCMPDS_5:47
    .=s.a2 by A13,A7,AMI_3:52,SCMPDS_2:62;
A17: t3.a1=Exec(k2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A5,A7,AMI_3:52,SCMPDS_2:62;
A18: t2.a1 =Exec(k3, t3).a1 by SCMPDS_5:46
    .=s.a1 by A17,A9,AMI_3:52,SCMPDS_2:59;
A19: t2.a =Exec(k3, t3).a by SCMPDS_5:46
    .=0 by A8,A9,AMI_3:52,SCMPDS_2:59;
  then
A20: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
A21: t2.a3 =Exec(k3, t3).a3 by SCMPDS_5:46
    .=t3.DataLoc(t3.a,2) by A9,SCMPDS_2:59
    .=s.a2 by A8,A16,SCMP_GCD:5;
A22: t2.a2 =Exec(k3, t3).a2 by SCMPDS_5:46
    .=s.a2 by A16,A9,AMI_3:52,SCMPDS_2:59;
  thus t1.a =Exec(k4, t2).a by SCMPDS_5:46
    .=0 by A19,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a1 =Exec(k4, t2).a1 by SCMPDS_5:46
    .=s.a1 by A18,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a2 =Exec(k4, t2).a2 by SCMPDS_5:46
    .=s.a2 by A22,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a3 =Exec(k4, t2).a3 by SCMPDS_5:46
    .=s.a2+1 by A21,A20,SCMPDS_2:60;
  thus t1.a4 =Exec(k4, t2).a4 by SCMPDS_5:46
    .=s.a4 by A11,A20,AMI_3:52,SCMPDS_2:60;
  thus t1.a5 =Exec(k4, t2).a5 by SCMPDS_5:46
    .=s.a4-s.a2 by A15,A20,AMI_3:52,SCMPDS_2:60;
A23: now
    let i be Element of NAT;
    assume i>=8;
    then i > 5 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A2,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A24: now
    let i be Element of NAT;
    assume
A25: i>=8;
    then
A26: i > 5 by XXREAL_0:2;
    thus t3.intpos i=Exec(k2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A7,A26,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A23,A25;
  end;
A27: now
    let i be Element of NAT;
    assume
A28: i>=8;
    then
A29: i > 3 by XXREAL_0:2;
    thus t2.intpos i=Exec(k3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A9,A29,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A24,A28;
  end;
  hereby
    let i be Element of NAT;
    assume
A30: i>=8;
    then
A31: i > 3 by XXREAL_0:2;
    thus t1.intpos i=Exec(k4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A20,A31,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A27,A30;
  end;
end;

theorem Th13:
  for s be 0-started State of SCMPDS,
  md,p0 be Element of NAT st s.GBP=0 & s.
  intpos 2=md & md >= p0+1 & p0 >= 7 holds Partition is_closed_on s,P
   & Partition
  is_halting_on s,P
proof
  set KW=K4 ';' WH3;
  let s be 0-started State of SCMPDS,md,n0 be Element of NAT;
  set s2=IExec(K4,P,s), a=GBP, P2 = P;
  assume that
A1: s.a=0 and
A2: s.a2=md and
A3: md >= n0+1 and
A4: n0 >= 7;
A5: s2.a2=s.a2 by A1,Lm28;
  set m3=md;
  s2.a5=s.a4-s.a2 by A1,Lm28;
  then
A6: s2.a4=m3+s2.a5 by A1,A2,Lm28;
  s2.a3=s.a2+1 by A1,Lm28;
  then
A7: s.a2=s2.a3-1;
A8: s2.a=0 by A1,Lm28;
  then
A9: WH3 is_halting_on s2,P2 by A2,A3,A4,A5,A7,A6,Lm27;
A10: WH3 is_closed_on s2,P2 by A2,A3,A4,A8,A5,A7,A6,Lm27;
  then
A11: KW is_closed_on s,P by A9,SCPISORT:10;
A12: KW is_halting_on s,P by A10,A9,SCPISORT:10;
  then
A13: KW ';' j8 is_closed_on s,P by A11,SCPISORT:11;
A14: KW ';' j8 is_halting_on s,P by A11,A12,SCPISORT:11;
  then
A15: KW ';' j8 ';' j9 is_halting_on s,P by A13,SCPISORT:11;
  KW ';' j8 ';' j9 is_closed_on s,P by A13,A14,SCPISORT:11;
  hence thesis by A15,SCPISORT:11;
end;

theorem Th14:
  for s be 0-started State of SCMPDS,
  md,p0,n be Element of NAT,f,f1 be
FinSequence of INT st s.GBP=0 & s.intpos 4-s.intpos 2 > 0 & s.intpos 2=md & md
  >= p0+1 & s.intpos 4 <= p0+n & p0 >= 7 & f is_FinSequence_on s,p0 & len f=n &
f1 is_FinSequence_on IExec(Partition,P,s),p0 & len f1=n holds
IExec(Partition,P,s).GBP=0 &
IExec(Partition,P,s).intpos 1=s.intpos 1 &
 f,f1 are_fiberwise_equipotent
& ex m4 be Element of NAT
   st m4=IExec(Partition,P,s).intpos 4 &
      md <= m4 & m4 <= s.intpos 4 &
  (for i be Element of NAT st md<=i & i < m4
    holds IExec(Partition,P,s).intpos m4 >= IExec(Partition,P,s).intpos i) &
  (for i be Element of NAT st m4 < i & i <= s.intpos 4
    holds IExec(Partition,P,s).intpos m4 <= IExec(Partition,P,s).intpos i) &
  for i be Element of NAT st i >= p0+1 & (i < s.intpos 2 or i > s.
    intpos 4) holds IExec(Partition,P,s).intpos i = s.intpos i
proof
  set KW=K4 ';' WH3;
  let s be 0-started State of SCMPDS,
      md,n0,n be Element of NAT, f,f1 be FinSequence of
  INT;
  set s1=IExec(Partition,P,s), s2=IExec(K4,P,s), P2 = P,
  s3=IExec(K4 ';' WH3,P,s), a=GBP;
A1: s2.a=(Initialize s2).a by SCMPDS_5:40;
A2: s2.a1=(Initialize s2).a1 by SCMPDS_5:40;
A3: s2.a2=(Initialize s2).a2 by SCMPDS_5:40;
A4: s2.a3=(Initialize s2).a3 by SCMPDS_5:40;
A5: s2.a4=(Initialize s2).a4 by SCMPDS_5:40;
A6: s2.a5=(Initialize s2).a5 by SCMPDS_5:40;
  assume that
A7: s.a=0 and
A8: s.a4-s.a2 > 0 and
A9: s.a2=md and
A10: md >= n0+1 and
A11: s.a4 <= n0+n and
A12: n0 >= 7;
A13: s2.GBP=0 by A7,Lm28;
A14: s2.a1=s.a1 by A7,Lm28;
A15: n0+1 >= 7+1 by A12,XREAL_1:8;
  then
A16: md >= 8 by A10,XXREAL_0:2;
  then
A17: md > 1 by XXREAL_0:2;
A18: md > 4 by A16,XXREAL_0:2;
A19: md-n0 >= 1 by A10,XREAL_1:21;
  then reconsider n1=md-n0 as Element of NAT by INT_1:16;
A20: md=n0+n1;
A21: s2.a4=s.a4 by A7,Lm28;
  set m3=md;
  s2.a5=s.a4-s.a2 by A7,Lm28;
  then
A22: s2.a4=m3+s2.a5 by A7,A9,Lm28;
  set s4=IExec(WH3,P2,s2);
A23: s4=IExec(WH3,P2,Initialize s2) by SCMPDS_5:48;
  consider f3 be FinSequence of INT such that
A24: len f3=n and
A25: for i be Element of NAT st 1<=i & i <= len f3 holds f3.i=s4.intpos(
  n0+i) by SCPISORT:2;
A26: f3 is_FinSequence_on s4,n0 by A25,SCPISORT:def 1;
  md < s.a4 by A8,A9,XREAL_1:49;
  then md < n0+n by A11,XXREAL_0:2;
  then
A27: n1 <= len f3 by A24,XREAL_1:22;
A28: s2.a2=s.a2 by A7,Lm28;
A29: s2.a3=s.a2+1 by A7,Lm28;
  then
A30: s.a2=s2.a3-1;
  then
A31: WH3 is_halting_on s2,P2 by A9,A10,A12,A13,A28,A22,Lm27;
  s.a2 < s2.a3 by A29,XREAL_1:31;
  then
A32: n0+1 <= s2.a3 by A9,A10,XXREAL_0:2;
A33: WH3 is_closed_on s2,P2 by A9,A10,A12,A13,A28,A30,A22,Lm27;
  then
A34: KW is_halting_on s,P by A31,SCPISORT:10;
  consider f2 be FinSequence of INT such that
A35: len f2=n and
A36: for i be Element of NAT st 1<=i & i <= len f2 holds f2.i=s2.intpos(
  n0+i) by SCPISORT:2;
A37: f2 is_FinSequence_on Initialize s2,n0
   proof let i be Element of NAT;
    assume 1 <= i & i <= len f2;
    then f2.i=s2.intpos(n0+i) by A36;
    hence thesis by SCMPDS_5:40;
   end;
  then
A38: f2,f3 are_fiberwise_equipotent by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22
,A32,A35,A24,A26,Lm26,A1,A3,A4,A5,A6,A23;

  s4.a4 > 0 by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24,A26,Lm26
,A1,A3,A4,A5,A6,A23;
  then reconsider m4=s4.a4 as Element of NAT by INT_1:16;
A39: s4.a4 >= md by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24,A26
,Lm26,A1,A3,A4,A5,A6,A23;
  then
A40: m4-n0 >= md-n0 by XREAL_1:11;
  then reconsider n2=m4-n0 as Element of NAT by A19,INT_1:16;
A41: m4-n0 >= 1 by A19,A40,XXREAL_0:2;
  s4.a2=md by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24,A26,Lm26,A1
,A3,A4,A5,A6,A23;
  then
A42: s3.a2=md by A33,A31,SCPISORT:8;
A43: s3.a4 =m4 by A33,A31,SCPISORT:8;
  s4.a=0 by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24,A26,Lm26,A1
,A3,A4,A5,A6,A23;
  then
A44: s3.a=0 by A33,A31,SCPISORT:8;
  then
A45: DataLoc(s3.a,6)=intpos(0+6) by SCMP_GCD:5;
  set t2=IExec(KW ';' j8 ';' j9,P,s), t3=IExec(KW ';' j8,P,s);
  assume that
A46: f is_FinSequence_on s,n0 and
A47: len f=n;
  assume that
A48: f1 is_FinSequence_on s1,n0 and
A49: len f1=n;
A50: dom f2 = Seg n by A35,FINSEQ_1:def 3;
A51: now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    assume
A52: i in dom f2;
    then
A53: 1 <= i by A50,FINSEQ_1:3;
    then i+n0 >= n0+1 by XREAL_1:8;
    then
A54: n0+i >= 8 by A15,XXREAL_0:2;
A55: i <= n by A50,A52,FINSEQ_1:3;
    hence f2.i=s2.intpos (n0+a) by A35,A36,A53
      .=s.intpos (n0+a) by A7,A54,Lm28
      .=f.i by A46,A47,A53,A55,SCPISORT:def 1;
  end;
A56: KW is_closed_on s,P by A33,A31,SCPISORT:10;
  then
A57: KW ';' j8 is_closed_on s,P by A34,SCPISORT:11;
A58: s4.a4 <= s2.a4 by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24
,A26,Lm26,A1,A3,A4,A5,A6,A23;
  then m4 <= n0+n by A11,A21,XXREAL_0:2;
  then
A59: n2 <= len f3 by A24,XREAL_1:22;
A60: t3.a6=Exec(j8,s3).a6 by A56,A34,SCMPDS_7:50
    .=s3.DataLoc(s3.a4,0) by A45,SCMPDS_2:59
    .=s3.intpos(m4+0) by A43,SCMP_GCD:5
    .=s4.intpos m4 by A33,A31,SCPISORT:8;
A61: t3.a4=Exec(j8,s3).a4 by A56,A34,SCMPDS_7:50
    .=m4 by A43,A45,AMI_3:52,SCMPDS_2:59;
  then
A62: DataLoc(t3.a4,0)=intpos(m4+0) by SCMP_GCD:5;
A63: s4.a1=s2.a1 by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24,A26
,Lm26,A1,A2,A3,A4,A5,A6,A23;
A64: t3.a1=Exec(j8,s3).a1 by A56,A34,SCMPDS_7:50
    .=s3.a1 by A45,AMI_3:52,SCMPDS_2:59
    .=s.a1 by A14,A63,A33,A31,SCPISORT:8;
A65: s4.a4 >= 8 by A39,A16,XXREAL_0:2;
  then
A66: m4 > 2 by XXREAL_0:2;
A67: t3.a=Exec(j8,s3).a by A56,A34,SCMPDS_7:50
    .=0 by A44,A45,AMI_3:52,SCMPDS_2:59;
A68: t3.a2=Exec(j8,s3).a2 by A56,A34,SCMPDS_7:50
    .=md by A42,A45,AMI_3:52,SCMPDS_2:59;
A69: KW ';' j8 is_halting_on s,P by A56,A34,SCPISORT:11;
  then
A70: KW ';' j8 ';' j9 is_halting_on s,P by A57,SCPISORT:11;
  t2.a2=Exec(j9,t3).a2 by A57,A69,SCMPDS_7:50
    .=md by A68,A62,A66,AMI_3:52,SCMPDS_2:59;
  then
A71: DataLoc(t2.a2,0)=intpos(md+0) by SCMP_GCD:5;
A72: m4 > 6 by A65,XXREAL_0:2;
A73: m4 > 1 by A65,XXREAL_0:2;
A74: t2.a6=Exec(j9,t3).a6 by A57,A69,SCMPDS_7:50
    .=s4.intpos m4 by A60,A62,A72,AMI_3:52,SCMPDS_2:59;
A75: t2.a=Exec(j9,t3).a by A57,A69,SCMPDS_7:50
    .=0 by A10,A39,A67,A62,AMI_3:52,SCMPDS_2:59;
A76: KW ';' j8 ';' j9 is_closed_on s,P by A57,A69,SCPISORT:11;
  then
A77: s1.intpos md=Exec(j0,t2).intpos md by A70,SCMPDS_7:50
    .=t2.DataLoc(t2.a,6) by A71,SCMPDS_2:59
    .=s4.intpos m4 by A75,A74,SCMP_GCD:5;
A78: now
    let i be Element of NAT;
    assume i >= 8;
    then
A79: i > 6 by XXREAL_0:2;
    thus t3.intpos i =Exec(j8,s3).intpos i by A56,A34,SCMPDS_7:50
      .=s3.intpos i by A45,A79,AMI_3:52,SCMPDS_2:59
      .=s4.intpos i by A33,A31,SCPISORT:8;
  end;
A80: now
    let i be Element of NAT;
    assume that
A81: i >= 8 and
A82: i <> m4;
    thus t2.intpos i =Exec(j9,t3).intpos i by A57,A69,SCMPDS_7:50
      .=t3.intpos i by A62,A82,AMI_3:52,SCMPDS_2:59
      .=s4.intpos i by A78,A81;
  end;
A83: now
    let i be Element of NAT;
    assume that
A84: i >= 8 and
A85: i <> m4 and
A86: i<>md;
    thus s1.intpos i =Exec(j0,t2).intpos i by A76,A70,SCMPDS_7:50
      .=t2.intpos i by A71,A86,AMI_3:52,SCMPDS_2:59
      .=s4.intpos i by A80,A84,A85;
  end;
A87: now
    let k be Element of NAT;
    assume that
A88: k<>n1 and
A89: k<>n2 and
A90: 1<=k and
A91: k <= len f3;
A92: k+n0<>md by A88;
A93: k+n0 >= n0+1 by A90,XREAL_1:8;
A94: k+n0<>m4 by A89;
    thus f3.k=s4.intpos(n0+k) by A25,A90,A91
      .=s1.intpos(n0+k) by A15,A83,A92,A94,A93,XXREAL_0:2
      .=f1.k by A48,A49,A24,A90,A91,SCPISORT:def 1;
  end;
A95: m4=n0+n2;
  then
A96: f3.n2=s1.intpos md by A25,A77,A41,A59
    .=f1.n1 by A48,A49,A24,A19,A27,A20,SCPISORT:def 1;
A97: t2.a1=Exec(j9,t3).a1 by A57,A69,SCMPDS_7:50
    .=s.a1 by A64,A62,A73,AMI_3:52,SCMPDS_2:59;
  thus s1.a=Exec(j0,t2).a by A76,A70,SCMPDS_7:50
    .=0 by A10,A75,A71,AMI_3:52,SCMPDS_2:59;
  thus s1.a1=Exec(j0,t2).a1 by A76,A70,SCMPDS_7:50
    .=s.a1 by A97,A71,A17,AMI_3:52,SCMPDS_2:59;
A98: m4 > 4 by A65,XXREAL_0:2;
A99: t2.a4=Exec(j9,t3).a4 by A57,A69,SCMPDS_7:50
    .=m4 by A61,A62,A98,AMI_3:52,SCMPDS_2:59;
A100: t2.intpos m4=Exec(j9,t3).intpos m4 by A57,A69,SCMPDS_7:50
    .=t3.DataLoc(t3.a2,0) by A62,SCMPDS_2:59
    .=t3.intpos (md+0) by A68,SCMP_GCD:5
    .=s4.intpos md by A10,A15,A78,XXREAL_0:2;
A101: now
    per cases;
    suppose
      m4=md;
      hence s1.intpos m4=s4.intpos md by A77;
    end;
    suppose
A102:  m4<>md;
      thus s1.intpos m4=Exec(j0,t2).intpos m4 by A76,A70,SCMPDS_7:50
        .=s4.intpos md by A100,A71,A102,AMI_3:52,SCMPDS_2:59;
    end;
  end;
  then f3.n1=s1.intpos m4 by A25,A19,A27,A20
    .=f1.n2 by A48,A49,A24,A41,A59,A95,SCPISORT:def 1;
  then f3,f1 are_fiberwise_equipotent by A49,A24,A19,A27,A41,A59,A96,A87,
SCPISORT:4;
  then f2,f1 are_fiberwise_equipotent by A38,CLASSES1:84;
  hence f,f1 are_fiberwise_equipotent by A47,A35,A51,FINSEQ_2:10;
  take m4;
  thus s1.a4=Exec(j0,t2).a4 by A76,A70,SCMPDS_7:50
    .=m4 by A99,A71,A18,AMI_3:52,SCMPDS_2:59;
A103: m3=s2.a3-1 by A9,A29;
  hence md <= m4 by A8,A9,A10,A11,A12,A13,A28,A21,A22,A32,A35,A37,A24,A26,Lm26
,A1,A3,A4,A5,A6,A23;
  thus m4 <= s.a4 by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24,A26
,Lm26,A1,A3,A4,A5,A6,A23;
A104: s2.a3=md+1 by A7,A9,Lm28;
  hereby
    let i be Element of NAT;
    assume that
A105: md<=i and
A106: i < m4;
    per cases;
    suppose
A107: i=md;
      then s2.a3 <= m4 by A104,A106,INT_1:20;
      then
      s1.intpos m4 >= s4.intpos m4
  by A8,A9,A10,A11,A12,A13,A28,A21,A103,A22,A32,A35,A37,A24,A26,A101,Lm26,A1,A3
,A4,A5,A6,A23;
      hence
      s1.intpos m4 >= s1.intpos i by A107,A77;
    end;
    suppose
A108: i<>md;
      then md < i by A105,XXREAL_0:1;
      then s2.a3 <= i by A9,A29,INT_1:20;
      then s4.intpos md >= s4.intpos i
     by A8,A9,A10,A11,A12,A13,A28,A21,A103,A22,A32,A35,A37,A24,A26,A106,Lm26,A1
,A3,A4,A5,A6,A23;
      hence s1.intpos m4 >= s1.intpos i by A16,A101,A83,A105,A108,XXREAL_0:2;
    end;
  end;
  hereby
    let i be Element of NAT;
    assume that
A109: m4 < i and
A110: i <= s.a4;
A111: md < i by A39,A109,XXREAL_0:2;
    s4.intpos md <= s4.intpos i by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32
,A35,A37,A24,A26,A109,A110,Lm26,A1,A3,A4,A5,A6,A23;
    hence s1.intpos m4 <= s1.intpos i by A16,A101,A83,A111,XXREAL_0:2;
  end;
  hereby
    let i be Element of NAT;
    assume that
A112: i >= n0+1 and
A113: i < s.a2 or i > s.a4;
A114: i >= 8 by A15,A112,XXREAL_0:2;
A115: now
      per cases by A113;
      case
A116:   i < s.a2;
        s.a2 < s2.a3 by A29,XREAL_1:31;
        hence i < s2.a3 by A116,XXREAL_0:2;
      end;
      case
        i > s.a4;
        hence i > s2.a4 by A7,Lm28;
      end;
    end;
A117: s2.intpos i = (Initialize s2).intpos i by SCMPDS_5:40;
A118:  for i be Element of NAT st i >= n0+1 &
      (i < (Initialize s2).a3 or i > (Initialize s2).a4)
       holds IExec(WH3,P2,Initialize s2).intpos i = (Initialize s2).intpos i
              by A8,A9,A10,A11,A12,A13,A28,A21,A103,A22,A32,A35,A37,A24,A26
,Lm26,A1,A3,A4,A5,A6,A23;
  i<>md & i<>m4
    proof
      per cases by A113;
      suppose
        i< s.a2;
        hence thesis by A8,A9,A10,A11,A12,A13,A28,A21,A30,A22,A32,A35,A37,A24
,A26,Lm26,A1,A3,A4,A5,A6,A23;
      end;
      suppose
        i > s.a4;
        hence thesis by A21,A39,A58,XXREAL_0:2;
      end;
    end;
    hence s1.intpos i = s4.intpos i by A15,A83,A112,XXREAL_0:2

      .=s2.intpos i by A112,A115,A118,A4,A5,A23,A117
      .=s.intpos i by A7,A114,Lm28;  ::
  end;
end;

theorem
  Partition is halt-free shiftable;

Lm29: for s being 0-started State of SCMPDS,
p0,n being Element of NAT holds card
QuickSort(n,p0)=57 & (p0 >= 7 implies QuickSort(n,p0) is_halting_on s,P
 & ex f,g
be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 & len g = n & g
is_FinSequence_on IExec(QuickSort(n,p0),P,s),p0
 & f,g are_fiberwise_equipotent &
g is_non_decreasing_on 1,n)
proof
  set b1=DataLoc(0,1);
  reconsider Pt=Partition as halt-free shiftable Program of SCMPDS;
  let s be 0-started State of SCMPDS,p0,n be Element of NAT;
  set pn=p0+n;

  set l1= (GBP,2):=(SBP,pn+1), l2= SubFrom(GBP,2,SBP,pn), l3= (GBP,2):=(SBP,pn

), l4= (GBP,4):=(SBP,pn+1), l5= (SBP,pn+3):=(SBP,pn+1), l6= (SBP,pn+1):=(GBP,4)
  , l7= (SBP,pn+2):=(GBP,4), l8= AddTo(SBP,pn+1,-1), l9= AddTo(SBP,pn+2,1), l0=
  AddTo(GBP,1,2), lb= Load AddTo(GBP,1,-2), L5= l5 ';' l6 ';' l7 ';' l8 ';' l9

';' l0, TR= l3 ';' l4 ';' Pt ';' L5, IF4= if>0(GBP,2,TR,lb),
  WB4= l1 ';' l2 ';' IF4, WH4= while>0(GBP,1,WB4);

  set m1= GBP:=0, m2= SBP:=1, m3= (SBP,pn):=(p0+1), m4= (SBP,pn+1):=pn, M4= m1
  ';' m2 ';' m3 ';' m4;

  set s1=IExec(M4,P,s), a=GBP, P1 = P;
A1: 7+n >= 7 by NAT_1:11;
A2: card L5= card (l5 ';' l6 ';' l7 ';' l8 ';' l9 )+1 by SCMP_GCD:8
    .= card (l5 ';' l6 ';' l7 ';' l8)+1+1 by SCMP_GCD:8
    .= 4+1+1 by Th4;
A3: card WB4=card (l1 ';' l2) + card IF4 by AFINSQ_1:20
    .=2+card IF4 by SCMP_GCD:9
    .=2+(card TR +card lb +2) by SCMPDS_6:79
    .=2+(card TR +1 +2) by SCMPDS_5:6
    .=2+(card (l3 ';' l4 ';' Pt)+ card L5+1+2) by AFINSQ_1:20
    .=2+(card (l3 ';' l4) + card Pt + card L5+1+2) by AFINSQ_1:20
    .=2+(2+ 38 + card L5+1+2) by Th12,SCMP_GCD:9
    .=51 by A2;
  thus card QuickSort(n,p0)=card M4 + card WH4 by AFINSQ_1:20
    .=4 + card WH4 by Th4
    .=4 + (51+2) by A3,SCMPDS_8:17
    .=57;
  assume
A4: p0 >= 7;
  then pn >= 7+n by XREAL_1:8;
  then
A5: pn >= 7 by A1,XXREAL_0:2;

A6: for t be State of SCMPDS,Q
   for m1 be Element of NAT st t.a=0 & t.SBP=m1 holds

IExec(l3 ';' l4,Q, t).a2=t.intpos(m1+pn)
 & IExec(l3 ';' l4,Q,t).a4=t.intpos(m1+pn+
  1) & for i be Element of NAT st i <> 2 & i <> 4 holds IExec(l3 ';' l4,Q,t).
  intpos i=t.intpos i

  proof
    let t be State of SCMPDS, Q;
    let m1 be Element of NAT;
    set t0=Initialize t, t2=IExec(l3 ';' l4,Q,t), t3=Exec(l3, t0), mp=m1+pn,
    Q0 = Q;
U: Initialize t0 = t0;
A7:  t2=IExec(l3 ';' l4, Q0,t0) by SCMPDS_5:48;
    assume that
A8: t.a=0 and
A9: t.SBP=m1;
A10: t0.a =0 by A8,SCMPDS_5:40;
    then
A11: DataLoc(t0.a,2)=intpos (0+2) by SCMP_GCD:5;
    then t3.a=0 by A10,AMI_3:52,SCMPDS_2:59;
    then
A12: DataLoc(t3.a,4)=intpos (0+4) by SCMP_GCD:5;
A13: t0.SBP =m1 by A9,SCMPDS_5:40;
    then
A14: t3.SBP=m1 by A11,AMI_3:52,SCMPDS_2:59;
    mp >= 0+7 by A5,XREAL_1:9;
    then mp+1 >= 7+1 by XREAL_1:8;
    then mp+1 > 2 by XXREAL_0:2;
    then
A15: t3.intpos(mp+1)=t0.intpos(mp+1) by A11,AMI_3:52,SCMPDS_2:59
      .=t.intpos(mp+1) by SCMPDS_5:40;

A16: t3.a2=t0.DataLoc(t0.SBP,pn) by A11,SCMPDS_2:59
      .=t0.intpos mp by A13,SCMP_GCD:5
      .=t.intpos mp by SCMPDS_5:40;
    thus t2.a2=Exec(l4, t3).a2 by A7,SCMPDS_5:47,U
      .=t.intpos mp by A16,A12,AMI_3:52,SCMPDS_2:59;
    thus t2.a4=Exec(l4, t3).a4 by A7,SCMPDS_5:47,U
      .=t3.DataLoc(t3.SBP,pn+1) by A12,SCMPDS_2:59
      .=t.intpos(mp+1) by A14,A15,SCMP_GCD:5;
    hereby
      let i be Element of NAT;
      assume that
A17:  i<>2 and
A18:  i <> 4;
      thus t2.intpos i =Exec(l4, t3).intpos i by A7,SCMPDS_5:47,U
        .=t3.intpos i by A12,A18,AMI_3:52,SCMPDS_2:59
        .=t0.intpos i by A11,A17,AMI_3:52,SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
    end;
  end;

A19: for t being State of SCMPDS,Q
   for m,m1 be Element of NAT st t.a=0 & t.SBP=m1 &

m1=m+1 holds IExec(L5,Q,t).a=0 & IExec(L5,Q,t).SBP=m1+2
 & IExec(L5,Q,t).intpos (m1+pn

)=t.intpos (m1+pn) & IExec(L5,Q,t).intpos (m1+pn+1)=t.a4-1
 & IExec(L5,Q,t).intpos (
  m1+pn+2)=t.a4+1 & IExec(L5,Q,t).intpos (m1+pn+3)=t.intpos (m1+pn+1)
   & for i be
  Element of NAT st i >= 8 & i < m1+pn holds IExec(L5,Q,t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS,Q;
    let m,m1 be Element of NAT;
    assume that
A20: t.a=0 and
A21: t.SBP=m1 and
A22: m1=m+1;

    set t0=Initialize t, t1=IExec(L5,Q,t), Q0 = Q,
    t2=IExec(l5 ';' l6 ';' l7 ';' l8 ';' l9,Q,t),
t3=IExec(l5 ';' l6 ';' l7 ';' l8,Q,t), t4=IExec(l5 ';' l6 ';' l7, Q,t),
    t5= IExec(l5 ';' l6, Q,t), t6=Exec(l5,t0), mp=m1+pn;
U: Initialize t0 = t0;
A23: t1=IExec(L5,Q0,t0) by SCMPDS_5:48;
A24: t2=IExec(l5 ';' l6 ';' l7 ';' l8 ';' l9,Q0,t0) by SCMPDS_5:48;
A25: t3=IExec(l5 ';' l6 ';' l7 ';' l8,Q0,t0) by SCMPDS_5:48;
A26: t4=IExec(l5 ';' l6 ';' l7, Q0,t0) by SCMPDS_5:48;
A27: t5= IExec(l5 ';' l6, Q0,t0) by SCMPDS_5:48;

A28: mp+3 <> mp+1;
    m1 >= 1 by A22,NAT_1:11;
    then
A29: mp >= 1+7 by A5,XREAL_1:9;
    then
A30: mp+1 >= 8+1 by XREAL_1:8;
    then
A31: mp+1 > 4 by XXREAL_0:2;
A32: mp+1 > 1 by A30,XXREAL_0:2;
A33: mp+0 <> mp+2;
A34: mp > 1 by A29,XXREAL_0:2;
A35: mp+1 <> mp+2;
A36: t0.SBP =m1 by A21,SCMPDS_5:40;
    then
A37: DataLoc(t0.SBP,pn+3)=intpos (mp+3) by SCMP_GCD:5;
A38: now
      let i be Element of NAT;
      assume i<>mp+3;
      hence t6.intpos i=t0.intpos i by A37,AMI_3:52,SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
    end;
    mp+0 <> mp+3;
    then
A39: t6.intpos mp=t.intpos mp by A38;
A40: mp+1 <> mp+2;
A41: mp+3 <> mp+2;
A42: mp+3 >= 8+3 by A29,XREAL_1:8;
    then
A43: mp+3 > 1 by XXREAL_0:2;
    mp+3 > 1 by A42,XXREAL_0:2;
    then
A44: t6.SBP=m1 by A21,A38;
    then
A45: DataLoc(t6.SBP,pn+1)=intpos (mp+1) by SCMP_GCD:5;
A46: now
      let i be Element of NAT;
      assume
A47:  i<>mp+1;
      thus t5.intpos i=Exec(l6, t6).intpos i by A27,SCMPDS_5:47,U
        .=t6.intpos i by A45,A47,AMI_3:52,SCMPDS_2:59;
    end;
    mp+1 > 1 by A30,XXREAL_0:2;
    then
A48: t5.SBP=m1 by A44,A46;
    then
A49: DataLoc(t5.SBP,pn+2)=intpos (mp+2) by SCMP_GCD:5;
A50: now
      let i be Element of NAT;
      assume
A51:  i<>mp+2;
      thus t4.intpos i=Exec(l7, t5).intpos i by A26,A27,SCMPDS_5:46
        .=t5.intpos i by A49,A51,AMI_3:52,SCMPDS_2:59;
    end;
    t6.intpos (mp+3)=t0.DataLoc(t0.SBP,pn+1) by A37,SCMPDS_2:59
      .=t0.intpos(m1+(pn+1)) by A36,SCMP_GCD:5
      .=t.intpos (mp+1) by SCMPDS_5:40;
    then t5.intpos(mp+3)=t.intpos(mp+1) by A46,A28;
    then
A52: t4.intpos(mp+3)=t.intpos(mp+1) by A50,A41;
A53: mp+3 > 4 by A42,XXREAL_0:2;
    then
A54: t6.a4=t.a4 by A38;
A55: mp+2 >= 8+2 by A29,XREAL_1:8;
    then
A56: mp+2 > 1 by XXREAL_0:2;
    mp+2 > 1 by A55,XXREAL_0:2;
    then
A57: t4.SBP=m1 by A48,A50;
    then
A58: DataLoc(t4.SBP,pn+1)=intpos (mp+1) by SCMP_GCD:5;
A59: now
      let i be Element of NAT;
      assume
A60:  i<>mp+1;
      thus t3.intpos i=Exec(l8, t4).intpos i by A26,A25,SCMPDS_5:46
        .=t4.intpos i by A58,A60,AMI_3:52,SCMPDS_2:60;
    end;
    m1+pn+1 > 1 by A30,XXREAL_0:2;
    then
A61: t3.SBP=m1 by A57,A59;
    then
A62: DataLoc(t3.SBP,pn+2)=intpos (mp+2) by SCMP_GCD:5;
A63: now
      let i be Element of NAT;
      assume
A64:  i<>mp+2;
      thus t2.intpos i=Exec(l9, t3).intpos i by A24,A25,SCMPDS_5:46
        .=t3.intpos i by A62,A64,AMI_3:52,SCMPDS_2:60;
    end;
A65: t6.a=0 by A20,A38;
    then
A66: t5.a=0 by A46;
    then t4.a=0 by A50;
    then t3.a=0 by A59;
    then
A67: t2.a=0 by A63;
    then
A68: DataLoc(t2.a,1)=intpos (0+1) by SCMP_GCD:5;
    mp+2 > 1 by A55,XXREAL_0:2;
    then
A69: t2.SBP=m1 by A61,A63;
A70: now
      let i be Element of NAT;
      assume i<>1;
      then
A71:  intpos i <> DataLoc(t2.a,1) by A67,AMI_3:52,SCMP_GCD:5;
      thus t1.intpos i=Exec(l0, t2).intpos i by A23,A24,SCMPDS_5:46
        .=t2.intpos i by A71,SCMPDS_2:60;
    end;
    hence t1.a=0 by A67;
A72: mp+0 <> mp+2;
    mp+0 <> mp+1;
    then t5.intpos mp=t.intpos mp by A39,A46;
    then
A73: t4.intpos mp=t.intpos mp by A50,A72;
    thus t1.SBP=Exec(l0, t2).SBP by A23,A24,SCMPDS_5:46
      .=m1+2 by A69,A68,SCMPDS_2:60;
    mp+0 <> mp+1;
    then t3.intpos mp=t.intpos mp by A73,A59;
    then t2.intpos mp=t.intpos mp by A63,A33;
    hence t1.intpos mp=t.intpos mp by A70,A34;
A74: mp+1 <> mp+2;
    t4.intpos(mp+2)=Exec(l7, t5).intpos(mp+2) by A26,A27,SCMPDS_5:46
      .=t5.DataLoc(t5.GBP,4) by A49,SCMPDS_2:59
      .=t5.intpos(0+4) by A66,SCMP_GCD:5
      .=t.a4 by A54,A46,A31;
    then
A75: t3.intpos(mp+2)=t.a4 by A59,A35;
    t5.intpos (mp+1)=Exec(l6, t6).intpos(mp+1) by A27,SCMPDS_5:47,U
      .=t6.DataLoc(t6.GBP,4) by A45,SCMPDS_2:59
      .=t6.intpos(0+4) by A65,SCMP_GCD:5
      .=t.a4 by A38,A53;
    then
A76: t4.intpos (mp+1)=t.a4 by A50,A74;
    t3.intpos(mp+1)=Exec(l8, t4).intpos(mp+1) by A26,A25,SCMPDS_5:46
      .=t.a4+-1 by A76,A58,SCMPDS_2:60
      .=t.a4-1;
    then t2.intpos(mp+1)=t.a4-1 by A63,A40;
    hence t1.intpos(mp+1)=t.a4-1 by A70,A32;
    t2.intpos(mp+2)=Exec(l9, t3).intpos(mp+2) by A24,A25,SCMPDS_5:46
      .=t.a4+1 by A75,A62,SCMPDS_2:60;
    hence t1.intpos(mp+2)=t.a4+1 by A70,A56;
A77: mp+3 <> mp+2;
    mp+3 <> mp+1;
    then t3.intpos(mp+3)=t.intpos(mp+1) by A52,A59;
    then t2.intpos(mp+3)=t.intpos(mp+1) by A63,A77;
    hence t1.intpos(mp+3)=t.intpos(mp+1) by A70,A43;
    hereby
A78:  mp <= mp+3 by NAT_1:11;
A79:  mp <= mp+2 by NAT_1:11;
A80:  mp <= mp+1 by NAT_1:11;
      let i be Element of NAT;
      assume that
A81:  i >= 8 and
A82:  i < mp;
      i > 1 by A81,XXREAL_0:2;
      hence t1.intpos i=t2.intpos i by A70
        .=t3.intpos i by A63,A82,A79
        .=t4.intpos i by A59,A82,A80
        .=t5.intpos i by A50,A82,A79
        .=t6.intpos i by A46,A82,A80
        .=t.intpos i by A38,A82,A78;
    end;
  end;

A83: for t be State of SCMPDS,Q
    for m,m1,md be Element of NAT,n4 be Integer, f1,

f2 be FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md & md

>= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn & f1 is_FinSequence_on t,

p0 & len f1=n & f2 is_FinSequence_on IExec(TR,Q,t),p0 & len f2=n
 holds IExec(TR,Q,t
  ).a=0 & IExec(TR,Q,t).a1=m1+2 & md=IExec(TR,Q,t).intpos(m1+pn)
   & n4=IExec(TR,Q,t).
  intpos (m1+pn+3)
   & (for j be Element of NAT st 1<=j & j<m1 holds IExec(TR,Q,t).
  intpos(pn+j)=t.intpos(pn+j)) & f1,f2 are_fiberwise_equipotent & ex m4 be

Element of NAT st md <= m4 & m4 <= n4
 & m4-1=IExec(TR,Q,t).intpos (m1+pn+1) & m4+
  1=IExec(TR,Q,t).intpos (m1+pn+2) &
   (for i be Element of NAT st md<=i & i < m4

holds IExec(TR,Q,t).intpos m4 >= IExec(TR,Q,t).intpos i)
 & (for i be Element of NAT

st m4 < i & i <= n4 holds IExec(TR,Q,t).intpos m4 <= IExec(TR,Q,t).intpos i)
 & for
  j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n
   holds IExec(TR,Q,t).
  intpos j = t.intpos j

  proof

    let t be State of SCMPDS, Q;
    let m,m1,md be Element of NAT,n4 be Integer, f1,f2 be
    FinSequence of INT;
    set t1=IExec(TR,Q,t), lPt=l3 ';' l4 ';' Pt, t2=IExec(lPt,Q,t), Q2 = Q,
    t4=IExec(l3 ';' l4,Q,t), mp=m1+pn, Q4 = Q;
A84: t4.a = (Initialize t4).a by SCMPDS_5:40;
A85: t4.a2 = (Initialize t4).a2 by SCMPDS_5:40;
A86: t4.a4 = (Initialize t4).a4 by SCMPDS_5:40;
A87: t4.a1 = (Initialize t4).a1 by SCMPDS_5:40;
    set tp=IExec(Pt,Q4,t4);
A88: tp=IExec(Pt,Q4,Initialize t4) by SCMPDS_5:48;
    assume that
A89: t.a=0 and
A90: t.SBP=m1 and
A91: m1=m+1 and
A92: t.intpos mp=md and
A93: md >= p0+1 and
A94: n4=t.intpos (mp+1) and
A95: n4-md > 0 and
A96: n4 <= pn;
A97: t4.a=0 by A6,A89,A90;
    assume that
A98: f1 is_FinSequence_on t,p0 and
A99: len f1=n;
A100: p0+1 >= 7+1 by A4,XREAL_1:8;
A101:    now
      let i be Element of NAT;
      assume that
A102:  1 <= i and
A103:  i <= len f1;
      p0+i >= p0+1 by A102,XREAL_1:8;
      then
A104:  p0+i >= 8 by A100,XXREAL_0:2;
      then
A105:  p0+i > 2 by XXREAL_0:2;
A106:  p0+i > 4 by A104,XXREAL_0:2;
      thus f1.i=t.intpos(p0+i) by A98,A102,A103,SCPISORT:def 1
        .=t4.intpos(p0+i) by A6,A89,A90,A105,A106;
    end;
A107: t4.a4=n4 by A6,A89,A90,A94;
A108: t4.a4=t.intpos(mp+1) by A6,A89,A90;
A109: t4.a2=t.intpos mp by A6,A89,A90;
    then Pt is_closed_on Initialize t4,Q4 by A4,A92,A93,A97,Th13,A84,A85;
    then
A110: Pt is_closed_on t4,Q4 by SCMPDS_6:139;
     Pt is_halting_on Initialize t4,Q4 by A4,A92,A93,A109,A97,Th13,A84,A85;
     then
A111: Pt is_halting_on t4,Q4 by SCMPDS_6:140;
    then
A112: lPt is_closed_on t,Q by A110,SCPISORT:10;
    assume that
A113: f2 is_FinSequence_on IExec(TR,Q,t),p0 and
A114: len f2=n;
    consider f4 be FinSequence of INT such that
A115: len f4=n and

A116: for i be Element of NAT st 1<=i & i <= len f4 holds f4.i=tp.
    intpos (p0+i) by SCPISORT:2;

A117: f1 is_FinSequence_on Initialize t4,p0
 proof let i be Element of NAT;
  assume  1 <= i & i <= len f1;
   then f1.i=t4.intpos(p0+i) by A101;
  hence thesis by SCMPDS_5:40;
 end;
A118: f4 is_FinSequence_on tp,p0 by A116,SCPISORT:def 1;
    then consider m4 be Element of NAT such that
A119: m4=tp.a4 and
A120: md <= m4 and
A121: m4 <= t4.a4 and
A122: for i be Element of NAT st md<=i & i < m4 holds tp.intpos m4 >=
    tp.intpos i and
A123: for i be Element of NAT st m4 < i & i <= t4.a4 holds tp.intpos
    m4 <= tp.intpos i and
A124: for i be Element of NAT st i >= p0+1 & (i < t4.a2 or i > t4.a4)
    holds tp.intpos i = (Initialize t4).intpos i
     by A4,A92,A93,A94,A95,A96,A99,A109,A108,A97,A117,A115,Th14,A84,A85,A86,A88
;

    tp.a=0 by A4,A92,A93,A94,A95,A96,A99,A109,A108,A97,A117,A115,A118,Th14,A84
,A85,A86,A88;

    then
A125: t2.a=0 by A110,A111,SCPISORT:8;
A126: lPt is_halting_on t,Q by A110,A111,SCPISORT:10;

    tp.a1=t4.a1 by A4,A92,A93,A94,A95,A96,A99,A109,A108,A97,A117,A115,A118,Th14
,A84,A85,A86,A87,A88;

    then
A127: t2.SBP=t4.a1 by A110,A111,SCPISORT:8
      .=m1 by A6,A89,A90;
    then
A128: IExec(L5,Q2,t2).intpos mp=t2.intpos mp by A19,A91,A125;
    IExec(L5,Q2,t2).a=0 by A19,A91,A125,A127;
    hence t1.a=0 by A112,A126,SCPISORT:7;
    IExec(L5,Q2,t2).SBP=m1+2 by A19,A91,A125,A127;
    hence t1.a1=m1+2 by A112,A126,SCPISORT:7;
A129: IExec(L5,Q2,t2).intpos (mp+3)=t2.intpos (mp+1) by A19,A91,A125,A127;
A130: IExec(L5,Q2,t2).intpos (mp+2)=t2.a4+1 by A19,A91,A125,A127;
A131: IExec(L5,Q2,t2).intpos (mp+1)=t2.a4-1 by A19,A91,A125,A127;
A132: 1+pn > pn by XREAL_1:31;
A133: m1 >= 1 by A91,NAT_1:11;
    then mp >= 1+pn by XREAL_1:8;
    then
A134: mp > pn by A132,XXREAL_0:2;
    then
A135: mp > t4.a4 by A96,A107,XXREAL_0:2;
    then
A136: m4 < mp by A121,XXREAL_0:2;
A137: dom f2 = Seg n by A114,FINSEQ_1:def 3;
A138: now
      let i be Nat;
      reconsider a = i as Element of NAT by ORDINAL1:def 13;
      assume
A139: i in dom f2;
      then
A140: 1 <= i by A137,FINSEQ_1:3;
      then p0+i >= p0+1 by XREAL_1:8;
      then
A141: p0+i >= 8 by A100,XXREAL_0:2;
A142: i <= n by A137,A139,FINSEQ_1:3;
      then p0+i <= pn by XREAL_1:8;
      then
A143: p0+i < mp by A134,XXREAL_0:2;
      thus f2.i = t1.intpos(p0+a) by A113,A114,A140,A142,SCPISORT:def 1
        .=IExec(L5,Q2,t2).intpos(p0+a) by A112,A126,SCPISORT:7
        .=t2.intpos (p0+a) by A19,A91,A125,A127,A141,A143
        .=tp.intpos (p0+a) by A110,A111,SCPISORT:8
        .=f4.i by A115,A116,A140,A142;
    end;
A144: mp >= 1+7 by A5,A133,XREAL_1:9;
    then
A145: mp > 4 by XXREAL_0:2;
A146: mp+1 > mp by XREAL_1:31;
    then
A147: mp+1 > t4.a4 by A135,XXREAL_0:2;
A148: pn >= p0 by NAT_1:11;
    then
A149: mp >= p0+1 by A133,XREAL_1:9;
    then
A150: mp+1 >= p0+1 by A146,XXREAL_0:2;
A151: mp+1 >= 8+1 by A144,XREAL_1:8;
    then
A152: mp+1 > 4 by XXREAL_0:2;
A153: t4.intpos mp = (Initialize t4).intpos mp by SCMPDS_5:40;
A154: t4.intpos (mp+1) = (Initialize t4).intpos (mp+1) by SCMPDS_5:40;
    mp > 2 by A144,XXREAL_0:2;
    hence md=t4.intpos mp by A6,A89,A90,A92,A145
      .=tp.intpos mp by A124,A149,A135,A153
      .=IExec(L5,Q2,t2).intpos mp by A110,A111,A128,SCPISORT:8
      .=t1.intpos mp by A112,A126,SCPISORT:7;
    mp+1 > 2 by A151,XXREAL_0:2;
    hence n4=t4.intpos (mp+1) by A6,A89,A90,A94,A152
      .=tp.intpos (mp+1) by A124,A150,A147,A154
      .=IExec(L5,Q2,t2).intpos (mp+3) by A110,A111,A129,SCPISORT:8
      .=t1.intpos (mp+3) by A112,A126,SCPISORT:7;
    hereby
      let j be Element of NAT;
      assume that
A155: 1<=j and
A156: j<m1;
A157: pn+j < mp by A156,XREAL_1:8;
      pn+j >= pn+1 by A155,XREAL_1:8;
      then pn+j > pn by A132,XXREAL_0:2;
      then
A158: pn+j > t4.a4 by A96,A107,XXREAL_0:2;
A159: pn+j >= p0+1 by A148,A155,XREAL_1:9;
A160: pn+j >= 1+7 by A5,A155,XREAL_1:9;
      then
A161: pn+j > 2 by XXREAL_0:2;
A162: pn+j > 4 by A160,XXREAL_0:2;
A163: t4.intpos (pn+j) = (Initialize t4).intpos (pn+j) by SCMPDS_5:40;
      thus t1.intpos(pn+j)=IExec(L5,Q2,t2).intpos(pn+j) by A112,A126,SCPISORT:7
        .=t2.intpos (pn+j) by A19,A91,A125,A127,A160,A157
        .=tp.intpos (pn+j) by A110,A111,SCPISORT:8
        .=t4.intpos (pn+j) by A124,A159,A158,A163
        .=t.intpos(pn+j) by A6,A89,A90,A161,A162;
    end;

    f1,f4 are_fiberwise_equipotent by A4,A92,A93,A94,A95,A96,A99,A109,A108,A97
,A117,A115,A118,Th14,A84,A85,A86,A88;

    hence f1,f2 are_fiberwise_equipotent by A114,A115,A138,FINSEQ_2:10;
    take m4;
    thus md <= m4 & m4 <= n4 by A6,A89,A90,A94,A120,A121;
    thus m4-1=t2.a4-1 by A119,A110,A111,SCPISORT:8
      .=t1.intpos (mp+1) by A112,A126,A131,SCPISORT:7;
    thus m4+1=t2.a4+1 by A119,A110,A111,SCPISORT:8
      .=t1.intpos (mp+2) by A112,A126,A130,SCPISORT:7;
A164: md >= 8 by A93,A100,XXREAL_0:2;
    then
A165: m4 >= 8 by A120,XXREAL_0:2;
    hereby
A166: tp.intpos m4=t2.intpos m4 by A110,A111,SCPISORT:8
        .=IExec(L5,Q2,t2).intpos m4 by A19,A91,A125,A127,A136,A165
        .=t1.intpos m4 by A112,A126,SCPISORT:7;
      let i be Element of NAT;
      assume that
A167: md<=i and
A168: i < m4;
A169: i < mp by A136,A168,XXREAL_0:2;
A170: i >= 8 by A164,A167,XXREAL_0:2;
      tp.intpos i=t2.intpos i by A110,A111,SCPISORT:8
        .=IExec(L5,Q2,t2).intpos i by A19,A91,A125,A127,A169,A170
        .=t1.intpos i by A112,A126,SCPISORT:7;
      hence t1.intpos m4 >= t1.intpos i by A122,A167,A168,A166;
    end;
    hereby
A171: tp.intpos m4=t2.intpos m4 by A110,A111,SCPISORT:8
        .=IExec(L5,Q2,t2).intpos m4 by A19,A91,A125,A127,A136,A165
        .=t1.intpos m4 by A112,A126,SCPISORT:7;
      let i be Element of NAT;
      assume that
A172: m4 < i and
A173: i <= n4;
A174: i < mp by A94,A108,A135,A173,XXREAL_0:2;
      i >= md by A120,A172,XXREAL_0:2;
      then
A175: i >= 8 by A164,XXREAL_0:2;
      tp.intpos i=t2.intpos i by A110,A111,SCPISORT:8
        .=IExec(L5,Q2,t2).intpos i by A19,A91,A125,A127,A174,A175
        .=t1.intpos i by A112,A126,SCPISORT:7;
      hence t1.intpos m4 <= t1.intpos i by A107,A123,A172,A173,A171;
    end;
    hereby
      let j be Element of NAT;
      assume that
A176: p0+1<=j & j<md or n4<j & j <= pn;
A177: now
        per cases by A176;
        suppose
A178:     p0+1<=j & j<md;

          hence j >= p0+1 & (j < t4.a2 or j > t4.a4) by A6,A89,A90,A92;

          md < mp by A120,A136,XXREAL_0:2;
          hence j < mp by A178,XXREAL_0:2;
        end;
        suppose
A179:     n4<j & j <= pn;
          n4 >= md by A107,A120,A121,XXREAL_0:2;
          then j >= md by A179,XXREAL_0:2;
          hence j >= p0+1 by A93,XXREAL_0:2;
          thus j < t4.a2 or j > t4.a4 by A6,A89,A90,A94,A179;
          thus j < mp by A134,A179,XXREAL_0:2;
        end;
      end;
      then
A180: j >= 8 by A100,XXREAL_0:2;
      then
A181: j > 2 by XXREAL_0:2;
A182: j > 4 by A180,XXREAL_0:2;
A183: t4.intpos j = (Initialize t4).intpos j by SCMPDS_5:40;
      thus t1.intpos j=IExec(L5,Q2,t2).intpos j by A112,A126,SCPISORT:7
        .=t2.intpos j by A19,A91,A125,A127,A177,A180
        .=tp.intpos j by A110,A111,SCPISORT:8
        .=t4.intpos j by A124,A177,A183
        .=t.intpos j by A6,A89,A90,A181,A182;
    end;
  end;

A184: for t be State of SCMPDS,Q
  for m be Element of NAT st t.a=0 & t.SBP=m holds
  IExec(l1 ';' l2,Q,t).a2=t.intpos (m+pn+1)-t.intpos (m+pn)
   & for i be Element of
  NAT st i <> 2 holds IExec(l1 ';' l2,Q,t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS,Q;
    let m be Element of NAT;
    assume that
A185: t.a=0 and
A186: t.SBP=m;
    set t0=Initialize t, t1=IExec(l1 ';' l2, Q,t), t2=Exec(l1, t0), mp=m+pn;
U: Initialize t0 = t0;
A187: t1=IExec(l1 ';' l2, Q,t0) by SCMPDS_5:48;

A188: t0.a =0 by A185,SCMPDS_5:40;
    then
A189: DataLoc(t0.a,2)=intpos (0+2) by SCMP_GCD:5;
    then t2.a=0 by A188,AMI_3:52,SCMPDS_2:59;
    then
A190: DataLoc(t2.a,2)=intpos (0+2) by SCMP_GCD:5;
A191: t0.SBP =m by A186,SCMPDS_5:40;
    then
A192: t2.SBP=m by A189,AMI_3:52,SCMPDS_2:59;
    mp >= 0+7 by A5,XREAL_1:9;
    then mp > 2 by XXREAL_0:2;
    then
A193: t2.intpos mp=t0.intpos mp by A189,AMI_3:52,SCMPDS_2:59
      .=t.intpos mp by SCMPDS_5:40;
A194: t2.a2=t0.DataLoc(t0.SBP,pn+1) by A189,SCMPDS_2:59
      .=t0.intpos (m+(pn+1)) by A191,SCMP_GCD:5
      .=t.intpos (mp+1) by SCMPDS_5:40;
    thus t1.a2 =Exec(l2, t2).a2 by A187,SCMPDS_5:47,U
      .=t2.a2-t2.DataLoc(t2.SBP,pn) by A190,SCMPDS_2:62
      .=t.intpos (mp+1)-t.intpos mp by A192,A194,A193,SCMP_GCD:5;
    hereby
      let i be Element of NAT;
      assume
A195: i <> 2;
      thus t1.intpos i=Exec(l2, t2).intpos i by A187,SCMPDS_5:47,U
        .=t2.intpos i by A190,A195,AMI_3:52,SCMPDS_2:62
        .=t0.intpos i by A189,A195,AMI_3:52,SCMPDS_2:59
        .=t.intpos i by SCMPDS_5:40;
    end;
  end;
A196: pn+1 >= 7+1 by A5,XREAL_1:8;

A197: for t be State of SCMPDS,Q
   for m be Element of NAT st t.a=0 & t.SBP=m & t.

intpos (m+pn+1) <= t.intpos (m+pn) holds IExec(WB4,Q,t).a=0
 & IExec(WB4,Q,t).a1=m-2
  & (for j be Element of NAT st 1<=j & j<m holds IExec(WB4,Q,t).intpos(pn+j)=t.
  intpos(pn+j)) & for j be Element of NAT st 1<=j & j <= n
   holds IExec(WB4,Q,t).
  intpos (p0+j) = t.intpos (p0+j)

  proof
    let t be State of SCMPDS,Q;
    let m be Element of NAT;
    set mp=m+pn, t1=IExec(l1 ';' l2,Q,t), Q1 = Q;
    assume that
A198: t.a=0 and
A199: t.SBP=m and
A200: t.intpos (mp+1) <= t.intpos mp;
A201: t1.a1=m by A184,A198,A199;
A202: t1.a2=t.intpos (mp+1)-t.intpos mp by A184,A198,A199;
    then
A203: t1.a2 <= 0 by A200,XREAL_1:49;
    set li=AddTo(GBP,1,-2), t0=Initialize t1;
A204: lb is_halting_on t1,Q1 by SCMPDS_6:35;
A205: t1.a=0 by A184,A198,A199;
    then
A206: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
A207: t0.a=0 by A205,SCMPDS_5:40;
    then
A208: DataLoc(t0.a,1)=intpos (0+1) by SCMP_GCD:5;
A209: lb is_closed_on t1,Q1 by SCMPDS_6:34;
    then
A210: IF4 is_halting_on t1,Q1 by A206,A203,A204,SCMPDS_6:83;
A211: IF4 is_closed_on t1,Q1 by A206,A203,A209,A204,SCMPDS_6:83;
A212: now
      let x;
      thus IExec(WB4,Q,t).x = IExec(IF4,Q1,t1).x by A211,A210,SCPISORT:8
        .=IExec(lb,Q1,t1).x by A200,A202,A206,SCMPDS_6:88,XREAL_1:49
        .=Exec(li,t0).x by SCMPDS_5:45;
    end;
A213: now
      let i be Element of NAT;
      assume i <> 1;
      then
A214: intpos i <> DataLoc(t0.a,1) by A207,AMI_3:52,SCMP_GCD:5;
      thus IExec(WB4,Q,t).intpos i=Exec(li,t0).intpos i by A212
        .=t0.intpos i by A214,SCMPDS_2:60
        .=t1.intpos i by SCMPDS_5:40;
    end;
    hence IExec(WB4,Q,t).a=0 by A205;
    thus IExec(WB4,Q,t).a1=Exec(li,t0).a1 by A212
      .=t0.a1+-2 by A208,SCMPDS_2:60
      .=t0.a1-2
      .=m-2 by A201,SCMPDS_5:40;
    hereby
      let j be Element of NAT;
      assume that
A215: 1<=j and
      j<m;
      pn+j >= pn+1 by A215,XREAL_1:8;
      then
A216: pn+j >= 8 by A196,XXREAL_0:2;
      then
A217: pn+j > 2 by XXREAL_0:2;
      pn+j > 1 by A216,XXREAL_0:2;
      hence IExec(WB4,Q,t).intpos(pn+j)=t1.intpos(pn+j) by A213
        .=t.intpos(pn+j) by A184,A198,A199,A217;
    end;
    hereby
      let j be Element of NAT;
      assume that
A218: 1<=j and
      j<=n;
A219: p0+1 >= 7+1 by A4,XREAL_1:8;
      p0+j >= p0+1 by A218,XREAL_1:8;
      then
A220: p0+j >= 8 by A219,XXREAL_0:2;
      then
A221: p0+j > 2 by XXREAL_0:2;
      p0+j > 1 by A220,XXREAL_0:2;
      hence IExec(WB4,Q,t).intpos(p0+j)=t1.intpos(p0+j) by A213
        .=t.intpos(p0+j) by A184,A198,A199,A221;
    end;
  end;

A222: for t be State of SCMPDS,Q
  for m1,md be Element of NAT st t.a=0 & t.SBP=m1 &
  t.intpos(m1+pn)=md & md >= p0+1 & t.intpos(m1+pn+1)-md > 0 holds TR
  is_closed_on t,Q & TR is_halting_on t,Q

  proof
    let t be State of SCMPDS,Q;
    let m1,md be Element of NAT;
    set lPt=l3 ';' l4 ';' Pt, t2=IExec(l3 ';' l4,Q,t), mp=m1+pn, Q2 = Q;
A223: t2.a = (Initialize t2).a by SCMPDS_5:40;
A224: t2.a2 = (Initialize t2).a2 by SCMPDS_5:40;
    assume that
A225: t.a=0 and
A226: t.SBP=m1 and
A227: t.intpos mp=md and
A228: md >= p0+1 and
    t.intpos (mp+1)-md > 0;
A229: t2.a=0 by A6,A225,A226;
A230: t2.a2=t.intpos mp by A6,A225,A226;
    then Pt is_halting_on Initialize t2,Q2 by A4,A227,A228,A229,Th13,A223,A224;
    then
A231: Pt is_halting_on t2,Q2 by SCMPDS_6:140;
     Pt is_closed_on Initialize t2,Q2 by A4,A227,A228,A230,A229,Th13,A223,A224;
     then
A232: Pt is_closed_on t2,Q2 by SCMPDS_6:139;
    then
A233: lPt is_halting_on t,Q by A231,SCPISORT:10;
    lPt is_closed_on t,Q by A232,A231,SCPISORT:10;
    hence thesis by A233,SCPISORT:9;
  end;

A234: for t be State of SCMPDS,Q
   for m,m1,md be Element of NAT,n4 be Integer, f1,

f2 be FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md & md

>= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn & f1 is_FinSequence_on t,

p0 & len f1=n & f2 is_FinSequence_on IExec(WB4,Q,t),p0 & len f2=n
 holds IExec(WB4,Q

,t).a=0 & IExec(WB4,Q,t).a1=m1+2 & md=IExec(WB4,Q,t).intpos(m1+pn)
 & n4=IExec(WB4,Q,t

).intpos (m1+pn+3) & (for j be Element of NAT st (1<=j & j<m1)
 holds IExec(WB4,Q,
  t).intpos(pn+j)=t.intpos(pn+j)) & f1,f2 are_fiberwise_equipotent & ex m4 be

Element of NAT st md <= m4 & m4 <= n4
 & m4-1=IExec(WB4,Q,t).intpos (m1+pn+1) & m4
  +1=IExec(WB4,Q,t).intpos (m1+pn+2)
   & (for i be Element of NAT st md<=i & i < m4
  holds IExec(WB4,Q,t).intpos m4 >= IExec(WB4,Q,t).intpos i)
   & (for i be Element of

NAT st m4 < i & i <= n4
 holds IExec(WB4,Q,t).intpos m4 <= IExec(WB4,Q,t).intpos i)

& for j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n
 holds IExec(WB4,Q
  ,t).intpos j = t.intpos j

  proof

    let t be State of SCMPDS,Q;
    let m,m1,md be Element of NAT,n4 be Integer, f1,f2 be
    FinSequence of INT;

    set mp=m1+pn, t1=IExec(l1 ';' l2,Q,t), Q1 = Q;
    assume that
A235: t.a=0 and
A236: t.SBP=m1 and
A237: m1=m+1 and
A238: t.intpos mp=md and
A239: md >= p0+1 and
A240: n4=t.intpos (mp+1) and
A241: n4-md > 0 and
A242: n4 <= pn;
A243: t1.a2 > 0 by A184,A235,A236,A238,A240,A241;
A244: mp >= 0+7 by A5,XREAL_1:9;
    then mp > 2 by XXREAL_0:2;
    then
A245: t1.intpos mp=md by A184,A235,A236,A238;
    assume that
A246: f1 is_FinSequence_on t,p0 and
A247: len f1=n;
A248: p0+1>= 7+1 by A4,XREAL_1:8;
    now
      let i be Element of NAT;
      assume that
A249: 1 <= i and
A250: i <= len f1;
      p0+i >= p0+1 by A249,XREAL_1:8;
      then p0+i >= 8 by A248,XXREAL_0:2;
      then
A251: p0+i > 2 by XXREAL_0:2;
      thus f1.i=t.intpos(p0+i) by A246,A249,A250,SCPISORT:def 1
        .= t1.intpos(p0+i) by A184,A235,A236,A251;
    end;
    then
A252: f1 is_FinSequence_on t1,p0 by SCPISORT:def 1;
    mp+1 >= 7+1 by A244,XREAL_1:8;
    then mp+1 > 2 by XXREAL_0:2;
    then
A253: n4=t1.intpos (mp+1) by A184,A235,A236,A240;
A254: t1.a=0 by A184,A235,A236;
    then
A255: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
A256: t1.SBP=m1 by A184,A235,A236;
    then
A257: TR is_halting_on t1,Q1 by A222,A239,A241,A245,A253,A254;
A258: TR is_closed_on t1,Q1 by A222,A239,A241,A256,A245,A253,A254;
    then
A259: IF4 is_halting_on t1,Q1 by A255,A243,A257,SCMPDS_6:82;
    assume that
A260: f2 is_FinSequence_on IExec(WB4,Q,t),p0 and
A261: len f2=n;
A262: IF4 is_closed_on t1,Q1 by A255,A243,A258,A257,SCMPDS_6:82;
A263: now
      let x;
      thus IExec(WB4,Q,t).x = IExec(IF4,Q1,t1).x by A262,A259,SCPISORT:8
        .=IExec(TR,Q1,t1).x by A255,A243,A258,A257,Th1;
    end;
    now
      let i be Element of NAT;
      assume that
A264: 1 <= i and
A265: i <= len f2;
      thus f2.i=IExec(WB4,Q,t).intpos(p0+i) by A260,A264,A265,SCPISORT:def 1
        .= IExec(TR,Q1,t1).intpos(p0+i) by A263;
    end;
    then
A266: f2 is_FinSequence_on IExec(TR,Q1,t1),p0 by SCPISORT:def 1;

    then IExec(TR,Q1,t1).a=0
     by A83,A237,A239,A241,A242,A247,A261,A256,A245,A253
,A254,A252;

    hence IExec(WB4,Q,t).a=0 by A263;
    consider m4 be Element of NAT such that
A267: md <= m4 and
A268: m4 <= n4 and
A269: m4-1=IExec(TR,Q1,t1).intpos (mp+1) and
A270: m4+1=IExec(TR,Q1,t1).intpos (mp+2) and

A271: for i be Element of NAT st md<=i & i < m4 holds IExec(TR,Q1,t1).
    intpos m4 >= IExec(TR,Q1,t1).intpos i and

A272: for i be Element of NAT st m4 < i & i <= n4 holds IExec(TR,Q1,t1).
    intpos m4 <= IExec(TR,Q1,t1).intpos i and

A273: for j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n

holds IExec(TR,Q1,t1).intpos j = t1.intpos j
 by A83,A237,A239,A241,A242,A247,A261
,A256,A245,A253,A254,A252,A266;

    IExec(TR,Q1,t1).a1=m1+2 by A83,A237,A239,A241,A242,A247,A261,A256,A245,A253
,A254,A252,A266;

    hence IExec(WB4,Q,t).a1=m1+2 by A263;

    md=IExec(TR,Q1,t1).intpos mp by A83,A237,A239,A241,A242,A247,A261,A256,A245
,A253,A254,A252,A266;

    hence md=IExec(WB4,Q,t).intpos mp by A263;

    n4=IExec(TR,Q1,t1).intpos (mp+3) by A83,A237,A239,A241,A242,A247,A261,A256
,A245,A253,A254,A252,A266;

    hence n4=IExec(WB4,Q,t).intpos (mp+3) by A263;
    hereby
      let j be Element of NAT;
      assume that
A274: 1<=j and
A275: j<m1;
      pn+j >= pn+1 by A274,XREAL_1:8;
      then pn+j >= 8 by A196,XXREAL_0:2;
      then
A276: pn+j > 2 by XXREAL_0:2;
      thus IExec(WB4,Q,t).intpos(pn+j)=IExec(TR,Q1,t1).intpos(pn+j) by A263

        .=t1.intpos(pn+j) by A83,A237,A239,A241,A242,A247,A261,A256,A245,A253
,A254,A252,A266,A274,A275

        .=t.intpos(pn+j) by A184,A235,A236,A276;
    end;

    thus f1,f2 are_fiberwise_equipotent by A83,A237,A239,A241,A242,A247,A261
,A256,A245,A253,A254,A252,A266;

    take m4;
    thus md <= m4 & m4 <= n4 by A267,A268;
    thus m4-1=IExec(WB4,Q,t).intpos (mp+1) by A263,A269;
    thus m4+1=IExec(WB4,Q,t).intpos (mp+2) by A263,A270;
    hereby
      let i be Element of NAT;
      assume that
A277: md<=i and
A278: i < m4;
      IExec(TR,Q1,t1).intpos m4 >= IExec(TR,Q1,t1).intpos i by A271,A277,A278;
      then IExec(WB4,Q,t).intpos m4 >= IExec(TR,Q1,t1).intpos i by A263;
      hence IExec(WB4,Q,t).intpos m4 >= IExec(WB4,Q,t).intpos i by A263;
    end;
    hereby
      let i be Element of NAT;
      assume that
A279: m4 < i and
A280: i <= n4;
      IExec(TR,Q1,t1).intpos m4 <= IExec(TR,Q1,t1).intpos i by A272,A279,A280;
      then IExec(WB4,Q,t).intpos m4 <= IExec(TR,Q1,t1).intpos i by A263;
      hence IExec(WB4,Q,t).intpos m4 <= IExec(WB4,Q,t).intpos i by A263;
    end;
    hereby
      let j be Element of NAT;
      assume that
A281: p0+1<=j & j<md or n4<j & j <= p0+n;
      now
        per cases by A281;
        suppose
          p0+1<=j & j<md;
          hence p0+1<=j;
        end;
        suppose
          n4<j & j <= p0+n;
          then j >= m4 by A268,XXREAL_0:2;
          then j >= md by A267,XXREAL_0:2;
          hence j >= p0+1 by A239,XXREAL_0:2;
        end;
      end;
      then j >= 8 by A248,XXREAL_0:2;
      then
A282: j > 2 by XXREAL_0:2;
      thus IExec(WB4,Q,t).intpos j = IExec(TR,Q1,t1).intpos j by A263
        .=t1.intpos j by A273,A281
        .=t.intpos j by A184,A235,A236,A282;
    end;
  end;
  consider f be FinSequence of INT such that
A283: len f=n and
A284: f is_FinSequence_on s,p0 by SCPISORT:3;
A285: pn+2 >= 7+2 by A5,XREAL_1:8;

A286: s1.a=0 & s1.a1=1 & s1.intpos(pn+1)=p0+1 & s1.intpos(pn+2)=pn & for i
  be Element of NAT st i >= 8 & i <= pn holds s1.intpos i=s.intpos i

  proof

    set t0=Initialize s, t2=IExec(m1 ';' m2 ';' m3,P,s), Q2 = P,
    t3=IExec(m1 ';' m2,P,s),
    t4=Exec(m1, t0);
A287: t4.a =0 by SCMPDS_2:57;
A288: t3.a=Exec(m2, t4).a by SCMPDS_5:47
      .=0 by A287,SCMPDS_2:57,SCMP_GCD:7;
A289: t3.SBP=Exec(m2, t4).SBP by SCMPDS_5:47
      .=1 by SCMPDS_2:57;
    then
A290: DataLoc(t3.SBP,pn)=intpos (pn+1) by SCMP_GCD:5;
A291: t2.a=Exec(m3,t3).a by SCMPDS_5:46
      .=0 by A288,A290,AMI_3:52,SCMPDS_2:58;
A292: t2.intpos (pn+1)=Exec(m3,t3).intpos (pn+1) by SCMPDS_5:46
      .=p0+1 by A290,SCMPDS_2:58;
A293: pn+2 > 1 by A285,XXREAL_0:2;
A294: pn+1 > 1 by A196,XXREAL_0:2;
A295: t2.SBP=Exec(m3,t3).SBP by SCMPDS_5:46
      .=1 by A289,A290,A294,AMI_3:52,SCMPDS_2:58;
    then
A296: DataLoc(t2.SBP,pn+1)=intpos (pn+(1+1)) by SCMP_GCD:5;
    thus s1.a=Exec(m4,t2).a by SCMPDS_5:46
      .=0 by A291,A296,AMI_3:52,SCMPDS_2:58;
    thus s1.a1=Exec(m4,t2).SBP by SCMPDS_5:46
      .=1 by A295,A296,A293,AMI_3:52,SCMPDS_2:58;
A297: pn+2 > pn+1 by XREAL_1:8;
    thus s1.intpos (pn+1)=Exec(m4,t2).intpos (pn+1) by SCMPDS_5:46
      .=p0+1 by A292,A296,A297,AMI_3:52,SCMPDS_2:58;
    thus s1.intpos (pn+2)=Exec(m4,t2).intpos (pn+2) by SCMPDS_5:46
      .=pn by A296,SCMPDS_2:58;
A298: now
      let i be Element of NAT;
      assume i >= 8;
      hence t4.intpos i =t0.intpos i by AMI_3:52,SCMPDS_2:57
        .=s.intpos i by SCMPDS_5:40;
    end;
A299: now
      let i be Element of NAT;
      assume
A300: i >= 8;
      then
A301: i > 1 by XXREAL_0:2;
      thus t3.intpos i =Exec(m2, t4).intpos i by SCMPDS_5:47
        .=t4.intpos i by A301,AMI_3:52,SCMPDS_2:57
        .=s.intpos i by A298,A300;
    end;
A302: now
      let i be Element of NAT;
      assume that
A303: i >= 8 and
A304: i <=pn;
A305: pn+1 > pn by XREAL_1:31;
      thus t2.intpos i =Exec(m3, t3).intpos i by SCMPDS_5:46
        .=t3.intpos i by A290,A304,A305,AMI_3:52,SCMPDS_2:58
        .=s.intpos i by A299,A303;
    end;
    hereby
A306: pn+2 > pn+0 by XREAL_1:8;
      let i be Element of NAT;
      assume that
A307: i >= 8 and
A308: i <=pn;
      thus s1.intpos i =Exec(m4, t2).intpos i by SCMPDS_5:46
        .=t2.intpos i by A296,A308,A306,AMI_3:52,SCMPDS_2:58
        .=s.intpos i by A302,A307,A308;
    end;
  end;
  now
A309: p0+1 >= 7+1 by A4,XREAL_1:8;
    let i be Element of NAT;
    assume that
A310: 1 <= i and
A311: i <= len f;
A312: p0+i <= pn by A283,A311,XREAL_1:8;
    p0+i >= p0+1 by A310,XREAL_1:8;
    then
A313: p0+i >= 8 by A309,XXREAL_0:2;
    thus f.i=s.intpos(p0+i) by A284,A310,A311,SCPISORT:def 1
      .=s1.intpos(p0+i) by A286,A313,A312;
  end;
  then
A314: f is_FinSequence_on s1,p0 by SCPISORT:def 1;
  consider g be FinSequence of INT such that
A315: len g=n and
A316: g is_FinSequence_on IExec(QuickSort(n,p0),P,s),p0 by SCPISORT:3;
A317: b1=intpos(0+1) by SCMP_GCD:5;

A318: for t be State of SCMPDS,Q
   for m,md be Element of NAT st t.a=0 & t.SBP=m & t
  .intpos(m+pn)=md & (md >= p0+1 or t.intpos(m+pn+1)-md <= 0) holds WB4
  is_closed_on t,Q & WB4 is_halting_on t,Q

  proof
    let t be State of SCMPDS,Q;
    let m,md be Element of NAT;
    set mp=m+pn, t1=IExec(l1 ';' l2,Q,t), Q1 = Q;
    assume that
A319: t.a=0 and
A320: t.SBP=m and
A321: t.intpos mp=md and
A322: md >= p0+1 or t.intpos(mp+1)-md <= 0;
A323: t1.a2=t.intpos (mp+1)-t.intpos mp by A184,A319,A320;
A324: t1.a=0 by A184,A319,A320;
    then
A325: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:5;
    per cases;
    suppose
A326: t1.DataLoc(t1.a,2) > 0;
A327: mp >= 0+7 by A5,XREAL_1:9;
      then mp+1 >= 7+1 by XREAL_1:8;
      then mp+1 > 2 by XXREAL_0:2;
      then
A328: t1.intpos(mp+1)-md > 0 by A184,A319,A320,A321,A323,A325,A326;
A329: t1.SBP=m by A184,A319,A320;
      mp > 2 by A327,XXREAL_0:2;
      then
A330: t1.intpos mp=md by A184,A319,A320,A321;

      then
A331: TR is_halting_on t1,Q1
 by A222,A184,A319,A320,A321,A322,A324,A325,A326,A329
,A328;

A332: TR is_closed_on t1,Q1
 by A222,A184,A319,A320,A321,A322,A324,A325,A326,A329
,A330,A328;

      then
A333: IF4 is_halting_on t1,Q1 by A326,A331,SCMPDS_6:82;
      IF4 is_closed_on t1,Q1 by A326,A332,A331,SCMPDS_6:82;
      hence thesis by A333,SCPISORT:10;
    end;
    suppose
A334: t1.DataLoc(t1.a,2) <= 0;
A335: lb is_halting_on t1,Q1 by SCMPDS_6:35;
A336: lb is_closed_on t1,Q1 by SCMPDS_6:34;
      then
A337: IF4 is_halting_on t1,Q1 by A334,A335,SCMPDS_6:83;
      IF4 is_closed_on t1,Q1 by A334,A336,A335,SCMPDS_6:83;
      hence thesis by A337,SCPISORT:10;
    end;
  end;
A338: now

    let t be State of SCMPDS, Q;
    let f1,f2 be FinSequence of INT, k1,k2,y1,yn be
    Element of NAT;
    set mm=2*k1+1, md=p0+y1, n4=p0+yn;
    assume that
A339: t.a=0 and
A340: mm=t.b1 and
A341: k2=pn+2*k1+1 and
A342: md=t.intpos k2 and
A343: n4=t.intpos(k2+1) and
A344: 1 <= y1 & yn <= n or y1 >= yn;
    set mp=mm+pn;
A345: md=t.intpos mp by A341,A342;
    now
      per cases by A344;
      case
        1 <= y1 & yn <= n;
        hence p0+1 <= md by XREAL_1:8;
      end;
      case
        y1 >= yn;
        then md >= t.intpos (mp+1) by A341,A343,XREAL_1:8;
        hence t.intpos (mp+1) -md <= 0 by XREAL_1:49;
      end;
    end;

    hence WB4 is_closed_on t,Q & WB4 is_halting_on t,Q
     by A318,A317,A339,A340,A345;

    consider f3 be FinSequence of INT such that
A346: len f3=n and

A347: for i be Element of NAT st 1<=i & i <= len f3 holds f3.i=t.
    intpos( p0+i) by SCPISORT:2;

    consider f4 be FinSequence of INT such that
A348: len f4=n and

A349: for i be Element of NAT st 1<=i & i <= len f4 holds f4.i=IExec(
    WB4,Q,t).intpos(p0+i) by SCPISORT:2;

A350: f4 is_FinSequence_on IExec(WB4,Q,t),p0 by A349,SCPISORT:def 1;
A351: f3 is_FinSequence_on t,p0 by A347,SCPISORT:def 1;
    hereby
      per cases;
      suppose
        t.intpos (mp+1) <= t.intpos mp;

        hence
        IExec(WB4,Q,t).a=t.a & for j be Element of NAT st 1<=j & j<mm holds
        IExec(WB4,Q,t).intpos(pn+j)=t.intpos(pn+j) by A197,A317,A339,A340;

      end;
      suppose
A352:   t.intpos (mp+1) > t.intpos mp;
        then
A353:   n4-md > 0 by A341,A342,A343,XREAL_1:52;
A354:   n4 <= pn by A341,A342,A343,A344,A352,XREAL_1:8;
        p0+1 <= md by A341,A342,A343,A344,A352,XREAL_1:8;

        hence
        IExec(WB4,Q,t).a=t.a & for j be Element of NAT st 1<=j & j<mm holds

IExec(WB4,Q,t).intpos(pn+j)=t.intpos(pn+j)
 by A234,A317,A339,A340,A341,A343,A345
,A346,A351,A348,A350,A353,A354;

      end;
    end;
    hereby
      assume y1>=yn;
      then
A355: t.intpos (mp+1) <= t.intpos mp by A341,A342,A343,XREAL_1:8;
      hence IExec(WB4,Q,t).b1=2*k1+1-2 by A197,A317,A339,A340
        .=2*k1-1;

      thus for j be Element of NAT st 1<=j & j <= n holds IExec(WB4,Q,t).intpos
      (p0+j) = t.intpos (p0+j) by A197,A317,A339,A340,A355;

    end;
A356: k2=mp by A341;
    hereby
      assume
A357: y1<yn;
      then
A358: p0+1 <= md by A344,XREAL_1:8;
      n4 > md by A357,XREAL_1:8;
      then
A359: n4-md > 0 by XREAL_1:52;
A360: n4 <= pn by A344,A357,XREAL_1:8;

      hence
      IExec(WB4,Q,t).b1=2*k1+1+2
       by A234,A317,A339,A340,A341,A343,A345,A346,A351
,A348,A350,A359,A358

        .=2*k1+3;
      consider m4 be Element of NAT such that
A361: md <= m4 and
A362: m4 <= n4 and
A363: m4-1=IExec(WB4,Q,t).intpos (mp+1) and
A364: m4+1=IExec(WB4,Q,t).intpos (mp+2) and

A365: for i be Element of NAT st md<=i & i < m4 holds IExec(WB4,Q,t).
      intpos m4 >= IExec(WB4,Q,t).intpos i and

A366: for i be Element of NAT st m4 < i & i <= n4 holds IExec(WB4,Q,t)
      . intpos m4 <= IExec(WB4,Q,t).intpos i and

A367: for j be Element of NAT st p0+1<=j & j<md or n4<j & j <= p0+n

holds IExec(WB4,Q,t).intpos j = t.intpos j
 by A234,A317,A339,A340,A341,A342,A343
,A346,A351,A348,A350,A359,A358,A360;

      hereby
        let j be Element of NAT;
        assume 1<=j & j<y1 or yn<j & j <= n;

        then p0+1<=p0+j & p0+j<md or n4<p0+j & p0+j <= p0+n by XREAL_1:8;

        hence IExec(WB4,Q,t).intpos(p0+j) = t.intpos (p0+j) by A367;
      end;
      m4-p0 >= y1 by A361,XREAL_1:21;
      then reconsider ym=m4-p0 as Element of NAT by INT_1:16;
      take ym;
      m4=p0+ym;
      hence y1 <= ym & ym <= yn by A361,A362,XREAL_1:8;

      thus md=IExec(WB4,Q,t).intpos k2
       by A234,A317,A339,A340,A342,A343,A356,A346
,A351,A348,A350,A359,A358,A360;

      thus p0+ym-1=IExec(WB4,Q,t).intpos (k2+1) by A341,A363;
      thus p0+ym+1=IExec(WB4,Q,t).intpos (k2+2) by A341,A364;

      thus n4=IExec(WB4,Q,t).intpos (k2+3)
       by A234,A317,A339,A340,A342,A343,A356
,A346,A351,A348,A350,A359,A358,A360;

      hereby
        let j be Element of NAT;
        assume that
A368:   y1 <= j and
A369:   j < ym;
A370:   p0+j < p0+ym by A369,XREAL_1:8;
        p0+y1 <= p0+j by A368,XREAL_1:8;

        hence
        IExec(WB4,Q,t).intpos (p0+j) <= IExec(WB4,Q,t).intpos (p0+ym)
         by A365,A370;

      end;
      hereby
        let j be Element of NAT;
        assume that
A371:   ym < j and
A372:   j <= yn;
A373:   p0+j <= p0+yn by A372,XREAL_1:8;
        p0+ym < p0+j by A371,XREAL_1:8;

        hence
        IExec(WB4,Q,t).intpos (p0+j) >= IExec(WB4,Q,t).intpos (p0+ym)
         by A366,A373;

      end;
    end;
    hereby
      assume that
A374: f1 is_FinSequence_on t,p0 and
A375: f2 is_FinSequence_on IExec(WB4,Q,t),p0 and
A376: len f1=n and
A377: len f2=n;
      per cases;
      suppose
A378:   t.intpos (mp+1) <= t.intpos mp;
A379:   dom f1 = Seg n by A376,FINSEQ_1:def 3;
        now
          let i be Nat;
          reconsider a = i as Element of NAT by ORDINAL1:def 13;
          assume
A380:     i in dom f1;
          then
A381:     1 <= i by A379,FINSEQ_1:3;
A382:     i <= n by A379,A380,FINSEQ_1:3;
          hence f1.i = t.intpos(p0+a) by A374,A376,A381,SCPISORT:def 1

            .=IExec(WB4,Q,t).intpos(p0+a) by A197,A317,A339,A340,A378,A381,A382

            .=f2.i by A375,A377,A381,A382,SCPISORT:def 1;
        end;
        hence f1,f2 are_fiberwise_equipotent by A376,A377,FINSEQ_2:10;
      end;
      suppose
A383:   t.intpos (mp+1) > t.intpos mp;
        then
A384:   n4-md > 0 by A341,A342,A343,XREAL_1:52;
A385:   n4 <= pn by A341,A342,A343,A344,A383,XREAL_1:8;
        p0+1 <= md by A341,A342,A343,A344,A383,XREAL_1:8;

        hence
        f1,f2 are_fiberwise_equipotent by A234,A317,A339,A340,A341,A343,A345
,A374,A375,A376,A377,A384,A385;

      end;
    end;
  end;
A386: s1.intpos(pn+1+1)=pn by A286;
  then
A387: WH4 is_closed_on s1,P1 by A3,A317,A338,A286,Lm6;
A388: WH4 is_halting_on s1,P1 by A3,A317,A338,A286,A386,Lm6;
  hence QuickSort(n,p0) is_halting_on s,P by A387,SCPISORT:10;
  take f,g;


  thus len f=n & f is_FinSequence_on s,p0 & len g=n & g is_FinSequence_on
  IExec(QuickSort(n,p0),P,s),p0 by A283,A284,A315,A316;

  now
    let i be Element of NAT;
    assume that
A389: 1 <= i and
A390: i <= len g;
    thus g.i=IExec(M4 ';' WH4,P,s).intpos(p0+i)
     by A316,A389,A390,SCPISORT:def 1
      .=IExec(WH4,P1,s1).intpos(p0+i) by A388,A387,SCPISORT:8;
  end;
  then g is_FinSequence_on IExec(WH4,P1,s1),p0 by SCPISORT:def 1;
  hence
 f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
::   thesis
   by A3,A317,A338,A286,A386,A283,A315,A314,Lm4;
end;

begin :: The Basic Property of Quick Sort and Its Correctness

theorem
  card QuickSort(n,p0)=57 by Lm29;

theorem
  for p0,n being Element of NAT st p0 >= 7 holds QuickSort(n,p0) is
  parahalting
proof
  let p0,n be Element of NAT;
  assume
A1:  p0 >= 7;
  for s be State of SCMPDS,P
   holds QuickSort(n,p0) is_halting_on s,P
   proof let s be State of SCMPDS,P;
    QuickSort(n,p0) is_halting_on Initialize s,P by A1,Lm29;
    hence thesis by SCMPDS_6:140;
   end;
  hence thesis by SCMPDS_6:35;
end;

theorem
  for s being 0-started State of SCMPDS,p0,n being Element of NAT st p0 >= 7
ex f,g be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 & len g = n
  & g is_FinSequence_on IExec(QuickSort(n,p0),P,s),p0 & f,g
  are_fiberwise_equipotent & g is_non_decreasing_on 1,n by Lm29;

