:: The Ring of Polynomials
::  by Robert Milewski
::
:: Received April 17, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, RLVECT_1, ALGSTR_0, XBOOLE_0, FINSEQ_1, STRUCT_0,
      SUBSET_1, RELAT_1, FUNCT_1, SUPINF_2, CARD_3, NAT_1, PARTFUN1, FINSEQ_5,
      ORDINAL4, ARYTM_3, XXREAL_0, FINSEQ_3, FINSEQ_2, PRE_POLY, TARSKI,
      CARD_1, ORDERS_1, RELAT_2, FINSET_1, ARYTM_1, FUNCT_2, POLYNOM1,
      ALGSEQ_1, FUNCOP_1, FUNCT_4, MESFUNC1, LATTICES, VECTSP_1, BINOP_1,
      CLASSES1, GROUP_1, ZFMISC_1, POLYNOM3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      RELAT_1, RELAT_2, FUNCT_1, ORDERS_1, XXREAL_0, NAT_1, NAT_D, CLASSES1,
      RELSET_1, PARTFUN1, FINSET_1, FUNCT_2, FUNCOP_1,
      FINSEQ_1, PRE_POLY, FINSEQ_2, FINSEQ_5, FINSEQOP, BINOP_1, RVSUM_1,
      FUNCT_7, TREES_4, WSIERP_1, STRUCT_0, ALGSTR_0,
      MATRLIN, BINARITH, GROUP_1, RLVECT_1, VFUNCT_1, FVSUM_1,
      VECTSP_1, NORMSP_1, POLYNOM1, ALGSEQ_1, BHSP_1, RECDEF_1;
 constructors BINOP_1, SQUARE_1, FINSEQOP, REALSET1, RFINSEQ, NAT_D, FINSEQ_5,
      WSIERP_1, ALGSEQ_1, BHSP_1, DTCONSTR, TRIANG_1, POLYNOM1, SEQ_1,
      RECDEF_1, SEQ_2, SEQM_3, REAL_1, BINARITH, CLASSES1, RELSET_1, RELAT_1,
      FUNCT_7, MATRLIN, PRE_POLY, FVSUM_1, VFUNCT_1;
 registrations RELAT_1, ORDINAL1, FUNCT_2, FUNCOP_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, MEMBERED, FINSEQ_1, FINSEQ_2, REALSET1, FINSEQ_5,
      STRUCT_0, VECTSP_1, VALUED_0, FINSET_1, RELSET_1, PRE_POLY, VFUNCT_1,
      CARD_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions TARSKI, XBOOLE_0, RELAT_1, RELAT_2, PRE_POLY, RLVECT_1, GROUP_1,
      VECTSP_1, ALGSEQ_1, FINSEQ_2, FUNCT_2, STRUCT_0, CARD_1, ALGSTR_0;
 theorems AXIOMS, TARSKI, ENUMSET1, RELSET_1, INT_1, NAT_1, CARD_1, RLVECT_1,
      VECTSP_1, ALGSEQ_1, RELAT_2, ORDERS_1, FUNCT_1, FUNCT_2, FUNCT_7,
      FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_4, FINSEQ_5, RFINSEQ,
      BINOP_1, CARD_3, RVSUM_1, FVSUM_1, MATRLIN, YELLOW15, POLYNOM1, RELAT_1,
      XBOOLE_0, RLVECT_2, XCMPLX_1, PARTFUN1, GROUP_1, XREAL_1, XXREAL_0,
      ORDINAL1, BHSP_1, NORMSP_1, XREAL_0, NAT_D, PRE_POLY;
 schemes FUNCT_2, FINSEQ_1, FINSEQ_2, NAT_1, RELSET_1, SUBSET_1, BINOP_1,
      RECDEF_1;

begin  :: Preliminaries

theorem Th1:
  for L be add-associative right_zeroed right_complementable (non
empty addLoopStr) for p be FinSequence of the carrier of L st for i be Element
  of NAT st i in dom p holds p.i = 0.L holds Sum p = 0.L
proof
  let L be add-associative right_zeroed right_complementable (non empty
  addLoopStr);
  let p be FinSequence of the carrier of L;
  assume
A1: for k be Element of NAT st k in dom p holds p.k = 0.L;
  now
    let k be Nat;
    assume
A2: k in dom p;
    hence p/.k = p.k by PARTFUN1:def 8
      .= 0.L by A1,A2;
  end;
  hence thesis by MATRLIN:15;
end;

theorem Th2:
  for V be Abelian add-associative right_zeroed (non empty
  addLoopStr) for p be FinSequence of the carrier of V holds Sum p = Sum Rev p
proof
  let V be Abelian add-associative right_zeroed (non empty addLoopStr);
  defpred P[FinSequence of the carrier of V] means Sum $1 = Sum Rev $1;
A1: for p be FinSequence of the carrier of V for x be Element of V st P[p]
  holds P[p^<*x*>]
  proof
    let p be FinSequence of the carrier of V;
    let x be Element of V;
    assume
A2: Sum p = Sum Rev p;
    thus Sum (p^<*x*>) = Sum p + Sum <*x*> by RLVECT_1:58
      .= Sum (<*x*>^Rev p) by A2,RLVECT_1:58
      .= Sum Rev (p^<*x*>) by FINSEQ_5:66;
  end;
A3: P[<*>(the carrier of V)];
  thus for p be FinSequence of the carrier of V holds P[p] from FINSEQ_2:sch 2
  (A3,A1);
end;

theorem Th3:
  for p be FinSequence of REAL holds Sum p = Sum Rev p
proof
  defpred P[FinSequence of REAL] means Sum $1 = Sum Rev $1;
A1: for p be FinSequence of REAL for x be Element of REAL st P[p] holds P[p^
  <*x*>]
  proof
    let p be FinSequence of REAL;
    let x be Element of REAL;
    assume
A2: Sum p = Sum Rev p;
    thus Sum (p^<*x*>) = Sum p + Sum <*x*> by RVSUM_1:105
      .= Sum (<*x*>^Rev p) by A2,RVSUM_1:105
      .= Sum Rev (p^<*x*>) by FINSEQ_5:66;
  end;
A3: P[<*>(REAL)];
  thus for p be FinSequence of REAL holds P[p] from FINSEQ_2:sch 2(A3,A1 );
end;

theorem Th4:
  for p be FinSequence of NAT for i be Element of NAT st i in dom p
  holds Sum p >= p.i
proof
  defpred P[FinSequence of NAT] means for i be Element of NAT st i in dom $1
  holds Sum $1 >= $1.i;
A1: for p be FinSequence of NAT for x being Element of NAT st P[p] holds P[p
  ^<*x*>]
  proof
    let p be FinSequence of NAT qua set;
    let x be Element of NAT;
    assume
A2: for i be Element of NAT st i in dom p holds Sum p >= p.i;
    let i be Element of NAT;
A3: p.i + x >= p.i by NAT_1:11;
    len (p^<*x*>) = len p + 1 by FINSEQ_2:19;
    then
A4: dom (p^<*x*>) = Seg (len p + 1) by FINSEQ_1:def 3
      .= Seg len p \/ {len p + 1} by FINSEQ_1:11
      .= dom p \/ {len p + 1} by FINSEQ_1:def 3;
    assume
A5: i in dom (p^<*x*>);
    per cases by A5,A4,XBOOLE_0:def 3;
    suppose
A6:   i in dom p;
      then Sum p >= p.i by A2;
      then Sum p + x >= p.i + x by XREAL_1:8;
      then Sum (p^<*x*>) >= p.i + x by RVSUM_1:104;
      then Sum (p^<*x*>) >= p.i by A3,XXREAL_0:2;
      hence thesis by A6,FINSEQ_1:def 7;
    end;
    suppose
      i in {len p + 1};
      then i = len p + 1 by TARSKI:def 1;
      then (p^<*x*>).i = x by FINSEQ_1:59;
      then Sum p + x >= (p^<*x*>).i by NAT_1:11;
      hence thesis by RVSUM_1:104;
    end;
  end;
A7: P[<*> NAT qua FinSequence of NAT];
  thus for p be FinSequence of NAT holds P[p] from FINSEQ_2:sch 2(A7,A1 );
end;

definition
  let D be non empty set;
  let i be Element of NAT;
  let p be FinSequence of D;
  redefine func Del(p,i) -> FinSequence of D;
  coherence by FINSEQ_3:114;
end;

definition
  let D be non empty set;
  let a,b be Element of D;
  redefine func <*a,b*> -> Element of 2-tuples_on D;
  coherence by FINSEQ_2:121;
end;

definition
  let D be non empty set;
  let k,n be Element of NAT;
  let p be Element of k-tuples_on D;
  let q be Element of n-tuples_on D;
  redefine func p^q -> Element of (k+n)-tuples_on D;
  coherence
   proof
    p^q is Tuple of k+n,D;
    hence thesis by FINSEQ_2:151;
   end;
end;

registration
  let D be non empty set;
  let n be Element of NAT;
  cluster -> FinSequence-yielding FinSequence of n-tuples_on D;
  coherence
  proof
    let p be FinSequence of n-tuples_on D;
    let x be set;
    assume
A1: x in dom p;
    then reconsider i=x as Element of NAT;
    p.i is Element of n-tuples_on D by A1,FINSEQ_2:13;
    hence thesis;
  end;
end;

definition
  let D be non empty set;
  let k,n be Element of NAT;
  let p be FinSequence of (k-tuples_on D);
  let q be FinSequence of (n-tuples_on D);
  redefine func p ^^ q -> Element of ((k+n)-tuples_on D)*;
  coherence
  proof
    rng (p^^q) c= (k+n)-tuples_on D
    proof
      let y be set;
      assume y in rng (p^^q);
      then consider x be set such that
A1:   x in dom (p^^q) and
A2:   y = (p^^q).x by FUNCT_1:def 5;
A3:   x in (dom p) /\ (dom q) by A1,PRE_POLY:def 4;
      then
A4:   x in dom p by XBOOLE_0:def 4;
A5:   x in dom q by A3,XBOOLE_0:def 4;
      y = p.x ^ q.x by A1,A2,PRE_POLY:def 4
        .= (p/.x) ^ q.x by A4,PARTFUN1:def 8
        .= (p/.x) ^ (q/.x) by A5,PARTFUN1:def 8;
      hence thesis;
    end;
    then p^^q is FinSequence of (k+n)-tuples_on D by FINSEQ_1:def 4;
    hence thesis by FINSEQ_1:def 11;
  end;
end;

scheme
  SeqOfSeqLambdaD{D()->non empty set,A()->Element of NAT, T(Element of NAT)->
Element of NAT, F(set,set)->Element of D()}: ex p be FinSequence of D()* st len
p = A() & for k be Element of NAT st k in Seg A() holds len (p/.k) = T(k) & for
  n be Element of NAT st n in dom (p/.k) holds (p/.k).n = F(k,n) proof
  defpred P[Element of NAT,Element of D()*] means len $2 = T($1) & for n be
  Element of NAT st n in dom $2 holds $2.n = F($1,n);
A1: for k be Element of NAT st k in Seg A() ex d be Element of D()* st P[k,d ]
  proof
    let k be Element of NAT;
    assume k in Seg A();
    deffunc G(Nat) = F(k,$1);
    consider d be FinSequence of D() such that
A2: len d = T(k) and
A3: for n be Nat st n in dom d holds d.n = G(n) from FINSEQ_2:sch 1;
    reconsider d as Element of D()* by FINSEQ_1:def 11;
    take d;
    thus len d = T(k) by A2;
    let n be Element of NAT;
    assume n in dom d;
    hence thesis by A3;
  end;
  consider p be FinSequence of D()* such that
A4: dom p = Seg A() and
A5: for k be Element of NAT st k in Seg A() holds P[k,p/.k] from
  RECDEF_1:sch 17(A1);
  take p;
  thus len p = A() by A4,FINSEQ_1:def 3;
  let k be Element of NAT;
  assume k in Seg A();
  hence thesis by A5;
end;

begin  :: The Lexicographic Order of Finite Sequences

definition
  let n be Element of NAT;
  let p,q be Element of n-tuples_on NAT;
  pred p < q means
  :Def1:
  ex i be Element of NAT st i in Seg n & p.i < q.i &
  for k be Element of NAT st 1 <= k & k < i holds p.k = q.k;
  asymmetry
  proof
    let p,q be Element of n-tuples_on NAT;
    given i be Element of NAT such that
A1: i in Seg n and
A2: p.i < q.i and
A3: for k be Element of NAT st 1 <= k & k < i holds p.k = q.k;
A4: 1 <= i by A1,FINSEQ_1:3;
    given j be Element of NAT such that
A5: j in Seg n and
A6: q.j < p.j and
A7: for k be Element of NAT st 1 <= k & k < j holds q.k = p.k;
A8: 1 <= j by A5,FINSEQ_1:3;
    per cases by XXREAL_0:1;
    suppose
      i < j;
      hence contradiction by A2,A7,A4;
    end;
    suppose
      j < i;
      hence contradiction by A3,A6,A8;
    end;
    suppose
      i = j;
      hence contradiction by A2,A6;
    end;
  end;
end;

notation
  let n be Element of NAT;
  let p,q be Element of n-tuples_on NAT;
  synonym q > p for p < q;
end;

definition
  let n be Element of NAT;
  let p,q be Element of n-tuples_on NAT;
  pred p <= q means
  :Def2:
  p < q or p = q;
  reflexivity;
end;

notation
  let n be Element of NAT;
  let p,q be Element of n-tuples_on NAT;
  synonym q >= p for p <= q;
end;

theorem Th5:
  for n be Element of NAT for p,q,r be Element of n-tuples_on NAT
  holds (p < q & q < r implies p < r) & ( p < q & q <= r or p <= q & q < r or p
  <= q & q <= r implies p <= r)
proof
  let n be Element of NAT;
  let p,q,r be Element of n-tuples_on NAT;
  thus
A1: p < q & q < r implies p < r
  proof
    assume that
A2: p < q and
A3: q < r;
    consider i be Element of NAT such that
A4: i in Seg n and
A5: p.i < q.i and
A6: for k be Element of NAT st 1 <= k & k < i holds p.k = q.k by A2,Def1;
    consider j be Element of NAT such that
A7: j in Seg n and
A8: q.j < r.j and
A9: for k be Element of NAT st 1 <= k & k < j holds q.k = r.k by A3,Def1;
    reconsider t = min(i,j) as Element of NAT by FINSEQ_2:1;
    take t;
    thus t in Seg n by A4,A7,XXREAL_0:15;
    now
      per cases by XXREAL_0:1;
      suppose
A10:    i < j;
A11:    i >= 1 by A4,FINSEQ_1:3;
        t = i by A10,XXREAL_0:def 9;
        hence p.t < r.t by A5,A9,A10,A11;
      end;
      suppose
A12:    i > j;
A13:    j >= 1 by A7,FINSEQ_1:3;
        t = j by A12,XXREAL_0:def 9;
        hence p.t < r.t by A6,A8,A12,A13;
      end;
      suppose
        i = j;
        hence p.t < r.t by A5,A8,XXREAL_0:2;
      end;
    end;
    hence p.t < r.t;
    let k be Element of NAT;
    assume that
A14: 1 <= k and
A15: k < t;
    t <= j by XXREAL_0:17;
    then
A16: k < j by A15,XXREAL_0:2;
    t <= i by XXREAL_0:17;
    then k < i by A15,XXREAL_0:2;
    hence p.k = q.k by A6,A14
      .= r.k by A9,A14,A16;
  end;
  assume
A17: p < q & q <= r or p <= q & q < r or p <= q & q <= r;
  per cases by A17;
  suppose
A18: p < q & q <= r;
    then q < r or q = r by Def2;
    hence thesis by A1,A18,Def2;
  end;
  suppose
A19: p <= q & q < r;
    then p < q or p = q by Def2;
    hence thesis by A1,A19,Def2;
  end;
  suppose
    p <= q & q <= r;
    hence thesis by A1,Def2;
  end;
end;

theorem Th6:
  for n be Element of NAT for p,q be Element of n-tuples_on NAT
holds p <> q implies ex i be Element of NAT st i in Seg n & p.i <> q.i & for k
  be Element of NAT st 1 <= k & k < i holds p.k = q.k
proof
  defpred P[Nat] means for p,q be Element of $1-tuples_on NAT holds p <> q
  implies ex i be Element of NAT st i in Seg $1 & p.i <> q.i & for k be Element
  of NAT st 1 <= k & k < i holds p.k = q.k;
A1: for n be Element of NAT st P[n] holds P[n+1]
  proof
    let n be Element of NAT;
    assume
A2: for p,q be Element of n-tuples_on NAT holds p <> q implies ex i be
Element of NAT st i in Seg n & p.i <> q.i & for k be Element of NAT st 1 <= k &
    k < i holds p.k = q.k;
    let p,q be Element of (n+1)-tuples_on NAT;
    consider t1 be Element of n-tuples_on NAT, d1 be Element of NAT such that
A3: p = t1^<*d1*> by FINSEQ_2:137;
    assume
A4: p <> q;
    consider t2 be Element of n-tuples_on NAT, d2 be Element of NAT such that
A5: q = t2^<*d2*> by FINSEQ_2:137;
A6: len t1 = n by CARD_1:def 13;
A7: len t2 = n by CARD_1:def 13;
    per cases;
    suppose
      t1 <> t2;
      then consider i be Element of NAT such that
A8:   i in Seg n and
A9:   t1.i <> t2.i and
A10:  for k be Element of NAT st 1 <= k & k < i holds t1.k = t2.k by A2;
      take i;
      thus i in Seg (n+1) by A8,FINSEQ_2:9;
      i in dom t1 by A6,A8,FINSEQ_1:def 3;
      then
A11:  p.i = t1.i by A3,FINSEQ_1:def 7;
      i in dom t2 by A7,A8,FINSEQ_1:def 3;
      hence p.i <> q.i by A5,A9,A11,FINSEQ_1:def 7;
      let k be Element of NAT;
      assume that
A12:  1 <= k and
A13:  k < i;
      i <= n by A8,FINSEQ_1:3;
      then
A14:  k <= n by A13,XXREAL_0:2;
      then
A15:  k in dom t1 by A6,A12,FINSEQ_3:27;
A16:  k in dom t2 by A7,A12,A14,FINSEQ_3:27;
      t1.k = t2.k by A10,A12,A13;
      hence p.k = t2.k by A3,A15,FINSEQ_1:def 7
        .= q.k by A5,A16,FINSEQ_1:def 7;
    end;
    suppose
A17:  t1 = t2;
      take i = n+1;
      thus i in Seg (n+1) by FINSEQ_1:6;
      p.i = d1 by A3,FINSEQ_2:136;
      hence p.i <> q.i by A3,A5,A4,A17,FINSEQ_2:136;
      let k be Element of NAT;
      assume that
A18:  1 <= k and
A19:  k < i;
A20:  k <= n by A19,NAT_1:13;
      then
A21:  k in dom t2 by A7,A18,FINSEQ_3:27;
      k in dom t1 by A6,A18,A20,FINSEQ_3:27;
      hence p.k = t2.k by A3,A17,FINSEQ_1:def 7
        .= q.k by A5,A21,FINSEQ_1:def 7;
    end;
  end;
A22: P[0];
  thus for n be Element of NAT holds P[n] from NAT_1:sch 1(A22,A1);
end;

theorem Th7:
  for n be Element of NAT for p,q be Element of n-tuples_on NAT
  holds p <= q or p > q
proof
  let n be Element of NAT;
  let p,q be Element of n-tuples_on NAT;
  assume
A1: not p <= q;
  then consider i be Element of NAT such that
A2: i in Seg n and
A3: p.i <> q.i and
A4: for k be Element of NAT st 1 <= k & k < i holds p.k = q.k by Th6;
  take i;
  thus i in Seg n by A2;
  not p < q by A1,Def2;
  then p.i >= q.i by A2,A4,Def1;
  hence q.i < p.i by A3,XXREAL_0:1;
  thus thesis by A4;
end;

definition
  let n be Element of NAT;
  func TuplesOrder n -> Order of n-tuples_on NAT means
  :Def3:
  for p,q be Element of n-tuples_on NAT holds [p,q] in it iff p <= q;
  existence
  proof
    defpred P[Element of n-tuples_on NAT,Element of n-tuples_on NAT] means $1
    <= $2;
    consider R be Relation of n-tuples_on NAT,n-tuples_on NAT such that
A1: for x,y be Element of n-tuples_on NAT holds [x,y] in R iff P[x,y]
    from RELSET_1:sch 2;
A2: R is_transitive_in n-tuples_on NAT
    proof
      let x,y,z be set;
      assume that
A3:   x in n-tuples_on NAT & y in n-tuples_on NAT & z in n-tuples_on NAT and
A4:   [x,y] in R & [y,z] in R;
      reconsider x1=x, y1=y, z1=z as Element of n-tuples_on NAT by A3;
      x1 <= y1 & y1 <= z1 by A1,A4;
      then x1 <= z1 by Th5;
      hence thesis by A1;
    end;
A5: R is_reflexive_in n-tuples_on NAT
    proof
      let x be set;
      assume x in n-tuples_on NAT;
      then reconsider x1=x as Element of n-tuples_on NAT;
      x1 <= x1;
      hence thesis by A1;
    end;
    then
A6: dom R = n-tuples_on NAT & field R =n-tuples_on NAT by ORDERS_1:98;
    R is_antisymmetric_in n-tuples_on NAT
    proof
      let x,y be set;
      assume that
A7:   x in n-tuples_on NAT & y in n-tuples_on NAT and
A8:   [x,y] in R and
A9:   [y,x] in R;
      reconsider x1=x, y1=y as Element of n-tuples_on NAT by A7;
      x1 <= y1 by A1,A8;
      then
A10:  x1 < y1 or x1 = y1 by Def2;
      y1 <= x1 by A1,A9;
      hence thesis by A10,Def2;
    end;
    then reconsider R as Order of n-tuples_on NAT by A5,A2,A6,PARTFUN1:def 4
,RELAT_2:def 9,def 12,def 16;
    take R;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let T1,T2 be Order of n-tuples_on NAT such that
A11: for p,q be Element of n-tuples_on NAT holds [p,q] in T1 iff p <= q and
A12: for p,q be Element of n-tuples_on NAT holds [p,q] in T2 iff p <= q;
    let x,y be set;
    thus [x,y] in T1 implies [x,y] in T2
    proof
      assume
A13:  [x,y] in T1;
      then consider p,q be set such that
A14:  [x,y] = [p,q] and
A15:  p in n-tuples_on NAT & q in n-tuples_on NAT by RELSET_1:6;
      reconsider p,q as Element of n-tuples_on NAT by A15;
      p <= q by A11,A13,A14;
      hence thesis by A12,A14;
    end;
    assume
A16: [x,y] in T2;
    then consider p,q be set such that
A17: [x,y] = [p,q] and
A18: p in n-tuples_on NAT & q in n-tuples_on NAT by RELSET_1:6;
    reconsider p,q as Element of n-tuples_on NAT by A18;
    p <= q by A12,A16,A17;
    hence thesis by A11,A17;
  end;
end;

registration
  let n be Element of NAT;
  cluster TuplesOrder n -> being_linear-order;
  coherence
  proof
    now
      let x,y be set;
      assume that
A1:   x in n-tuples_on NAT & y in n-tuples_on NAT and
      x <> y and
A2:   not [x,y] in TuplesOrder n;
      reconsider p=x, q=y as Element of n-tuples_on NAT by A1;
      not p <= q by A2,Def3;
      then p > q by Th7;
      then q <= p by Def2;
      hence [y,x] in TuplesOrder n by Def3;
    end;
    then
    field TuplesOrder n = n-tuples_on NAT & TuplesOrder n is_connected_in
    n -tuples_on NAT by ORDERS_1:100,RELAT_2:def 6;
    then TuplesOrder n is connected by RELAT_2:def 14;
    hence thesis by ORDERS_1:def 5;
  end;
end;

begin  :: Decomposition of Natural Numbers

definition
  let i be non empty Element of NAT;
  let n be Element of NAT;
  func Decomp(n,i) -> FinSequence of i-tuples_on NAT means
  :Def4:
  ex A be
  finite Subset of i-tuples_on NAT st it = SgmX (TuplesOrder i,A) & for p be
  Element of i-tuples_on NAT holds p in A iff Sum p = n;
  existence
  proof
    reconsider n1 = n+1 as non empty set;
    defpred P[Element of i-tuples_on NAT] means Sum $1 = n;
    consider A be Subset of i-tuples_on NAT such that
A1: for p be Element of i-tuples_on NAT holds p in A iff P[p] from
    SUBSET_1:sch 3;
A2: A c= i-tuples_on (n+1)
    proof
      let x be set;
      assume
A3:   x in A;
      then reconsider p=x as Element of i-tuples_on NAT;
A4:   Sum p = n by A1,A3;
      rng p c= n+1
      proof
        let y be set;
        assume that
A5:     y in rng p and
A6:     not y in n+1;
        rng p c= NAT by FINSEQ_1:def 4;
        then reconsider k=y as Element of NAT by A5;
        not y in { t where t is Element of NAT : t < n+1 } by A6,AXIOMS:30;
        then
A7:     k >= n+1;
        ex j be Nat st j in dom p & p.j = k by A5,FINSEQ_2:11;
        then Sum p >= k by Th4;
        hence contradiction by A4,A7,NAT_1:13;
      end;
      then len p = i & p is FinSequence of (n+1) by CARD_1:def 13
,FINSEQ_1:def 4;
      then p is Element of i-tuples_on n1 by FINSEQ_2:110;
      hence thesis;
    end;
    n+1 is finite by CARD_1:69;
    then i-tuples_on (n+1) is finite by YELLOW15:2;
    then reconsider A as finite Subset of i-tuples_on NAT by A2;
    take SgmX (TuplesOrder i,A);
    thus thesis by A1;
  end;
  uniqueness
  proof
    let p1,p2 be FinSequence of i-tuples_on NAT;
    given A1 be finite Subset of i-tuples_on NAT such that
A8: p1 = SgmX (TuplesOrder i,A1) and
A9: for p be Element of i-tuples_on NAT holds p in A1 iff Sum p = n;
    given A2 be finite Subset of i-tuples_on NAT such that
A10: p2 = SgmX (TuplesOrder i,A2) and
A11: for p be Element of i-tuples_on NAT holds p in A2 iff Sum p = n;
    now
      let x be set;
      thus x in A1 implies x in A2
      proof
        assume
A12:    x in A1;
        then reconsider p = x as Element of i-tuples_on NAT;
        Sum p = n by A9,A12;
        hence thesis by A11;
      end;
      assume
A13:  x in A2;
      then reconsider p = x as Element of i-tuples_on NAT;
      Sum p = n by A11,A13;
      hence x in A1 by A9;
    end;
    hence thesis by A8,A10,TARSKI:2;
  end;
end;

registration
  let i be non empty Element of NAT;
  let n be Element of NAT;
  cluster Decomp(n,i) -> non empty one-to-one FinSequence-yielding;
  coherence
  proof
    reconsider p2 = (i-'1)|->0 as FinSequence of NAT;
    i >= 1 by NAT_1:14;
    then i-'1+1 = i by XREAL_1:237;
    then ((i-'1)|->0)^<*n*> is Tuple of i, NAT;
    then reconsider p1 = ((i-'1)|->0)^<*n*> as Element of i-tuples_on NAT
     by FINSEQ_2:151;
    consider A be finite Subset of i-tuples_on NAT such that
A1: Decomp(n,i) = SgmX (TuplesOrder i,A) and
A2: for p be Element of i-tuples_on NAT holds p in A iff Sum p = n by Def4;
    Sum p1 = Sum p2 + n by RVSUM_1:104
      .= 0 qua Nat+n by RVSUM_1:111;
    then reconsider A as non empty finite Subset of i-tuples_on NAT by A2;
    SgmX (TuplesOrder i,A) is non empty finite;
    hence thesis by A1;
  end;
end;

theorem Th8:
  for n be Element of NAT holds len Decomp(n,1) = 1
proof
  let n be Element of NAT;
  consider A be finite Subset of 1-tuples_on NAT such that
A1: Decomp(n,1) = SgmX (TuplesOrder 1,A) and
A2: for p be Element of 1-tuples_on NAT holds p in A iff Sum p = n by Def4;
A3: A = {<*n*>}
  proof
    thus A c= {<*n*>}
    proof
      let y be set;
      assume
A4:   y in A;
      then reconsider p=y as Element of 1-tuples_on NAT;
A5:   Sum p = n by A2,A4;
      consider k be Element of NAT such that
A6:   p = <*k*> by FINSEQ_2:117;
      Sum p = k by A6,RVSUM_1:103;
      hence thesis by A5,A6,TARSKI:def 1;
    end;
    let y be set;
    assume y in {<*n*>};
    then
A7: y = <*n*> by TARSKI:def 1;
A8:  <*n*> is Element of 1-tuples_on NAT by FINSEQ_2:151;
    Sum <*n*> = n by RVSUM_1:103;
    hence y in A by A2,A7,A8;
  end;
  field TuplesOrder 1 = 1-tuples_on NAT by ORDERS_1:100;
  then TuplesOrder 1 linearly_orders 1-tuples_on NAT by ORDERS_1:133;
  hence len Decomp(n,1) = card A by A1,ORDERS_1:134,PRE_POLY:11
    .= 1 by A3,CARD_1:50;
end;

theorem Th9:
  for n be Element of NAT holds len Decomp(n,2) = n+1
proof
  let n be Element of NAT;
  deffunc F(Nat) = <*$1,n-'$1*>;
  consider q be FinSequence such that
A1: len q = n and
A2: for k be Nat st k in dom q holds q.k = F(k) from FINSEQ_1:sch 2;
A3: dom q = Seg n by A1,FINSEQ_1:def 3;
  set q1 = q^<*<*0,n*>*>;
A4: dom q = Seg n by A1,FINSEQ_1:def 3;
A5: len q1 = n+1 by A1,FINSEQ_2:19;
  then
A6: dom q1 = Seg (n+1) by FINSEQ_1:def 3;
  now
    let x1,x2 be set;
    assume that
A7: x1 in dom q1 and
A8: x2 in dom q1 and
A9: q1.x1 = q1.x2;
    reconsider k1=x1, k2=x2 as Element of NAT by A7,A8;
    x2 in Seg n \/ {n+1} by A6,A8,FINSEQ_1:11;
    then
A10: x2 in Seg n or x2 in {n+1} by XBOOLE_0:def 3;
    x1 in Seg n \/ {n+1} by A6,A7,FINSEQ_1:11;
    then
A11: x1 in Seg n or x1 in {n+1} by XBOOLE_0:def 3;
    now
      per cases by A11,A10,TARSKI:def 1;
      suppose
A12:    x1 in Seg n & x2 in Seg n;
        then
A13:    q1.k1 = q.k1 & q1.k2 = q.k2 by A3,FINSEQ_1:def 7;
        q.k1 = <*k1,n-'k1*> & q.k2 = <*k2,n-'k2*> by A2,A4,A12;
        hence x1 = x2 by A9,A13,FINSEQ_1:98;
      end;
      suppose
A14:    x1 in Seg n & x2 = n+1;
        then
A15:    q1.k2 = <*0,n*> by A1,FINSEQ_1:59;
        q1.k1 = q.k1 by A3,A14,FINSEQ_1:def 7
          .= <*k1,n-'k1*> by A2,A4,A14;
        then k1 = 0 by A9,A15,FINSEQ_1:98;
        hence x1 = x2 by A14,FINSEQ_1:3;
      end;
      suppose
A16:    x1 = n+1 & x2 in Seg n;
        then
A17:    q1.k1 = <*0,n*> by A1,FINSEQ_1:59;
        q1.k2 = q.k2 by A3,A16,FINSEQ_1:def 7
          .= <*k2,n-'k2*> by A2,A4,A16;
        then k2 = 0 by A9,A17,FINSEQ_1:98;
        hence x1 = x2 by A16,FINSEQ_1:3;
      end;
      suppose
        x1 = n+1 & x2 = n+1;
        hence x1 = x2;
      end;
    end;
    hence x1 = x2;
  end;
  then q1 is one-to-one by FUNCT_1:def 8;
  then
A18: card(rng q1) = n+1 by A5,FINSEQ_4:77;
A19: rng q c= rng q1 by FINSEQ_1:42;
A20: rng q1 = {<*i,n-'i*> where i is Element of NAT : i <= n}
  proof
    thus rng q1 c= {<*i,n-'i*> where i is Element of NAT : i <= n}
    proof
      let x be set;
      assume x in rng q1;
      then consider j be Nat such that
A21:  j in dom q1 and
A22:  q1.j = x by FINSEQ_2:11;
      reconsider j as Element of NAT by ORDINAL1:def 13;
      j in Seg n \/ {n+1} by A6,A21,FINSEQ_1:11;
      then
A23:  j in Seg n or j in {n+1} by XBOOLE_0:def 3;
      now
        per cases by A23,TARSKI:def 1;
        suppose
A24:      j in Seg n;
          then
A25:      q1.j = q.j by A3,FINSEQ_1:def 7;
          q.j = <*j,n-'j*> & j <= n by A2,A4,A24,FINSEQ_1:3;
          hence thesis by A22,A25;
        end;
        suppose
          j = n+1;
          then q1.j = <*0,n*> by A1,FINSEQ_1:59
            .= <*0,n-'0*> by NAT_D:40;
          hence thesis by A22;
        end;
      end;
      hence thesis;
    end;
    let x be set;
    assume x in {<*i,n-'i*> where i is Element of NAT : i <= n};
    then consider i be Element of NAT such that
A26: x = <*i,n-'i*> and
A27: i <= n;
A28: i = 0 or i >= 0 qua Nat+1 by NAT_1:13;
    now
      per cases by A27,A28,FINSEQ_1:3;
      suppose
A29:    i = 0;
A30:    n+1 in dom q1 by A6,FINSEQ_1:6;
        q1.(n+1) = <*0,n*> by A1,FINSEQ_1:59
          .= x by A26,A29,NAT_D:40;
        hence thesis by A30,FUNCT_1:def 5;
      end;
      suppose
A31:    i in Seg n;
        then q.i = x by A2,A4,A26;
        then x in rng q by A3,A31,FUNCT_1:def 5;
        hence thesis by A19;
      end;
    end;
    hence thesis;
  end;
  consider A be finite Subset of 2-tuples_on NAT such that
A32: Decomp(n,2) = SgmX (TuplesOrder 2,A) and
A33: for p be Element of 2-tuples_on NAT holds p in A iff Sum p = n by Def4;
A34: A = {<*i,n-'i*> where i is Element of NAT : i <= n}
  proof
    thus A c= {<*i,n-'i*> where i is Element of NAT : i <= n}
    proof
      let x be set;
      assume
A35:  x in A;
      then reconsider p=x as Element of 2-tuples_on NAT;
      consider d1,d2 be Element of NAT such that
A36:  p = <*d1,d2*> by FINSEQ_2:120;
A37:  d1+d2 = Sum p by A36,RVSUM_1:107
        .= n by A33,A35;
      then n-d1 >= 0;
      then
A38:  d2 = n-'d1 by A37,XREAL_0:def 2;
      d1 <= n by A37,NAT_1:11;
      hence thesis by A36,A38;
    end;
    let x be set;
    assume x in { <*i,n-'i*> where i is Element of NAT : i <= n };
    then consider i be Element of NAT such that
A39: x = <*i,n-'i*> and
A40: i <= n;
A41: n-i >= 0 by A40,XREAL_1:50;
    Sum <*i,n-'i*> = i+(n-'i) by RVSUM_1:107
      .= i+(n-i) by A41,XREAL_0:def 2
      .= n;
    hence thesis by A33,A39;
  end;
  field TuplesOrder 2 = 2-tuples_on NAT by ORDERS_1:100;
  then TuplesOrder 2 linearly_orders 2-tuples_on NAT by ORDERS_1:133;
  hence thesis by A32,A34,A20,A18,ORDERS_1:134,PRE_POLY:11;
end;

theorem
  for n be Element of NAT holds Decomp(n,1) = <*<*n*>*>
proof
  let n be Element of NAT;
  consider A be finite Subset of 1-tuples_on NAT such that
A1: Decomp(n,1) = SgmX (TuplesOrder 1,A) and
A2: for p be Element of 1-tuples_on NAT holds p in A iff Sum p = n by Def4;
A3: A = {<*n*>}
  proof
    thus A c= {<*n*>}
    proof
      let y be set;
      assume
A4:   y in A;
      then reconsider p=y as Element of 1-tuples_on NAT;
A5:   Sum p = n by A2,A4;
      consider k be Element of NAT such that
A6:   p = <*k*> by FINSEQ_2:117;
      Sum p = k by A6,RVSUM_1:103;
      hence thesis by A5,A6,TARSKI:def 1;
    end;
    let y be set;
    assume y in {<*n*>};
    then
A7: y = <*n*> by TARSKI:def 1;
A8:  <*n*> is Element of 1-tuples_on NAT by FINSEQ_2:151;
    Sum <*n*> = n by RVSUM_1:103;
    hence thesis by A2,A7,A8;
  end;
  len Decomp(n,1) = 1 by Th8;
  then
A9: dom Decomp(n,1) = Seg 1 by FINSEQ_1:def 3
    .= dom <*<*n*>*> by FINSEQ_1:55;
  field TuplesOrder 1 = 1-tuples_on NAT by ORDERS_1:100;
  then TuplesOrder 1 linearly_orders A by ORDERS_1:133,134;
  then rng <*<*n*>*> = {<*n*>} & rng Decomp(n,1) = {<*n*>} by A1,A3,FINSEQ_1:56
,PRE_POLY:def 2;
  hence thesis by A9,FUNCT_1:17;
end;

theorem Th11:
  for i,j,n,k1,k2 be Element of NAT st Decomp(n,2).i = <*k1,n-'k1
  *> & Decomp(n,2).j = <*k2,n-'k2*> holds i<j iff k1<k2
proof
  let i,j,n,k1,k2 be Element of NAT;
  assume that
A1: Decomp(n,2).i = <*k1,n-'k1*> and
A2: Decomp(n,2).j = <*k2,n-'k2*>;
A3: j in dom Decomp(n,2) by A2,FUNCT_1:def 4;
  then
A4: Decomp(n,2).j = (Decomp(n,2))/.j by PARTFUN1:def 8;
  consider A be finite Subset of 2-tuples_on NAT such that
A5: Decomp(n,2) = SgmX (TuplesOrder 2,A) and
  for p be Element of 2-tuples_on NAT holds p in A iff Sum p = n by Def4;
  field TuplesOrder 2 = 2-tuples_on NAT by ORDERS_1:100;
  then
A6: TuplesOrder 2 linearly_orders A by ORDERS_1:133,134;
A7: i in dom Decomp(n,2) by A1,FUNCT_1:def 4;
  then
A8: Decomp(n,2).i = (Decomp(n,2))/.i by PARTFUN1:def 8;
  thus i<j implies k1<k2
  proof
    assume
A9: i<j;
    then
    [<*k1,n-'k1*>,<*k2,n-'k2*>] in TuplesOrder 2 by A5,A6,A1,A2,A7,A3,A8,A4,
PRE_POLY:def 2;
    then
A10: <*k1,n-'k1*> <= <*k2,n-'k2*> by Def3;
    <*k1,n-'k1*> <> <*k2,n-'k2*> by A5,A6,A1,A2,A7,A3,A8,A4,A9,PRE_POLY:def 2;
    then <*k1,n-'k1*> < <*k2,n-'k2*> by A10,Def2;
    then consider t be Element of NAT such that
A11: t in Seg 2 and
A12: <*k1,n-'k1*>.t < <*k2,n-'k2*>.t and
A13: for k be Element of NAT st 1 <= k & k < t holds <*k1,n-'k1*>.k =
    <*k2,n-'k2*>.k by Def1;
    per cases by A11,FINSEQ_1:4,TARSKI:def 2;
    suppose
A14:  t = 1;
      then <*k1,n-'k1*>.t = k1 by FINSEQ_1:61;
      hence thesis by A12,A14,FINSEQ_1:61;
    end;
    suppose
      t = 2;
      then <*k1,n-'k1*>.1 = <*k2,n-'k2*>.1 by A13;
      then <*k1,n-'k1*>.1 = k2 by FINSEQ_1:61;
      then k1 = k2 by FINSEQ_1:61;
      hence thesis by A12;
    end;
  end;
  assume
A15: k1<k2;
A16: for k be Element of NAT st 1 <= k & k < 1 holds <*k1,n-'k1*>.k = <*k2,n
  -'k2*>.k;
A17: <*k1,n-'k1*>.1 = k1 by FINSEQ_1:61;
  1 in Seg 2 & <*k2,n-'k2*>.1 = k2 by FINSEQ_1:3,61;
  then
A18: <*k1,n-'k1*> < <*k2,n-'k2*> by A15,A17,A16,Def1;
  assume
A19: i>=j;
  per cases by A19,XXREAL_0:1;
  suppose
    i = j;
    hence contradiction by A1,A2,A15,A17,FINSEQ_1:61;
  end;
  suppose
A20: j<i;
    then
    [<*k2,n-'k2*>,<*k1,n-'k1*>] in TuplesOrder 2 by A5,A6,A1,A2,A7,A3,A8,A4,
PRE_POLY:def 2;
    then
A21: <*k2,n-'k2*> <= <*k1,n-'k1*> by Def3;
    <*k2,n-'k2*> <> <*k1,n-'k1*> by A5,A6,A1,A2,A7,A3,A8,A4,A20,PRE_POLY:def 2;
    hence contradiction by A18,A21,Def2;
  end;
end;

theorem Th12:
  for i,n,k1,k2 be Element of NAT st Decomp(n,2).i = <*k1,n-'k1*>
  & Decomp(n,2).(i+1) = <*k2,n-'k2*> holds k2=k1+1
proof
  let i,n,k1,k2 be Element of NAT;
  assume that
A1: Decomp(n,2).i = <*k1,n-'k1*> and
A2: Decomp(n,2).(i+1) = <*k2,n-'k2*>;
  assume
A3: k2 <> k1+1;
  i+(0 qua Nat) < i+1 by XREAL_1:8;
  then
A4: k1 < k2 by A1,A2,Th11;
  then k1+1 <= k2 by NAT_1:13;
  then
A5: k1+1 < k2 by A3,XXREAL_0:1;
  consider A be finite Subset of 2-tuples_on NAT such that
A6: Decomp(n,2) = SgmX (TuplesOrder 2,A) and
A7: for p be Element of 2-tuples_on NAT holds p in A iff Sum p = n by Def4;
  field TuplesOrder 2 = 2-tuples_on NAT by ORDERS_1:100;
  then TuplesOrder 2 linearly_orders A by ORDERS_1:133,134;
  then
A8: rng Decomp(n,2) = A by A6,PRE_POLY:def 2;
  k1 < n
  proof
    Sum <*k2,n-'k2*> = k2 + (n-'k2) by RVSUM_1:107;
    then
A9: Sum <*k2,n-'k2*> >= k2 by NAT_1:11;
    assume k1 >= n;
    then k2 > n by A4,XXREAL_0:2;
    then not Decomp(n,2).(i+1) in rng Decomp(n,2) by A7,A8,A2,A9;
    then not i+1 in dom Decomp(n,2) by FUNCT_1:def 5;
    hence contradiction by A2,FUNCT_1:def 4;
  end;
  then
A10: k1+1 <= n by NAT_1:13;
  Sum <*k1+1,n-'(k1+1)*> = k1+1+(n-'(k1+1)) by RVSUM_1:107
    .= n by A10,XREAL_1:237;
  then <*k1+1,n-'(k1+1)*> in rng Decomp(n,2) by A7,A8;
  then consider k be Nat such that
  k in dom Decomp(n,2) and
A11: Decomp(n,2).k = <*k1+1,n-'(k1+1)*> by FINSEQ_2:11;
  reconsider k as Element of NAT by ORDINAL1:def 13;
  k1+(0 qua Nat) < k1+1 by XREAL_1:8;
  then i < k by A1,A11,Th11;
  then i+1 <= k by NAT_1:13;
  hence contradiction by A2,A5,A11,Th11;
end;

theorem Th13:
  for n be Element of NAT holds Decomp(n,2).1 = <*0,n*>
proof
  let n be Element of NAT;
  consider A be finite Subset of 2-tuples_on NAT such that
A1: Decomp(n,2) = SgmX (TuplesOrder 2,A) and
A2: for p be Element of 2-tuples_on NAT holds p in A iff Sum p = n by Def4;
A3: now
    let y be Element of 2-tuples_on NAT;
    consider d1,d2 be Element of NAT such that
A4: y = <*d1,d2*> by FINSEQ_2:120;
    assume y in A;
    then Sum <*d1,d2*> = n by A2,A4;
    then
A5: d1 + d2 = n by RVSUM_1:107;
    now
      per cases;
      suppose
        d1 = 0;
        hence <*0,n*> <= <*d1,d2*> by A5;
      end;
      suppose
        d1 > 0;
        then <*0,n*>.1 < d1 by FINSEQ_1:61;
        then
A6:     <*0,n*>.1 < <*d1,d2*>.1 by FINSEQ_1:61;
        1 in Seg 2 & for k be Element of NAT st 1 <= k & k < 1 holds <*0,
        n*>.k = <* d1,d2*>.k by FINSEQ_1:3;
        then <*0,n*> < <*d1,d2*> by A6,Def1;
        hence <*0,n*> <= <*d1,d2*> by Def2;
      end;
    end;
    hence [<*0,n*>,y] in TuplesOrder 2 by A4,Def3;
  end;
  1 <= n+1 by NAT_1:11;
  then 1 in Seg (n+1) by FINSEQ_1:3;
  then 1 in Seg len Decomp(n,2) by Th9;
  then
A7: 1 in dom Decomp(n,2) by FINSEQ_1:def 3;
  field TuplesOrder 2 = 2-tuples_on NAT by ORDERS_1:100;
  then
A8: TuplesOrder 2 linearly_orders A by ORDERS_1:133,134;
  Sum <*0,n*> = 0 qua Nat+n by RVSUM_1:107;
  then <*0,n*> in A by A2;
  then (SgmX (TuplesOrder 2,A))/.1 = <*0,n*> by A8,A3,PRE_POLY:20;
  hence thesis by A1,A7,PARTFUN1:def 8;
end;

theorem Th14:
  for n,i be Element of NAT st i in Seg (n+1) holds Decomp(n,2).i
  = <*i-'1,n+1-'i*>
proof
  let n,i be Element of NAT;
  defpred P[Nat] means $1 <= n+1 implies Decomp(n,2).$1 = <*$1-'1,n+1-'$1*>;
  assume i in Seg (n+1);
  then
A1: 1 <= i & i <= n+1 by FINSEQ_1:3;
  consider A be finite Subset of 2-tuples_on NAT such that
A2: Decomp(n,2) = SgmX (TuplesOrder 2,A) and
A3: for p be Element of 2-tuples_on NAT holds p in A iff Sum p = n by Def4;
A4: for j be non empty Nat st P[j] holds P[j+1]
  proof
    field TuplesOrder 2 = 2-tuples_on NAT by ORDERS_1:100;
    then
A5: TuplesOrder 2 linearly_orders A by ORDERS_1:133,134;
    let j be non empty Nat;
    assume that
A6: j <= n+1 implies Decomp(n,2).j = <*j-'1,n+1-'j*> and
A7: j+1 <= n+1;
    n >= j by A7,XREAL_1:8;
    then
A8: n-j >= 0 by XREAL_1:50;
    n+1-(j+1) >= 0 by A7,XREAL_1:50;
    then
A9: n+1-'(j+1) = n-j by XREAL_0:def 2
      .= n-'j by A8,XREAL_0:def 2;
    reconsider jj=j as non empty Element of NAT by ORDINAL1:def 13;
    j >= 1 by NAT_1:14;
    then
A10: j-1 >= 1-1 by XREAL_1:11;
    j+1 >= 1 by NAT_1:11;
    then j+1 in Seg (n+1) by A7,FINSEQ_1:3;
    then j+1 in Seg len Decomp(n,2) by Th9;
    then
A11: j+1 in dom Decomp(n,2) by FINSEQ_1:def 3;
    then Decomp(n,2).(j+1) = (Decomp(n,2))/.(j+1) by PARTFUN1:def 8;
    then consider d1,d2 be Element of NAT such that
A12: Decomp(n,2).(j+1) = <*d1,d2*> by FINSEQ_2:120;
    Decomp(n,2).(j+1) in rng Decomp(n,2) by A11,FUNCT_1:def 5;
    then Decomp(n,2).(j+1) in A by A2,A5,PRE_POLY:def 2;
    then Sum <*d1,d2*> = n by A3,A12;
    then
A13: d1+d2 = n by RVSUM_1:107;
    then n-d1 >= 0;
    then
A14: d2 = n-'d1 by A13,XREAL_0:def 2;
    j < n+1 by A7,NAT_1:13;
    then
A15: n+1-j >= 0 by XREAL_1:50;
    then n-(j-1) >= 0;
    then
A16: n-(j-'1) >= 0 by A10,XREAL_0:def 2;
    n+1-'j = n-(j-1) by A15,XREAL_0:def 2
      .= n-(j-'1) by A10,XREAL_0:def 2
      .= n-'(j-'1) by A16,XREAL_0:def 2;
    then d1 = jj-'1+1 by A6,A7,A12,A14,Th12,NAT_1:13
      .= j by NAT_1:14,XREAL_1:237;
    hence thesis by A12,A14,A9,NAT_D:34;
  end;
A17: P[1]
  proof
    assume 1 <= n+1;
    thus Decomp(n,2).1 = <*0,n*> by Th13
      .= <*1-'1,n*> by XREAL_1:234
      .= <*1-'1,n+1-'1*> by NAT_D:34;
  end;
  for j be non empty Nat holds P[j] from NAT_1:sch 10(A17,A4);
  hence thesis by A1;
end;

definition
  let L be non empty multMagma;
  let p,q,r be sequence of L;
  let t be FinSequence of 3-tuples_on NAT;
  func prodTuples(p,q,r,t) -> Element of (the carrier of L)* means
  :Def5:
  len
it = len t & for k be Element of NAT st k in dom t holds it.k = (p.((t/.k)/.1))
  *(q.((t/.k)/.2))*(r.((t/.k)/.3));
  existence
  proof
    deffunc F(Nat) = (p.((t/.$1)/.1))*(q.((t/.$1)/.2))*(r.((t/.$1)/.3));
    consider p1 be FinSequence of the carrier of L such that
A1: len p1 = len t and
A2: for k be Nat st k in dom p1 holds p1.k = F(k) from FINSEQ_2:sch 1;
A3: dom p1 = Seg len t by A1,FINSEQ_1:def 3;
    reconsider p1 as Element of (the carrier of L)* by FINSEQ_1:def 11;
    take p1;
    thus len p1 = len t by A1;
    let k be Element of NAT;
    assume k in dom t;
    then k in Seg len t by FINSEQ_1:def 3;
    hence thesis by A2,A3;
  end;
  uniqueness
  proof
    let p1,p2 be Element of (the carrier of L)* such that
A4: len p1 = len t and
A5: for k be Element of NAT st k in dom t holds p1.k = (p.((t/.k)/.1))
    *(q.((t/.k)/.2))*(r.((t/.k)/.3)) and
A6: len p2 = len t and
A7: for k be Element of NAT st k in dom t holds p2.k = (p.((t/.k)/.1))
    *(q.((t/.k)/.2))*(r.((t/.k)/.3));
A8: dom p1 = Seg len t by A4,FINSEQ_1:def 3;
    now
      let i be Nat;
      assume i in dom p1;
      then
A9:   i in dom t by A8,FINSEQ_1:def 3;
      hence p1.i = (p.((t/.i)/.1))*(q.((t/.i)/.2))*(r.((t/.i)/.3)) by A5
        .= p2.i by A7,A9;
    end;
    hence thesis by A4,A6,FINSEQ_2:10;
  end;
end;

theorem Th15:
  for L be non empty multMagma for p,q,r be sequence of L for t be
  FinSequence of 3-tuples_on NAT for P be Permutation of dom t for t1 be
  FinSequence of 3-tuples_on NAT st t1 = t*P holds prodTuples(p,q,r,t1) =
  prodTuples(p,q,r,t)*P
proof
  let L be non empty multMagma;
  let p,q,r be sequence of L;
  let t be FinSequence of 3-tuples_on NAT;
  let P be Permutation of dom t;
  let t1 be FinSequence of 3-tuples_on NAT;
A1: rng P = dom t by FUNCT_2:def 3;
  assume
A2: t1 = t*P;
  then
A3: dom P = dom t1 by A1,RELAT_1:46;
A4: now
    let x be set;
    assume
A5: x in dom t1;
    then reconsider i=x as Element of NAT;
A6: prodTuples(p,q,r,t1).i = (p.((t1/.i)/.1))*(q.((t1/.i)/.2))*(r.((t1/.i
)/.3)) & (prodTuples(p,q,r,t)*P).x = prodTuples(p,q,r,t).(P.x) by A3,A5,Def5,
FUNCT_1:23;
    reconsider j=P.i as Element of NAT;
A7: P.i in rng P by A3,A5,FUNCT_1:def 5;
    t1/.i = t1.i by A5,PARTFUN1:def 8
      .= t.(P.i) by A2,A5,FUNCT_1:22
      .= t/.j by A1,A7,PARTFUN1:def 8;
    hence prodTuples(p,q,r,t1).x = (prodTuples(p,q,r,t)*P).x by A1,A7,A6,Def5;
  end;
  len prodTuples(p,q,r,t1) = len t1 by Def5;
  then
A8: dom prodTuples(p,q,r,t1) = Seg len t1 by FINSEQ_1:def 3;
  len prodTuples(p,q,r,t) = len t by Def5;
  then rng P = dom prodTuples(p,q,r,t) by A1,FINSEQ_3:31;
  then
A9: dom (prodTuples(p,q,r,t)*P) = dom t1 by A3,RELAT_1:46;
  dom t1 = Seg len t1 by FINSEQ_1:def 3;
  hence thesis by A8,A9,A4,FUNCT_1:9;
end;

theorem Th16:
  for D be set for f be FinSequence of D* for i be Element of NAT
  holds Card (f|i) = (Card f)|i
proof
  let D be set;
  let f be FinSequence of D*;
  let i be Element of NAT;
A1: f|i = f|Seg i by FINSEQ_1:def 15;
  reconsider k = min(i,len f) as Element of NAT by FINSEQ_2:1;
  dom Card (f|i) = dom (f|i) by CARD_3:def 2;
  then
A2: len Card (f|i) = len (f|i) by FINSEQ_3:31
    .= min(i,len f) by A1,FINSEQ_2:24;
  then
A3: dom Card (f|i) = Seg k by FINSEQ_1:def 3;
A4: dom Card f = dom f by CARD_3:def 2;
A5: (Card f)|i = (Card f)|Seg i by FINSEQ_1:def 15;
A6: now
A7: len f = len Card f by A4,FINSEQ_3:31;
    let j be Nat;
    assume
A8: j in dom Card (f|i);
    per cases;
    suppose
A9:   i <= len f;
A10:  1 <= j by A3,A8,FINSEQ_1:3;
A11:  k = i by A9,XXREAL_0:def 9;
      then j <= i by A3,A8,FINSEQ_1:3;
      then j <= len f by A9,XXREAL_0:2;
      then
A12:  j in dom f by A10,FINSEQ_3:27;
      len ((Card f)|i) = i by A7,A9,FINSEQ_1:80;
      then
A13:  dom ((Card f)|i) = Seg i by FINSEQ_1:def 3;
      reconsider Cf = Card f as FinSequence of NAT qua set;
A14:  Seg len (f|i) = dom (f|i) by FINSEQ_1:def 3;
A15:  len(f|i) = i by A9,FINSEQ_1:80;
      hence Card (f|i).j = card ((f|i).j) by A3,A8,A11,A14,CARD_3:def 2
        .= card ((f|i)/.j) by A3,A8,A11,A15,A14,PARTFUN1:def 8
        .= card (f/.j) by A3,A8,A11,A15,A14,FINSEQ_4:85
        .= card (f.j) by A12,PARTFUN1:def 8
        .= (Card f).j by A12,CARD_3:def 2
        .= Cf/.j by A4,A12,PARTFUN1:def 8
        .= (Cf|i)/.j by A3,A8,A11,A13,FINSEQ_4:85
        .= (Card f)|i.j by A3,A8,A11,A13,PARTFUN1:def 8;
    end;
    suppose
A16:  i > len f;
      then f|i = f by A1,FINSEQ_2:23;
      hence Card (f|i).j = (Card f)|i.j by A5,A7,A16,FINSEQ_2:23;
    end;
  end;
  len ((Card f)|i) = min(i,len Card f) by A5,FINSEQ_2:24
    .= min(i,len f) by A4,FINSEQ_3:31;
  hence thesis by A2,A6,FINSEQ_2:10;
end;

theorem
  for p be FinSequence of REAL for q be FinSequence of NAT st p=q for i
  be Element of NAT holds p|i = q|i;

theorem Th18:
  for p be FinSequence of NAT for i,j be Element of NAT st i <= j
  holds Sum (p|i) <= Sum (p|j)
proof
  let p be FinSequence of NAT;
  let i,j be Element of NAT;
  assume
A1: i <= j;
  then consider k be Nat such that
A2: j = i + k by NAT_1:10;
  reconsider k as Element of NAT by ORDINAL1:def 13;
  per cases;
  suppose
A3: j <= len p;
    then
A4: len (p|j) = i + k by A2,FINSEQ_1:80;
    then consider q,r be FinSequence of NAT such that
A5: len q = i and
    len r = k and
A6: (p|j) = q^r by FINSEQ_2:26;
A7: len (p|i) = i by A1,A3,FINSEQ_1:80,XXREAL_0:2;
    then
A8: dom (p|i) = Seg i by FINSEQ_1:def 3;
A9: now
      reconsider p1 = p as FinSequence of REAL;
      let n be Nat;
      assume
A10:  n in dom (p|i);
      then
A11:  (p1|i)/.n = p/.n by FINSEQ_4:85;
A12:  Seg i = dom q by A5,FINSEQ_1:def 3;
A13:  Seg i c= Seg j & Seg j = dom (p|j) by A1,A2,A4,FINSEQ_1:7,def 3;
      Seg i = dom (p|i) by A7,FINSEQ_1:def 3;
      then
A14:  (p1|j)/.n = p/.n by A10,A13,FINSEQ_4:85;
      thus (p|i).n = (p1|i)/.n by A10,PARTFUN1:def 8
        .= (p|j).n by A8,A10,A13,A11,A14,PARTFUN1:def 8
        .= q.n by A6,A8,A10,A12,FINSEQ_1:def 7;
    end;
A15: Sum q + Sum r >= Sum q + (0 qua Nat) by XREAL_1:8;
    Sum (p|j) = Sum q + Sum r by A6,RVSUM_1:105;
    hence thesis by A7,A5,A9,A15,FINSEQ_2:10;
  end;
  suppose
    j > len p;
    then
A16: p|j = p by FINSEQ_1:79;
    now
      per cases;
      suppose
        i >= len p;
        hence thesis by A16,FINSEQ_1:79;
      end;
      suppose
A17:    i < len p;
        then consider t be Nat such that
A18:    len p = i + t by NAT_1:10;
        consider q,r be FinSequence of NAT such that
A19:    len q = i and
        len r = t and
A20:    p = q^r by A18,FINSEQ_2:26;
A21:    len (p|i) = i by A17,FINSEQ_1:80;
        then
A22:    dom(p|i) = Seg i by FINSEQ_1:def 3;
A23:    now
A24:      Seg i = dom q by A19,FINSEQ_1:def 3;
          reconsider p1 = p as FinSequence of REAL;
          let n be Nat;
A25:      dom (p|i) c= dom p by FINSEQ_5:20;
          assume
A26:      n in dom(p|i);
          then
A27:      (p1|i)/.n = p/.n by FINSEQ_4:85;
          thus (p|i).n = (p1|i)/.n by A26,PARTFUN1:def 8
            .= p.n by A26,A27,A25,PARTFUN1:def 8
            .= q.n by A20,A22,A26,A24,FINSEQ_1:def 7;
        end;
A28:    Sum q + Sum r >= Sum q + (0 qua Nat) by XREAL_1:8;
        Sum p = Sum q + Sum r by A20,RVSUM_1:105;
        hence thesis by A16,A19,A21,A23,A28,FINSEQ_2:10;
      end;
    end;
    hence thesis;
  end;
end;

theorem
  for D being set, p be FinSequence of D for i be Element of NAT st i <
  len p holds p|(i+1) = p|i ^ <*p.(i+1)*> by FINSEQ_5:86;

theorem Th20:
  for p be FinSequence of REAL for i be Element of NAT st i < len
  p holds Sum (p|(i+1)) = Sum (p|i) + p.(i+1)
proof
  let p be FinSequence of REAL;
  let i be Element of NAT;
  assume i < len p;
  then p|(i+1) = p|i ^ <*p.(i+1)*> by FINSEQ_5:86;
  hence thesis by RVSUM_1:104;
end;

theorem Th21:
  for p be FinSequence of NAT for i,j,k1,k2 be Element of NAT st i
< len p & j < len p & 1 <= k1 & 1 <= k2 & k1 <= p.(i+1) & k2 <= p.(j+1) & (Sum
  (p|i)) + k1 = (Sum (p|j)) + k2 holds i = j & k1 = k2
proof
  let p be FinSequence of NAT;
  let i,j,k1,k2 be Element of NAT;
  assume that
A1: i < len p and
A2: j < len p and
A3: 1 <= k1 and
A4: 1 <= k2 and
A5: k1 <= p.(i+1) and
A6: k2 <= p.(j+1) and
A7: (Sum (p|i)) + k1 = (Sum (p|j)) + k2 and
A8: i <> j or k1 <> k2;
A9: i <> j by A7,A8,XCMPLX_1:2;
  reconsider p1 = p as FinSequence of REAL;
A10: Sum (p1|i) + p.(i+1) >= Sum (p|i) + k1 by A5,XREAL_1:8;
A11: Sum (p1|j) + p.(j+1) >= Sum (p|j) + k2 by A6,XREAL_1:8;
  per cases;
  suppose
    i < j;
    then i+1 <= j by NAT_1:13;
    then Sum (p|j) >= Sum (p1|(i+1)) by Th18;
    then Sum (p|j) >= Sum (p1|i) + p.(i+1) by A1,Th20;
    then
A12: Sum (p|j) >= Sum (p|j) + k2 by A7,A10,XXREAL_0:2;
    Sum (p|j) + k2 >= Sum (p|j) by NAT_1:11;
    then Sum (p|j) = Sum (p|j) + k2 by A12,XXREAL_0:1;
    then k2 = 0;
    hence contradiction by A4;
  end;
  suppose
    i >= j;
    then j < i by A9,XXREAL_0:1;
    then j+1 <= i by NAT_1:13;
    then Sum (p|i) >= Sum (p1|(j+1)) by Th18;
    then Sum (p|i) >= Sum (p1|j) + p.(j+1) by A2,Th20;
    then
A13: Sum (p|i) >= Sum (p|i) + k1 by A7,A11,XXREAL_0:2;
    Sum (p|i) + k1 >= Sum (p|i) by NAT_1:11;
    then Sum (p|i) = Sum (p|i) + k1 by A13,XXREAL_0:1;
    then k1 = 0;
    hence contradiction by A3;
  end;
end;

theorem Th22:
  for D1,D2 be set for f1 be FinSequence of D1* for f2 be
  FinSequence of D2* for i1,i2,j1,j2 be Element of NAT st i1 in dom f1 & i2 in
  dom f2 & j1 in dom (f1.i1) & j2 in dom (f2.i2) & Card f1 = Card f2 & (Sum ((
  Card f1)|(i1-'1))) + j1 = (Sum ((Card f2)|(i2-'1))) + j2 holds i1 = i2 & j1 =
  j2
proof
  let D1,D2 be set;
  let f1 be FinSequence of D1*;
  let f2 be FinSequence of D2*;
  let i1,i2,j1,j2 be Element of NAT;
  assume that
A1: i1 in dom f1 and
A2: i2 in dom f2 and
A3: j1 in dom (f1.i1) and
A4: j2 in dom (f2.i2) and
A5: Card f1 = Card f2 & (Sum ((Card f1)|(i1-'1))) + j1 = (Sum ((Card f2)
  |(i2-'1) )) + j2;
A6: j1 >= 1 & j2 >= 1 by A3,A4,FINSEQ_3:27;
A7: 1 <= i1 by A1,FINSEQ_3:27;
  then
A8: i1-1 >= 0 by XREAL_1:50;
  j1 <= len (f1.i1) by A3,FINSEQ_3:27;
  then j1 <= (Card f1).i1 by A1,CARD_3:def 2;
  then
A9: j1 <= (Card f1).(i1-'1+1) by A7,XREAL_1:237;
A10: 1 <= i2 by A2,FINSEQ_3:27;
  then
A11: i2-1 >= 0 by XREAL_1:50;
  dom Card f2 = dom f2 by CARD_3:def 2;
  then
A12: len Card f2 = len f2 by FINSEQ_3:31;
  dom Card f1 = dom f1 by CARD_3:def 2;
  then
A13: len Card f1 = len f1 by FINSEQ_3:31;
  i1 <= len f1 by A1,FINSEQ_3:27;
  then i1 < len f1 + 1 by NAT_1:13;
  then i1 - 1 < len f1 + 1 - 1 by XREAL_1:11;
  then
A14: i1-'1 < len Card f1 by A13,A8,XREAL_0:def 2;
  j2 <= len (f2.i2) by A4,FINSEQ_3:27;
  then j2 <= (Card f2).i2 by A2,CARD_3:def 2;
  then
A15: j2 <= (Card f2).(i2-'1+1) by A10,XREAL_1:237;
  i2 <= len f2 by A2,FINSEQ_3:27;
  then i2 < len f2 + 1 by NAT_1:13;
  then i2 - 1 < len f2 + 1 - 1 by XREAL_1:11;
  then i2-'1 < len Card f2 by A12,A11,XREAL_0:def 2;
  then i1-'1 = i2-'1 by A5,A14,A6,A9,A15,Th21;
  then i1-1 = i2-'1 by A8,XREAL_0:def 2;
  then i1-1 = i2-1 by A11,XREAL_0:def 2;
  hence thesis by A5,A14,A6,A9,A15,Th21;
end;

begin  :: Polynomials

definition
  let L be non empty ZeroStr;
  mode Polynomial of L is AlgSequence of L;
end;

theorem Th23:
  for L be non empty ZeroStr for p be Polynomial of L for n be
  Element of NAT holds n >= len p iff n is_at_least_length_of p
proof
  let L be non empty ZeroStr;
  let p be Polynomial of L;
  let n be Element of NAT;
  thus n >= len p implies n is_at_least_length_of p
  proof
    assume
A1: n >= len p;
    let i be Nat;
    assume i >= n;
    hence p.i = 0.L by A1,ALGSEQ_1:22,XXREAL_0:2;
  end;
  assume n is_at_least_length_of p;
  hence thesis by ALGSEQ_1:def 4;
end;

scheme
  PolynomialLambdaF{R()->non empty addLoopStr, A()->Element of NAT, F(Element
of NAT)->Element of R()}: ex p be Polynomial of R() st len p <= A() & for n be
  Element of NAT st n < A() holds p.n=F(n) proof
  defpred P[Element of NAT,Element of R()] means $1<A() & $2=F($1) or $1>=A()
  & $2=0.R();
A1: for x be Element of NAT ex y be Element of R() st P[x,y]
  proof
    let x be Element of NAT;
    x<A() implies x<A() & F(x) = F(x);
    hence thesis;
  end;
  ex f be Function of NAT,the carrier of R() st for x be Element of NAT
  holds P[x,f.x] from FUNCT_2:sch 3(A1);
  then consider f be Function of NAT,the carrier of R() such that
A2: for x be Element of NAT holds x<A() & f.x=F(x) or x>=A() & f.x=0.R();
  ex n be Nat st for i be Nat st i >= n holds f.i = 0.R()
  proof
    take A();
    let i be Nat;
    i in NAT by ORDINAL1:def 13;
    hence thesis by A2;
  end;
  then reconsider f as AlgSequence of R() by ALGSEQ_1:def 2;
  take f;
  now
    let i be Nat;
    i in NAT by ORDINAL1:def 13;
    hence i>=A() implies f.i=0.R() by A2;
  end;
  then A() is_at_least_length_of f by ALGSEQ_1:def 3;
  hence thesis by A2,ALGSEQ_1:def 4;
end;

registration
  let L be right_zeroed (non empty addLoopStr);
  let p,q be Polynomial of L;
  cluster p+q -> finite-Support;
  coherence
  proof
    take s=len p + len q;
    let i be Nat;
    assume
A1: i >= s;
    len p + len q >= len p by NAT_1:11;
    then
A2: p.i = 0.L by A1,ALGSEQ_1:22,XXREAL_0:2;
A3: len p + len q >= len q by NAT_1:11;
    i in NAT by ORDINAL1:def 13;
    hence (p+q).i = p.i + q.i by NORMSP_1:def 5
      .= 0.L + 0.L by A1,A2,A3,ALGSEQ_1:22,XXREAL_0:2
      .= 0.L by RLVECT_1:def 7;
  end;
end;

theorem Th24:
  for L be right_zeroed (non empty addLoopStr) for p,q be
  Polynomial of L for n be Element of NAT holds (n is_at_least_length_of p & n
  is_at_least_length_of q) implies n is_at_least_length_of p+q
proof
  let L be right_zeroed (non empty addLoopStr);
  let p,q be Polynomial of L;
  let n be Element of NAT;
  assume
A1: n is_at_least_length_of p & n is_at_least_length_of q;
  let i be Nat;
  assume i>=n;
  then
A2: p.i = 0.L & q.i = 0.L by A1,ALGSEQ_1:def 3;
  i in NAT by ORDINAL1:def 13;
  hence (p+q).i = 0.L + 0.L by A2,NORMSP_1:def 5
    .= 0.L by RLVECT_1:def 7;
end;

theorem
  for L be right_zeroed (non empty addLoopStr) for p,q be Polynomial of
  L holds support (p+q) c= support p \/ support q
proof
  let L be right_zeroed (non empty addLoopStr);
  let p,q be Polynomial of L;
  let x be set;
  assume
A1: x in support (p+q);
  then reconsider x1 = x as Element of NAT;
A2: x1 < len (p+q) by A1,ALGSEQ_1:10;
  x1 < len p or x1 < len q
  proof
    assume ( not x1 < len p)& not x1 < len q;
    then x1 is_at_least_length_of p & x1 is_at_least_length_of q by Th23;
    then x1 is_at_least_length_of p+q by Th24;
    hence contradiction by A2,Th23;
  end;
  then x in Segm len p or x in Segm len q by NAT_1:45;
  hence thesis by XBOOLE_0:def 3;
end;

definition
  let L be Abelian (non empty addLoopStr);
  let p,q be sequence of L;
  redefine func p+q;
  commutativity
  proof
    let p,q be sequence of L;
    now
      let n be Element of NAT;
      thus (p+q).n = p.n + q.n by NORMSP_1:def 5
        .= (q+p).n by NORMSP_1:def 5;
    end;
    hence p+q = q+p by FUNCT_2:113;
  end;
end;

theorem Th26:
  for L be add-associative (non empty addLoopStr) for p,q,r be
  sequence of L holds p+q+r = p+(q+r)
proof
  let L be add-associative (non empty addLoopStr);
  let p,q,r be sequence of L;
  now
    let n be Element of NAT;
    thus (p+q+r).n = (p+q).n + r.n by NORMSP_1:def 5
      .= p.n + q.n + r.n by NORMSP_1:def 5
      .= p.n + (q.n + r.n) by RLVECT_1:def 6
      .= p.n + (q+r).n by NORMSP_1:def 5
      .= (p+(q+r)).n by NORMSP_1:def 5;
  end;
  hence thesis by FUNCT_2:113;
end;

registration
  let L be add-associative right_zeroed right_complementable (non empty
  addLoopStr);
  let p be Polynomial of L;
  cluster -p -> finite-Support;
  coherence
  proof
    take s=len p;
    let i be Nat;
    assume
A1: i >= s;
    i in NAT by ORDINAL1:def 13;
    hence (-p).i = -p.i by BHSP_1:51
      .= - 0.L by A1,ALGSEQ_1:22
      .= 0.L by RLVECT_1:25;
  end;
end;

Lm1: for L be non empty addLoopStr for p,q be sequence of L holds p-q = p+-q
proof
  let L be non empty addLoopStr;
  let p,q be sequence of L;
  let n be Element of NAT;
  thus (p-q).n = p.n-q.n by NORMSP_1:def 6
    .= p.n + (-q).n by BHSP_1:51
    .= (p+-q).n by NORMSP_1:def 5;
end;

definition
  let L be non empty addLoopStr;
  canceled 2;
  let p,q be sequence of L;
  redefine func p-q equals
  p+-q;
  compatibility by Lm1;
end;

registration
  let L be add-associative right_zeroed right_complementable (non empty
  addLoopStr);
  let p,q be Polynomial of L;
  cluster p-q -> finite-Support;
  coherence;
end;

theorem
  for L be non empty addLoopStr for p,q be sequence of L for n be
  Element of NAT holds (p-q).n = p.n - q.n by NORMSP_1:def 6;

definition
  let L be non empty ZeroStr;
  func 0_.(L) -> sequence of L equals
  NAT --> 0.L;
  coherence;
end;

registration
  let L be non empty ZeroStr;
  cluster 0_.(L) -> finite-Support;
  coherence
  proof
    take 0;
    let i be Nat;
    assume i >= 0;
    i in NAT by ORDINAL1:def 13;
    hence thesis by FUNCOP_1:13;
  end;
end;

canceled;

theorem Th29:
  for L be right_zeroed (non empty addLoopStr) for p be sequence
  of L holds p+0_.(L) = p
proof
  let L be right_zeroed (non empty addLoopStr);
  let p be sequence of L;
  now
    let n be Element of NAT;
    thus (p+0_.(L)).n = p.n + (0_.(L)).n by NORMSP_1:def 5
      .= p.n + 0.L by FUNCOP_1:13
      .= p.n by RLVECT_1:def 7;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th30:
  for L be add-associative right_zeroed right_complementable (non
  empty addLoopStr) for p be sequence of L holds p-p = 0_.(L)
proof
  let L be add-associative right_zeroed right_complementable (non empty
  addLoopStr);
  let p be sequence of L;
  now
    let n be Element of NAT;
    thus (p-p).n = p.n - p.n by NORMSP_1:def 6
      .= 0.L by RLVECT_1:28
      .= (0_.(L)).n by FUNCOP_1:13;
  end;
  hence thesis by FUNCT_2:113;
end;

definition
  let L be non empty multLoopStr_0;
  func 1_.(L) -> sequence of L equals
  0_.(L)+*(0,1.L);
  coherence;
end;

registration
  let L be non empty multLoopStr_0;
  cluster 1_.(L) -> finite-Support;
  coherence
  proof
    take 1;
    let i be Nat;
A1: i in NAT by ORDINAL1:def 13;
    assume i >= 1;
    hence (1_.(L)).i = (0_.(L)).i by FUNCT_7:34
      .= 0.L by A1,FUNCOP_1:13;
  end;
end;

theorem Th31:
  for L be non empty multLoopStr_0 holds (1_.(L)).0 = 1.L & for n
  be Nat st n <> 0 holds (1_.(L)).n = 0.L
proof
  let L be non empty multLoopStr_0;
  0 in NAT;
  then 0 in dom 0_.(L) by FUNCT_2:def 1;
  hence (1_.(L)).0 = 1.L by FUNCT_7:33;
  let n be Nat;
A1: n in NAT by ORDINAL1:def 13;
  assume n <> 0;
  hence (1_.(L)).n = (0_.(L)).n by FUNCT_7:34
    .= 0.L by A1,FUNCOP_1:13;
end;

definition
  let L be non empty doubleLoopStr;
  let p,q be sequence of L;
  func p*'q -> sequence of L means
  :Def11:
  for i be Element of NAT ex r be
  FinSequence of the carrier of L st len r = i+1 & it.i = Sum r & for k be
  Element of NAT st k in dom r holds r.k = p.(k-'1) * q.(i+1-'k);
  existence
  proof
    defpred P[Element of NAT,Element of L] means ex r be FinSequence of the
carrier of L st len r = $1+1 & $2 = Sum r & for k be Element of NAT st k in dom
    r holds r.k = p.(k-'1) * q.($1+1-'k);
A1: for i be Element of NAT ex v be Element of L st P[i,v]
    proof
      let i be Element of NAT;
      deffunc F(Nat) = p.($1-'1) * q.(i+1-'$1);
      consider r be FinSequence of the carrier of L such that
A2:   len r = i+1 and
A3:   for k be Nat st k in dom r holds r.k = F(k) from FINSEQ_2:sch 1;
      take v = Sum r;
      take r;
      thus len r = i+1 by A2;
      thus v = Sum r;
      let k be Element of NAT;
      assume k in dom r;
      hence thesis by A3;
    end;
    consider f be Function of NAT,the carrier of L such that
A4: for i be Element of NAT holds P[i,f.i] from FUNCT_2:sch 3(A1);
    take f;
    thus thesis by A4;
  end;
  uniqueness
  proof
    let p1,p2 be sequence of L such that
A5: for i be Element of NAT ex r be FinSequence of the carrier of L st
len r = i+1 & p1.i = Sum r & for k be Element of NAT st k in dom r holds r.k =
    p.(k-'1) * q.(i+1-'k) and
A6: for i be Element of NAT ex r be FinSequence of the carrier of L st
len r = i+1 & p2.i = Sum r & for k be Element of NAT st k in dom r holds r.k =
    p.(k-'1) * q.(i+1-'k);
    now
      let i be Element of NAT;
      consider r1 be FinSequence of the carrier of L such that
A7:   len r1 = i+1 and
A8:   p1.i = Sum r1 and
A9:   for k be Element of NAT st k in dom r1 holds r1.k = p.(k-'1) *
      q.(i+1-'k) by A5;
      consider r2 be FinSequence of the carrier of L such that
A10:  len r2 = i+1 and
A11:  p2.i = Sum r2 and
A12:  for k be Element of NAT st k in dom r2 holds r2.k = p.(k-'1) *
      q.(i+1-'k) by A6;
A13:  dom r1 = Seg len r2 by A7,A10,FINSEQ_1:def 3
        .= dom r2 by FINSEQ_1:def 3;
      now
        let k be Nat;
        assume
A14:    k in dom r1;
        hence r1.k = p.(k-'1) * q.(i+1-'k) by A9
          .= r2.k by A12,A13,A14;
      end;
      hence p1.i = p2.i by A8,A11,A13,FINSEQ_1:17;
    end;
    hence p1 = p2 by FUNCT_2:113;
  end;
end;

registration
  let L be add-associative right_zeroed right_complementable distributive (non
  empty doubleLoopStr);
  let p,q be Polynomial of L;
  cluster p*'q -> finite-Support;
  coherence
  proof
    take s = len p + len q;
    let i be Nat;
    i in NAT by ORDINAL1:def 13;
    then consider r be FinSequence of the carrier of L such that
A1: len r = i+1 and
A2: (p*'q).i = Sum r and
A3: for k be Element of NAT st k in dom r holds r.k = p.(k-'1) * q.(i+
    1-'k) by Def11;
    assume i >= s;
    then len p <= i - len q by XREAL_1:21;
    then
A4: -len p >= -(i - len q) by XREAL_1:26;
    now
      let k be Element of NAT;
      assume
A5:   k in dom r;
      then
A6:   r.k = p.(k-'1) * q.(i+1-'k) by A3;
      k <= i+1 by A1,A5,FINSEQ_3:27;
      then
A7:   i+1-k >= 0 by XREAL_1:50;
      per cases;
      suppose
        k-'1 < len p;
        then k-1 < len p by XREAL_0:def 2;
        then -(k-1) > -len p by XREAL_1:26;
        then 1-k > len q - i by A4,XXREAL_0:2;
        then i+(1-k) > len q by XREAL_1:21;
        then i+1-'k >= len q by A7,XREAL_0:def 2;
        then q.(i+1-'k) = 0.L by ALGSEQ_1:22;
        hence r.k = 0.L by A6,VECTSP_1:36;
      end;
      suppose
        k-'1 >= len p;
        then p.(k-'1) = 0.L by ALGSEQ_1:22;
        hence r.k = 0.L by A6,VECTSP_1:39;
      end;
    end;
    hence thesis by A2,Th1;
  end;
end;

theorem Th32:
  for L be Abelian add-associative right_zeroed
right_complementable right-distributive (non empty doubleLoopStr) for p,q,r be
  sequence of L holds p*'(q+r) = p*'q+p*'r
proof
  let L be Abelian add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr);
  let p,q,r be sequence of L;
  now
    let i be Element of NAT;
    consider r1 be FinSequence of the carrier of L such that
A1: len r1 = i+1 and
A2: (p*'(q+r)).i = Sum r1 and
A3: for k be Element of NAT st k in dom r1 holds r1.k = p.(k-'1) * (q+
    r).(i+1-'k) by Def11;
A4: dom r1 = Seg (i+1) by A1,FINSEQ_1:def 3;
    consider r3 be FinSequence of the carrier of L such that
A5: len r3 = i+1 and
A6: (p*'r).i = Sum r3 and
A7: for k be Element of NAT st k in dom r3 holds r3.k = p.(k-'1) * r.
    (i+1-'k) by Def11;
    consider r2 be FinSequence of the carrier of L such that
A8: len r2 = i+1 and
A9: (p*'q).i = Sum r2 and
A10: for k be Element of NAT st k in dom r2 holds r2.k = p.(k-'1) * q.(
    i+1-'k) by Def11;
    reconsider r29=r2, r39=r3 as Element of (i+1)-tuples_on (the carrier of L)
    by A8,A5,FINSEQ_2:110;
A11: len (r29 + r39) = i+1 by CARD_1:def 13;
    now
      let k be Nat;
      assume
A12:  k in dom r1;
      then
A13:  k in dom (r2 + r3) by A11,A4,FINSEQ_1:def 3;
      k in dom r3 by A5,A4,A12,FINSEQ_1:def 3;
      then
A14:  r3.k = p.(k-'1) * r.(i+1-'k) by A7;
      k in dom r2 by A8,A4,A12,FINSEQ_1:def 3;
      then
A15:  r2.k = p.(k-'1) * q.(i+1-'k) by A10;
      thus r1.k = p.(k-'1) * (q+r).(i+1-'k) by A3,A12
        .= p.(k-'1) * (q.(i+1-'k) +r.(i+1-'k)) by NORMSP_1:def 5
        .= p.(k-'1) * q.(i+1-'k) + p.(k-'1) * r.(i+1-'k) by VECTSP_1:def 11
        .= (r2 + r3).k by A13,A15,A14,FVSUM_1:21;
    end;
    then Sum r1 = Sum(r29 + r39) by A1,A11,FINSEQ_2:10
      .= Sum r2 + Sum r3 by FVSUM_1:95;
    hence (p*'(q+r)).i = (p*'q+p*'r).i by A2,A9,A6,NORMSP_1:def 5;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th33:
  for L be Abelian add-associative right_zeroed
  right_complementable left-distributive (non empty doubleLoopStr) for p,q,r be
  sequence of L holds (p+q)*'r = p*'r+q*'r
proof
  let L be Abelian add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr);
  let p,q,r be sequence of L;
  now
    let i be Element of NAT;
    consider r1 be FinSequence of the carrier of L such that
A1: len r1 = i+1 and
A2: ((p+q)*'r).i = Sum r1 and
A3: for k be Element of NAT st k in dom r1 holds r1.k = (p+q).(k-'1) *
    r.(i+1-'k) by Def11;
A4: dom r1 = Seg(i+1) by A1,FINSEQ_1:def 3;
    consider r3 be FinSequence of the carrier of L such that
A5: len r3 = i+1 and
A6: (q*'r).i = Sum r3 and
A7: for k be Element of NAT st k in dom r3 holds r3.k = q.(k-'1) * r.
    (i+1-'k) by Def11;
    consider r2 be FinSequence of the carrier of L such that
A8: len r2 = i+1 and
A9: (p*'r).i = Sum r2 and
A10: for k be Element of NAT st k in dom r2 holds r2.k = p.(k-'1) * r.(
    i+1-'k) by Def11;
    reconsider r29=r2, r39=r3 as Element of (i+1)-tuples_on (the carrier of L)
    by A8,A5,FINSEQ_2:110;
A11: len (r29 + r39) = i+1 by CARD_1:def 13;
    now
      let k be Nat;
      assume
A12:  k in dom r1;
      then
A13:  k in dom (r2 + r3) by A11,A4,FINSEQ_1:def 3;
      k in dom r3 by A5,A4,A12,FINSEQ_1:def 3;
      then
A14:  r3.k = q.(k-'1) * r.(i+1-'k) by A7;
      k in dom r2 by A8,A4,A12,FINSEQ_1:def 3;
      then
A15:  r2.k = p.(k-'1) * r.(i+1-'k) by A10;
      thus r1.k = (p+q).(k-'1) * r.(i+1-'k) by A3,A12
        .= (p.(k-'1) + q.(k-'1)) * r.(i+1-'k) by NORMSP_1:def 5
        .= p.(k-'1) * r.(i+1-'k) + q.(k-'1) * r.(i+1-'k) by VECTSP_1:def 12
        .= (r2 + r3).k by A13,A15,A14,FVSUM_1:21;
    end;
    then Sum r1 = Sum(r29 + r39) by A1,A11,FINSEQ_2:10
      .= Sum r2 + Sum r3 by FVSUM_1:95;
    hence ((p+q)*'r).i = (p*'r+q*'r).i by A2,A9,A6,NORMSP_1:def 5;
  end;
  hence thesis by FUNCT_2:113;
end;

definition let n be Element of NAT;
 redefine func <*n*> -> Element of 1-tuples_on NAT;
 coherence
  proof
   thus <*n*> is Element of 1-tuples_on NAT by FINSEQ_2:151;
  end;
end;

theorem Th34:
  for L be Abelian add-associative right_zeroed
  right_complementable well-unital associative distributive (non empty
  doubleLoopStr) for p,q,r be sequence of L holds p*'q*'r = p*'(q*'r)
proof
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative distributive (non empty doubleLoopStr);
  let p,q,r be sequence of L;
  now
    let i be Element of NAT;
    deffunc F(Nat) = (Decomp($1-'1,2)) ^^
    ($1 |-> <*i+1-'$1*> qua FinSequence of 1-tuples_on NAT);
    consider f2 be FinSequence of ((2+1)-tuples_on NAT)* such that
A1: len f2 = i+1 and
A2: for k be Nat st k in dom f2 holds f2.k = F(k) from FINSEQ_2:sch 1;
A3: dom f2 = Seg(i+1) by A1,FINSEQ_1:def 3;
    reconsider f2 as FinSequence of (3-tuples_on NAT)*;
    deffunc F(Nat) = ((i+2-'$1) |-> <*$1-'1*>) ^^ (Decomp(i+1-'$1,2));
    consider g2 be FinSequence of ((1+2)-tuples_on NAT)* such that
A4: len g2 = i+1 and
A5: for k be Nat st k in dom g2 holds g2.k = F(k) from FINSEQ_2:sch 1;
A6: dom g2 = Seg(i+1) by A4,FINSEQ_1:def 3;
    reconsider g2 as FinSequence of (3-tuples_on NAT)*;
    consider r2 be FinSequence of the carrier of L such that
A7: len r2 = i+1 and
A8: (p*'(q*'r)).i = Sum r2 and
A9: for k be Element of NAT st k in dom r2 holds r2.k = p.(k-'1) * (q
    *'r).(i+1-'k) by Def11;
A10: dom r2 = Seg(i+1) by A7,FINSEQ_1:def 3;
A11: dom Card f2 = dom f2 by CARD_3:def 2
      .= Seg len g2 by A1,A4,FINSEQ_1:def 3
      .= dom g2 by FINSEQ_1:def 3
      .= dom Card g2 by CARD_3:def 2
      .= dom Rev Card g2 by FINSEQ_5:60;
A12: now
      let j be Nat;
A13:  dom (j |-> <*i+1-'j*>) = Seg j by FUNCOP_1:19;
      assume
A14:  j in dom Card f2;
      then
A15:  j in Seg len Rev Card g2 by A11,FINSEQ_1:def 3;
      then
A16:  j >= 1 by FINSEQ_1:3;
      then j-1 >= 0 by XREAL_1:50;
      then
A17:  i+1-(j-1) <= i+1 by XREAL_1:45;
A18:  dom Card g2 = dom g2 by CARD_3:def 2;
      then
A19:  len Card g2 = len g2 by FINSEQ_3:31;
      then
A20:  j in Seg len g2 by A15,FINSEQ_5:def 3;
      then
A21:  f2.j = (Decomp(j-'1,2)) ^^ (j |-> <*i+1-'j*>) by A2,A3,A4;
      i+1 >= j by A4,A20,FINSEQ_1:3;
      then
A22:  i+1-j >= 0 by XREAL_1:50;
      then i+1-j+1 = i+1-'j+1 by XREAL_0:def 2;
      then reconsider lj = len Card g2 - j + 1 as Element of NAT by A4,A18,
FINSEQ_3:31;
      i+1-(i+1-j+1) = 0 qua Nat+(j-1);
      then
A23:  i+1-(i+1-j+1) >= 0 by A16,XREAL_1:50;
      then
A24:  i+1-'lj+1 = 0 qua Nat+(j-1)+1 by A4,A19,XREAL_0:def 2
        .= j;
      i+1-j+1 >= 0 qua Nat+1 by A22,XREAL_1:8;
      then lj in Seg (i+1) by A4,A19,A17,FINSEQ_1:3;
      then
A25:  g2.lj = ((i+2-'lj) |-> <*lj-'1*>)^^(Decomp(i+1-'lj,2)) by A5,A6;
A26:  i+1-'lj+1 = i+1-lj+1 by A4,A19,A23,XREAL_0:def 2
        .= i+(1+1)-lj;
A27:  dom ((i+2-'lj) |-> <*lj-'1*>) = Seg (i+2-'lj) by FUNCOP_1:19
        .= Seg j by A24,A26,XREAL_0:def 2;
A28:  dom Decomp(i+1-'lj,2) = Seg len Decomp(i+1-'lj,2) by FINSEQ_1:def 3
        .= Seg j by A24,Th9;
      Seg len (g2.lj) = dom (g2.lj) by FINSEQ_1:def 3
        .= (Seg j) /\ (Seg j) by A25,A28,A27,PRE_POLY:def 4
        .= Seg j;
      then
A29:  len (g2.lj) = j by FINSEQ_1:8;
A30:  dom Decomp(j-'1,2) = Seg len Decomp(j-'1,2) by FINSEQ_1:def 3
        .= Seg (j-'1+1) by Th9
        .= Seg j by A16,XREAL_1:237;
      Seg len (f2.j) = dom (f2.j) by FINSEQ_1:def 3
        .= (Seg j) /\ (Seg j) by A21,A30,A13,PRE_POLY:def 4
        .= Seg j;
      then
A31:  len (f2.j) = j by FINSEQ_1:8;
      len Card g2 - j + 1 in Seg len g2 by A19,A20,FINSEQ_5:2;
      then
A32:  len Card g2 - j + 1 in dom g2 by FINSEQ_1:def 3;
      j in dom f2 by A14,CARD_3:def 2;
      hence (Card f2).j = j by A31,CARD_3:def 2
        .= (Card g2).(len Card g2 - j + 1) by A32,A29,CARD_3:def 2
        .= (Rev Card g2).j by A11,A14,FINSEQ_5:def 3;
    end;
    len Card f2 = len Rev Card g2 by A11,FINSEQ_3:31;
    then
A33: Card f2 = Rev Card g2 by A12,FINSEQ_2:10;
    reconsider w = Card g2 as FinSequence of NAT;
A34: Seg len FlattenSeq f2 = dom FlattenSeq f2 by FINSEQ_1:def 3;
    now
      let y be set;
      thus y in rng FlattenSeq f2 implies y in rng FlattenSeq g2
      proof
        assume y in rng FlattenSeq f2;
        then consider x be Nat such that
A35:    x in dom FlattenSeq f2 and
A36:    (FlattenSeq f2).x = y by FINSEQ_2:11;
        consider i1,j1 be Element of NAT such that
A37:    i1 in dom f2 and
A38:    j1 in dom (f2.i1) and
        x = (Sum Card (f2|(i1-'1))) + j1 and
A39:    (f2.i1).j1 = (FlattenSeq f2).x by A35,PRE_POLY:29;
A40:    f2.i1 = (Decomp(i1-'1,2)) ^^ (i1 |-> <*i+1-'i1*>) by A2,A37;
        then j1 in dom (Decomp(i1-'1,2)) /\ dom (i1 |-> <*i+1-'i1*>) by A38,
PRE_POLY:def 4;
        then j1 in dom (i1 |-> <*i+1-'i1*>) by XBOOLE_0:def 4;
        then
A41:    j1 in Seg i1 by FUNCOP_1:19;
        then
A42:    j1 <= i1 by FINSEQ_1:3;
        then
A43:    i1-j1 >= 0 by XREAL_1:50;
        set j2 = i1-'j1+1;
        set i2 = j1;
A44:    dom ((i+2-'i2) |-> <*i2-'1*>) = Seg (i+2-'i2) by FUNCOP_1:19;
A45:    i1 in Seg (i+1) by A1,A37,FINSEQ_1:def 3;
        then
A46:    1 <= i1 by FINSEQ_1:3;
        then
A47:    j1 in Seg (i1-'1+1) by A41,XREAL_1:237;
A48:    i1 <= i+1 by A45,FINSEQ_1:3;
        then
A49:    i+1-i1 >= 0 by XREAL_1:50;
A50:    i+1 >= j1 by A48,A42,XXREAL_0:2;
        then
A51:    i+1-j1 >=0 by XREAL_1:50;
        then
A52:    i+1-'i2+1 = i+1-i2+1 by XREAL_0:def 2
          .= i+(1+1)-i2;
        i+1-'j1 >= i1-'j1 by A48,NAT_D:42;
        then i+1-'j1+1 >= i1-'j1+1 by XREAL_1:8;
        then i+1-'j1+1-(i1-'j1+1) >= 0 by XREAL_1:50;
        then
A53:    i+1-'j1+1-'(i1-'j1+1)=i+1-'j1+1-(i1-'j1+1) by XREAL_0:def 2
          .= i+1-'j1+1-(i1-j1+1) by A43,XREAL_0:def 2
          .= i+1-j1+1-(1-j1+i1) by A51,XREAL_0:def 2
          .= i+1-'i1 by A49,XREAL_0:def 2;
        1 <= j1 by A41,FINSEQ_1:3;
        then
A54:    i2 in Seg (i+1) by A50,FINSEQ_1:3;
        then
A55:    g2.i2 = ((i+2-'i2) |-> <*i2-'1*>)^^(Decomp(i+1-'i2,2)) by A5,A6;
        i1-'j1 <= i+1-'i2 by A48,NAT_D:42;
        then 1 <= i1-'j1+1 & i1-'j1+1 <= i+1-'i2+1 by NAT_1:11,XREAL_1:8;
        then
A56:    j2 in Seg (i+1-'i2+1) by FINSEQ_1:3;
        then
A57:    j2 in Seg (i+2-'i2) by A52,XREAL_0:def 2;
        dom Decomp(i+1-'i2,2) = Seg len Decomp(i+1-'i2,2) by FINSEQ_1:def 3
          .= Seg (i+1-'i2+1) by Th9
          .= Seg (i+2-'i2) by A52,XREAL_0:def 2;
        then dom (g2.i2) = (Seg (i+2-'i2)) /\ (Seg (i+2-'i2)) by A55,A44,
PRE_POLY:def 4;
        then
A58:    j2 in dom (g2.i2) by A56,A52,XREAL_0:def 2;
        then
A59:    (g2.i2).j2=(((i+2-'i2) |-> <*i2-'1*>).j2)^((Decomp(i+1-'i2,2)).
        j2) by A55,PRE_POLY:def 4
          .= <*i2-'1*> ^ ((Decomp(i+1-'i2,2)).j2) by A57,FUNCOP_1:13
          .= <*i2-'1*> ^ <*j2-'1,i+1-'i2+1-'j2*> by A56,Th14
          .= <*j1-'1,i1-'j1+1-'1,i+1-'j1+1-'(i1-'j1+1)*> by FINSEQ_1:60
          .= <*j1-'1,i1-'j1,i+1-'i1*> by A53,NAT_D:34;
        i2 in dom g2 by A4,A54,FINSEQ_1:def 3;
        then
A60:    (Sum Card (g2|(i2-'1))) + j2 in dom FlattenSeq g2 & (g2.i2).j2 =
        (FlattenSeq g2).((Sum Card (g2|(i2-'1))) + j2) by A58,PRE_POLY:30;
        y = ((Decomp(i1-'1,2)).j1) ^ ((i1 |-> <*i+1-'i1*>).j1) by A36,A38,A39
,A40,PRE_POLY:def 4
          .= ((Decomp(i1-'1,2)).j1) ^ <*i+1-'i1*> by A41,FUNCOP_1:13
          .= <*j1-'1,i1-'1+1-'j1*> ^ <*i+1-'i1*> by A47,Th14
          .= <*j1-'1,i1-'j1*> ^ <*i+1-'i1*> by A46,XREAL_1:237
          .= <*j1-'1,i1-'j1,i+1-'i1*> by FINSEQ_1:60;
        hence thesis by A59,A60,FUNCT_1:def 5;
      end;
      assume y in rng FlattenSeq g2;
      then consider x be Nat such that
A61:  x in dom FlattenSeq g2 and
A62:  (FlattenSeq g2).x = y by FINSEQ_2:11;
      consider i1,j1 be Element of NAT such that
A63:  i1 in dom g2 and
A64:  j1 in dom (g2.i1) and
      x = (Sum Card (g2|(i1-'1))) + j1 and
A65:  (g2.i1).j1 = (FlattenSeq g2).x by A61,PRE_POLY:29;
A66:  g2.i1 = ((i+2-'i1) |-> <*i1-'1*>)^^(Decomp(i+1-'i1,2)) by A5,A63;
      then j1 in dom ((i+2-'i1) |-> <*i1-'1*>) /\ dom (Decomp(i+1-'i1,2)) by
A64,PRE_POLY:def 4;
      then j1 in dom ((i+2-'i1) |-> <*i1-'1*>) by XBOOLE_0:def 4;
      then
A67:  j1 in Seg (i+2-'i1) by FUNCOP_1:19;
      then j1 >= 1 by FINSEQ_1:3;
      then
A68:  j1-1 >= 0 by XREAL_1:50;
A69:  i1 in Seg (i+1) by A4,A63,FINSEQ_1:def 3;
      then i1 <= i+1 by FINSEQ_1:3;
      then
A70:  i+1-i1 >= 0 by XREAL_1:50;
      then i+1-'i1+1 = i+1-i1+1 by XREAL_0:def 2
        .= i+(1+1)-i1;
      then
A71:  j1 in Seg (i+1-'i1+1) by A67,XREAL_0:def 2;
      then
A72:  j1 <= i+1-'i1+1 by FINSEQ_1:3;
      then
A73:  i+1-'i1+1-j1 >= 0 by XREAL_1:50;
      j1 <= i+1-i1+1 by A70,A72,XREAL_0:def 2;
      then j1-1 <= i+1-i1 by XREAL_1:22;
      then
A74:  j1-1+i1 <= i+1 by XREAL_1:21;
      then
A75:  j1-'1+i1 <= i+1 by A68,XREAL_0:def 2;
      i+1-(j1-1+i1) >= 0 by A74,XREAL_1:50;
      then i+1-(j1-'1+i1) >= 0 by A68,XREAL_0:def 2;
      then
A76:  i+1-'(j1-'1+i1) = i+1-(j1-'1+i1) by XREAL_0:def 2
        .= i+1-(j1-1+i1) by A68,XREAL_0:def 2
        .= i+1-i1+1-j1
        .= i+1-'i1+1-j1 by A70,XREAL_0:def 2
        .= i+1-'i1+1-'j1 by A73,XREAL_0:def 2;
A77:  y = (((i+2-'i1) |-> <*i1-'1*>).j1) ^ (Decomp(i+1-'i1,2).j1) by A62,A64
,A65,A66,PRE_POLY:def 4
        .= <*i1-'1*> ^ (Decomp(i+1-'i1,2).j1) by A67,FUNCOP_1:13
        .= <*i1-'1*> ^ <*j1-'1,i+1-'i1+1-'j1*> by A71,Th14
        .= <*i1-'1,j1-'1,i+1-'i1+1-'j1*> by FINSEQ_1:60;
      set j2 = i1;
      set i2 = j1-'1+i1;
A78:  j1-'1+i1 >= i1 by NAT_1:11;
A79:  dom (i2 |-> <*i+1-'i2*>) = Seg i2 by FUNCOP_1:19;
A80:  1 <= i1 by A69,FINSEQ_1:3;
      then
A81:  j2 in Seg i2 by A78,FINSEQ_1:3;
      then
A82:  j2 in Seg (i2-'1+1) by A80,A78,XREAL_1:237,XXREAL_0:2;
      j1-'1+i1 >= 1 by A80,A78,XXREAL_0:2;
      then
A83:  i2 in Seg (i+1) by A75,FINSEQ_1:3;
      then
A84:  f2.i2 = (Decomp(i2-'1,2)) ^^ (i2 |-> <*i+1-'i2*>) by A2,A3;
      dom Decomp(i2-'1,2) = Seg len Decomp(i2-'1,2) by FINSEQ_1:def 3
        .= Seg (i2-'1+1) by Th9
        .= Seg i2 by A80,A78,XREAL_1:237,XXREAL_0:2;
      then dom (f2.i2) = (Seg i2) /\ (Seg i2) by A84,A79,PRE_POLY:def 4;
      then
A85:  j2 in dom (f2.i2) by A80,A78,FINSEQ_1:3;
      i2 in dom f2 by A1,A83,FINSEQ_1:def 3;
      then
A86:  (Sum Card (f2|(i2-'1))) + j2 in dom FlattenSeq f2 & (f2.i2).j2 = (
      FlattenSeq f2).((Sum Card (f2|(i2-'1))) + j2) by A85,PRE_POLY:30;
      (f2.i2).j2 = (Decomp(i2-'1,2).j2) ^ ((i2 |-> <*i+1-'i2*>).j2) by A84,A85,
PRE_POLY:def 4
        .= (Decomp(i2-'1,2).j2) ^ <*i+1-'i2*> by A81,FUNCOP_1:13
        .= <*j2-'1,i2-'1+1-'j2*> ^ <*i+1-'i2*> by A82,Th14
        .= <*j2-'1,i2-'1+1-'j2,i+1-'i2*> by FINSEQ_1:60
        .= <*i1-'1,j1-'1+i1-'i1,i+1-'(j1-'1+i1)*> by A80,A78,XREAL_1:237
,XXREAL_0:2
        .= <*i1-'1,j1-'1,i+1-'i1+1-'j1*> by A76,NAT_D:34;
      hence y in rng FlattenSeq f2 by A77,A86,FUNCT_1:def 5;
    end;
    then
A87: rng FlattenSeq f2 = rng FlattenSeq g2 by TARSKI:2;
    now
A88:  i+1+1 >= i+1 by NAT_1:11;
      let x,y be set;
      assume that
A89:  x in dom FlattenSeq g2 and
A90:  y in dom FlattenSeq g2 and
A91:  (FlattenSeq g2).x = (FlattenSeq g2).y;
      consider i1,j1 be Element of NAT such that
A92:  i1 in dom g2 and
A93:  j1 in dom (g2.i1) and
A94:  x = (Sum Card (g2|(i1-'1))) + j1 and
A95:  (g2.i1).j1 = (FlattenSeq g2).x by A89,PRE_POLY:29;
A96:  g2.i1 = ((i+2-'i1) |-> <*i1-'1*>)^^(Decomp(i+1-'i1,2)) by A5,A92;
      i1 in Seg (i+1) by A4,A92,FINSEQ_1:def 3;
      then
A97:  i1 <= i+1 by FINSEQ_1:3;
      then i+1+1 >= i1 by A88,XXREAL_0:2;
      then
A98:  i+2-i1 >= 0 by XREAL_1:50;
      i+1-i1 >= 0 by A97,XREAL_1:50;
      then
A99:  i+1-'i1+1 = i+1-i1+1 by XREAL_0:def 2
        .= i+2-'i1 by A98,XREAL_0:def 2;
A100: dom ((i+2-'i1) |-> <*i1-'1*>) = Seg (i+2-'i1) by FUNCOP_1:19;
      dom Decomp(i+1-'i1,2) = Seg len Decomp(i+1-'i1,2) by FINSEQ_1:def 3
        .= Seg (i+2-'i1) by A99,Th9;
      then
A101: dom
 (g2.i1) = (Seg (i+2-'i1)) /\ (Seg (i+2-'i1)) by A96,A100,PRE_POLY:def 4
        .= Seg (i+2-'i1);
      j1 in Seg len(g2.i1) by A93,FINSEQ_1:def 3;
      then
A102: j1 >= 1 by FINSEQ_1:3;
      consider i2,j2 be Element of NAT such that
A103: i2 in dom g2 and
A104: j2 in dom (g2.i2) and
A105: y = (Sum Card (g2|(i2-'1))) + j2 and
A106: (g2.i2).j2 = (FlattenSeq g2).y by A90,PRE_POLY:29;
A107: g2.i2 = ((i+2-'i2) |-> <*i2-'1*>)^^(Decomp(i+1-'i2,2)) by A5,A103;
      i2 in Seg (i+1) by A4,A103,FINSEQ_1:def 3;
      then
A108: i2 <= i+1 by FINSEQ_1:3;
      then i+1+1 >= i2 by A88,XXREAL_0:2;
      then
A109: i+2-i2 >= 0 by XREAL_1:50;
      i+1-i2 >= 0 by A108,XREAL_1:50;
      then
A110: i+1-'i2+1 = i+1-i2+1 by XREAL_0:def 2
        .= i+2-'i2 by A109,XREAL_0:def 2;
A111: dom ((i+2-'i2) |-> <*i2-'1*>) = Seg (i+2-'i2) by FUNCOP_1:19;
      dom Decomp(i+1-'i2,2) = Seg len Decomp(i+1-'i2,2) by FINSEQ_1:def 3
        .= Seg (i+2-'i2) by A110,Th9;
      then
A112: dom
 (g2.i2) = (Seg (i+2-'i2)) /\ (Seg (i+2-'i2)) by A107,A111,PRE_POLY:def 4
        .= Seg (i+2-'i2);
A113: (g2.i2).j2=(((i+2-'i2) |-> <*i2-'1*>).j2)^((Decomp(i+1-'i2,2)).j2)
      by A104,A107,PRE_POLY:def 4
        .= <*i2-'1*> ^ ((Decomp(i+1-'i2,2)).j2) by A104,A112,FUNCOP_1:13
        .= <*i2-'1*> ^ <*j2-'1,i+1-'i2+1-'j2*> by A104,A110,A112,Th14
        .= <*i2-'1,j2-'1,i+1-'i2+1-'j2*> by FINSEQ_1:60;
      j2 in Seg len(g2.i2) by A104,FINSEQ_1:def 3;
      then
A114: j2 >= 1 by FINSEQ_1:3;
      (g2.i1).j1=(((i+2-'i1) |-> <*i1-'1*>).j1)^((Decomp(i+1-'i1,2)).j1)
      by A93,A96,PRE_POLY:def 4
        .= <*i1-'1*> ^ ((Decomp(i+1-'i1,2)).j1) by A93,A101,FUNCOP_1:13
        .= <*i1-'1*> ^ <*j1-'1,i+1-'i1+1-'j1*> by A93,A99,A101,Th14
        .= <*i1-'1,j1-'1,i+1-'i1+1-'j1*> by FINSEQ_1:60;
      then i1-'1 = i2-'1 & j1-'1 = j2-'1 by A91,A95,A106,A113,FINSEQ_1:99;
      hence x = y by A94,A105,A102,A114,XREAL_1:236;
    end;
    then
A115: FlattenSeq g2 is one-to-one by FUNCT_1:def 8;
    len FlattenSeq f2 = Sum Card f2 by PRE_POLY:27
      .= Sum w by A33,Th3
      .= len FlattenSeq g2 by PRE_POLY:27;
    then FlattenSeq f2 is one-to-one by A87,A115,FINSEQ_4:76;
    then FlattenSeq f2,FlattenSeq g2 are_fiberwise_equipotent by A87,A115,
RFINSEQ:39;
    then consider P be Permutation of dom (FlattenSeq g2) such that
A116: FlattenSeq f2 = (FlattenSeq g2)*P by RFINSEQ:17;
A117: dom Card g2 = dom g2 by CARD_3:def 2;
    then
A118: len Card g2 = len g2 by FINSEQ_3:31;
    consider r1 be FinSequence of the carrier of L such that
A119: len r1 = i+1 and
A120: (p*'q*'r).i = Sum r1 and
A121: for k be Element of NAT st k in dom r1 holds r1.k = (p*'q).(k-'1)
    * r.(i+1-'k) by Def11;
A122: dom r1 = Seg(i+1) by A119,FINSEQ_1:def 3;
    deffunc F(Nat) = prodTuples(p,q,r,f2/.$1);
    consider f1 be FinSequence of (the carrier of L)* such that
A123: len f1 = len f2 and
A124: for k be Nat st k in dom f1 holds f1.k = F(k) from FINSEQ_2:sch 1;
A125: dom f1 = Seg len f2 by A123,FINSEQ_1:def 3;
A126: now
      let j be Nat;
A127: dom (j |-> <*i+1-'j*>) = Seg j by FUNCOP_1:19;
      consider r3 be FinSequence of the carrier of L such that
A128: len r3 = j-'1+1 and
A129: (p*'q).(j-'1) = Sum r3 and
A130: for k be Element of NAT st k in dom r3 holds r3.k = p.(k-'1) *
      q.(j-'1+1-'k) by Def11;
      assume
A131: j in dom r1;
      then
A132: 1 <= j by A122,FINSEQ_1:3;
      then
A133: len r3 = j by A128,XREAL_1:237;
      len Decomp(j-'1,2) = j-'1+1 by Th9
        .= j by A132,XREAL_1:237;
      then
A134: dom Decomp(j-'1,2) = Seg j by FINSEQ_1:def 3;
A135: dom r1 = dom f1 by A119,A1,A123,FINSEQ_3:31;
      then
A136: f1/.j = f1.j by A131,PARTFUN1:def 8
        .= prodTuples(p,q,r,f2/.j) by A1,A124,A125,A122,A131;
      dom f1 = dom f2 by A123,FINSEQ_3:31;
      then
A137: f2/.j = f2.j by A131,A135,PARTFUN1:def 8
        .= (Decomp(j-'1,2)) ^^ (j |-> <*i+1-'j*>) by A2,A3,A122,A131;
      then
A138: dom (f2/.j) = (dom (Decomp(j-'1,2))) /\ dom (j |-> <*i+1-'j*>) by
PRE_POLY:def 4
        .= Seg j by A134,A127;
A139: len prodTuples(p,q,r,f2/.j) = len (f2/.j) by Def5
        .= j by A131,A138,FINSEQ_1:def 3;
      then
A140: dom prodTuples(p,q,r,f2/.j) = Seg j by FINSEQ_1:def 3;
A141: dom (r3 * (r.(i+1-'j))) = dom r3 by POLYNOM1:def 3;
A142: now
        let k be Nat;
        assume
A143:   k in dom prodTuples(p,q,r,f2/.j);
        then
A144:   (f2/.j)/.k = (f2/.j).k by A138,A140,PARTFUN1:def 8
          .= (Decomp(j-'1,2)).k ^ (j |-> <*i+1-'j*>).k by A137,A138,A140,A143,
PRE_POLY:def 4
          .= <*k-'1,j-'1+1-'k*> ^ (j |-> <*i+1-'j*>).k by A128,A133,A140,A143
,Th14
          .= <*k-'1,j-'1+1-'k*> ^ <*i+1-'j*> by A140,A143,FUNCOP_1:13
          .= <*k-'1,j-'1+1-'k,i+1-'j*> by FINSEQ_1:60;
        1 in Seg 3 by ENUMSET1:def 1,FINSEQ_3:1;
        then 1 in Seg len ((f2/.j)/.k) by A144,FINSEQ_1:62;
        then 1 in dom ((f2/.j)/.k) by FINSEQ_1:def 3;
        then
A145:   ((f2/.j)/.k)/.1 = ((f2/.j)/.k).1 by PARTFUN1:def 8
          .= k-'1 by A144,FINSEQ_1:62;
A146:   k in dom r3 by A133,A140,A143,FINSEQ_1:def 3;
        then
A147:   r3/.k = r3.k by PARTFUN1:def 8
          .= p.(k-'1) * q.(j-'1+1-'k) by A130,A146;
        3 in Seg 3 by ENUMSET1:def 1,FINSEQ_3:1;
        then 3 in Seg len ((f2/.j)/.k) by A144,FINSEQ_1:62;
        then 3 in dom ((f2/.j)/.k) by FINSEQ_1:def 3;
        then
A148:   ((f2/.j)/.k)/.3 = ((f2/.j)/.k).3 by PARTFUN1:def 8
          .= i+1-'j by A144,FINSEQ_1:62;
        2 in Seg 3 by ENUMSET1:def 1,FINSEQ_3:1;
        then 2 in Seg len ((f2/.j)/.k) by A144,FINSEQ_1:62;
        then 2 in dom ((f2/.j)/.k) by FINSEQ_1:def 3;
        then
A149:   ((f2/.j)/.k)/.2 = ((f2/.j)/.k).2 by PARTFUN1:def 8
          .= j-'1+1-'k by A144,FINSEQ_1:62;
        thus prodTuples(p,q,r,f2/.j).k = (p.(((f2/.j)/.k)/.1))* (q.(((f2/.j)/.
        k)/.2))*(r.(((f2/.j)/.k)/.3)) by A138,A140,A143,Def5
          .= (r3*(r.(i+1-'j)))/.k by A146,A147,A145,A149,A148,POLYNOM1:def 3
          .= (r3 * (r.(i+1-'j))).k by A141,A146,PARTFUN1:def 8;
      end;
      len f1 = len (Sum f1) by MATRLIN:def 8;
      then
A150: dom f1 = dom (Sum f1) by FINSEQ_3:31;
      len (r3 * (r.(i+1-'j))) = len r3 by A141,FINSEQ_3:31;
      then
A151: prodTuples(p,q,r,f2/.j) = r3 * (r.(i+1-'j)) by A139,A133,A142,FINSEQ_2:10
;
      (p*'q).(j-'1) * r.(i+1-'j) = Sum (r3 * (r.(i+1-'j))) by A129,POLYNOM1:29;
      hence r1.j = Sum (r3 * (r.(i+1-'j))) by A121,A131
        .= (Sum f1)/.j by A131,A150,A135,A136,A151,MATRLIN:def 8
        .= (Sum f1).j by A131,A150,A135,PARTFUN1:def 8;
    end;
    deffunc F(Nat) = prodTuples(p,q,r,g2/.$1);
    consider g1 be FinSequence of (the carrier of L)* such that
A152: len g1 = len g2 and
A153: for k be Nat st k in dom g1 holds g1.k = F(k) from FINSEQ_2:sch 1;
A154: dom g1 = Seg len g2 by A152,FINSEQ_1:def 3;
A155: now
      let j be Nat;
A156: dom ((i+2-'j) |-> <*j-'1*>) = Seg (i+2-'j) by FUNCOP_1:19;
      consider r3 be FinSequence of the carrier of L such that
A157: len r3 = i+1-'j+1 and
A158: (q*'r).(i+1-'j) = Sum r3 and
A159: for k be Element of NAT st k in dom r3 holds r3.k = q.(k-'1) *
      r.(i+1-'j+1-'k) by Def11;
      assume
A160: j in dom r2;
      then
A161: j <= i+1 by A10,FINSEQ_1:3;
      i+1+1 >= i+1 by NAT_1:11;
      then i+1+1 >= j by A161,XXREAL_0:2;
      then
A162: i+2-j >= 0 by XREAL_1:50;
      i+1-j >= 0 by A161,XREAL_1:50;
      then
A163: i+1-'j+1 =i+1-j+1 by XREAL_0:def 2
        .= i+2-'j by A162,XREAL_0:def 2;
      then len Decomp(i+1-'j,2) = i+2-'j by Th9;
      then
A164: dom Decomp(i+1-'j,2) = Seg (i+2-'j) by FINSEQ_1:def 3;
A165: dom r2 = dom g1 by A7,A4,A152,FINSEQ_3:31;
      then
A166: g1/.j = g1.j by A160,PARTFUN1:def 8
        .= prodTuples(p,q,r,g2/.j) by A4,A153,A154,A10,A160;
      dom g1 = dom g2 by A152,FINSEQ_3:31;
      then
A167: g2/.j = g2.j by A160,A165,PARTFUN1:def 8
        .= ((i+2-'j) |-> <*j-'1*>) ^^ (Decomp(i+1-'j,2)) by A5,A6,A10,A160;
      then
A168: dom (g2/.j) = dom ((i+2-'j) |-> <*j-'1*>) /\ dom (Decomp(i+1-'j,2))
      by PRE_POLY:def 4
        .= Seg (i+2-'j) by A164,A156;
A169: len prodTuples(p,q,r,g2/.j) = len (g2/.j) by Def5
        .= i+2-'j by A168,FINSEQ_1:def 3;
      then
A170: dom prodTuples(p,q,r,g2/.j) = Seg (i+2-'j) by FINSEQ_1:def 3;
A171: dom ((p.(j-'1)) * r3) = dom r3 by POLYNOM1:def 2;
A172: now
        let k be Nat;
        assume
A173:   k in dom prodTuples(p,q,r,g2/.j);
        then
A174:   (g2/.j)/.k = (g2/.j).k by A168,A170,PARTFUN1:def 8
          .= ((i+2-'j) |-> <*j-'1*>).k ^ (Decomp(i+1-'j,2)).k by A167,A168,A170
,A173,PRE_POLY:def 4
          .= ((i+2-'j) |-> <*j-'1*>).k^<*k-'1,i+1-'j+1-'k*> by A163,A170,A173
,Th14
          .= <*j-'1*> ^ <*k-'1,i+1-'j+1-'k*> by A170,A173,FUNCOP_1:13
          .= <*j-'1,k-'1,i+1-'j+1-'k*> by FINSEQ_1:60;
        1 in Seg 3 by ENUMSET1:def 1,FINSEQ_3:1;
        then 1 in Seg len ((g2/.j)/.k) by A174,FINSEQ_1:62;
        then 1 in dom ((g2/.j)/.k) by FINSEQ_1:def 3;
        then
A175:   ((g2/.j)/.k)/.1 = ((g2/.j)/.k).1 by PARTFUN1:def 8
          .= j-'1 by A174,FINSEQ_1:62;
A176:   k in dom r3 by A157,A163,A170,A173,FINSEQ_1:def 3;
        then
A177:   r3/.k = r3.k by PARTFUN1:def 8
          .= q.(k-'1) * r.(i+1-'j+1-'k) by A159,A176;
        3 in Seg 3 by ENUMSET1:def 1,FINSEQ_3:1;
        then 3 in Seg len ( (g2/.j)/.k) by A174,FINSEQ_1:62;
        then 3 in dom ((g2/.j)/.k) by FINSEQ_1:def 3;
        then
A178:   ((g2/.j)/.k)/.3 = ((g2/.j)/.k).3 by PARTFUN1:def 8
          .= i+1-'j+1-'k by A174,FINSEQ_1:62;
        2 in Seg 3 by ENUMSET1:def 1,FINSEQ_3:1;
        then 2 in Seg len ((g2/.j)/.k) by A174,FINSEQ_1:62;
        then 2 in dom ((g2/.j)/.k) by FINSEQ_1:def 3;
        then
A179:   ((g2/.j)/.k)/.2 = ((g2/.j)/.k).2 by PARTFUN1:def 8
          .= k-'1 by A174,FINSEQ_1:62;
        thus prodTuples(p,q,r,g2/.j).k = (p.(((g2/.j)/.k)/.1))* (q.(((g2/.j)/.
        k)/.2))*(r.(((g2/.j)/.k)/.3)) by A168,A170,A173,Def5
          .= (p.(((g2/.j)/.k)/.1))*((q.(((g2/.j)/.k)/.2))* (r.(((g2/.j)/.k)
        /.3))) by GROUP_1:def 4
          .= ((p.(j-'1)) * r3)/.k by A176,A177,A175,A179,A178,POLYNOM1:def 2
          .= ((p.(j-'1)) * r3).k by A171,A176,PARTFUN1:def 8;
      end;
      len g1 = len (Sum g1) by MATRLIN:def 8;
      then
A180: dom g1 = dom (Sum g1) by FINSEQ_3:31;
      len ((p.(j-'1)) * r3) = len r3 by A171,FINSEQ_3:31;
      then
A181: prodTuples(p,q,r,g2/.j) = (p.(j-'1)) * r3 by A157,A163,A169,A172,
FINSEQ_2:10;
      p.(j-'1) * (q*'r).(i+1-'j) = Sum (p.(j-'1) * r3) by A158,POLYNOM1:28;
      hence r2.j = Sum (p.(j-'1) * r3) by A9,A160
        .= (Sum g1)/.j by A160,A180,A165,A166,A181,MATRLIN:def 8
        .= (Sum g1).j by A160,A180,A165,PARTFUN1:def 8;
    end;
A182: dom Card g2 = Seg(i+1) by A4,A117,FINSEQ_1:def 3;
A183: now
      let j be Nat;
      assume
A184: j in dom Card g2;
      then
A185: j in dom g1 by A4,A152,A182,FINSEQ_1:def 3;
      g1.j = prodTuples(p,q,r,g2/.j) by A4,A153,A154,A182,A184;
      then
A186: len (g1.j) = len (g2/.j) by Def5
        .= len (g2.j) by A117,A184,PARTFUN1:def 8;
      thus (Card g2).j = len (g2.j) by A117,A184,CARD_3:def 2
        .= (Card g1).j by A185,A186,CARD_3:def 2;
    end;
A187: dom Card g1 = dom g1 by CARD_3:def 2;
    then len Card g1 = len g1 by FINSEQ_3:31;
    then
A188: Card g2 = Card g1 by A152,A118,A183,FINSEQ_2:10;
    then
A189: len (FlattenSeq g2) = len (FlattenSeq g1) by PRE_POLY:28;
    then
A190: dom (FlattenSeq g2) = dom (FlattenSeq g1) by FINSEQ_3:31;
    then reconsider P as Permutation of dom (FlattenSeq g1);
A191: dom FlattenSeq g1 = Seg len FlattenSeq g1 by FINSEQ_1:def 3;
A192: now
      let j be Nat;
      assume
A193: j in dom FlattenSeq g1;
      then consider i1,j1 be Element of NAT such that
A194: i1 in dom g1 and
A195: j1 in dom (g1.i1) and
A196: j = (Sum Card (g1|(i1-'1))) + j1 and
A197: (g1.i1).j1 = (FlattenSeq g1).j by PRE_POLY:29;
A198: j in dom FlattenSeq g2 by A189,A191,A193,FINSEQ_1:def 3;
      then consider i2,j2 be Element of NAT such that
A199: i2 in dom g2 & j2 in dom (g2.i2) and
A200: j = (Sum Card (g2|(i2-'1))) + j2 and
A201: (g2.i2).j2 = (FlattenSeq g2).j by PRE_POLY:29;
      (Sum ((Card g1)|(i1-'1))) + j1 = (Sum Card (g1|(i1-'1))) + j1 by Th16
        .= (Sum ((Card g2)|(i2-'1))) + j2 by A196,A200,Th16;
      then
A202: i1 = i2 & j1 = j2 by A188,A194,A195,A199,Th22;
      i1 in Seg len g2 by A152,A194,FINSEQ_1:def 3;
      then
A203: i1 in dom g2 by FINSEQ_1:def 3;
A204: g1.i1 = prodTuples(p,q,r,g2/.i1) by A153,A194;
      then len (g1.i1) = len (g2/.i1) by Def5
        .= len (g2.i1) by A187,A117,A188,A194,PARTFUN1:def 8;
      then j1 in Seg len (g2.i1) by A195,FINSEQ_1:def 3;
      then
A205: j1 in Seg len (g2/.i1) by A203,PARTFUN1:def 8;
      then j1 in dom (g2/.i1) by FINSEQ_1:def 3;
      then
A206: ((g2/.i1)/.j1) = (g2/.i1).j1 by PARTFUN1:def 8
        .= (g2.i1).j1 by A203,PARTFUN1:def 8
        .= (FlattenSeq g2)/.j by A198,A201,A202,PARTFUN1:def 8;
      Seg len (g2/.i1) = dom (g2/.i1) by FINSEQ_1:def 3;
      hence
      (FlattenSeq g1).j = (p.(((g2/.i1)/.j1)/.1))* (q.(((g2/.i1)/.j1)/.2)
      )*(r.(( (g2/.i1)/.j1)/.3)) by A197,A204,A205,Def5
        .= (prodTuples(p,q,r,FlattenSeq g2)).j by A190,A193,A206,Def5;
    end;
A207: dom Card f2 = dom f2 by CARD_3:def 2;
    then
A208: len Card f2 = len f2 by FINSEQ_3:31;
A209: dom Card f2 = Seg(i+1) by A1,A207,FINSEQ_1:def 3;
A210: now
      let j be Nat;
      assume
A211: j in dom Card f2;
      then
A212: j in dom f1 by A1,A123,A209,FINSEQ_1:def 3;
      f1.j = prodTuples(p,q,r,f2/.j) by A1,A124,A125,A209,A211;
      then
A213: len (f1.j) = len (f2/.j) by Def5
        .= len (f2.j) by A207,A211,PARTFUN1:def 8;
      thus (Card f2).j = len (f2.j) by A207,A211,CARD_3:def 2
        .= (Card f1).j by A212,A213,CARD_3:def 2;
    end;
A214: dom Card f1 = dom f1 by CARD_3:def 2;
    then len Card f1 = len f1 by FINSEQ_3:31;
    then
A215: Card f2 = Card f1 by A123,A208,A210,FINSEQ_2:10;
    then
A216: len FlattenSeq f1 = len FlattenSeq f2 by PRE_POLY:28;
A217: Seg len FlattenSeq f1 = dom FlattenSeq f1 by FINSEQ_1:def 3;
A218: now
      let j be Nat;
      assume
A219: j in dom FlattenSeq f1;
      then consider i1,j1 be Element of NAT such that
A220: i1 in dom f1 and
A221: j1 in dom (f1.i1) and
A222: j = (Sum Card (f1|(i1-'1))) + j1 and
A223: (f1.i1).j1 = (FlattenSeq f1).j by PRE_POLY:29;
A224: j in dom FlattenSeq f2 by A216,A34,A219,FINSEQ_1:def 3;
      then consider i2,j2 be Element of NAT such that
A225: i2 in dom f2 & j2 in dom (f2.i2) and
A226: j = (Sum Card (f2|(i2-'1))) + j2 and
A227: (f2.i2).j2 = (FlattenSeq f2).j by PRE_POLY:29;
      (Sum ((Card f1)|(i1-'1))) + j1 = (Sum Card (f1|(i1-'1))) + j1 by Th16
        .= (Sum ((Card f2)|(i2-'1))) + j2 by A222,A226,Th16;
      then
A228: i1 = i2 & j1 = j2 by A215,A220,A221,A225,Th22;
      i1 in Seg len f2 by A123,A220,FINSEQ_1:def 3;
      then
A229: i1 in dom f2 by FINSEQ_1:def 3;
A230: f1.i1 = prodTuples(p,q,r,f2/.i1) by A124,A220;
      then len (f1.i1) = len (f2/.i1) by Def5
        .= len (f2.i1) by A214,A207,A215,A220,PARTFUN1:def 8;
      then j1 in Seg len (f2.i1) by A221,FINSEQ_1:def 3;
      then
A231: j1 in Seg len (f2/.i1) by A229,PARTFUN1:def 8;
      then j1 in dom (f2/.i1) by FINSEQ_1:def 3;
      then
A232: (f2/.i1)/.j1 = (f2/.i1).j1 by PARTFUN1:def 8
        .= (f2.i1).j1 by A229,PARTFUN1:def 8
        .= (FlattenSeq f2)/.j by A224,A227,A228,PARTFUN1:def 8;
      Seg len (f2/.i1) = dom (f2/.i1) by FINSEQ_1:def 3;
      hence
      (FlattenSeq f1).j = (p.(((f2/.i1)/.j1)/.1))* (q.(((f2/.i1)/.j1)/.2)
      )*(r.(((f2/.i1)/.j1)/.3)) by A223,A230,A231,Def5
        .= (p.(((FlattenSeq f2)/.j)/.1))* (q.(((FlattenSeq f2)/.j)/.2))*(r.(
      ((FlattenSeq f2)/.j)/.3)) by A232
        .= (prodTuples(p,q,r,FlattenSeq f2)).j by A216,A34,A217,A219,Def5;
    end;
    len Sum g1 = i+1 by A4,A152,MATRLIN:def 8;
    then r2 = Sum g1 by A7,A155,FINSEQ_2:10;
    then
A233: Sum r2 = Sum FlattenSeq g1 by POLYNOM1:34;
    len FlattenSeq g1=len prodTuples(p,q,r,FlattenSeq g2) by A189,Def5;
    then
A234: FlattenSeq g1=prodTuples(p,q,r,FlattenSeq g2) by A192,FINSEQ_2:10;
    len FlattenSeq f1=len prodTuples(p,q,r,FlattenSeq f2) by A216,Def5;
    then FlattenSeq f1=prodTuples(p,q,r,FlattenSeq f2) by A218,FINSEQ_2:10;
    then
A235: FlattenSeq f1 = (FlattenSeq g1)*P by A234,A116,Th15;
    len Sum f1 = i+1 by A1,A123,MATRLIN:def 8;
    then r1 = Sum f1 by A119,A126,FINSEQ_2:10;
    then Sum r1 = Sum FlattenSeq f1 by POLYNOM1:34;
    hence (p*'q*'r).i = (p*'(q*'r)).i by A120,A8,A233,A235,RLVECT_2:9;
  end;
  hence thesis by FUNCT_2:113;
end;

definition
  let L be Abelian add-associative right_zeroed commutative (non empty
  doubleLoopStr);
  let p,q be sequence of L;
  redefine func p*'q;
  commutativity
  proof
    let p,q be sequence of L;
    now
      let i be Element of NAT;
      consider r1 be FinSequence of the carrier of L such that
A1:   len r1 = i+1 and
A2:   (p*'q).i = Sum r1 and
A3:   for k be Element of NAT st k in dom r1 holds r1.k = p.(k-'1) * q
      .(i+1-'k) by Def11;
      consider r2 be FinSequence of the carrier of L such that
A4:   len r2 = i+1 and
A5:   (q*'p).i = Sum r2 and
A6:   for k be Element of NAT st k in dom r2 holds r2.k = q.(k-'1) * p
      .(i+1-'k) by Def11;
      now
        let k be Nat;
        assume
A7:     k in dom r1;
        then
A8:     1 <= k by FINSEQ_3:27;
        then
A9:     k-1 >= 0 by XREAL_1:50;
        k <= i+1 by A1,A7,FINSEQ_3:27;
        then
A10:    i+1-k >= 0 by XREAL_1:50;
        then reconsider k1 = len r2 - k + 1 as Element of NAT by A4,INT_1:16;
A11:    i+1-'k = i+1-k+1-1 by A10,XREAL_0:def 2
          .= k1-'1 by A4,A10,XREAL_0:def 2;
        1-k <= 0 by A8,XREAL_1:49;
        then i+(1-k) <= i+(0 qua Nat) by XREAL_1:8;
        then
A12:    k1 <= i+1 by A4,XREAL_1:8;
        then i+1-k1 >= 0 by XREAL_1:50;
        then
A13:    i+1-'k1 = i+1-(i+1-(k-1)) by A4,XREAL_0:def 2
          .= k-'1 by A9,XREAL_0:def 2;
        i+1-k+1 >= 0 qua Nat+1 by A10,XREAL_1:8;
        then
A14:    k1 in dom r2 by A4,A12,FINSEQ_3:27;
        thus r1.k = p.(k-'1) * q.(i+1-'k) by A3,A7
          .= r2.(len r2 - k + 1) by A6,A14,A13,A11;
      end;
      then r1 = Rev r2 by A1,A4,FINSEQ_5:def 3;
      hence (p*'q).i = (q*'p).i by A2,A5,Th2;
    end;
    hence p*'q = q*'p by FUNCT_2:113;
  end;
end;

theorem
  for L be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr) for p be sequence of L holds p*'
  0_.(L) = 0_.(L)
proof
  let L be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr);
  let p be sequence of L;
  now
    let i be Element of NAT;
    consider r be FinSequence of the carrier of L such that
    len r = i+1 and
A1: (p*'0_.(L)).i = Sum r and
A2: for k be Element of NAT st k in dom r holds r.k = p.(k-'1) * (0_.(
    L)).(i+1-'k) by Def11;
    now
      let k be Element of NAT;
      assume k in dom r;
      hence r.k = p.(k-'1) * (0_.(L)).(i+1-'k) by A2
        .= p.(k-'1) * 0.L by FUNCOP_1:13
        .= 0.L by VECTSP_1:36;
    end;
    hence (p*'0_.(L)).i = 0.L by A1,Th1
      .= (0_.(L)).i by FUNCOP_1:13;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th36:
  for L be add-associative right_zeroed well-unital
  right_complementable right-distributive (non empty doubleLoopStr) for p be
  sequence of L holds p*'1_.(L) = p
proof
  let L be add-associative right_zeroed well-unital right_complementable
  right-distributive (non empty doubleLoopStr);
  let p be sequence of L;
  now
    let i be Element of NAT;
    consider r be FinSequence of the carrier of L such that
A1: len r = i+1 and
A2: (p*'1_.(L)).i = Sum r and
A3: for k be Element of NAT st k in dom r holds r.k = p.(k-'1) * (1_.(
    L)).(i+1-'k) by Def11;
    i+1 in Seg len r by A1,FINSEQ_1:6;
    then
A4: i+1 in dom r by FINSEQ_1:def 3;
    now
      let k be Element of NAT;
      assume k in dom Del(r,i+1);
      then
A5:   k in Seg len Del(r,i+1) by FINSEQ_1:def 3;
      then k in Seg i by A1,PRE_POLY:12;
      then
A6:   k <= i by FINSEQ_1:3;
      then
A7:   k < i+1 by NAT_1:13;
A8:   i+1-k <> 0 by A6,NAT_1:13;
      i+1-k >= 0 by A7,XREAL_1:50;
      then
A9:   i+1-'k <> 0 by A8,XREAL_0:def 2;
      1 <= k by A5,FINSEQ_1:3;
      then k in Seg (i+1) by A7,FINSEQ_1:3;
      then
A10:  k in dom r by A1,FINSEQ_1:def 3;
      thus Del(r,i+1).k = r.k by A7,FINSEQ_3:119
        .= p.(k-'1) * (1_.(L)).(i+1-'k) by A3,A10
        .= p.(k-'1) * 0.L by A9,Th31
        .= 0.L by VECTSP_1:36;
    end;
    then
A11: Sum Del(r,i+1) = 0.L by Th1;
    r = Del(r,i+1) ^ <*r.(i+1)*> by A1,PRE_POLY:13
      .= Del(r,i+1) ^ <*r/.(i+1)*> by A4,PARTFUN1:def 8;
    then
A12: Sum r = Sum Del(r,i+1) + Sum <*r/.(i+1)*> by RLVECT_1:58
      .= Sum Del(r,i+1) + (r/.(i+1)) by RLVECT_1:61;
    r/.(i+1) = r.(i+1) by A4,PARTFUN1:def 8
      .= p.(i+1-'1) * (1_.(L)).(i+1-'(i+1)) by A3,A4
      .= p.i * (1_.(L)).(i+1-'(i+1)) by NAT_D:34
      .= p.i * (1_.(L)).0 by XREAL_1:234
      .= (p.i) * 1_L by Th31
      .= p.i by VECTSP_1:def 13;
    hence (p*'1_.(L)).i = p.i by A2,A12,A11,RLVECT_1:10;
  end;
  hence thesis by FUNCT_2:113;
end;

begin  :: The Ring of Polynomials

definition
  let L be add-associative right_zeroed right_complementable distributive (non
  empty doubleLoopStr);
  func Polynom-Ring L -> strict non empty doubleLoopStr means
  :Def12:
  (for x
  be set holds x in the carrier of it iff x is Polynomial of L) & (for x,y be
Element of it, p,q be sequence of L st x = p & y = q holds x+y = p+q) & (for x,
  y be Element of it, p,q be sequence of L st x = p & y = q holds x*y = p*'q) &
  0.it = 0_.(L) & 1.it = 1_.(L);
  existence
  proof
A1: 0_.(L) in {x where x is Polynomial of L : not contradiction};
    then reconsider
    Ca = {x where x is Polynomial of L : not contradiction} as non
    empty set;
    reconsider Ze = 0_.(L) as Element of Ca by A1;
    defpred P[set,set,set] means ex p,q be Polynomial of L st p=$1 & q=$2 & $3
    =p+q;
A2: for x,y be Element of Ca ex u be Element of Ca st P[x,y,u]
    proof
      let x,y be Element of Ca;
      x in Ca;
      then consider p be Polynomial of L such that
A3:   x=p;
      y in Ca;
      then consider q be Polynomial of L such that
A4:   y=q;
      p+q in Ca;
      then reconsider u=p+q as Element of Ca;
      take u,p,q;
      thus thesis by A3,A4;
    end;
    consider Ad be Function of [:Ca,Ca:],Ca such that
A5: for x,y be Element of Ca holds P[x,y,Ad.(x,y)] from BINOP_1:sch 3(
    A2 );
    1_.(L) in {x where x is Polynomial of L : not contradiction};
    then reconsider Un = 1_.(L) as Element of Ca;
    defpred P[set,set,set] means ex p,q be Polynomial of L st p=$1 & q=$2 & $3
    =p*'q;
A6: for x,y be Element of Ca ex u be Element of Ca st P[x,y,u]
    proof
      let x,y be Element of Ca;
      x in Ca;
      then consider p be Polynomial of L such that
A7:   x=p;
      y in Ca;
      then consider q be Polynomial of L such that
A8:   y=q;
      p*'q in Ca;
      then reconsider u=p*'q as Element of Ca;
      take u,p,q;
      thus thesis by A7,A8;
    end;
    consider Mu be Function of [:Ca,Ca:],Ca such that
A9: for x,y be Element of Ca holds P[x,y,Mu.(x,y)] from BINOP_1:sch 3
    (A6 );
    reconsider P = doubleLoopStr(# Ca, Ad, Mu, Un, Ze #) as strict non empty
    doubleLoopStr;
    take P;
    thus for x be set holds x in the carrier of P iff x is Polynomial of L
    proof
      let x be set;
      thus x in the carrier of P implies x is Polynomial of L
      proof
        assume x in the carrier of P;
        then ex p be Polynomial of L st x=p;
        hence thesis;
      end;
      thus thesis;
    end;
    thus for x,y be Element of P, p,q be sequence of L st x = p & y = q holds
    x+y = p+q
    proof
      let x,y be Element of P;
      let p,q be sequence of L;
      assume
A10:  x = p & y = q;
      ex p1,q1 be Polynomial of L st p1 = x & q1 = y & Ad.(x, y) = p1+q1 by A5;
      hence thesis by A10;
    end;
    thus for x,y be Element of P, p,q be sequence of L st x = p & y = q holds
    x*y = p*'q
    proof
      let x,y be Element of P;
      let p,q be sequence of L;
      assume
A11:  x = p & y = q;
      ex p1,q1 be Polynomial of L st p1 = x & q1 = y & Mu.(x,y) = p1*'q1 by A9;
      hence thesis by A11;
    end;
    thus 0.P = 0_.(L);
    thus thesis;
  end;
  uniqueness
  proof
    let P1,P2 be strict non empty doubleLoopStr such that
A12: for x be set holds x in the carrier of P1 iff x is Polynomial of L and
A13: for x,y be Element of P1, p,q be sequence of L st x = p & y = q
    holds x+y = p+q and
A14: for x,y be Element of P1, p,q be sequence of L st x = p & y = q
    holds x*y = p*'q and
A15: 0.P1 = 0_.(L) & 1.P1 = 1_.(L) and
A16: for x be set holds x in the carrier of P2 iff x is Polynomial of L and
A17: for x,y be Element of P2, p,q be sequence of L st x = p & y = q
    holds x+y = p+q and
A18: for x,y be Element of P2, p,q be sequence of L st x = p & y = q
    holds x*y = p*'q and
A19: 0.P2 = 0_.(L) & 1.P2 = 1_.(L);
A20: now
      let x be set;
      x in the carrier of P1 iff x is Polynomial of L by A12;
      hence x in the carrier of P1 iff x in the carrier of P2 by A16;
    end;
    then
A21: the carrier of P1 = the carrier of P2 by TARSKI:2;
A22: now
      let x be Element of P1, y be Element of P2;
      reconsider y1=y as Element of P1 by A20;
      reconsider x1=x as Element of P2 by A20;
      reconsider p=x as sequence of L by A12;
      reconsider q=y as sequence of L by A16;
      thus (the multF of P1).(x,y) = x*y1 .= p*'q by A14
        .= x1*y by A18
        .= (the multF of P2).(x,y);
    end;
    now
      let x be Element of P1, y be Element of P2;
      reconsider y1=y as Element of P1 by A20;
      reconsider x1=x as Element of P2 by A20;
      reconsider p=x as sequence of L by A12;
      reconsider q=y as sequence of L by A16;
      thus (the addF of P1).(x,y) = x+y1 .= p+q by A13
        .= x1+y by A17
        .= (the addF of P2).(x,y);
    end;
    then the addF of P1 = the addF of P2 by A21,BINOP_1:2;
    hence thesis by A15,A19,A21,A22,BINOP_1:2;
  end;
end;

registration
  let L be Abelian add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr);
  cluster Polynom-Ring L -> Abelian;
  coherence
  proof
    let p,q be Element of Polynom-Ring L;
    reconsider p1=p, q1=q as sequence of L by Def12;
    thus p + q = p1 + q1 by Def12
      .= q + p by Def12;
  end;
end;

registration
  let L be add-associative right_zeroed right_complementable distributive (non
  empty doubleLoopStr);
  cluster Polynom-Ring L -> add-associative;
  coherence
  proof
    let p,q,r be Element of Polynom-Ring L;
    reconsider p1=p, q1=q, r1=r as sequence of L by Def12;
A1: q + r = q1 + r1 by Def12;
    p + q = p1 + q1 by Def12;
    hence (p + q) + r = (p1 + q1) + r1 by Def12
      .= p1 + (q1 + r1) by Th26
      .= p + (q + r) by A1,Def12;
  end;
  cluster Polynom-Ring L -> right_zeroed;
  coherence
  proof
    let p be Element of Polynom-Ring L;
    reconsider p1=p as sequence of L by Def12;
    0.(Polynom-Ring L) = 0_.(L) by Def12;
    hence p + 0.(Polynom-Ring L) = p1 + 0_.(L) by Def12
      .= p by Th29;
  end;
  cluster Polynom-Ring L -> right_complementable;
  coherence
  proof
    let p be Element of Polynom-Ring L;
    reconsider p1=p as Polynomial of L by Def12;
    reconsider q = -p1 as Element of Polynom-Ring L by Def12;
    take q;
    thus p + q = p1 - p1 by Def12
      .= 0_.(L) by Th30
      .= 0.(Polynom-Ring L) by Def12;
  end;
end;

registration
  let L be Abelian add-associative right_zeroed right_complementable
  commutative distributive (non empty doubleLoopStr);
  cluster Polynom-Ring L -> commutative;
  coherence
  proof
    let p,q be Element of Polynom-Ring L;
    reconsider p1=p, q1=q as sequence of L by Def12;
    thus p * q = p1 *' q1 by Def12
      .= q * p by Def12;
  end;
end;

registration
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative distributive (non empty doubleLoopStr);
  cluster Polynom-Ring L -> associative;
  coherence
  proof
    let p,q,r be Element of Polynom-Ring L;
    reconsider p1=p, q1=q, r1=r as sequence of L by Def12;
A1: q * r = q1 *' r1 by Def12;
    p * q = p1 *' q1 by Def12;
    hence (p * q) * r = (p1 *' q1) *' r1 by Def12
      .= p1 *' (q1 *' r1) by Th34
      .= p * (q * r) by A1,Def12;
  end;
end;

Lm2: now
  let L be add-associative right_zeroed right_complementable well-unital
  Abelian commutative distributive (non empty doubleLoopStr);
  set Pm = Polynom-Ring L;
  let x, e be Element of Pm;
  reconsider p = x as Polynomial of L by Def12;
  assume
A1: e = 1.Pm;
A2: 1.Pm = 1_.L by Def12;
  hence x*e = p*'1_.L by A1,Def12
    .= x by Th36;
  thus e*x = p*'1_.L by A1,A2,Def12
    .= x by Th36;
end;

registration
  let L be add-associative right_zeroed right_complementable well-unital
  Abelian commutative distributive (non empty doubleLoopStr);
  cluster Polynom-Ring L -> well-unital;
  coherence
  proof
    let x be Element of Polynom-Ring L;
    thus thesis by Lm2;
  end;
end;

registration
  let L be Abelian add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr);
  cluster Polynom-Ring L -> distributive;
  coherence
  proof
    let p,q,r be Element of Polynom-Ring L;
    reconsider p1=p, q1=q, r1=r as sequence of L by Def12;
A1: p*q = p1*'q1 & p*r = p1*'r1 by Def12;
    q+r = q1+r1 by Def12;
    hence p*(q+r) = p1*'(q1+r1) by Def12
      .= p1*'q1+p1*'r1 by Th32
      .= p*q+p*r by A1,Def12;
A2: q*p = q1*'p1 & r*p = r1*'p1 by Def12;
    q+r = q1+r1 by Def12;
    hence (q+r)*p = (q1+r1)*'p1 by Def12
      .= q1*'p1+r1*'p1 by Th33
      .= q*p+r*p by A2,Def12;
  end;
end;

theorem
  for L being add-associative right_zeroed right_complementable
well-unital Abelian commutative distributive (non empty doubleLoopStr) holds 1.
  Polynom-Ring L = 1_.L by Def12;
