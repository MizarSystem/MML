:: Trees: Connected, Acyclic Graphs
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies AMI_1, ARYTM_1, BOOLE, CARD_1, CAT_1, FINSEQ_1, FINSET_1,
      FUNCOP_1, FUNCT_1, GLIB_000, GLIB_001, GLIB_002, GRAPH_1, MATRIX_2,
      MSAFREE2, MSUALG_1, NEWTON, ORDINAL1, ORDINAL2, QUANTAL1, PBOOLE,
      PRE_TOPC, REALSET1, RELAT_1, RELAT_2, TARSKI, TOPGEN_1, TREES_1,
      SETFAM_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, NUMBERS, SUBSET_1, SETFAM_1, XREAL_0,
      DOMAIN_1, REAL_1, RELAT_1, FUNCT_1, CARD_1, PBOOLE, FUNCT_2, ORDINAL1,
      ORDINAL2, FINSEQ_1, FINSET_1, NAT_1, CQC_LANG, GLIB_000, GLIB_001, ABIAN;
 constructors DOMAIN_1, CARD_FIL, REAL_1, AMISTD_2, POLYNOM2, BINARITH,
      GRAPH_2, GLIB_001;
 registrations RELSET_1, FINSET_1, NAT_1, CARD_1, INT_1, ABIAN, JORDAN1D,
      ORDINAL2, GLIB_000, GLIB_001, POLYNOM1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI;
 theorems CARD_1, CARD_2, CQC_LANG, FINSEQ_1, FINSEQ_3, FINSET_1, FUNCOP_1,
      FUNCT_1, FUNCT_2, GLIB_000, GLIB_001, HEYTING3, INT_1, JORDAN12, NAT_1,
      ORDINAL1, ORDINAL2, PBOOLE, PENCIL_1, REAL_1, RELAT_1, RLSUB_2, TARSKI,
      XBOOLE_0, XBOOLE_1, XCMPLX_1, ZFMISC_1, XREAL_1;
 schemes BINARITH, NAT_1, SUBSET_1, GLIB_000;

begin :: Preliminary

registration let X be finite set;
  cluster bool X -> finite;
  coherence by FINSET_1:24;
end;

theorem Th1: :: tCARD02
  for X being finite set st 1 < card X holds
    ex x1,x2 being set st x1 in X & x2 in X & x1 <> x2 proof
    let X be finite set; assume
A1: 1 < card X; then
    card X <> 0; then
A2: X <> {} by CARD_1:47;
    set x1 = choose X;
A3: x1 in X by A2;
    now assume
    A4: for x2 being set st x2 in X holds x2 = x1;
        now let x be set;
            hereby assume x in X; then
               x = x1 by A4;
               hence x in {x1} by TARSKI:def 1;
            end;
            assume x in {x1};
            hence x in X by A3, TARSKI:def 1;
        end; then
        X = {x1} by TARSKI:2;
        hence contradiction by A1,CARD_1:79;
    end;
    hence thesis;
end;

begin :: Definitions

definition let G be _Graph; ::dGCONNECT
  attr G is connected means :Def1:
    for u,v being Vertex of G holds
      ex W being Walk of G st W is_Walk_from u,v;
end;

definition let G be _Graph; ::dGACYCLIC
  attr G is acyclic means :Def2:
    not ex W being Walk of G st W is Cycle-like;
end;

definition let G be _Graph; ::dGTREE
  attr G is Tree-like means :Def3:
    G is acyclic & G is connected;
end;

registration
  cluster trivial -> connected _Graph;
  coherence proof
    let G be _Graph; assume G is trivial; then
    consider x being Vertex of G such that
A1: the_Vertices_of G = {x} by GLIB_000:25;
    now let u,v be Vertex of G; set W = G.walkOf(x);
        u = x & v = x by A1, TARSKI:def 1; then
        W is_Walk_from u,v by GLIB_001:14;
        hence ex W being Walk of G st W is_Walk_from u,v;
    end;
    hence G is connected by Def1;
  end;
end;

registration
  cluster trivial loopless -> Tree-like _Graph;
  coherence proof
    let G be _Graph; assume
A1: G is trivial & G is loopless;
    now given W being Walk of G such that
    A2: W is Cycle-like;
        W is non trivial by A2, GLIB_001:def 31; then
        W.edges() <> {} by GLIB_001:137; then consider e being set such that
    A3: e in W.edges() by XBOOLE_0:def 1;
        thus contradiction by A1, A3, GLIB_000:26;
    end; then
A4: G is acyclic by Def2;
    reconsider G'=G as trivial _Graph by A1;
    G' is connected;
    hence thesis by A4,Def3;
  end;
end;

registration
  cluster acyclic -> simple _Graph;
  coherence proof
    let G be _Graph; assume
A1: not ex W being Walk of G st W is Cycle-like;
    now given e being set such that
    A2: e in the_Edges_of G & (the_Source_of G).e = (the_Target_of G).e;
        set v1 = (the_Source_of G).e, v2 = (the_Target_of G).e;
        reconsider v1,v2 as Vertex of G by A2, FUNCT_2:7;
    A3: e Joins v1,v1,G by A2, GLIB_000:def 15;
        set W = G.walkOf(v1,e,v1);
        len W = 3 by A3, GLIB_001:15; then
        W is non trivial by GLIB_001:126; then
        W is Cycle-like by GLIB_001:def 31;
        hence contradiction by A1;
    end; then
A4: G is loopless by GLIB_000:def 20;
    now let e1,e2,v1,v2 be set; assume
    A5: e1 Joins v1,v2,G & e2 Joins v1,v2,G; then
    A6: e2 Joins v2,v1,G by GLIB_000:17;
    A7: v1 <> v2 by A4, GLIB_000:21, A5;
        now assume
        A8: e1 <> e2;
            set W1 = G.walkOf(v1,e1,v2), W = W1.addEdge(e2);
            reconsider W1 as Path of G;
        A9: len W1 = 3 by A5,GLIB_001:15;
        A10: W1.first() = v1 & W1.last() = v2 by A5,GLIB_001:16;
        A11: e2 Joins W1.last(), v1, G by A6, A5,GLIB_001:16;
            W1.edges() = {e1} by A5, GLIB_001:109; then
        A12: not e2 in W1.edges() by A8, TARSKI:def 1;
            W1.first() = v1 & W1.last() = v2 by A5,GLIB_001:16; then
        A13: W1 is open by A7, GLIB_001:def 24;
            W.first() = v1 & W.last() = v1
              by A10,A6,GLIB_001:64; then
        A14: W is closed by GLIB_001:def 24;
        A15: W is non trivial by A11, GLIB_001:133;
            now let n be odd Nat; assume
            A16: 1 < n & n <= len W1; then
                1+1 <= n by NAT_1:38; then
                2*1 < n by REAL_1:def 5; then
                2*1+1 <= n by NAT_1:38; then
            A17: n = 3 by A9,A16,XREAL_1:1;
                W1 = <*v1,e1,v2*> by A5,GLIB_001:def 5;
                hence W1.n <> v1 by A7, A17, FINSEQ_1:62;
            end;
            hence W is Path-like by A11,A12,A13,GLIB_001:151; then
            W is Cycle-like by A14,A15,GLIB_001:def 31;
            hence contradiction by A1;
        end;
        hence e1 = e2;
    end; then
    G is non-multi by GLIB_000:def 22;
    hence thesis by A4, GLIB_000:def 24;
  end;
end;

registration
  cluster Tree-like -> acyclic connected _Graph;
  coherence by Def3;
end;

registration
  cluster acyclic connected -> Tree-like _Graph;
  coherence by Def3;
end;

registration let G be _Graph, v be Vertex of G;
  cluster -> Tree-like inducedSubgraph of G,{v},{};
  coherence;
end;

definition let G be _Graph, v be set;
  pred G is_DTree_rooted_at v means :Def4: ::dGDTREE
    G is Tree-like &
     for x being Vertex of G holds
      ex W being DWalk of G st W is_Walk_from v,x;
end;

registration
  cluster trivial finite Tree-like _Graph;
  existence proof
    set V = {1}, E = {};
    reconsider S = {} as Function of E,V by FUNCT_2:55, RELAT_1:60;
    set G = createGraph(V,E,S,S); take G;
    thus thesis;
  end;

  cluster non trivial finite Tree-like _Graph;
  existence proof
    set V = {0,1}, E = {0}, S = 0 .--> 0, T = 0 .--> 1;
A1: dom S = E & dom T = E by CQC_LANG:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        S.x = 0 by CQC_LANG:6;
        hence S.x in V by TARSKI:def 2;
    end; then reconsider S as Function of E,V by A1, FUNCT_2:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        T.x = 1 by CQC_LANG:6;
        hence T.x in V by TARSKI:def 2;
    end; then reconsider T as Function of E,V by A1, FUNCT_2:5;
    set G = createGraph(V,E,S,T);
A2: the_Vertices_of G = V & the_Edges_of G = E & the_Source_of G = S &
      the_Target_of G = T by GLIB_000:8;
    take G;
    now assume Card (the_Vertices_of G) = one; then
        consider x being set such that
    A3: the_Vertices_of G = {x} by CARD_2:20, CARD_2:60;
        thus contradiction by A2,A3,ZFMISC_1:9;
    end;
    hence G is non trivial & G is finite by GLIB_000:def 21;
    reconsider a0 = 0, a1 = 1 as Vertex of G by A2,TARSKI:def 2;
A4: 0 in the_Edges_of G by A2,TARSKI:def 1;
A5:(the_Source_of G).0 = 0 & (the_Target_of G).0 = 1 by A2,CQC_LANG:6; then
A6: 0 Joins 0,1, G by A4, GLIB_000:def 15;
    now given W being Walk of G such that
    A7: W is Cycle-like;
    A8: W is closed & W is non trivial & W is Path-like
          by A7, GLIB_001:def 31; then
    A9: W is Trail-like by GLIB_001:def 28;
        now per cases;
        suppose
        A10: len W =  3; then
        A11: W.(1+1) Joins W.1, W.(1+2), G by GLIB_001:def 3, JORDAN12:3;
            set e = W.(1+1), v1 = W.1, v2 = W.(1+2);
            v1 = v2 by A8,A10,GLIB_001:119; then
            e in the_Edges_of G &
              (((the_Source_of G).e = v1 & (the_Target_of G).e = v1) or
              ((the_Source_of G).e = v1 & (the_Target_of G).e = v1))
              by A11, GLIB_000:def 15; then
            (v1 = 0 & v1 = 1) or (v1 = 1 & v1 = 0) by A5,A2,TARSKI:def 1;
            hence contradiction; end;
          suppose
        A12: len W <> 3;
        A13: 3 <= len W by A8, GLIB_001:126; then
            3 < len W by A12, REAL_1:def 5; then
        A14: 3+1 <= len W by NAT_1:38; then
        A15: 2*2 in dom W by FINSEQ_3:27;
            3-1 <= len W - 0 by A13, REAL_1:92; then
        A16: 2*1 in dom W by FINSEQ_3:27;
            W.(2*1) in {0} & W.(2*2) in {0} by A2,A15, A16, GLIB_001:9; then
            W.(2*1) = 0 & W.(2*2) = 0 by TARSKI:def 1;
            hence contradiction by A9,A14,GLIB_001:139;
          end;
        end;
        hence contradiction;
    end; then
A17: G is acyclic by Def2;
    set W1 = G.walkOf(0,0,1), W2 = W1.reverse();
A18: W1 is_Walk_from 0,1 by A6,GLIB_001:16; then
A19: W2 is_Walk_from 1,0 by GLIB_001:24;
    now let u,v be Vertex of G;
        now per cases by A2,TARSKI:def 2;
        suppose u = 0 & v = 0; then
            G.walkOf(a0) is_Walk_from u,v by GLIB_001:14;
            hence ex W being Walk of G st W is_Walk_from u,v; end;
        suppose u = 0 & v = 1;
            hence ex W being Walk of G st W is_Walk_from u,v by A18; end;
        suppose u = 1 & v = 0;
            hence ex W being Walk of G st W is_Walk_from u,v by A19; end;
        suppose u = 1 & v = 1; then
            G.walkOf(a1) is_Walk_from u,v by GLIB_001:14;
            hence ex W being Walk of G st W is_Walk_from u,v; end;
        end;
        hence ex W being Walk of G st W is_Walk_from u,v;
    end; then
    G is connected by Def1;
    hence G is Tree-like by A17, Def3;
  end;
end;

registration let G be _Graph;
  cluster trivial finite Tree-like Subgraph of G;
  existence  proof
    consider IT being finite trivial simple Subgraph of G;
    take IT;
    thus thesis;
  end;
end;

registration let G be acyclic _Graph;
  cluster -> acyclic Subgraph of G;
  coherence proof
    let G2 be Subgraph of G;
    now given W2 being Walk of G2 such that
    A1: W2 is Cycle-like;
    A2: W2 is closed & W2 is non trivial & W2 is Path-like
          by A1,GLIB_001:def 31;
        reconsider W = W2 as Walk of G by GLIB_001:168;
        W is closed & W is non trivial & W is Path-like
          by A2, GLIB_001:177; then
        W is Cycle-like by GLIB_001:def 31;
        hence contradiction by Def2;
    end;
    hence thesis by Def2;
  end;
end;

definition let G be _Graph, v be Vertex of G; ::dGREACH
  func G.reachableFrom(v) -> non empty Subset of the_Vertices_of G means
     :Def5:
    for x being set holds x in it iff
      ex W being Walk of G st W is_Walk_from v,x;
  existence proof
    defpred P[set] means ex W being Walk of G st W is_Walk_from v,$1;
    consider IT being Subset of the_Vertices_of G such that
A1: for x being set holds x in IT iff x in the_Vertices_of G & P[x]
      from SUBSET_1:sch 1;
    G.walkOf(v) is_Walk_from v,v by GLIB_001:14; then
    reconsider IT as non empty Subset of the_Vertices_of G by A1;
    take IT; let x being set;
    thus x in IT implies ex W being Walk of G st W is_Walk_from v,x by A1;
    assume ex W being Walk of G st W is_Walk_from v, x; then
    consider W being Walk of G such that
A2: W is_Walk_from v, x;
    x is Vertex of G by A2, GLIB_001:19;
    hence x in IT by A1,A2;
  end;
  uniqueness proof
    let IT1, IT2 be non empty Subset of the_Vertices_of G such that
A3: for x being set holds x in IT1 iff
      ex W being Walk of G st W is_Walk_from v,x and
A4: for x being set holds x in IT2 iff
      ex W being Walk of G st W is_Walk_from v,x;
    now let x be set;
        hereby assume x in IT1; then
            ex W being Walk of G st W is_Walk_from v, x by A3;
            hence x in IT2 by A4;
        end;
        assume x in IT2; then
        ex W being Walk of G st W is_Walk_from v, x by A4;
        hence x in IT1 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

definition let G be _Graph, v be Vertex of G; ::dGREACHD:
  func G.reachableDFrom(v) -> non empty Subset of the_Vertices_of G means
     :Def6:
    for x being set holds x in it iff
      ex W being DWalk of G st W is_Walk_from v,x;
  existence proof
    defpred P[set] means ex W being directed Walk of G st W is_Walk_from v,$1;
    consider IT being Subset of the_Vertices_of G such that
A1: for x being set holds x in IT iff x in the_Vertices_of G & P[x]
      from SUBSET_1:sch 1;
    set W = G.walkOf(v);
    W is_Walk_from v,v by GLIB_001:14; then
    reconsider IT as non empty Subset of the_Vertices_of G by A1;
    take IT; let x be set;
    thus x in IT implies ex W being directed Walk of G st W is_Walk_from v,x
      by A1;
    given W being directed Walk of G such that
A2: W is_Walk_from v, x;
    x is Vertex of G by A2, GLIB_001:19;
    hence x in IT by A1, A2;
  end;
  uniqueness proof
    let IT1, IT2 be non empty Subset of the_Vertices_of G such that
A3: for x being set holds x in IT1 iff
      ex W being directed Walk of G st W is_Walk_from v,x and
A4: for x being set holds x in IT2 iff
      ex W being directed Walk of G st W is_Walk_from v,x;
    now let x be set;
        hereby assume x in IT1; then
            ex W being directed Walk of G st W is_Walk_from v, x by A3;
            hence x in IT2 by A4;
        end;
        assume x in IT2; then
        ex W being directed Walk of G st W is_Walk_from v, x by A4;
        hence x in IT1 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

Lm1:
   for G being _Graph, v being Vertex of G holds v in G.reachableFrom(v) proof
    let G be _Graph, v be Vertex of G;
    G.walkOf(v) is_Walk_from v,v by GLIB_001:14;
    hence thesis by Def5;
end;

Lm2:
for G being _Graph, v1 being Vertex of G, e,x,y being set holds
  x in G.reachableFrom(v1) & e Joins x,y,G implies
    y in G.reachableFrom(v1) proof
    let G be _Graph, v1 be Vertex of G, e,x,y be set;
    set RFV = G.reachableFrom(v1); assume
A1: x in RFV & e Joins x,y,G; then consider W being Walk of G such that
A2: W is_Walk_from v1,x by Def5;
    W.addEdge(e) is_Walk_from v1,y by A1, A2, GLIB_001:67;
    hence thesis by Def5;
end;

Lm3:
for G being _Graph, v1,v2 being Vertex of G holds
  v1 in G.reachableFrom(v2) implies
    G.reachableFrom(v1) = G.reachableFrom(v2) proof
    let G be _Graph, v1,v2 be Vertex of G; assume
    v1 in G.reachableFrom(v2); then
    consider WA being Walk of G such that
A1: WA is_Walk_from v2,v1 by Def5;
A2: WA.reverse() is_Walk_from v1,v2 by A1, GLIB_001:24;
    now let x be set;
        hereby assume x in G.reachableFrom(v1); then
            consider WB being Walk of G such that
        A3: WB is_Walk_from v1,x by Def5;
            WA.append(WB) is_Walk_from v2,x by A1,A3,GLIB_001:32;
            hence x in G.reachableFrom(v2) by Def5;
        end;
        assume x in G.reachableFrom(v2); then
        consider WB being Walk of G such that
    A4: WB is_Walk_from v2,x by Def5;
        WA.reverse().append(WB) is_Walk_from v1,x by A2,A4,GLIB_001:32;
        hence x in G.reachableFrom(v1) by Def5;
    end;
    hence G.reachableFrom(v1) = G.reachableFrom(v2) by TARSKI:2;
end;

Lm4:
  for G being _Graph, W being Walk of G, v being Vertex of G holds
    v in W.vertices() implies W.vertices() c= G.reachableFrom(v) proof
    let G be _Graph, W be Walk of G, v be Vertex of G; assume
    v in W.vertices(); then consider m being odd Nat such that
A1: m <= len W & W.m = v by GLIB_001:88;
    let x be set; assume x in W.vertices(); then
        consider n being odd Nat such that
    A2: n <= len W & W.n = x by GLIB_001:88;
        now per cases;
        suppose m <= n; then
            W.cut(m,n) is_Walk_from v,x by A1,A2,GLIB_001:38;
            hence ex W2 being Walk of G st W2 is_Walk_from v,x; end;
        suppose m > n; then
            W.cut(n,m) is_Walk_from x,v by A1,A2,GLIB_001:38; then
            W.cut(n,m).reverse() is_Walk_from v,x by GLIB_001:24;
            hence ex W2 being Walk of G st W2 is_Walk_from v,x; end;
        end;
        hence x in G.reachableFrom(v) by Def5;
end;

definition let G1 be _Graph, G2 be Subgraph of G1;
  attr G2 is Component-like means :Def7:
    G2 is connected &
    not ex G3 being connected Subgraph of G1 st G2 c< G3;
end;

registration let G be _Graph;
  cluster Component-like -> connected Subgraph of G;
  coherence by Def7;
end;

registration let G be _Graph, v be Vertex of G;
  cluster -> Component-like inducedSubgraph of G,G.reachableFrom(v);
  coherence proof
    let G2 be inducedSubgraph of G,G.reachableFrom(v);
A1: the_Vertices_of G2 = G.reachableFrom(v) &
      the_Edges_of G2 = G.edgesBetween(G.reachableFrom(v)) by GLIB_000:def 39;
    now let x,y be Vertex of G2;
        consider W1R being Walk of G such that
    A2: W1R is_Walk_from v,x by A1,Def5;
        consider W2 being Walk of G such that
    A3: W2 is_Walk_from v,y by A1,Def5;
        set W1 = W1R.reverse(), W = W1.append(W2);
    A4: W1 is_Walk_from x,v by A2,GLIB_001:24; then
    A5: W is_Walk_from x,y by A3, GLIB_001:32;
    A6: W1.last() = v & W2.first() = v by A3,A4,GLIB_001:def 23; then
    A7: W.vertices() = W1.vertices() \/ W2.vertices() by GLIB_001:94;
        v in W1.vertices() by A6, GLIB_001:89; then
        v in W.vertices() by A7, XBOOLE_0:def 2; then
    A8: W.vertices() c= the_Vertices_of G2 by A1, Lm4; then
    A9: G.edgesBetween(W.vertices()) c= G.edgesBetween(the_Vertices_of G2)
          by GLIB_000:39;
        W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110; then
        W.edges() c= G.edgesBetween(the_Vertices_of G2)
          by A9,XBOOLE_1:1; then
        reconsider W as Walk of G2 by A1,A8,GLIB_001:171;
        take W;
        thus W is_Walk_from x,y by A5, GLIB_001:20;
    end; then
A10: G2 is connected by Def1;
    now given G3 being connected Subgraph of G such that
    A11: G2 c< G3;
        G2 c= G3 by A11, GLIB_000:def 38; then
    A12: G2 is Subgraph of G3 by GLIB_000:def 37;
    A13: v in the_Vertices_of G2 by A1, Lm1;
    A14: the_Vertices_of G2 c= the_Vertices_of G3 by A12,GLIB_000:def 34;
    A15: now given x being set such that
        A16: x in the_Vertices_of G3 & not x in the_Vertices_of G2;
            consider W being Walk of G3 such that
        A17: W is_Walk_from v,x by A14,A13,A16, Def1;
            reconsider W as Walk of G by GLIB_001:168;
            W is_Walk_from v,x by A17, GLIB_001:20;
            hence contradiction by A1,A16,Def5;
        end;
    A18: the_Vertices_of G2 c= the_Vertices_of G3 by A12,GLIB_000:def 34;
        now per cases by A11, GLIB_000:102;
        suppose ex x being set st x in the_Vertices_of G3 &
            not x in the_Vertices_of G2;
            hence contradiction by A15; end;
        suppose ex e being set st e in the_Edges_of G3 &
            not e in the_Edges_of G2; then consider e being set such that
        A19: e in the_Edges_of G3 & not e in the_Edges_of G2;
            set v1 = (the_Source_of G3).e, v2 = (the_Target_of G3).e;
        A20: e Joins v1,v2,G3 by A19, GLIB_000:def 15; then
        A21: e Joins v1,v2,G by GLIB_000:75;
            now per cases;
            suppose the_Vertices_of G3 = the_Vertices_of G2; then
                reconsider v1,v2 as Vertex of G2 by A20,GLIB_000:16;
                v1 in G.reachableFrom(v) &
                v2 in G.reachableFrom(v) by A1;
                hence contradiction by A1,A19,A21,GLIB_000:35; end;
            suppose the_Vertices_of G3 <> the_Vertices_of G2; then
                the_Vertices_of G2 c< the_Vertices_of G3
                  by A18,XBOOLE_0:def 8;
                hence contradiction by A15,RLSUB_2:77; end;
            end;
            hence contradiction; end;
        end;
        hence contradiction;
    end;
    hence thesis by A10, Def7;
  end;
end;

registration let G be _Graph;
  cluster Component-like Subgraph of G;
  existence proof
    consider v being Vertex of G;
    consider IT being inducedSubgraph of G,G.reachableFrom(v); take IT;
    thus thesis;
  end;
end;

definition let G be _Graph;
  mode Component of G is Component-like Subgraph of G;
end;

definition let G be _Graph;
  func G.componentSet() -> non empty Subset-Family of the_Vertices_of G means
    :Def8: ::dGCOMPSET
    for x being set holds x in it iff
       ex v being Vertex of G st x = G.reachableFrom(v);
  existence proof
    defpred P[set] means ex v being Vertex of G st $1 = G.reachableFrom(v);
    consider IT being Subset-Family of the_Vertices_of G such that
A1: for x being set holds x in IT iff x in bool the_Vertices_of G & P[x]
      from SUBSET_1:sch 1;
    consider v being Vertex of G; set x = G.reachableFrom(v);
    x in IT by A1; then
    reconsider IT as non empty Subset-Family of the_Vertices_of G;
    take IT;
    thus thesis by A1;
  end;
  uniqueness proof
    defpred P[set] means ex v being Vertex of G st $1 = G.reachableFrom(v);
    let IT1,IT2 be non empty Subset-Family of the_Vertices_of G such that
A2: for x being set holds x in IT1 iff P[x] and
A3: for x being set holds x in IT2 iff P[x];
    now let x be set;
        x in IT1 iff P[x] by A2;
        hence x in IT1 iff x in IT2 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

registration let G be _Graph, X be Element of G.componentSet();
  cluster -> Component-like inducedSubgraph of G,X;
  coherence proof
    let G2 be inducedSubgraph of G,X;
    consider v being Vertex of G such that
A1: X = G.reachableFrom(v) by Def8;
    G2 is inducedSubgraph of G,G.reachableFrom(v) by A1;
    hence thesis;
  end;
end;

definition let G be _Graph;
  func G.numComponents() -> Cardinal equals  ::dGNUMPCOMP
    Card G.componentSet();
  coherence;
end;

definition let G be finite _Graph;
  redefine func G.numComponents() -> non empty Nat;
  coherence proof
    G.numComponents() = card G.componentSet();
    hence thesis by CARD_2:59;
  end;
end;

definition let G be _Graph, v be Vertex of G;
  attr v is cut-vertex means :Def10: ::dCUTV1
    for G2 being removeVertex of G,v holds
      G.numComponents() <` G2.numComponents();
end;

definition let G be finite _Graph, v be Vertex of G;
  redefine attr v is cut-vertex means :Def11: ::dCUTV2
    for G2 being removeVertex of G,v holds
      G.numComponents() < G2.numComponents();
  compatibility proof
    hereby assume
    A1: v is cut-vertex;
        let G2 be removeVertex of G,v;
        G.numComponents() <` G2.numComponents() by A1, Def10; then
        Card G.numComponents() <` G2.numComponents() by CARD_1:66; then
        Card G.numComponents() <` Card G2.numComponents() by CARD_1:66;
        hence G.numComponents() < G2.numComponents() by CARD_1:73;
    end;
    assume
A2: for G2 being removeVertex of G,v holds
      G.numComponents() < G2.numComponents();
    now let G2 be removeVertex of G,v;
        G.numComponents() < G2.numComponents() by A2; then
        Card G.numComponents() <` Card G2.numComponents() by CARD_1:73; then
        G.numComponents() <` Card G2.numComponents() by CARD_1:66;
        hence G.numComponents() <` G2.numComponents() by CARD_1:66;
    end;
    hence v is cut-vertex by Def10;
  end;
end;

Lm5:
  for G1 being non trivial connected _Graph, v being Vertex of G1,
      G2 being removeVertex of G1,v st v is endvertex
   holds G2 is connected proof
    let G1 be non trivial connected _Graph, v being Vertex of G1,
        G2 be removeVertex of G1,v; assume
A1: v is endvertex; then consider ev being set such that
A2: v.edgesInOut() = {ev} & not ev Joins v, v,G1 by GLIB_000:def 53;
    set VG = the_Vertices_of G1, VG2 = the_Vertices_of G2;
    now let v1',v2' be Vertex of G2;
        reconsider v1=v1', v2=v2' as Vertex of G1 by GLIB_000:45;
        consider W being Walk of G1 such that
    A3: W is_Walk_from v1,v2 by Def1;
        v1' in VG2 & v2' in VG2; then
        v1' in VG \ {v} & v2' in VG \ {v} by GLIB_000:50; then
    A4: not v1 in {v} & not v2 in {v} by XBOOLE_0:def 4; then
    A5: v1 <> v & v2 <> v by TARSKI:def 1;
        consider T being Trail of W;
    A6: T is_Walk_from v1, v2 by A3, GLIB_001:161;
        now let x be set; assume
        A7: x in T.vertices();
            now assume x = v; then
                v = T.first() or v = T.last() by A1, A7, GLIB_001:144;
                hence contradiction by A5,A6,GLIB_001:def 23;
            end; then
            not x in {v} by TARSKI:def 1; then
            x in VG \ {v} by A7, XBOOLE_0:def 4;
            hence x in VG2 by GLIB_000:50;
        end; then
    A8: T.vertices() c= VG2 by TARSKI:def 3;
    A9: T.1 = v1 & T.(len T) = v2 by A6, GLIB_001:18;
        now let e be set; assume
        A10: e in T.edges(); then
            consider n being even Nat such that
        A11: 1 <= n & n <= len T & T.n = e by GLIB_001:100;
            n in dom T by A11, FINSEQ_3:27; then
            consider n1 being odd Nat such that
        A12: n1 = n-1 & n-1 in dom T & n+1 in dom T &
               T.n Joins T.(n1), T.(n+1),G1 by GLIB_001:10;
        A13: n1 <= len T & n+1 <= len T by A12, FINSEQ_3:27;
            now assume
            A14: e in v.edgesInOut(); then
            A15: e = ev by A2, TARSKI:def 1;
                now per cases by A11,A12,A14, GLIB_000:68;
                suppose
                A16: T.(n1) = v; then
                A17: T.vertexAt(n1) = v by A13, GLIB_001:def 8;
                A18: n1 <> 1 by A4,TARSKI:def 1, A9, A16;
                A19: 1 <= n1 by HEYTING3:1; then
                A20: 1 < n1 by A18,REAL_1:def 5;
                    reconsider n2 = n1 - 1 as even Nat
                      by A19,INT_1:18;
                    T.n2 in v.edgesInOut() by A13, A17,A20,GLIB_001:12; then
                A21: T.n = T.n2 by A2,A15,A11,TARSKI:def 1;
                    n - 1  < n - 0 by REAL_1:92; then
                A22: n1 - 1 < n - 0 by A12, REAL_1:92;
                    1+1 <= n1 by A20, NAT_1:38; then
                    1+1-1 <= n2 by REAL_1:92;
                    hence contradiction by A11, A21, A22, GLIB_001:139; end;
                suppose
                A23: T.(n+1) = v; then
                A24: T.vertexAt(n+1) = v by A13, GLIB_001:def 8;
                A25: n+1 < len T by A5,A9,A23,A13,REAL_1:def 5; then
                    T.(n+1+1) in v.edgesInOut() by A24, GLIB_001:11; then
                A26: T.n = T.(n+1+1) by A2,A11,A15,TARSKI:def 1;
                A27: n + 0 < n+(1+1) by XREAL_1:10;
                    n+1+1 <= len T by A25, NAT_1:38;
                    hence contradiction by A11, A26, A27, GLIB_001:139; end;
                end;
                hence contradiction;
            end; then
            e in (the_Edges_of G1) \ v.edgesInOut() by A10, XBOOLE_0:def 4;
then
            e in (the_Edges_of G1) \ G1.edgesInOut({v}) by GLIB_000:def 42;then
            e in G1.edgesBetween( the_Vertices_of G1 \ {v}) by GLIB_000:38;
            hence e in the_Edges_of G2 by GLIB_000:50;
        end; then
        T.edges() c= the_Edges_of G2 by TARSKI:def 3; then
        reconsider W'=T as Walk of G2 by A8, GLIB_001:171;
        W' is_Walk_from v1',v2' by A6, GLIB_001:20;
        hence ex W being Walk of G2 st W is_Walk_from v1',v2';
    end;
    hence G2 is connected by Def1;
end;

Lm6:
for G being _Graph holds
  (ex v1 being Vertex of G st for v2 being Vertex of G
    ex W being Walk of G st W is_Walk_from v1,v2) implies
    G is connected proof
    let G be _Graph;
    given v1 being Vertex of G such that
A1: for v2 being Vertex of G ex W being Walk of G st W is_Walk_from v1,v2;
    now let x,y be Vertex of G;
        consider W1 being Walk of G such that
    A2: W1 is_Walk_from v1,x by A1;
        consider W2 being Walk of G such that
    A3: W2 is_Walk_from v1,y by A1;
        W1.reverse() is_Walk_from x,v1 by A2, GLIB_001:24; then
        W1.reverse().append(W2) is_Walk_from x,y by A3, GLIB_001:32;
        hence ex W being Walk of G st W is_Walk_from x,y;
    end;
    hence G is connected by Def1;
end;

Lm7:
  for G being _Graph holds
  (ex v being Vertex of G st G.reachableFrom(v) = the_Vertices_of G)
    implies G is connected proof
    let G be _Graph;
    assume ex v being Vertex of G st G.reachableFrom(v)=the_Vertices_of G; then
    consider v being Vertex of G such that
A1: G.reachableFrom(v) = the_Vertices_of G;
    now let x,y be Vertex of G;
        consider W1 being Walk of G such that
    A2: W1 is_Walk_from v,x by A1,Def5;
        consider W2 being Walk of G such that
    A3: W2 is_Walk_from v,y by A1,Def5;
        W1.reverse() is_Walk_from x,v by A2, GLIB_001:24; then
        W1.reverse().append(W2) is_Walk_from x,y by A3, GLIB_001:32;
        hence ex W being Walk of G st W is_Walk_from x,y;
    end;
    hence G is connected by Def1;
end;

Lm8:
for G being _Graph holds
  G is connected implies
    for v being Vertex of G holds G.reachableFrom(v) = the_Vertices_of G proof
    let G be _Graph; assume
A1: G is connected;
    let v be Vertex of G;
    now let x be set;
        thus x in G.reachableFrom(v) implies x in the_Vertices_of G;
        assume x in the_Vertices_of G; then
        consider W being Walk of G such that
    A2: W is_Walk_from v,x by A1, Def1;
        thus x in G.reachableFrom(v) by A2, Def5;
    end;
    hence G.reachableFrom(v) = the_Vertices_of G by TARSKI:2;
end;

Lm9:
  for G1,G2 being _Graph,v1 being Vertex of G1, v2 being Vertex of G2
    st G1 == G2 & v1 = v2
    holds G1.reachableFrom(v1) = G2.reachableFrom(v2) proof
    let G1,G2 be _Graph, v1 be Vertex of G1, v2 be Vertex of G2; assume
A1: G1 == G2 & v1 = v2;
    now let x be set;
        hereby assume x in G1.reachableFrom(v1); then
            consider W being Walk of G1 such that
        A2: W is_Walk_from v2,x by A1, Def5;
            reconsider W2 = W as Walk of G2 by A1, GLIB_001:180;
            W2 is_Walk_from v2,x by A2, GLIB_001:20;
            hence x in G2.reachableFrom(v2) by Def5;
        end;
        assume x in G2.reachableFrom(v2); then
        consider W being Walk of G2 such that
    A3: W is_Walk_from v1,x by A1, Def5;
        reconsider W2 = W as Walk of G1 by A1, GLIB_001:180;
        W2 is_Walk_from v1,x by A3, GLIB_001:20;
        hence x in G1.reachableFrom(v1) by Def5;
    end;
    hence thesis by TARSKI:2;
end;

Lm10:
  for G1 being _Graph, G2 being connected Subgraph of G1 holds
    G2 is spanning implies G1 is connected  proof
    let G1 be _Graph, G2 be connected Subgraph of G1; assume
A1: G2 is spanning;
    now let u',v' be Vertex of G1;
        reconsider u=u', v=v' as Vertex of G2 by A1,GLIB_000:def 35;
        consider W being Walk of G2 such that
    A2: W is_Walk_from u,v by Def1;
        reconsider W as Walk of G1 by GLIB_001:168;
        take W;
        thus W is_Walk_from u',v' by A2, GLIB_001:20;
    end;
    hence G1 is connected by Def1;
end;

Lm11:
for G being _Graph holds
  G is connected iff G.componentSet() = {the_Vertices_of G} proof
    let G be _Graph;
    hereby assume
    A1: G is connected;
        now let x be set;
            hereby assume x in G.componentSet(); then
                consider v being Vertex of G such that
            A2: x = G.reachableFrom(v) by Def8;
                x = the_Vertices_of G by A1,A2,Lm8;
                hence x in {the_Vertices_of G} by TARSKI:def 1;
            end;
            assume x in {the_Vertices_of G}; then
        A3: x = the_Vertices_of G by TARSKI:def 1;
            consider v being Vertex of G;
            G.reachableFrom(v) = the_Vertices_of G by A1,Lm8;
            hence x in G.componentSet() by A3,Def8;
        end;
        hence G.componentSet() = {the_Vertices_of G} by TARSKI:2;
    end;
    assume G.componentSet() = {the_Vertices_of G}; then
    the_Vertices_of G in G.componentSet() by TARSKI:def 1; then
    consider v being Vertex of G such that
A4: G.reachableFrom(v) = the_Vertices_of G by Def8;
    thus G is connected by A4,Lm7;
end;

Lm12:
for G1,G2 being _Graph holds
  G1 == G2 implies G1.componentSet() = G2.componentSet() proof
    let G1,G2 be _Graph; assume
A1: G1 == G2;
    now let x be set;
        hereby assume x in G1.componentSet(); then
            consider v1 being Vertex of G1 such that
        A2: x = G1.reachableFrom(v1) by Def8;
            reconsider v2 = v1 as Vertex of G2 by A1,GLIB_000:def 36;
            x = G2.reachableFrom(v2) by A1,A2,Lm9;
            hence x in G2.componentSet() by Def8;
        end;
        assume x in G2.componentSet(); then
        consider v2 being Vertex of G2 such that
    A3: x = G2.reachableFrom(v2) by Def8;
        reconsider v1 = v2 as Vertex of G1 by A1,GLIB_000:def 36;
        x = G1.reachableFrom(v1) by A1,A3,Lm9;
        hence x in G1.componentSet() by Def8;
    end;
    hence thesis by TARSKI:2;
end;

Lm13:
  for G being _Graph, x being set holds
  x in G.componentSet() implies
    x is non empty Subset of the_Vertices_of G proof
    let G be _Graph, x be set;
    assume x in G.componentSet(); then
    consider v being Vertex of G such that
A1: x = G.reachableFrom(v) by Def8;
    thus thesis by A1;
end;

Lm14:
  for G being _Graph, C being Component of G holds
    the_Edges_of C = G.edgesBetween(the_Vertices_of C) proof
    let G be _Graph, C be Component of G;
    reconsider VC = the_Vertices_of C as Subset of the_Vertices_of G;
    set EB = G.edgesBetween(VC);
    C.edgesBetween(the_Vertices_of C) c= EB by GLIB_000:79; then
A1: the_Edges_of C c= EB by GLIB_000:37;
    now let e be set;
        thus e in the_Edges_of C implies e in EB by A1;
        assume
    A2: e in EB;
        now assume
        A3: not e in the_Edges_of C;
            consider GX being inducedSubgraph of G,VC,EB;
        A4: the_Vertices_of GX = VC & the_Edges_of GX = EB
              by GLIB_000:def 39; then
        A5: C is spanning Subgraph of GX
              by A1,GLIB_000:47,GLIB_000:def 35;then
            GX is connected by Lm10; then
            not C c< GX by Def7; then
            GX == C or not C c= GX by GLIB_000:def 38;
            hence contradiction by A3,A2,A4,GLIB_000:def 36,A5,GLIB_000:def 37;
        end;
        hence e in the_Edges_of C;
    end;
    hence thesis by TARSKI:2;
end;

Lm15:
  for G being _Graph, C1,C2 being Component of G holds
     the_Vertices_of C1 = the_Vertices_of C2 iff C1 == C2 proof
    let G be _Graph, C1,C2 be Component of G;
    hereby assume
    A1: the_Vertices_of C1 = the_Vertices_of C2; then
        the_Edges_of C1 = G.edgesBetween(the_Vertices_of C2) by Lm14
                       .= the_Edges_of C2 by Lm14;
        hence C1 == C2 by A1, GLIB_000:89;
    end;
    assume C1 == C2;
    hence thesis by GLIB_000:def 36;
end;

Lm16:
  for G being _Graph, C being Component of G, v being Vertex of G holds
    v in the_Vertices_of C iff the_Vertices_of C = G.reachableFrom(v) proof
    let G be _Graph, C be Component of G, v be Vertex of G;
    hereby assume
    A1: v in the_Vertices_of C;
        now let x be set;
            hereby assume x in the_Vertices_of C; then
                reconsider x'=x as Vertex of C;
                consider W being Walk of C such that
            A2: W is_Walk_from v,x' by A1, Def1;
                reconsider W as Walk of G by GLIB_001:168;
                W is_Walk_from v,x by A2, GLIB_001:20;
                hence x in G.reachableFrom(v) by Def5;
            end;
            assume
        A3: x in G.reachableFrom(v); then
            reconsider x'=x as Vertex of G;
            consider CX being inducedSubgraph of G,G.reachableFrom(x');
            not C c< CX & not CX c< C by Def7; then
        A4: (C == CX or not C c= CX) & (CX == C or not CX c= C)
              by GLIB_000:def 38;
        A5: the_Vertices_of CX = G.reachableFrom(x') &
              the_Edges_of CX = G.edgesBetween(G.reachableFrom(x'))
              by GLIB_000:def 39; then
        A6: x in the_Vertices_of CX by Lm1;
        A7: G.reachableFrom(x') = G.reachableFrom(v) by A3, Lm3;
            now let z be set; assume z in the_Vertices_of C; then
                consider W being Walk of C such that
            A8: W is_Walk_from v,z by A1, Def1;
                reconsider W as Walk of G by GLIB_001:168;
                W is_Walk_from v,z by A8, GLIB_001:20;
                hence z in the_Vertices_of CX by A5,A7,Def5;
            end; then
        A9: the_Vertices_of C c= the_Vertices_of CX by TARSKI:def 3;
            now let e be set; assume
            A10: e in the_Edges_of C;
                set v1 = (the_Source_of C).e, v2 = (the_Target_of C).e;
                reconsider v1,v2 as Vertex of C by A10, FUNCT_2:7;
                e Joins v1,v2,C by A10, GLIB_000:def 15; then
            A11: e Joins v1,v2,G by GLIB_000:75;
                consider W1 being Walk of C such that
            A12: W1 is_Walk_from v,v1 by A1, Def1;
                reconsider W1 as Walk of G by GLIB_001:168;
            A13: W1 is_Walk_from v,v1 by A12, GLIB_001:20;
                consider W2 being Walk of C such that
            A14: W2 is_Walk_from v,v2 by A1, Def1;
                reconsider W2 as Walk of G by GLIB_001:168;
                W2 is_Walk_from v,v2 by A14, GLIB_001:20; then
                v1 in G.reachableFrom(x') &
                  v2 in G.reachableFrom(x') by Def5,A7,A13;
                hence e in the_Edges_of CX by A11,A5,GLIB_000:35;
            end; then
            the_Edges_of C c= the_Edges_of CX by TARSKI:def 3; then
            C is Subgraph of CX by A9, GLIB_000:47;
            hence x in the_Vertices_of C
              by A4,A6,GLIB_000:def 36,GLIB_000:def 37;
        end;
        hence the_Vertices_of C = G.reachableFrom(v) by TARSKI:2;
    end;
    assume the_Vertices_of C = G.reachableFrom(v);
    hence v in the_Vertices_of C by Lm1;
end;

Lm17: ::tGCOMP05
  for G being _Graph, C1,C2 being Component of G, v being set st
    v in the_Vertices_of C1 & v in the_Vertices_of C2 holds C1 == C2 proof
    let G be _Graph, C1,C2 be Component of G, v be set; assume
A1: v in the_Vertices_of C1 & v in the_Vertices_of C2; then
    reconsider v' = v as Vertex of G;
    the_Vertices_of C1 = G.reachableFrom(v') &
    the_Vertices_of C2 = G.reachableFrom(v') by A1, Lm16;
    hence C1 == C2 by Lm15;
end;

Lm18:
for G being _Graph holds
  G is connected iff G.numComponents() = 1 proof
    let G be _Graph;
    hereby assume G is connected; then
        G.componentSet() = {the_Vertices_of G} by Lm11; then
        Card G.componentSet() = 1 by CARD_1:50, CARD_2:20;
        hence G.numComponents() = 1;
    end;
    assume G.numComponents() = 1; then
    Card G.componentSet() = 1; then
    consider V being set such that
A1: G.componentSet() = {V} by CARD_2:60;
A2: V in G.componentSet() by A1, TARSKI:def 1;
    now let v be set; assume v in the_Vertices_of G; then
        reconsider v'=v as Vertex of G;
        now assume
        A3: not v in V;
            set V2 = G.reachableFrom(v');
            V2 in G.componentSet() by Def8; then
            not v in V2 by A1,A3,TARSKI:def 1;
            hence contradiction by Lm1;
        end;
        hence v in V;
    end; then
    the_Vertices_of G c= V by TARSKI:def 3; then
    V = the_Vertices_of G by A2,XBOOLE_0:def 10;
    hence G is connected by A1,Lm11;
end;

Lm19:
for G1,G2 being _Graph holds
  G1 == G2 implies G1.numComponents() = G2.numComponents() by Lm12;

Lm20:
  for G being connected _Graph, v being Vertex of G holds
    v is non cut-vertex iff
    for G2 being removeVertex of G,v holds
      G2.numComponents() <=` G.numComponents() proof
    let G be connected _Graph, v be Vertex of G;
    hereby assume v is non cut-vertex; then
        consider G3 being removeVertex of G,v such that
    A1: not G.numComponents() <` G3.numComponents() by Def10;
    A2: G3.numComponents() <=` G.numComponents() by A1, CARD_1:14;
        let G2 be removeVertex of G,v;
        G2 == G3 by GLIB_000:96;
        hence G2.numComponents() <=` G.numComponents() by A2,Lm19;
    end;
    assume
A3: for G2 being removeVertex of G,v holds
      G2.numComponents() <=` G.numComponents();
    now assume
    A4: for G3 being removeVertex of G,v holds
          G.numComponents() <` G3.numComponents();
        consider X being removeVertex of G,v;
    A5: X.numComponents() <=` G.numComponents() by A3;
        G.numComponents() <` X.numComponents() by A4;
        hence contradiction by A5,CARD_1:14;
    end;
    hence v is non cut-vertex by Def10;
end;

Lm21:
  for G being connected _Graph, v being Vertex of G,
      G2 being removeVertex of G,v st not v is cut-vertex holds
   G2 is connected proof
    let G be connected _Graph, v be Vertex of G, G2 be removeVertex of G,v;
    assume
A1: not v is cut-vertex;
    G.numComponents() = 1 by Lm18; then
    G2.numComponents() c= succ {} by A1,Lm20,ORDINAL2:def 4, CARD_2:20; then
    G2.numComponents() c= {} \/ {{}} by ORDINAL1:def 1; then
A2: G2.numComponents() = {} or G2.numComponents() = {{}} by ZFMISC_1:39;
    consider x being Vertex of G2;
    Card G2.componentSet() <> {} by CARD_2:59; then
    G2.numComponents() = {} \/ {{}} by A2
                      .= 1 by ORDINAL2:def 4, CARD_2:20, ORDINAL1:def 1;
    hence G2 is connected by Lm18;
end;

Lm22:
  for G being non trivial finite connected _Graph holds
   ex v1,v2 being Vertex of G st v1 <> v2 & not v1 is cut-vertex &
      not v2 is cut-vertex proof
   defpred P[Nat] means for G being non trivial finite connected _Graph st
     G.order() = $1 holds ex v1,v2 being Vertex of G st v1 <> v2 &
     not v1 is cut-vertex & not v2 is cut-vertex;
 now let k be Nat; assume
 A1: for n being Nat st n < k holds P[n];
  now per cases by REAL_1:def 5;
  suppose
  A2: k < 2;
   now let G be non trivial finite connected _Graph such that
   A3: G.order() = k;
       G.order() < 1+1 by A2, A3; then
   A4: G.order() <= 1 by NAT_1:38;
       1 <= G.order() by GLIB_000:28; then
       G.order() = 1 by A4, XREAL_1:1;
       hence ex v1,v2 being Vertex of G st v1 <> v2 &
       not v1 is cut-vertex & not v2 is cut-vertex by GLIB_000:29;
   end;
   hence P[k]; end;
  suppose
  A5: k = 2;
   now let G be non trivial finite connected _Graph such that
   A6: G.order() = k;
       consider v1,v2 being Vertex of G such that
   A7: v1 <> v2 by GLIB_000:24;
   A8: G.numComponents() = 1 by Lm18;
       take v1, v2;
       thus v1 <> v2 by A7;
    now let v be Vertex of G;
        consider GRV being removeVertex of G,v;
        assume v is cut-vertex; then
    A9: 1 < GRV.numComponents() by A8, Def11;
        GRV.order() + 1 = 2 by A5,A6,GLIB_000:51; then
        GRV.order() = 2 - 1; then
        reconsider GRV' = GRV as trivial _Graph by GLIB_000:29;
        GRV' is connected;
        hence contradiction by A9,Lm18;
    end;
    hence not v1 is cut-vertex & not v2 is cut-vertex;
   end;
   hence P[k]; end;
  suppose 2 < k;
   now let G be non trivial finite connected _Graph such that
   A10: G.order() = k;
   A11: G.numComponents() = 1 by Lm18;
    now per cases;
    suppose
    A12: not ex v being Vertex of G st v is cut-vertex;
        consider v1,v2 being Vertex of G such that
    A13: v1 <> v2 by GLIB_000:24;
        take v1,v2;
        thus v1 <> v2 by A13;
        thus not v1 is cut-vertex & not v2 is cut-vertex by A12; end;
    suppose ex cv being Vertex of G st cv is cut-vertex; then
        consider cv being Vertex of G such that
    A14: cv is cut-vertex;
        consider G2 being removeVertex of G,cv;
        1 < G2.numComponents() by A11, A14, Def11; then
        1+1 <= G2.numComponents() by NAT_1:38; then
        2 <= card G2.componentSet(); then
        card 2 <= card G2.componentSet() by CARD_1:66; then
        Card 2 c= Card G2.componentSet() by CARD_2:57; then
        2 c= Card G2.componentSet() by CARD_1:66; then
        consider C1,C2 being set such that
    A15: C1 in G2.componentSet() & C2 in G2.componentSet() &
        C1 <> C2 by PENCIL_1:2;
        reconsider C1,C2 as Element of G2.componentSet() by A15;
    A16: G2.order() + 1 = k by A10, GLIB_000:51;
        G.edgesBetween( (the_Vertices_of G) \ {cv} ) =
          (the_Edges_of G) \ (G.edgesInOut({cv})) by GLIB_000:38;then
        G.edgesBetween( (the_Vertices_of G) \ {cv} ) =
          (the_Edges_of G) \ cv.edgesInOut() by GLIB_000:def 42; then
    A17: the_Vertices_of G2 = (the_Vertices_of G) \ {cv} &
        the_Edges_of G2 = (the_Edges_of G) \ cv.edgesInOut() by GLIB_000:50;
    A18: now let C be Component of G2;
      now assume
      A19: for a being Vertex of C holds
          not ex e being set st e Joins cv,a,G;
          consider x being Vertex of C;
          the_Vertices_of C c= the_Vertices_of G2; then
          reconsider x'=x as Vertex of G2 by TARSKI:def 3;
          the_Vertices_of G2 c= the_Vertices_of G; then
          reconsider x''=x' as Vertex of G by TARSKI:def 3;
          not x' in {cv} by A17, XBOOLE_0:def 4; then
      A20: x <> cv by TARSKI:def 1;
          consider W being Walk of G such that
      A21: W is_Walk_from cv,x'' by Def1;
          consider P being Path of W;
          P is_Walk_from cv,x'' by A21, GLIB_001:161; then
      A22: P.first() = cv & P.last() = x by GLIB_001:def 23; then
      A23: P is non trivial by A20, GLIB_001:128; then
      A24: len P <> 1 by GLIB_001:126;
          1 <= len P by HEYTING3:1; then
          2*0+1 < len P by A24, REAL_1:def 5; then
          P.(1+1) Joins P.1,P.(1+2),G by GLIB_001:def 3;then
      A25: P.2 Joins cv, P.3, G by A22,GLIB_001:def 6;
      A26: the_Vertices_of C = G2.reachableFrom(x') by Lm16;
          set P2 = P.cut(2*1+1, len P);
      A27: 2*1+1 <= len P by A23, GLIB_001:126; then
          P2 is_Walk_from P.3, P.(len P) by GLIB_001:38; then
      A28: P2 is_Walk_from P.3, x by A22, GLIB_001:def 7;
      A29: P.(2*0+1)=cv & P.(len P)=x by A22,GLIB_001:def 6,GLIB_001:def 7;
       now assume cv in P2.vertices(); then
           consider n being odd Nat such that
       A30: n <= len P2 & P2.n = cv by GLIB_001:88;
       A31: 1 <= n by HEYTING3:1; then
           n in dom P2 by A30, FINSEQ_3:27; then
       A32: P.(3+n-1) = cv & 3+n-1 in dom P by A27, A30, GLIB_001:48;
       A33: cv = P.(n+2) & 2+n <= len P by A32, FINSEQ_3:27;
           1+0 < n+2 by A31, XREAL_1:10;
           hence contradiction by A20,A29,A33,GLIB_001:def 28;
       end; then reconsider P2 as Walk of G2 by GLIB_001:172;
          P2 is_Walk_from P.3, x by A28, GLIB_001:20; then
          P2.reverse() is_Walk_from x,P.3 by GLIB_001:24;then
          P.3 in G2.reachableFrom(x') by Def5;
          hence contradiction by A19,A25,A26;
      end; then consider a being Vertex of C, e being set such that
     A34: e Joins cv,a,G;
     A35: e in the_Edges_of G by A34,GLIB_000:def 15;
       now per cases;
       suppose C is trivial; then
           consider v'' being Vertex of C such that
       A36: the_Vertices_of C = {v''} by GLIB_000:25;
           the_Vertices_of C c= the_Vertices_of G2; then
           reconsider v'=v'' as Vertex of G2 by TARSKI:def 3;
           not v' in {cv} by A17, XBOOLE_0:def 4; then
       A37: v' <> cv by TARSKI:def 1;
       A38: {v'} = G2.reachableFrom(v') by A36, Lm16;
           reconsider v=v' as Vertex of G by GLIB_000:45;
           take v;
           thus v in the_Vertices_of C;
        now assume
        A39: v is cut-vertex;
            consider G3 being removeVertex of G,v;
        A40: 1 < G3.numComponents() by A11,A39,Def11;
        A41: now let e, z be set; assume
         A42: e Joins v,z,G; then
         A43: e in the_Edges_of G & z in the_Vertices_of G
               by GLIB_000:16,GLIB_000:def 15;
          now assume
          A44: z <> v & z <> cv; then
              not e in cv.edgesInOut() by A37,A42,GLIB_000:68; then
              e in the_Edges_of G2 by A17, A43, XBOOLE_0:def 4; then
          A45: e Joins v,z,G2 by A42, GLIB_000:76;
              v in G2.reachableFrom(v') by Lm1; then
              z in G2.reachableFrom(v') by A45, Lm2;
              hence contradiction by A44, TARSKI:def 1,A38;
          end;
          hence z = v or z = cv;
         end;
         now let x,y be Vertex of G3;
          now per cases;
          suppose
          A46: x = y; set W = G3.walkOf(x);
              take W;
              thus W is_Walk_from x,y by A46, GLIB_001:14; end;
          suppose
          A47: x <> y;
              reconsider x'=x,y'=y as Vertex of G by GLIB_000:45;
              consider W being Walk of G such that
          A48: W is_Walk_from x',y' by Def1;
              consider P being Path of W;
          A49: P is_Walk_from x',y' by A48, GLIB_001:161;
              the_Vertices_of G3 = (the_Vertices_of G)\{v} by GLIB_000:50; then
              not x in {v} & not y in {v} by XBOOLE_0:def 4; then
              x <> v & y <> v by TARSKI:def 1; then
          A50: v <> P.1 & v <> P.(len P) by A49, GLIB_001:18;
           now assume v in P.vertices(); then
               consider n being odd Nat such that
           A51: n <= len P & P.n = v by GLIB_001:88;
               1 <= n by HEYTING3:1; then
               1 < n by A50, A51, REAL_1:def 5; then
               1+1 <= n by NAT_1:38; then
               reconsider n2 = n-2*1 as odd Nat by INT_1:18;
               set e1 = P.(n2+1), e2 = P.(n+1);
               n - 2 < len P - 0 by A51, REAL_1:92; then
               e1 Joins P.n2, P.(n2+2), G by GLIB_001:def 3; then
           A52: e1 Joins v, P.n2, G by A51,GLIB_000:17;
           A53: n < len P by A50, A51, REAL_1:def 5; then
           A54: e2 Joins v, P.(n+2), G by A51, GLIB_001:def 3;
            now assume
            A55: P.n2 = v;
                n2 < n - 0 by REAL_1:92;
                hence contradiction by A50,A51,A55,GLIB_001:def 28;
            end; then
           A56: P.n2 = cv by A41,A52;
           A57: n+2 <= len P by A53, GLIB_001:1;
            now assume
            A58: P.(n+2) = v;
                n+0 < n+2 by XREAL_1:10;
                hence contradiction by A50,A57,A58,A51,GLIB_001:def 28;
            end; then
           A59: P.(n+2) = cv by A41,A54;
               n2 < n - 0 by REAL_1:92; then
               n2+0 < n+2 by XREAL_1:10; then
               cv = P.1 & cv = P.(len P) by A56,A57,A59,GLIB_001:def 28; then
               cv = x & cv = y by A49, GLIB_001:18;
               hence contradiction by A47;
           end; then reconsider P as Walk of G3 by GLIB_001:172;
              take P;
              thus P is_Walk_from x,y by A49, GLIB_001:20; end;
          end;
          hence ex P being Walk of G3 st P is_Walk_from x,y;
         end; then
            G3 is connected by Def1;
            hence contradiction by A40,Lm18;
        end;
        hence not v is cut-vertex; end;
       suppose C is non trivial; then reconsider C'=C as non trivial _Graph;
           C.order() <= G2.order() by GLIB_000:78; then
           C.order()+0 < G2.order()+1 by XREAL_1:10; then
           consider v1, v2 being Vertex of C' such that
       A60: v1 <> v2 & not v1 is cut-vertex & not v2 is cut-vertex by A1,A16;
           consider C'R1 being removeVertex of C',v1;
           consider C'R2 being removeVertex of C',v2;
       A61: C'R1 is connected & C'R2 is connected by A60, Lm21;
           v1 in the_Vertices_of G2 & v2 in the_Vertices_of G2
             by GLIB_000:45; then
           not v1 in {cv} & not v2 in {cv} by A17, XBOOLE_0:def 4; then
       A62: v1 <> cv & v2 <> cv by TARSKI:def 1;
       A63: the_Vertices_of C'R1 = (the_Vertices_of C') \ {v1} &
           the_Vertices_of C'R2 = (the_Vertices_of C') \ {v2} by GLIB_000:50;
        now per cases;
        suppose not v1 in cv.allNeighbors(); then
        A64: v1 <> a by A34,GLIB_000:74;
            reconsider v'=v1 as Vertex of G2 by GLIB_000:45;
            reconsider v =v' as Vertex of G by GLIB_000:45;
            take v;
            thus v in the_Vertices_of C;
            consider G3 being removeVertex of G,v;
        A65: the_Vertices_of G3 = (the_Vertices_of G) \ {v} by GLIB_000:50;
            not cv in {v} by A62, TARSKI:def 1; then
            reconsider cv' = cv as Vertex of G3 by A65, XBOOLE_0:def 4;
        A66: the_Vertices_of C = G2.reachableFrom(v') by Lm16;
         now let y be Vertex of G3;
          now per cases;
          suppose y = cv; then
              G3.walkOf(y) is_Walk_from cv',y by GLIB_001:14;
              hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
          suppose
          A67: y <> cv;
           now per cases;
           suppose
           A68: y in the_Vertices_of C;
               not y in {v1} by A65,XBOOLE_0:def 4; then
           A69: y in the_Vertices_of C'R1 by A63,A68,XBOOLE_0:def 4;
                not a in {v1} by A64, TARSKI:def 1; then
               a in the_Vertices_of C'R1 by A63,XBOOLE_0:def 4; then
               consider W being Walk of C'R1 such that
           A70: W is_Walk_from y,a by A69, A61, Def1;
           A71: W.1 = y & W.(len W) = a by A70, GLIB_001:18;
           A72: now assume v in W.vertices(); then
                not v in {v1} by A63,XBOOLE_0:def 4;
                hence contradiction by TARSKI:def 1;
               end;
               reconsider W as Walk of C by GLIB_001:168;
               reconsider W as Walk of G2 by GLIB_001:168;
               reconsider W as Walk of G by GLIB_001:168;
               not v in W.vertices() by A72, GLIB_001:99; then
               reconsider W as Walk of G3 by GLIB_001:172;
           A73: W is_Walk_from y,a by A71, GLIB_001:18;
               not e in v.edgesInOut() by A34,A62,A64,GLIB_000:68; then
               e in (the_Edges_of G)\v.edgesInOut() by A35,XBOOLE_0:def 4;then
               e in (the_Edges_of G)\G.edgesInOut({v}) by GLIB_000:def 42;then
               e in G.edgesBetween((the_Vertices_of G)\{v}) by GLIB_000:38;then
               e in the_Edges_of G3 by GLIB_000:50; then
               e Joins cv,a,G3 by A34, GLIB_000:76; then
               e Joins a,cv,G3 by GLIB_000:17; then
               W.addEdge(e) is_Walk_from y,cv by A73, GLIB_001:67; then
               W.addEdge(e).reverse() is_Walk_from cv,y by GLIB_001:24;
               hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
           suppose
           A74: not y in the_Vertices_of C;
               reconsider y'=y as Vertex of G by GLIB_000:45;
               consider W being Walk of G such that
           A75: W is_Walk_from cv,y' by Def1;
               consider P being Path of W;
           A76: P is_Walk_from cv,y' by A75, GLIB_001:161;
           A77: P.1 = cv & P.(len P) = y' by A76, GLIB_001:18;
            now assume v in P.vertices(); then
                consider n being odd Nat such that
            A78: n <= len P & P.n = v by GLIB_001:88;
                1 <= n by HEYTING3:1; then
            A79: 1 < n by A62,A77,A78,REAL_1:def 5;
                set P2 = P.cut(n,len P);
            A80: P2 is_Walk_from v, y' by A78, A77, GLIB_001:38;
             now assume cv in P2.vertices(); then
                 consider m being odd Nat such that
             A81: m <= len P2 & P2.m = cv by GLIB_001:88;
             A82: 1 <= m by HEYTING3:1; then
                 m in dom P2 by A81, FINSEQ_3:27; then
             A83: P.(n+m-1) = cv & n+m-1 in dom P by A78,A81,GLIB_001:48;then
                 reconsider nm1 = n+m-1 as odd Nat;
                 1+1 < n+m by A79, A82, XREAL_1:10; then
                 1+1-1 < n+m-1 by REAL_1:92; then
             A84: 2*0+1 < n+m-1;
                 n+m-1 is Nat by A83; then
                 n+m-1 <= len P by A83, FINSEQ_3:27;
                 hence contradiction by A67,A77,A83, A84, GLIB_001:def 28;
             end; then reconsider P2 as Walk of G2 by GLIB_001:172;
                P2 is_Walk_from v,y' by A80, GLIB_001:20;
                hence contradiction by A66, A74, Def5;
            end; then reconsider P as Walk of G3 by GLIB_001:172;
               take P;
               thus P is_Walk_from cv',y by A76, GLIB_001:20; end;
           end;
           hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
          end;
             hence ex W being Walk of G3 st W is_Walk_from cv',y;
         end; then G3 is connected by Lm6; then
            G3.numComponents() = 1 by Lm18;
            hence not v is cut-vertex by A11, Def11; end;
        suppose v1 in cv.allNeighbors() & not v2 in cv.allNeighbors(); then
        A85: v2 <> a by A34, GLIB_000:74;
            reconsider v'=v2 as Vertex of G2 by GLIB_000:45;
            reconsider v =v' as Vertex of G by GLIB_000:45;
            take v;
            thus v in the_Vertices_of C;
            consider G3 being removeVertex of G,v;
        A86: the_Vertices_of G3 = (the_Vertices_of G) \ {v} by GLIB_000:50;
            not cv in {v} by A62, TARSKI:def 1; then
            reconsider cv' = cv as Vertex of G3 by A86, XBOOLE_0:def 4;
        A87: the_Vertices_of C = G2.reachableFrom(v') by Lm16;
         now let y be Vertex of G3;
          now per cases;
          suppose y = cv; then
              G3.walkOf(y) is_Walk_from cv',y by GLIB_001:14;
              hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
          suppose
          A88: y <> cv;
           now per cases;
           suppose
           A89: y in the_Vertices_of C;
               not y in {v2} by A86,XBOOLE_0:def 4; then
           A90: y in the_Vertices_of C'R2 by A63,A89,XBOOLE_0:def 4;
               not a in {v2} by A85, TARSKI:def 1; then
               a in the_Vertices_of C'R2 by A63,XBOOLE_0:def 4; then
               consider W being Walk of C'R2 such that
           A91: W is_Walk_from y,a by A90, A61, Def1;
           A92: W.1 = y & W.(len W) = a by A91, GLIB_001:18;
           A93: now assume v in W.vertices(); then
                not v in {v2} by XBOOLE_0:def 4,A63;
                hence contradiction by TARSKI:def 1;
               end;
               reconsider W as Walk of C by GLIB_001:168;
               reconsider W as Walk of G2 by GLIB_001:168;
               reconsider W as Walk of G by GLIB_001:168;
               not v in W.vertices() by A93,GLIB_001:99; then
               reconsider W as Walk of G3 by GLIB_001:172;
           A94: W is_Walk_from y,a by A92, GLIB_001:18;
               not e in v.edgesInOut() by A34,A62,A85,GLIB_000:68; then
               e in (the_Edges_of G) \ v.edgesInOut() by A35,XBOOLE_0:def 4;
then
               e in (the_Edges_of G)\G.edgesInOut({v}) by GLIB_000:def 42; then
               e in G.edgesBetween(the_Vertices_of G\{v}) by GLIB_000:38; then
               e in the_Edges_of G3 by GLIB_000:50; then
                e Joins cv,a,G3 by A34, GLIB_000:76; then
                e Joins a,cv,G3 by GLIB_000:17; then
                W.addEdge(e) is_Walk_from y,cv by A94, GLIB_001:67; then
                W.addEdge(e).reverse() is_Walk_from cv,y by GLIB_001:24;
                hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
            suppose
            A95: not y in the_Vertices_of C;
                reconsider y'=y as Vertex of G by GLIB_000:45;
                consider W being Walk of G such that
            A96: W is_Walk_from cv,y' by Def1;
                consider P being Path of W;
            A97: P is_Walk_from cv,y' by A96, GLIB_001:161;
            A98: P.1 = cv & P.(len P) = y' by A97, GLIB_001:18;
             now assume v in P.vertices(); then
                 consider n being odd Nat such that
             A99: n <= len P & P.n = v by GLIB_001:88;
                 1 <= n by HEYTING3:1; then
             A100: 1 < n by A62,A98,A99,REAL_1:def 5;
                 set P2 = P.cut(n,len P);
             A101: P2 is_Walk_from v, y' by A99, A98, GLIB_001:38;
              now assume cv in P2.vertices(); then
                  consider m being odd Nat such that
              A102: m <= len P2 & P2.m = cv by GLIB_001:88;
              A103: 1 <= m by HEYTING3:1; then
                  m in dom P2 by A102, FINSEQ_3:27; then
              A104: P.(n+m-1) = cv & n+m-1 in dom P by A99, A102, GLIB_001:48;
then
                  reconsider nm1 = n+m-1 as odd Nat;
                  1+1 < n+m by A100, A103, XREAL_1:10; then
                  1+1-1 < n+m-1 by REAL_1:92; then
              A105: 2*0+1 < n+m-1;
                  n+m-1 is Nat by A104; then
                  n+m-1 <= len P by A104, FINSEQ_3:27;
                  hence contradiction by A88,A98,A104,A105,GLIB_001:def 28;
              end; then
                 reconsider P2 as Walk of G2 by GLIB_001:172;
                 P2 is_Walk_from v,y' by A101, GLIB_001:20;
                 hence contradiction by A87, A95, Def5;
             end; then
                reconsider P as Walk of G3 by GLIB_001:172;
                take P;
                thus P is_Walk_from cv',y by A97, GLIB_001:20; end;
            end;
              hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
          end;
             hence ex W being Walk of G3 st W is_Walk_from cv',y;
         end; then G3 is connected by Lm6; then
            G3.numComponents() = 1 by Lm18;
            hence not v is cut-vertex by A11,Def11; end;
        suppose v1 in cv.allNeighbors() & v2 in cv.allNeighbors(); then
            consider e being set such that
        A106: e Joins cv,v2,G by GLIB_000:74;
        A107: e in the_Edges_of G by A106, GLIB_000:def 15;
            set a = v2;
            reconsider v'=v1 as Vertex of G2 by GLIB_000:45;
            reconsider v =v' as Vertex of G by GLIB_000:45;
            take v;
            thus v in the_Vertices_of C;
            consider G3 being removeVertex of G,v;
        A108: the_Vertices_of G3 = (the_Vertices_of G) \ {v} by GLIB_000:50;
            not cv in {v} by A62, TARSKI:def 1; then
            reconsider cv' = cv as Vertex of G3 by A108, XBOOLE_0:def 4;
        A109: the_Vertices_of C = G2.reachableFrom(v') by Lm16;
         now let y be Vertex of G3;
          now per cases;
          suppose y = cv; then
              G3.walkOf(y) is_Walk_from cv',y by GLIB_001:14;
              hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
          suppose
          A110: y <> cv;
           now per cases;
            suppose
            A111: y in the_Vertices_of C;
                not y in {v1} by A108,XBOOLE_0:def 4; then
            A112: y in the_Vertices_of C'R1 by A63,A111,XBOOLE_0:def 4;
                not a in {v1} by A60, TARSKI:def 1; then
                a in the_Vertices_of C'R1 by A63,XBOOLE_0:def 4; then
                consider W being Walk of C'R1 such that
            A113: W is_Walk_from y,a by A112, A61, Def1;
            A114: W.1 = y & W.(len W) = a by A113, GLIB_001:18;
            A115: now assume v in W.vertices(); then
                    not v in {v1} by XBOOLE_0:def 4, A63;
                    hence contradiction by TARSKI:def 1;
                end;
                reconsider W as Walk of C by GLIB_001:168;
                reconsider W as Walk of G2 by GLIB_001:168;
                reconsider W as Walk of G by GLIB_001:168;
                not v in W.vertices() by A115,GLIB_001:99; then
                reconsider W as Walk of G3 by GLIB_001:172;
            A116: W is_Walk_from y,a by A114, GLIB_001:18;
                not e in v.edgesInOut() by A62,A60,A106,GLIB_000:68; then
                e in (the_Edges_of G)\v.edgesInOut() by A107, XBOOLE_0:def 4;
then
                e in (the_Edges_of G)\G.edgesInOut({v}) by GLIB_000:def 42;then
                e in G.edgesBetween(the_Vertices_of G\{v}) by GLIB_000:38; then
                e in the_Edges_of G3 by GLIB_000:50; then
                e Joins cv,a,G3 by A106,GLIB_000:76; then
                e Joins a,cv,G3 by GLIB_000:17; then
                W.addEdge(e) is_Walk_from y,cv by A116, GLIB_001:67; then
                W.addEdge(e).reverse() is_Walk_from cv,y by GLIB_001:24;
                hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
            suppose
            A117: not y in the_Vertices_of C;
                reconsider y'=y as Vertex of G by GLIB_000:45;
                consider W being Walk of G such that
            A118: W is_Walk_from cv,y' by Def1;
                consider P being Path of W;
            A119: P is_Walk_from cv,y' by A118, GLIB_001:161;
            A120: P.1 = cv & P.(len P) = y' by A119, GLIB_001:18;
             now assume v in P.vertices(); then
                 consider n being odd Nat such that
             A121: n <= len P & P.n = v by GLIB_001:88;
                 1 <= n by HEYTING3:1; then
             A122: 1 < n by A62,A120,A121,REAL_1:def 5;
                 set P2 = P.cut(n,len P);
             A123: P2 is_Walk_from v, y' by A121, A120, GLIB_001:38;
              now assume cv in P2.vertices(); then
                  consider m being odd Nat such that
              A124: m <= len P2 & P2.m = cv by GLIB_001:88;
              A125: 1 <= m by HEYTING3:1; then
                  m in dom P2 by A124, FINSEQ_3:27; then
              A126: P.(n+m-1) = cv & n+m-1 in dom P by A121, A124, GLIB_001:48;
then
                  reconsider nm1 = n+m-1 as odd Nat;
                  1+1 < n+m by A122, A125, XREAL_1:10; then
                  1+1-1 < n+m-1 by REAL_1:92; then
              A127: 2*0+1 < n+m-1;
                  n+m-1 is Nat by A126; then
                  n+m-1 <= len P by A126, FINSEQ_3:27;
                  hence contradiction by A110,A120,A126,A127,GLIB_001:def 28;
              end; then
                 reconsider P2 as Walk of G2 by GLIB_001:172;
                 P2 is_Walk_from v,y' by A123, GLIB_001:20;
                 hence contradiction by A109, A117,Def5;
             end; then
                reconsider P as Walk of G3 by GLIB_001:172;
                take P;
                thus P is_Walk_from cv',y by A119, GLIB_001:20; end;
            end;
              hence ex W being Walk of G3 st W is_Walk_from cv',y; end;
          end;
             hence ex W being Walk of G3 st W is_Walk_from cv',y;
         end; then G3 is connected by Lm6; then
            G3.numComponents() = 1 by Lm18;
            hence not v is cut-vertex by A11, Def11; end;
        end;
           hence ex v being Vertex of G st
             v in the_Vertices_of C & not v is cut-vertex; end;
       end;
         hence ex v being Vertex of G st v in the_Vertices_of C &
           not v is cut-vertex;
     end;
        consider CC1 being inducedSubgraph of G2,C1;
        consider CC2 being inducedSubgraph of G2,C2;
        consider v1 being Vertex of G such that
    A128: v1 in the_Vertices_of CC1 & not v1 is cut-vertex by A18;
        consider v2 being Vertex of G such that
    A129: v2 in the_Vertices_of CC2 & not v2 is cut-vertex by A18;
        take v1,v2;
     now assume v1 = v2; then
     A130: CC1 == CC2 by A128,A129,Lm17;
         C1 is non empty Subset of the_Vertices_of G2 &
         C2 is non empty Subset of the_Vertices_of G2 by Lm13; then
         the_Vertices_of CC1 = C1 & the_Vertices_of CC2 = C2
           by GLIB_000:def 39;
         hence contradiction by A15,A130,GLIB_000:def 36;
     end;
        hence v1 <> v2;
        thus not v1 is cut-vertex & not v2 is cut-vertex by A128,A129; end;
    end;
       hence ex v1,v2 being Vertex of G st v1 <> v2 &
       not v1 is cut-vertex & not v2 is cut-vertex;
   end;
      hence P[k]; end;
  end;
     hence P[k];
 end; then
A131: for k being Nat st for n being Nat st n < k holds P[n] holds P[k];
A132: for k being Nat holds P[k] from NAT_1:sch 4(A131);
    let G be non trivial finite connected _Graph;
    G.order() = G.order();
    hence thesis by A132;
end;

registration let G be non trivial finite connected _Graph;
  cluster non cut-vertex Vertex of G;
  existence proof
    consider v1,v2 being Vertex of G such that
A1: v1 <> v2 & not v1 is cut-vertex & not v2 is cut-vertex by Lm22;
    thus thesis by A1;
  end;
end;

Lm23: ::tGACYCLIC02
  for G being acyclic _Graph, W being Path of G, e being set
    st not e in W.edges() & e in W.last().edgesInOut()
    holds W.addEdge(e) is Path-like proof
    let G be acyclic _Graph, W be Path of G, e be set; assume
A1: not e in W.edges() & e in W.last().edgesInOut(); then
A2: e Joins W.last(), W.last().adj(e), G by GLIB_000:70;
    set v = W.last().adj(e), W2 = W.addEdge(e);
A3: W2 is Trail-like by A1, GLIB_001:143;
A4: len W2 = len W + 2 by A2, GLIB_001:65;
now per cases;
    suppose
    A5: W is trivial; then
        for n being odd Nat st 1 < n & n <= len W holds W.n <> v
          by GLIB_001:127;
        hence thesis by A1, A2, A5, GLIB_001:151; end;
    suppose
    A6: W is non trivial;
    A7: now assume W is closed; then
            W is Cycle-like by A6, GLIB_001:def 31;
            hence contradiction by Def2;
        end;
        now let n be odd Nat; assume
        A8: 1 < n & n <= len W;
            now assume
            A9: W.n = v;
                set W3 = W2.cut(n,len W2);
            A10: n <= len W2 by A4,A8,NAT_1:37;
            A11: W3 is Trail-like by A3, GLIB_001:142;
            A12: W3.first()=W2.n & W3.last()=W2.(len W2) by A10,GLIB_001:38;
                n in dom W by A8, FINSEQ_3:27; then
            A13: W3.first() = v by A9,A12,A2,GLIB_001:66;
            A14: W3.last() = W2.last() by A12, GLIB_001:def 7
                         .= v by A2, GLIB_001:64;
                now assume W3 is trivial; then
                    len W3 = 1 by GLIB_001:127; then
                    1 + n = len W2 + 1 by A10, GLIB_001:37; then
                    2 + len W <= len W by A4,A8; then
                    2 + len W - len W <= len W - len W by REAL_1:92; then
                    2 <= 0;
                    hence contradiction;
                end; then
                consider W4 being Path of W3 such that
            A15: W4 is non trivial by A11, GLIB_001:167;
                W4 is_Walk_from v,v by A13, A14, GLIB_001:def 32; then
                W4 is closed by GLIB_001:120; then
                W4 is Cycle-like by A15, GLIB_001:def 31;
                hence contradiction by Def2;
            end;
            hence W.n <> v;
        end;
        hence thesis by A1, A2, A7, GLIB_001:151; end;
      end;
    hence thesis;
end;

Lm24:
  for G being non trivial finite acyclic _Graph st the_Edges_of G <> {}
    holds ex v1,v2 being Vertex of G st v1 <> v2 & v1 is endvertex &
    v2 is endvertex & v2 in G.reachableFrom(v1) proof
    let G be non trivial finite acyclic _Graph such that
A1: the_Edges_of G <> {}; set e = choose the_Edges_of G;
    defpred P[Nat] means ex W being Path of G st len W = $1;
A2: now let k be Nat; assume P[k]; then
        consider P being Path of G such that
    A3: len P = k;
        len P.vertexSeq() <= G.order() + 1 by GLIB_001:155; then
        2*len P.vertexSeq() <= 2*(G.order()+1) by XREAL_1:66; then
        k + 1 <= 2*(G.order() + 1) by A3, GLIB_001:def 14; then
        k+1-1 <= 2*(G.order() + 1) - 0 by REAL_1:92;
        hence k <= 2*(G.order()+1);
    end;
    set src = (the_Source_of G).e, tar = (the_Target_of G).e;
A4: e Joins src,tar,G by A1, GLIB_000:def 15;
A5: len G.walkOf(src,e,tar) = 3 by A4, GLIB_001:15; then
A6: ex k being Nat st P[k];
    consider k being Nat such that
A7: P[k] & for n being Nat st P[n] holds n <= k from NAT_1:sch 6(A2,A6);
    consider W being Path of G such that
A8: len W = k & for n being Nat st P[n] holds n <= k by A7;
A9: 3 <= len W by A5,A8; then
A10: W is non trivial by GLIB_001:126;
A11: now assume W.first() = W.last(); then
        W is closed by GLIB_001:def 24; then
        W is Cycle-like by A10, GLIB_001:def 31;
        hence contradiction by Def2;
    end; then
A12: W is open by GLIB_001:def 24;
A13: now let W be Path of G; assume
    A14: len W = k & W is open; then
    A15: W is non trivial by A9,A8,GLIB_001:126;
        2+1 <= len W by A14,A5,A8; then
        2 < len W by NAT_1:38; then
        reconsider lenW2 = len W - 2*1 as odd Nat by INT_1:18;
    A16: lenW2 + 2 = len W;
        now assume not W.last() is endvertex; then
            W.last().degree() <> 1 by GLIB_000:def 54; then
        A17: card W.last().edgesInOut() <> 1 by GLIB_000:22;
            W.last() in W.vertices() by GLIB_001:89; then
            not W.last() is isolated by A15, GLIB_001:136; then
            W.last().degree() <> 0 by GLIB_000:def 52; then
            card W.last().edgesInOut() <> 0 by GLIB_000:22; then
            0 < card W.last().edgesInOut() by NAT_1:19; then
            0+1 <= card W.last().edgesInOut() by NAT_1:38; then
            1 < card W.last().edgesInOut() by A17, REAL_1:def 5; then
            consider e1,e2 being set such that
        A18: e1 in W.last().edgesInOut() &
              e2 in W.last().edgesInOut() & e1 <> e2 by Th1;
            now per cases;
            suppose
            A19: e1 = W.(lenW2+1); take e2;
                thus e2 in W.last().edgesInOut() & e2 <> W.(lenW2+1)
                  by A18,A19; end;
            suppose
            A20: e1 <> W.(lenW2+1); take e1;
                thus e1 in W.last().edgesInOut() & e1 <> W.(lenW2+1)
                  by A18,A20; end;
            end; then
            consider e being set such that
        A21: e in W.last().edgesInOut() & e <> W.(lenW2+1);
            consider v being Vertex of G such that
        A22: e Joins W.last(),v,G by A21, GLIB_000:67;
            now per cases;
            suppose v in W.vertices(); then consider n being odd Nat such that
            A23: n <= len W & W.n = v by GLIB_001:88;
                set m = W.rfind(n);
            A24: m <= len W & W.m = v & for k being odd Nat
                  st k <= len W & W.k = v holds k <= m by A23, GLIB_001:def 22;
                set W2 = W.cut(m,len W);
            A25: W2.first() = v & W2.last() = W.(len W) by A24, GLIB_001:38;
then
            A26: e Joins W2.last(),v,G by A22,GLIB_001:def 7; then
            A27: e in W2.last().edgesInOut() by GLIB_000:65;
                now per cases;
                suppose not e in W2.edges(); then
                A28: W2.addEdge(e) is Path-like by A27,Lm23;
                    W2.addEdge(e).first() = v & W2.addEdge(e).last() = v
                      by A25, A26, GLIB_001:64; then
                A29: W2.addEdge(e) is closed by GLIB_001:def 24;
                    W2.addEdge(e) is non trivial by A26, GLIB_001:133; then
                    W2.addEdge(e) is Cycle-like by A28,A29,GLIB_001:def 31;
                    hence contradiction by Def2; end;
                suppose
                A30: e in W2.edges();
                    W2.edges() c= W.edges() by GLIB_001:107; then
                    consider a being even Nat such that
                A31: 1 <= a & a <= len W & W.a = e by A30,GLIB_001:100;
                    a < lenW2 + 2 by A31, REAL_1:def 5; then
                    a+1 <= lenW2+1+1 by NAT_1:38; then
                    a <= lenW2+1 by XREAL_1:8; then
                A32: a < lenW2+1 by A21,A31,REAL_1:def 5;
                    reconsider a1 = a - 1 as odd Nat by A31, INT_1:18;
                A33: a1 < len W-0 by A31, REAL_1:92;
                    a1+1 = a; then
                A34: e Joins W.a1, W.(a1+2), G by A31, A33, GLIB_001:def 3;
                    now per cases by A22,A34, GLIB_000:18;
                    suppose W.last() = W.a1 & v = W.(a1+2); then
                        W.(len W) = W.a1 by GLIB_001:def 7;
                        hence contradiction by A14, A33, GLIB_001:148; end;
                    suppose W.last() = W.(a1+2) & v = W.a1; then
                    A35: W.(len W) = W.(a1+2) by GLIB_001:def 7;
                        a1 < lenW2+1-1 by A32, REAL_1:92; then
                        a1+2 < len W by A16, XREAL_1:10;
                        hence contradiction by A14, A35, GLIB_001:148; end;
                    end;
                    hence contradiction; end;
                end;
                hence contradiction; end;
              suppose not v in W.vertices(); then
            A36: W.addEdge(e) is Path-like by A22,A14,GLIB_001:152;
                len W.addEdge(e) = k + 2 by A14, A22, GLIB_001:65; then
                k+2 <= k+0 by A8,A36;
                hence contradiction by XREAL_1:8;
              end;
            end;
            hence contradiction;
        end;
        hence W.last() is endvertex;
    end;
A37: W.last() is endvertex by A8, A12, A13;
A38: len W.reverse() = k by A8, GLIB_001:22;
    W.reverse() is open by A12, GLIB_001:121; then
    W.reverse().last() is endvertex by A13, A38; then
A39: W.first() is endvertex by GLIB_001:23;
    W is_Walk_from W.first(),W.last() by GLIB_001:def 23; then
    W.last() in G.reachableFrom(W.first()) by Def5;
    hence thesis by A11, A37, A39;
end;

Lm25:
  for G being non trivial finite Tree-like _Graph holds
    ex v1,v2 being Vertex of G st v1 <> v2 & v1 is endvertex &
     v2 is endvertex proof
    let G be non trivial finite Tree-like _Graph;
    consider v1, v2 being Vertex of G such that
A1: v1 <> v2 by GLIB_000:24;
    consider W being Walk of G such that
A2: W is_Walk_from v1,v2 by Def1;
A3: 1 <= len W by HEYTING3:1;
    now assume len W = 1; then
    A4: W.last() = W.1 by GLIB_001:def 7
                .= W.first() by GLIB_001:def 6;
        W.first() = v1 & W.last() = v2 by A2, GLIB_001:def 23;
        hence contradiction by A1, A4;
    end; then
    1 < len W by A3, REAL_1:def 5; then
A5: 1+1 <= len W by NAT_1:38;
    1+1 in dom W by A5, FINSEQ_3:27; then
    W.(2*1) in the_Edges_of G by GLIB_001:9; then
    consider v1,v2 being Vertex of G such that
A6: v1 <> v2 & v1 is endvertex & v2 is endvertex & v2 in G.reachableFrom(v1)
      by Lm24;
    thus thesis by A6;
end;

registration let G be non trivial finite Tree-like _Graph;
  cluster endvertex Vertex of G;
  existence proof
    consider v1,v2 being Vertex of G such that
A1: v1 <> v2 & v1 is endvertex & v2 is endvertex by Lm25;
    take v1;
    thus thesis by A1;
  end;
end;

registration let G be non trivial finite Tree-like _Graph,
               v be endvertex Vertex of G;
  cluster -> Tree-like removeVertex of G,v;
  coherence proof
    let G2 be removeVertex of G,v;
    G2 is connected by Lm5;
    hence thesis by Def3;
  end;
end;

definition let GSq be GraphSeq;
  attr GSq is connected means :Def12: ::dGSEQCONNECT
    for n being Nat holds GSq.->n is connected;

  attr GSq is acyclic means :Def13: ::dGSEQACYCLIC
    for n being Nat holds GSq.->n is acyclic;

  attr GSq is Tree-like means :Def14: ::dGSEQTREE
    for n being Nat holds GSq.->n is Tree-like;
end;

registration
  cluster trivial -> connected GraphSeq;
  coherence proof
    let GSq be GraphSeq; assume
A1: GSq is trivial;
    let n be Nat;
    reconsider G = GSq.->n as trivial _Graph by A1,GLIB_000:def 62;
    G is connected;
    hence GSq.-> n is connected;
  end;
  cluster trivial loopless -> Tree-like GraphSeq;
  coherence proof
    let GSq be GraphSeq; assume
A2: GSq is trivial & GSq is loopless;
    let n be Nat;
    reconsider G = GSq.->n as trivial loopless _Graph
      by A2,GLIB_000:def 61,GLIB_000:def 62;
    G is Tree-like;
    hence GSq.-> n is Tree-like;
  end;
  cluster acyclic -> simple GraphSeq;
  coherence proof
    let GSq be GraphSeq; assume
A3: GSq is acyclic;
    now let n be Nat;
        reconsider G = GSq.->n as acyclic _Graph by A3,Def13;
        G is simple;
        hence GSq.-> n is simple;
    end;
    hence thesis by GLIB_000:def 66;
  end;
  cluster Tree-like -> acyclic connected GraphSeq;
  coherence proof
    let GSq be GraphSeq; assume
A4: GSq is Tree-like;
    now let n be Nat;
        reconsider G = GSq.->n as Tree-like _Graph by A4,Def14;
        G is acyclic & G is connected;
        hence GSq.->n is acyclic & GSq.->n is connected;
    end;
    hence thesis by Def13,Def12;
  end;
  cluster acyclic connected -> Tree-like GraphSeq;
  coherence proof
    let GSq be GraphSeq; assume
A5: GSq is acyclic & GSq is connected;
    let n be Nat;
    reconsider G = GSq.->n as acyclic connected _Graph
      by A5,Def13,Def12;
    G is Tree-like;
    hence thesis;
  end;
end;

registration
  cluster halting finite Tree-like GraphSeq;
  existence proof
    consider G being finite Tree-like _Graph;
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19; then
    reconsider F as ManySortedSet of NAT by PBOOLE:def 3;
    now let x be Nat;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    take F;
    F.1 in rng F & F.(1+1) in rng F by A1, FUNCT_1:12; then
    F.1 in {G} & F.(1+1) in {G} by FUNCOP_1:14; then
    F.1 = G & F.(1+1) = G by TARSKI:def 1;
    hence F is halting by GLIB_000:def 56;
    now let x be Nat;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14; then
        F.x = G by TARSKI:def 1;
        hence F.->x is finite & F.->x is Tree-like by GLIB_000:def 59;
    end;
    hence thesis by GLIB_000:def 60,Def14;
  end;
end;

registration let GSq be connected GraphSeq, n be Nat;
  cluster GSq.->n -> connected;
  coherence by Def12;
end;

registration let GSq be acyclic GraphSeq, n be Nat;
  cluster GSq.->n -> acyclic;
  coherence by Def13;
end;

registration let GSq be Tree-like GraphSeq, n be Nat;
  cluster GSq.->n -> Tree-like;
  coherence;
end;

begin :: Theorems

reserve G,G1,G2,G3 for _Graph;
reserve e,x,y for set;
reserve v,v1,v2 for Vertex of G;
reserve W for Walk of G;

theorem Th2: ::tGCONNECT01
  for G being non trivial connected _Graph, v being Vertex of G holds
    not v is isolated proof
    let G be non trivial connected _Graph, v be Vertex of G;
    consider v1,v2 being Vertex of G such that
A1: v1 <> v2 by GLIB_000:24;
    now per cases;
    suppose v1 = v;
       hence ex u being Vertex of G st u <> v by A1; end;
    suppose v1 <> v;
       hence ex u being Vertex of G st u <> v; end;
    end; then
    consider u being Vertex of G such that
A2: u <> v;
    consider W being Walk of G such that
A3: W is_Walk_from u,v by Def1;
A4: W.first() = u & W.last() = v by A3, GLIB_001:def 23; then
A5: v in W.vertices() by GLIB_001:89;
    W is non trivial by A2, A4, GLIB_001:128;
    hence not v is isolated by A5, GLIB_001:136;
end;

theorem Th3: ::tGCONNECT02
  for G1 being non trivial _Graph, v being Vertex of G1,
      G2 being removeVertex of G1,v st G2 is connected &
      ex e being set st e in v.edgesInOut() & not e Joins v,v,G1
   holds G1 is connected proof
    let G1 be non trivial _Graph, v be Vertex of G1,
        G2 be removeVertex of G1,v; assume
A1: G2 is connected &
      ex e being set st e in v.edgesInOut() & not e Joins v,v,G1; then
    consider e being set such that
A2: e in v.edgesInOut() & not e Joins v,v,G1;
A3: now let x be Vertex of G1; assume x <> v; then
        not x in {v} by TARSKI:def 1; then
        x in (the_Vertices_of G1) \ {v} by XBOOLE_0:def 4;
        hence x in (the_Vertices_of G2) by GLIB_000:50;
    end;
    set v3 = v.adj(e);
    v <> v3 by A2, GLIB_000:70; then
    reconsider v3'=v3 as Vertex of G2 by A3;
A4: e Joins v,v3,G1 by A2, GLIB_000:70; then
A5: e Joins v3,v,G1 by GLIB_000:17;
    now let v1, v2 be Vertex of G1;
        now per cases;
        suppose v1 <> v; then reconsider v1'=v1 as Vertex of G2 by A3;
            now per cases;
            suppose v2 <> v; then reconsider v2'=v2 as Vertex of G2 by A3;
                consider W' being Walk of G2 such that
            A6: W' is_Walk_from v1',v2' by A1, Def1;
                reconsider W=W' as Walk of G1 by GLIB_001:168;
                W is_Walk_from v1,v2 by A6, GLIB_001:20;
                hence ex W being Walk of G1 st W is_Walk_from v1,v2; end;
            suppose
            A7: v2 = v;
                consider W' being Walk of G2 such that
            A8: W' is_Walk_from v1',v3' by A1, Def1;
                reconsider W=W' as Walk of G1 by GLIB_001:168;
                W is_Walk_from v1,v3 by A8, GLIB_001:20; then
                W.first() = v1 & W.last() = v3 by GLIB_001:def 23; then
                W.addEdge(e) is_Walk_from v1, v2 by A5, A7, GLIB_001:64;
                hence ex W being Walk of G1 st W is_Walk_from v1,v2; end;
            end;
            hence ex W being Walk of G1 st W is_Walk_from v1,v2; end;
        suppose
        A9: v1 = v;
            now per cases;
            suppose v2 <> v; then reconsider v2'=v2 as Vertex of G2 by A3;
                set W1 = G1.walkOf(v1,e,v3);
            A10: W1 is_Walk_from v1, v3 by A4, A9, GLIB_001:16;
                consider W2' being Walk of G2 such that
            A11: W2' is_Walk_from v3',v2' by A1, Def1;
                reconsider W2=W2' as Walk of G1 by GLIB_001:168;
            A12: W2 is_Walk_from v3, v2 by A11, GLIB_001:20;
                take W = W1.append(W2);
                thus W is_Walk_from v1,v2 by A10, A12, GLIB_001:32; end;
            suppose
            A13: v2 = v;
                take W = G1.walkOf(v);
                thus W is_Walk_from v1,v2 by A9, A13, GLIB_001:14; end;
            end;
            hence ex W being Walk of G1 st W is_Walk_from v1,v2; end;
        end;
        hence ex W being Walk of G1 st W is_Walk_from v1,v2;
    end;
    hence G1 is connected by Def1;
end;

theorem ::tGCONNECT03
  for G1 being non trivial connected _Graph, v being Vertex of G1,
      G2 being removeVertex of G1,v st v is endvertex
   holds G2 is connected by Lm5;

theorem Th5: ::tGCONNECT04
  for G1 being connected _Graph, W being Walk of G1, e being set,
      G2 being removeEdge of G1,e st W is Cycle-like & e in W.edges()
   holds G2 is connected proof
    let G1 be connected _Graph, W be Walk of G1, e be set,
        G2 be removeEdge of G1,e; assume
A1: W is Cycle-like & e in W.edges(); then
    reconsider v1 = (the_Source_of G1).e, v2 = (the_Target_of G1).e
      as Vertex of G1 by FUNCT_2:7;
    e Joins v1,v2,G1 by A1, GLIB_000:def 15; then
    consider X being Walk of G1 such that
A2: X is_Walk_from v1,v2 & not e in X.edges() by A1, GLIB_001:158;
    reconsider X2 = X as Walk of G2 by A2, GLIB_001:173;
A3: X2 is_Walk_from v1,v2 by A2, GLIB_001:20; then
A4: X2.reverse() is_Walk_from v2,v1 by GLIB_001:24;
    now let u,v be Vertex of G2;
        the_Vertices_of G2 c= the_Vertices_of G1; then
        reconsider u'=u,v'=v as Vertex of G1 by TARSKI:def 3;
        consider C being Walk of G1 such that
    A5: C is_Walk_from u',v' by Def1;
        consider P being Path of C;
    A6: P is_Walk_from u',v' by A5, GLIB_001:161; then
    A7: P.1 = u & P.(len P) = v by GLIB_001:18;
        now per cases;
        suppose e in P.edges(); then
            consider a,b being Vertex of G1, m being odd Nat such that
        A8: m+2 <= len P & a = P.m & e = P.(m+1) & b = P.(m+2) &
              e Joins a,b,G1 by GLIB_001:104;
            reconsider a,b as Vertex of G2 by GLIB_000:54;
            set P1 = P.cut(1,m), P2 = P.cut(m+2, len P);
        A9: 1 <= m & 1 is odd by HEYTING3:1, JORDAN12:3;
        A10: m+2-2 < len P - 0 by A8, REAL_1:92; then
        A11: P1 is_Walk_from u,a by A7, A8, A9, GLIB_001:38;
        A12: P2 is_Walk_from b,v by A7, A8, GLIB_001:38;
        A13: m+1 <= len P by A10, NAT_1:38;
            now assume e in P1.edges(); then
                consider x being even Nat such that
            A14: 1 <= x & x <= len P1 & P1.x = e by GLIB_001:100;
                x <= m by A14, A10, GLIB_001:46; then
            A15: x < m+1 by NAT_1:38;
                x in dom P1 by A14, FINSEQ_3:27; then
                P.x = e by A14, A10, GLIB_001:47;
                hence contradiction by A8,A13,A14,A15,GLIB_001:139;
            end; then reconsider P1'=P1 as Walk of G2 by GLIB_001:173;
            now assume e in P2.edges(); then
                consider x being even Nat such that
            A16: 1 <= x & x <= len P2 & P2.x = e by GLIB_001:100;
                reconsider x1 = x-1 as odd Nat by A16, INT_1:18;
            A17: x1+1 = x;
                x1 < len P2 - 0 by A16, REAL_1:92; then
            A18: e = P.(m+2+x1) & m+2+x1 in dom P
                  by A8,A16,A17,GLIB_001:37; then
            A19: m+2+x1 <= len P by FINSEQ_3:27;
            A20: m+1 < m+1+1 by NAT_1:38;
                0 <= x1 by NAT_1:18; then
            A21: m+1+0 < m+2+x1 by A20, XREAL_1:10;
                1 <= m+1 by NAT_1:37;
                hence contradiction by A8, A18, A19, A21, GLIB_001:139;
            end; then reconsider P2'=P2 as Walk of G2 by GLIB_001:173;
        A22: P1' is_Walk_from u,a by A11, GLIB_001:20;
        A23: P2' is_Walk_from b,v by A12, GLIB_001:20;
            now per cases by GLIB_000:def 15, A8;
            suppose a = v1 & b = v2; then
                P1'.append(X2) is_Walk_from u,b by A3,A22,GLIB_001:32; then
                P1'.append(X2).append(P2') is_Walk_from u,v
                  by A23,GLIB_001:32;
                hence ex W being Walk of G2 st W is_Walk_from u,v; end;
            suppose b = v1 & a = v2; then
                P1'.append(X2.reverse()) is_Walk_from u,b
                  by A4,A22,GLIB_001:32; then
                P1'.append(X2.reverse()).append(P2') is_Walk_from u,v
                  by A23,GLIB_001:32;
                hence ex W being Walk of G2 st W is_Walk_from u,v; end;
            end;
            hence ex W being Walk of G2 st W is_Walk_from u,v; end;
        suppose not e in P.edges(); then
            reconsider P as Walk of G2 by GLIB_001:173;
            take P;
            thus P is_Walk_from u,v by A6, GLIB_001:20; end;
        end;
        hence ex W being Walk of G2 st W is_Walk_from u,v;
    end;
    hence thesis by Def1;
end;

theorem ::tGCONNECT05
  (ex v1 being Vertex of G st for v2 being Vertex of G
    ex W being Walk of G st W is_Walk_from v1,v2) implies
    G is connected by Lm6;

theorem ::tGCONNECT06: **CLUSTERED
  for G being trivial _Graph holds G is connected;

theorem Th8: ::tGCONNECT07
  G1 == G2 & G1 is connected implies G2 is connected proof assume
A1: G1 == G2 & G1 is connected;
    now let u,v be Vertex of G2;
        reconsider u'=u,v'=v as Vertex of G1 by A1,GLIB_000:def 36;
        consider W' being Walk of G1 such that
    A2: W' is_Walk_from u',v' by A1, Def1;
        reconsider W = W' as Walk of G2 by A1,GLIB_001:180;
        take W;
        thus W is_Walk_from u,v by A2, GLIB_001:20;
    end;
    hence G2 is connected by Def1;
end;

theorem ::tGREACH01
  v in G.reachableFrom(v) by Lm1;

theorem ::tGREACH02
  x in G.reachableFrom(v1) & e Joins x,y,G implies
    y in G.reachableFrom(v1) by Lm2;

theorem ::tGREACH03
  G.edgesBetween(G.reachableFrom(v)) = G.edgesInOut(G.reachableFrom(v)) proof
    set R = G.reachableFrom(v);
A1: G.edgesBetween(R) c= G.edgesInOut(R) by GLIB_000:36;
    now let x be set; set Sx = (the_Source_of G).x, Tx = (the_Target_of G).x;
        assume
    A2: x in G.edgesInOut(R); then
        reconsider Sx, Tx as Vertex of G by FUNCT_2:7;
        now per cases by A2,GLIB_000:31;
        suppose
        A3: Sx in R; then
        A4: x in G.edgesOutOf(R) by A2,GLIB_000:def 29;
            consider W being Walk of G such that
        A5: W is_Walk_from v,Sx by A3, Def5;
            now assume
            A6: not Tx in R;
            A7: W.first() = v & W.last() = Sx by A5, GLIB_001:def 23; then
                x Joins W.last(), Tx,G by A2,GLIB_000:def 15; then
                W.addEdge(x) is_Walk_from v, Tx by A7, GLIB_001:64;
                hence contradiction by A6,Def5;
            end; then
            x in G.edgesInto(R) by A2,GLIB_000:def 28; then
            x in G.edgesInto(R) /\ G.edgesOutOf(R) by A4, XBOOLE_0:def 3;
            hence x in G.edgesBetween(R) by GLIB_000:def 31; end;
        suppose
        A8: Tx in R; then
        A9: x in G.edgesInto(R) by A2,GLIB_000:def 28;
            consider W being Walk of G such that
        A10: W is_Walk_from v,Tx by A8, Def5;
            now assume
            A11: not Sx in R;
            A12: W.first() = v & W.last() = Tx by A10, GLIB_001:def 23; then
                x Joins W.last(), Sx,G by A2,GLIB_000:def 15; then
                W.addEdge(x) is_Walk_from v, Sx by A12, GLIB_001:64;
                hence contradiction by A11,Def5;
            end; then
            x in G.edgesOutOf(R) by A2,GLIB_000:def 29; then
            x in G.edgesInto(R) /\ G.edgesOutOf(R) by A9, XBOOLE_0:def 3;
            hence x in G.edgesBetween(R) by GLIB_000:def 31; end;
        end;
        hence x in G.edgesBetween(R);
    end; then
    G.edgesInOut(R) c= G.edgesBetween(R) by TARSKI:def 3;
    hence thesis by A1, XBOOLE_0:def 10;
end;

theorem ::tGREACH04
  v1 in G.reachableFrom(v2) implies
    G.reachableFrom(v1) = G.reachableFrom(v2) by Lm3;

theorem ::tGREACH05
  v in W.vertices() implies W.vertices() c= G.reachableFrom(v) by Lm4;

theorem ::tGREACH06
  for G1 being _Graph, G2 being Subgraph of G1, v1 being Vertex of G1,
      v2 being Vertex of G2 st v1 = v2 holds
    G2.reachableFrom(v2) c= G1.reachableFrom(v1) proof
    let G1 be _Graph, G2 be Subgraph of G1, v1 be Vertex of G1,
        v2 be Vertex of G2; assume
A1: v1 = v2;
    let v be set; assume v in G2.reachableFrom(v2); then
    consider W being Walk of G2 such that
A2: W is_Walk_from v2,v by Def5;
    reconsider W2=W as Walk of G1 by GLIB_001:168;
    W2 is_Walk_from v1,v by A1,A2,GLIB_001:20;
    hence v in G1.reachableFrom(v1) by Def5;
end;

theorem ::tGREACH07
  (ex v being Vertex of G st G.reachableFrom(v) = the_Vertices_of G)
    implies G is connected by Lm7;

theorem ::tGREACH08
  G is connected implies
    for v being Vertex of G holds G.reachableFrom(v) = the_Vertices_of G
      by Lm8;

theorem ::tGREACH09
  for v1 being Vertex of G1, v2 being Vertex of G2 st G1 == G2 & v1 = v2
    holds G1.reachableFrom(v1) = G2.reachableFrom(v2) by Lm9;

theorem  ::tGREACHD01
  v in G.reachableDFrom(v) proof
    G.walkOf(v) is_Walk_from v,v by GLIB_001:14;
    hence thesis by Def6;
end;

theorem  ::tGREACHD02
  x in G.reachableDFrom(v1) & e DJoins x,y,G
    implies y in G.reachableDFrom(v1) proof
    set RFV = G.reachableDFrom(v1); assume
A1: x in RFV & e DJoins x,y,G; then
    consider W being directed Walk of G such that
A2: W is_Walk_from v1,x by Def6;
    W.addEdge(e) is directed & W.addEdge(e) is_Walk_from v1,y
      by A1, A2, GLIB_001:124;
    hence thesis by Def6;
end;

theorem  ::tGREACHD03
    G.reachableDFrom(v) c= G.reachableFrom(v) proof
    set RFD = G.reachableDFrom(v), RFV = G.reachableFrom(v);
    let x be set; assume
A1: x in RFD; then reconsider x'=x as Vertex of G;
    consider W being directed Walk of G such that
A2: W is_Walk_from v,x' by A1, Def6;
    thus x in RFV by A2, Def5;
end;

theorem  ::tGREACHD04
  for G1 being _Graph, G2 being Subgraph of G1, v1 being Vertex of G1,
      v2 being Vertex of G2 st v1 = v2 holds
    G2.reachableDFrom(v2) c= G1.reachableDFrom(v1) proof
    let G1 be _Graph, G2 be Subgraph of G1, v1 be Vertex of G1,
        v2 be Vertex of G2; assume
A1: v1 = v2;
    now let v be set; assume v in G2.reachableDFrom(v2); then
        consider W being DWalk of G2 such that
    A2: W is_Walk_from v2,v by Def6;
        reconsider W as DWalk of G1 by GLIB_001:176;
        W is_Walk_from v1,v by A1, A2, GLIB_001:20;
        hence v in G1.reachableDFrom(v1) by Def6;
    end;
    hence thesis by TARSKI:def 3;
end;

theorem  ::tGREACHD05
  for v1 being Vertex of G1, v2 being Vertex of G2 st G1 == G2 & v1 = v2
    holds G1.reachableDFrom(v1) = G2.reachableDFrom(v2) proof
    let v1 be Vertex of G1, v2 be Vertex of G2; assume
A1: G1 == G2 & v1 = v2;
   now let x be set;
        hereby assume x in G1.reachableDFrom(v1); then
            consider W being DWalk of G1 such that
        A2: W is_Walk_from v2,x by A1, Def6;
            reconsider W2 = W as DWalk of G2 by A1, GLIB_001:182,GLIB_001:180;
            W2 is_Walk_from v2,x by A2, GLIB_001:20;
            hence x in G2.reachableDFrom(v2) by Def6;
        end;
        assume x in G2.reachableDFrom(v2); then
        consider W being DWalk of G2 such that
    A3: W is_Walk_from v1,x by A1, Def6;
        reconsider W2 = W as DWalk of G1 by A1, GLIB_001:182,GLIB_001:180;
        W2 is_Walk_from v1,x by A3, GLIB_001:20;
        hence x in G1.reachableDFrom(v1) by Def6;
    end;
    hence thesis by TARSKI:2;
end;

theorem  ::tSUBGRAPH_GA01
  for G1 being _Graph, G2 being connected Subgraph of G1 holds
    G2 is spanning implies G1 is connected by Lm10;

theorem  ::tGCOMPSET01
  union G.componentSet() = the_Vertices_of G
   proof
    now let x be set;
        thus x in union G.componentSet()
               implies x in the_Vertices_of G;
        assume x in the_Vertices_of G; then
        reconsider x'=x as Vertex of G; set Y = G.reachableFrom(x');
    A1: x in Y by Lm1;
        Y in G.componentSet() by Def8;
        hence x in union G.componentSet() by A1, TARSKI:def 4;
    end;
    hence thesis by TARSKI:2;
end;

theorem  ::tGCOMPSET02
  G is connected iff G.componentSet() = {the_Vertices_of G} by Lm11;

theorem  ::tGCOMPSET03
  G1 == G2 implies G1.componentSet() = G2.componentSet() by Lm12;

theorem  ::tGCOMPSET04
  x in G.componentSet() implies
    x is non empty Subset of the_Vertices_of G by Lm13;

theorem  ::tGNUMCOMP01
  G is connected iff G.numComponents() = 1 by Lm18;

theorem  ::tGNUMCOMP02
  G1 == G2 implies G1.numComponents() = G2.numComponents() by Lm19;

theorem  ::tGCOMP01
  G is Component of G iff G is connected proof
    thus G is Component of G implies G is connected;
    assume
A1: G is connected;
A2: G is Subgraph of G by GLIB_000:43;
    now given G2 being connected Subgraph of G such that
    A3: G c< G2;
        now per cases by A2,A3,GLIB_000:101;
        suppose the_Vertices_of G c< the_Vertices_of G2;
            hence contradiction by XBOOLE_0:def 8; end;
        suppose the_Edges_of G c< the_Edges_of G2;
            hence contradiction by XBOOLE_0:def 8; end;
        end;
        hence contradiction;
    end;
    hence G is Component of G by A1,GLIB_000:43,Def7;
end;

theorem  ::tGCOMP02
  for C being Component of G holds
    the_Edges_of C = G.edgesBetween(the_Vertices_of C) by Lm14;

theorem  ::tGCOMP03
  for C1,C2 being Component of G holds
     the_Vertices_of C1 = the_Vertices_of C2 iff C1 == C2 by Lm15;

theorem  ::tGCOMP04
  for C being Component of G, v being Vertex of G holds
    v in the_Vertices_of C iff the_Vertices_of C = G.reachableFrom(v)
    by Lm16;

theorem  ::tGCOMP05
  for C1,C2 being Component of G, v being set st
    v in the_Vertices_of C1 & v in the_Vertices_of C2 holds C1 == C2
    by Lm17;

theorem  ::tCUTV01
  for G being connected _Graph, v being Vertex of G holds
    v is non cut-vertex iff
    for G2 being removeVertex of G,v holds
      G2.numComponents() <=` G.numComponents() by Lm20;

theorem  ::tCUTV02
  for G being connected _Graph, v being Vertex of G,
      G2 being removeVertex of G,v st not v is cut-vertex holds
   G2 is connected by Lm21;

theorem  ::tCUTV03
  for G being non trivial finite connected _Graph holds
   ex v1,v2 being Vertex of G st v1 <> v2 & not v1 is cut-vertex &
      not v2 is cut-vertex by Lm22;

theorem Th38: ::tCUTV04
  v is cut-vertex implies G is non trivial proof assume
A1: v is cut-vertex;
    now assume
    A2: G is trivial;
        reconsider G'=G as trivial _Graph by A2;
    A3: G'.numComponents() = 1 by Lm18;
        consider G2 being removeVertex of G',v;
        G2.numComponents() = 1 by Lm18; then
        1 <` 1 by A1,A3,Def10;
        hence contradiction;
    end;
    hence thesis;
end;

theorem  ::tCUTV05
  for v1 being Vertex of G1, v2 being Vertex of G2 st G1 == G2 & v1 = v2 holds
    v1 is cut-vertex implies v2 is cut-vertex proof
    let v1 be Vertex of G1, v2 be Vertex of G2; assume
A1: G1 == G2 & v1 = v2 & v1 is cut-vertex; then
A2: G1.numComponents() = G2.numComponents() by Lm19;
    consider G1A being removeVertex of G1,v1;
A3: G2.numComponents() <` G1A.numComponents() by A1,A2,Def10;
A4: G1 is non trivial by A1, Th38; then
A5: the_Vertices_of G1A = the_Vertices_of G1 \ {v2} by A1,GLIB_000:50
                       .= the_Vertices_of G2 \ {v2} by A1,GLIB_000:def 36;
A6: the_Edges_of G1A = G1.edgesBetween(the_Vertices_of G1 \ {v1})
                       by A4, GLIB_000:50
                    .= G1.edgesBetween(the_Vertices_of G2 \ {v2})
                       by A1,GLIB_000:def 36
                    .= G2.edgesBetween(the_Vertices_of G2 \ {v2})
                       by A1,GLIB_000:93;
    let G2A be removeVertex of G2,v2;
A7: G2 is non trivial by A1,A4,GLIB_000:92; then
A8: the_Vertices_of G2A = the_Vertices_of G1A by A5,GLIB_000:50;
A9: the_Edges_of G2A = the_Edges_of G1A by A6,A7,GLIB_000:50;
    G2 is Subgraph of G1 by A1, GLIB_000:90; then
    G2A is Subgraph of G1 by GLIB_000:46; then
    G1A == G2A by A8,A9,GLIB_000:89;
    hence G2.numComponents() <` G2A.numComponents() by A3,Lm19;
end;

theorem Th40: ::tGCONNECT_GF01
  for G being finite connected _Graph holds
     G.order() <= G.size() + 1 proof
   defpred P[finite _Graph] means
     $1 is connected implies $1.order() <= $1.size() + 1;
A1: for G being finite _Graph st G.order() = 1 holds P[G] by NAT_1:37;
A2: now let k be non empty Nat; assume
    A3: for Gk being finite _Graph st Gk.order() = k holds P[Gk];
        let Gk1 be finite _Graph; assume
    A4: Gk1.order() = k+1;
        now assume
        A5: Gk1 is connected;
            now assume Gk1.order() = 1; then
                k+1 = 0+1 by A4;
                hence contradiction;
            end; then
            reconsider Gk1' = Gk1 as non trivial finite connected _Graph
              by A5,GLIB_000:29;
            consider v1,v2 being Vertex of Gk1' such that
        A6: v1 <> v2 & not v1 is cut-vertex & not v2 is cut-vertex by Lm22;
            consider Gkb being removeVertex of Gk1', v1;
        A7: Gkb is connected by A6, Lm21;
        A8: Gkb.order() + 1 = k + 1 &
              Gkb.size()+card v1.edgesInOut()=Gk1.size() by A4,GLIB_000:51;then
        A9: Gkb.size() = Gk1.size() - card v1.edgesInOut();
            Gkb.order() = k by A8; then
        A10: k <= Gk1.size() - card v1.edgesInOut() + 1 by A3,A7,A9;
            not v1 is isolated by Th2; then
            v1.edgesInOut() <> {} by GLIB_000:def 51; then
            card v1.edgesInOut() <> 0 by CARD_2:59; then
            0 < card v1.edgesInOut() by NAT_1:19; then
            0+1 <= card v1.edgesInOut() by NAT_1:38; then
            k+1 <= Gk1.size() + 1 - card v1.edgesInOut() + card v1.edgesInOut()
              by A10,XREAL_1:9;
            hence Gk1.order() <= Gk1.size() + 1 by A4;
        end;
        hence P[Gk1];
    end;
A11: for G being finite _Graph holds P[G] from GLIB_000:sch 1(A1,A2);
    let G be finite connected _Graph;
    thus thesis by A11;
end;

theorem  ::tGACYCLIC01 **CLUSTERED
  for G being acyclic _Graph holds G is simple;

theorem  ::tGACYCLIC02
  for G being acyclic _Graph, W being Path of G, e being set
    st not e in W.edges() & e in W.last().edgesInOut()
    holds W.addEdge(e) is Path-like by Lm23;

theorem  ::tGACYCLIC03
  for G being non trivial finite acyclic _Graph st the_Edges_of G <> {}
    holds ex v1,v2 being Vertex of G st v1 <> v2 & v1 is endvertex &
    v2 is endvertex & v2 in G.reachableFrom(v1) by Lm24;

theorem Th44: ::tGACYCLIC04
  G1 == G2 & G1 is acyclic implies G2 is acyclic proof assume
A1: G1 == G2 & G1 is acyclic; then
    reconsider G1' = G1 as acyclic _Graph;
    G2 is Subgraph of G1' by A1,GLIB_000:90;
    hence G2 is acyclic;
end;

theorem  ::tGTREE01
  for G being non trivial finite Tree-like _Graph holds
    ex v1,v2 being Vertex of G st v1 <> v2 & v1 is endvertex &
     v2 is endvertex by Lm25;

theorem Th46: ::tGTREE02
  for G being finite _Graph holds
    G is Tree-like iff G is acyclic & G.order() = G.size() + 1 proof
    let G be finite _Graph;
    hereby assume
    A1: G is Tree-like;
        hence G is acyclic by Def3;
        defpred P[Nat] means for T being finite Tree-like _Graph st
           T.order() = $1 holds $1 = T.size() + 1;
        now let T be finite Tree-like _Graph;
            set VT = the_Vertices_of T, ET = the_Edges_of T;
            assume T.order() = 1; then
            card VT = 1 by GLIB_000:def 26;then consider v being set such that
        A2: VT = {v} by CARD_2:60;
            reconsider v as Vertex of T by A2, TARSKI:def 1;
            now assume ex e st e in ET; then consider e being set such that
            A3: e in ET;
                (the_Source_of T).e in {v} & (the_Target_of T).e in {v}
                  by A2, A3, FUNCT_2:7; then
                (the_Source_of T).e = v & (the_Target_of T).e = v
                  by TARSKI:def 1; then
                e Joins v,v,T by A3, GLIB_000:def 15; then
                T.walkOf(v,e,v) is Cycle-like by GLIB_001:157;
                hence contradiction by Def2;
            end; then
            card ET = 0 by CARD_1:78, XBOOLE_0:def 1; then
            T.size() = 0 by GLIB_000:def 27;
            hence 1 = T.size() + 1;
        end; then
    A4: P[1];
        now let k be non empty Nat; assume
        A5: for T being finite Tree-like _Graph st T.order() = k
              holds k = T.size() + 1;
            let T be finite Tree-like _Graph; assume
        A6: T.order() = k+1; then
            T.order() <> 1 by XCMPLX_1:3; then
            reconsider aT = T as non trivial finite Tree-like _Graph
              by GLIB_000:29;
            consider v being endvertex Vertex of aT;
            consider T2 being removeVertex of aT,v;
            T2.order() + 1 - 1 = k + 1 - 1 by A6, GLIB_000:51; then
            T2.order() = k + 1 - 1; then
        A7: k = T2.size() + 1 by A5;
            card v.edgesInOut() = v.degree() by GLIB_000:22
                               .= 1 by GLIB_000:def 54;
            hence k+1 = T.size() + 1 by A7,GLIB_000:51;
        end; then
    A8: for k being non empty Nat st P[k] holds P[k+1];
        for k being non empty Nat holds P[k] from BINARITH:sch 1(A4,A8);
        hence G.order() = G.size() + 1 by A1;
    end;
    assume
A9: G is acyclic & G.order() = G.size() + 1;
    defpred P[Nat] means for G being finite acyclic _Graph st G.order() = $1 &
      G.order() = G.size() + 1 holds G is connected;
    now let G be finite acyclic _Graph; assume
        G.order() = 1 & G.order() = G.size() + 1; then
        consider v being Vertex of G such that
    A10: the_Vertices_of G = {v} by GLIB_000:30;
        now let v1,v2 be Vertex of G;
            v1 = v & v2 = v by A10, TARSKI:def 1; then
            G.walkOf(v) is_Walk_from v1,v2 by GLIB_001:14;
            hence ex W being Walk of G st W is_Walk_from v1,v2;
        end;
        hence G is connected by Def1;
    end; then
A11: P[1];
    now let k be non empty Nat; assume
    A12: for G being finite acyclic _Graph st G.order() = k &
          G.order() = G.size() + 1 holds G is connected;
        let G be finite acyclic _Graph; assume
    A13: G.order() = k+1 & G.order() = G.size()+1;
        now assume G.order() = 1; then
            0 + 1 = k + 1 by A13;
            hence contradiction;
        end; then
        reconsider aG = G as non trivial finite acyclic _Graph by GLIB_000:29;
        the_Edges_of G <> {} by A13,CARD_1:78, GLIB_000:def 27;
        then consider v,v2 being Vertex of aG such that
    A14: v <> v2 & v is endvertex & v2 is endvertex &
    v2 in aG.reachableFrom(v) by Lm24;
        consider G2 being removeVertex of G,v;
A15: G2.order() + 1 = aG.order() & G2.size() + card v.edgesInOut() = aG.size()
          by GLIB_000:51;
        G2.order() + 1 = k + 1 by A13, GLIB_000:51; then
    A16: G2.order() = k;
        card v.edgesInOut() = v.degree() by GLIB_000:22
                           .= 1 by A14, GLIB_000:def 54; then
        G2.size() + 1 = k by A13, A15; then
    A17: G2 is connected by A12, A16;
        consider e being set such that
    A18: v.edgesInOut() = {e} & not e Joins v,v,G by A14, GLIB_000:def 53;
        e in v.edgesInOut() by A18, TARSKI:def 1;
        hence G is connected by A17, A18, Th3;
    end; then
A19: for k being non empty Nat st P[k] holds P[k+1];
    for k being non empty Nat holds P[k] from BINARITH:sch 1(A11,A19); then
    G is connected by A9;
    hence G is Tree-like by A9, Def3;
end;

theorem  ::tGTREE03
  for G being finite _Graph holds
    G is Tree-like iff G is connected & G.order() = G.size() + 1 proof
     let G be finite _Graph;
    thus G is Tree-like implies G is connected & G.order() = G.size()+1
      by Def3,Th46;
    assume
A1: G is connected & G.order() = G.size() + 1;
    now assume not G is acyclic; then
        consider W being Walk of G such that
    A2: W is Cycle-like by Def2;
        set e = choose W.edges();
        consider G2 being removeEdge of G,e;
        W is non trivial by A2, GLIB_001:def 31; then
    A3: W.edges() <> {} by GLIB_001:137; then
    A4: e in W.edges();
    A5: G2 is connected by A1, A2, A3,Th5;
        G2.order()=G.order() & G2.size()+1=G.size() by A4,GLIB_000:55; then
        G2.size() + 1 + 1 <= G2.size() + 1 + 0 by A1,A5, Th40;
        hence contradiction by XREAL_1:8;
    end;
    hence G is Tree-like by A1, Def3;
end;

theorem Th48: ::tGTREE04
  G1 == G2 & G1 is Tree-like implies G2 is Tree-like proof assume
A1: G1 == G2 & G1 is Tree-like; then
    G1 is connected & G1 is acyclic by Def3; then
    G2 is connected & G2 is acyclic by A1,Th8,Th44;
    hence thesis by Def3;
end;

theorem  ::tGDTREE01
  G is_DTree_rooted_at x implies x is Vertex of G  proof
    consider v being Vertex of G;
    assume G is_DTree_rooted_at x; then
    consider W being DWalk of G such that
A1: W is_Walk_from x,v by Def4;
    thus x is Vertex of G by A1, GLIB_001:19;
end;

theorem  ::tGDTREE02
  G1 == G2 & G1 is_DTree_rooted_at x implies G2 is_DTree_rooted_at x proof
    assume
A1: G1 == G2 & G1 is_DTree_rooted_at x; then
A2: G1 is Tree-like &
    for y being Vertex of G1 holds
      ex W being DWalk of G1 st W is_Walk_from x,y by Def4;
A3: G2 is Tree-like by A1,A2,Th48;
    now let y be Vertex of G2;
        reconsider y' = y as Vertex of G1 by A1, GLIB_000:def 36;
        consider W being DWalk of G1 such that
    A4: W is_Walk_from x,y' by A1,Def4;
        reconsider W'=W as DWalk of G2 by A1,GLIB_001:180,GLIB_001:182;
        take W';
        thus W' is_Walk_from x,y by A4,GLIB_001:20;
    end;
    hence G2 is_DTree_rooted_at x by A3, Def4;
end;  
