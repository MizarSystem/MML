:: More About Polynomials: Monomials and Constant Polynomials
::  by Christoph Schwarzweller
::
:: Received November 28, 2001
:: Copyright (c) 2001 Association of Mizar Users
 
environ

 vocabularies RLVECT_1, ALGSTR_1, ALGSTR_0, VECTSP_1, BINOP_1, LATTICES,
      VECTSP_2, ZFMISC_1, XBOOLE_0, STRUCT_0, POLYNOM1, VALUED_0, SUBSET_1,
      SUPINF_2, FUNCT_4, PRE_POLY, FUNCT_1, FUNCOP_1, RELAT_1, ORDINAL1,
      CARD_1, PARTFUN1, POLYNOM2, FINSEQ_1, CARD_3, NUMBERS, XXREAL_0,
      QC_LANG1, FINSET_1, ORDERS_1, ARYTM_3, NAT_1, MESFUNC1, QUOFIELD,
      GROUP_1, TARSKI, MSSUBFAM, ALGSEQ_1, CAT_3, XCMPLX_0, ORDINAL4, POLYNOM7;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELSET_1, FUNCT_1,
      FINSET_1, ORDINAL1, PARTFUN1, FUNCT_2, FUNCT_7, POLYNOM1, NUMBERS,
      XXREAL_0, DOMAIN_1, STRUCT_0, ALGSTR_0, FUNCT_4, NAT_1, ALGSTR_1,
      RLVECT_1, ORDERS_1, FINSEQ_1, FUNCOP_1, GROUP_1, QUOFIELD, GRCAT_1,
      VECTSP_2, POLYNOM2, VECTSP_1, GROUP_6, PRE_POLY;
 constructors RFUNCT_3, REALSET2, GRCAT_1, GROUP_6, TRIANG_1, QUOFIELD,
      POLYNOM2, ALGSTR_1, RELSET_1, FUNCT_7, FVSUM_1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FUNCOP_1, FINSET_1, XREAL_0,
      STRUCT_0, VECTSP_1, ALGSTR_1, POLYNOM1, POLYNOM2, ALGSTR_0, CARD_1,
      SUBSET_1, PRE_POLY;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, STRUCT_0;
 theorems TARSKI, FINSEQ_1, FUNCT_1, FUNCT_2, RELAT_1, ZFMISC_1, VECTSP_1,
      POLYNOM1, STRUCT_0, QUOFIELD, FUNCT_7, FUNCT_4, FUNCOP_1, GRCAT_1, BINOM,
      FINSEQ_3, RLVECT_1, VECTSP_2, GROUP_1, NAT_1, FINSEQ_2, FINSEQ_5,
      MATRLIN, POLYNOM2, XBOOLE_0, REALSET1, XREAL_1, GROUP_6, XXREAL_0,
      ORDINAL1, PARTFUN1, PRE_POLY;
 schemes FUNCT_2;

begin

registration
  cluster Abelian left_zeroed right_zeroed add-associative
    right_complementable well-unital associative commutative distributive
    domRing-like (non trivial doubleLoopStr);
  existence
  proof
    consider R being domRing;
    take R;
    thus thesis;
  end;
end;

definition
  let X be set, R be non empty ZeroStr, p be Series of X,R;
  canceled;
  attr p is non-zero means
  :Def2:
  p <> 0_(X,R);
end;

registration
  let X be set, R be non trivial ZeroStr;
  cluster non-zero Series of X,R;
  existence
  proof
    consider a being Element of NonZero R;
A1: not a in {0.R} by XBOOLE_0:def 5;
    reconsider a as Element of R;
    set p = 0_(X,R)+*(EmptyBag X,a);
    reconsider p as Function of Bags X, the carrier of R;
    reconsider p as Function of Bags X, R;
    reconsider p as Series of X,R;
    take p;
    0_(X,R) = (Bags X --> 0.R) by POLYNOM1:def 24;
    then dom 0_(X,R) = Bags X by FUNCOP_1:19;
    then
A2: p.(EmptyBag X) = a by FUNCT_7:33;
    a <> 0.R by A1,TARSKI:def 1;
    then p <> 0_(X,R) by A2,POLYNOM1:81;
    hence thesis by Def2;
  end;
end;

registration
  let n be Ordinal, R be non trivial ZeroStr;
  cluster non-zero Polynomial of n,R;
  existence
  proof
    consider a being Element of NonZero R;
A1: not a in {0.R} by XBOOLE_0:def 5;
    reconsider a as Element of R;
    set p = 0_(n,R)+*(EmptyBag n,a);
    reconsider p as Function of Bags n, the carrier of R;
    reconsider p as Function of Bags n, R;
    reconsider p as Series of n,R;
A2: now
      let u be set;
      assume
A3:   u in Support p;
      then
A4:   u is Element of Bags n;
      now
        assume u <> EmptyBag n;
        then p.u = (0_(n,R)).u by FUNCT_7:34
          .= 0.R by A4,POLYNOM1:81;
        hence contradiction by A3,POLYNOM1:def 9;
      end;
      hence u in {EmptyBag n} by TARSKI:def 1;
    end;
    0_(n,R) = (Bags n --> 0.R) by POLYNOM1:def 24;
    then dom 0_(n,R) = Bags n by FUNCOP_1:19;
    then
A5: p.(EmptyBag n) = a by FUNCT_7:33;
    now
      let u be set;
      assume u in {EmptyBag n};
      then
A6:   u = EmptyBag n by TARSKI:def 1;
      a <> 0.R by A1,TARSKI:def 1;
      hence u in Support p by A5,A6,POLYNOM1:def 9;
    end;
    then Support p = {EmptyBag n} by A2,TARSKI:2;
    then reconsider p as Polynomial of n,R by POLYNOM1:def 10;
    take p;
    a <> 0.R by A1,TARSKI:def 1;
    then p <> 0_(n,R) by A5,POLYNOM1:81;
    hence thesis by Def2;
  end;
end;

theorem Th1:
  for X being set, R being non empty ZeroStr, s being Series of X,R
  holds s = 0_(X,R) iff Support s = {}
proof
  let X be set, R be (non empty ZeroStr), s be Series of X,R;
A1: now
    assume
A2: Support s = {};
A3: now
      let x be set;
      assume x in Bags X;
      then reconsider x9 = x as Element of Bags X;
      s.x9 = 0.R by A2,POLYNOM1:def 9;
      hence s.x = (0_(X,R)).x by POLYNOM1:81;
    end;
    dom s = Bags X & dom 0_(X,R) = Bags X by FUNCT_2:def 1;
    hence s = 0_(X,R) by A3,FUNCT_1:9;
  end;
  now
    assume
A4: s = 0_(X,R);
    now
      consider x being Element of Support s;
      assume Support s <> {};
      then
A5:   x in Support s;
      then reconsider x as bag of X;
      s.x <> 0.R by A5,POLYNOM1:def 9;
      hence contradiction by A4,POLYNOM1:81;
    end;
    hence Support s = {};
  end;
  hence thesis by A1;
end;

theorem
  for X being set, R being non empty ZeroStr holds R is non trivial iff
  ex s being Series of X,R st Support(s) <> {}
proof
  let X be set, R be non empty ZeroStr;
A1: now
    set x = EmptyBag X;
    assume
A2: R is non trivial;
    now
      assume
A3:   not(ex a being Element of R st a <> 0.R);
      ex x being set st the carrier of R = {x}
      proof
        take 0.R;
A4:     now
          let u be set;
          assume u in the carrier of R;
          then u = 0.R by A3;
          hence u in {0.R} by TARSKI:def 1;
        end;
        for u being set holds u in {0.R} implies u in the carrier of R;
        hence thesis by A4,TARSKI:2;
      end;
      hence contradiction by A2,REALSET1:def 4;
    end;
    then consider a being Element of R such that
A5: a <> 0.R;
    set s = (Bags X) --> a;
    reconsider s as Function of Bags X,the carrier of R;
    reconsider s as Function of Bags X,R;
    reconsider s as Series of X,R;
    take s;
    s.x = a by FUNCOP_1:13;
    then EmptyBag X in Support s by A5,POLYNOM1:def 9;
    hence ex s being Series of X,R st Support(s) <> {};
  end;
  now
    assume ex s being Series of X,R st Support(s) <> {};
    then consider s being Series of X,R such that
A6: Support(s) <> {};
    consider b being Element of Support s;
    b in Support s by A6;
    then reconsider b as Element of Bags X;
    now
      assume ex x being set st the carrier of R = {x};
      then consider x being set such that
A7:   the carrier of R = {x};
      0.R = x by A7,TARSKI:def 1
        .= s.b by A7,TARSKI:def 1;
      hence contradiction by A6,POLYNOM1:def 9;
    end;
    hence R is non trivial by REALSET1:def 4;
  end;
  hence thesis by A1;
end;

definition
  let X be set, b be bag of X;
  attr b is univariate means
  :Def3:
  ex u being Element of X st support b = {u};
end;

registration
  let X be non empty set;
  cluster univariate bag of X;
  existence
  proof
    consider x being Element of X;
    set b = EmptyBag X +* (x,1);
    take b;
A1: dom (EmptyBag X) = X by PARTFUN1:def 4;
    then
A2: b.x = ((EmptyBag X)+*(x.-->1)).x by FUNCT_7:def 3;
A3: dom (x.-->1) = {x} by FUNCOP_1:19;
A4: for u being set holds u in support b implies u in {x}
    proof
      let u be set;
      assume
A5:   u in support b;
      now
        assume u <> x;
        then
A6:     not u in dom (x.-->1) by A3,TARSKI:def 1;
        b.u = ((EmptyBag X)+*(x.-->1)).u by A1,FUNCT_7:def 3;
        then b.u = (EmptyBag X).u by A6,FUNCT_4:12
          .= 0 by PRE_POLY:52;
        hence contradiction by A5,PRE_POLY:def 7;
      end;
      hence thesis by TARSKI:def 1;
    end;
    x in dom (x.-->1) by A3,TARSKI:def 1;
    then
A7: b.x = (x.-->1).x by A2,FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    for u being set holds u in {x} implies u in support b
    proof
      let u be set;
      assume u in {x};
      then u = x by TARSKI:def 1;
      hence thesis by A7,PRE_POLY:def 7;
    end;
    then support b = {x} by A4,TARSKI:2;
    hence thesis by Def3;
  end;
end;

registration
  let X be non empty set;
  cluster univariate -> non empty bag of X;
  coherence
  proof
    let b be bag of X;
    assume b is univariate;
    then consider x being Element of X such that
A1: support b = {x} by Def3;
    x in support b by A1,TARSKI:def 1;
    then b.x <> 0 by PRE_POLY:def 7;
    then b.x <> (EmptyBag X).x by PRE_POLY:52;
    hence thesis by POLYNOM2:def 1;
  end;
end;

begin :: Polynomials without Variables

theorem
  for b being bag of {} holds b = EmptyBag {}
proof
  set n = {};
  let b be bag of {};
A1: for b being bag of n holds b = {}
  proof
    let b be bag of n;
    b in Bags n by PRE_POLY:def 12;
    hence thesis by PRE_POLY:51,TARSKI:def 1;
  end;
  then EmptyBag n = {};
  hence thesis by A1;
end;

Lm1: for L being (non empty doubleLoopStr), p being Polynomial of {},L holds
ex a being Element of L st p = {EmptyBag {}} --> a
proof
  set n = {};
  let L be (non empty doubleLoopStr), p be Polynomial of {},L;
A1: for b being bag of {} holds b = {}
  proof
    let b be bag of {};
    b in Bags {} by PRE_POLY:def 12;
    hence thesis by PRE_POLY:51,TARSKI:def 1;
  end;
  reconsider p as Function of Bags {},L;
  reconsider p as Function of {{}},the carrier of L by PRE_POLY:51;
  set a = p/.{};
A2: dom p = {{}} by FUNCT_2:def 1
    .= {EmptyBag n} by A1;
A3: for u being set holds u in p implies u in [:{EmptyBag n},{a}:]
  proof
    let u be set;
    assume
A4: u in p;
    then consider p1,p2 being set such that
A5: u = [p1,p2] by RELAT_1:def 1;
A6: p1 in dom p by A4,A5,RELAT_1:def 4;
    then reconsider p1 as bag of n by A2;
A7: p1 = {} by A1;
    then p2 = p.{} by A4,A5,A6,FUNCT_1:def 4
      .= p/.{} by A6,A7,PARTFUN1:def 8;
    then p2 in {a} by TARSKI:def 1;
    hence thesis by A2,A5,A6,ZFMISC_1:def 2;
  end;
  take a;
A8: EmptyBag n = {} by A1;
  for u being set holds u in [:{EmptyBag n},{a}:] implies u in p
  proof
    let u be set;
    assume u in [:{EmptyBag n},{a}:];
    then consider u1,u2 being set such that
A9: u1 in {EmptyBag n} and
A10: u2 in {a} and
A11: u = [u1,u2] by ZFMISC_1:def 2;
A12: u1 = {} by A8,A9,TARSKI:def 1;
    u2 = a by A10,TARSKI:def 1
      .= p.{} by A2,A9,A12,PARTFUN1:def 8;
    hence thesis by A2,A9,A11,A12,FUNCT_1:8;
  end;
  hence thesis by A3,TARSKI:2;
end;

theorem
  for L being right_zeroed add-associative right_complementable
well-unital distributive (non trivial doubleLoopStr), p being Polynomial of {},
  L, x being Function of {},L holds eval(p,x) = p.(EmptyBag{})
proof
  set n = {};
  let L be right_zeroed add-associative right_complementable well-unital
  distributive (non trivial doubleLoopStr), p be Polynomial of {},L, x be
  Function of {},L;
A1: for b being bag of n holds b = {}
  proof
    let b be bag of n;
    b in Bags n by PRE_POLY:def 12;
    hence thesis by PRE_POLY:51,TARSKI:def 1;
  end;
  then
A2: EmptyBag n = {};
  consider a being Element of L such that
A3: p = {EmptyBag n} --> a by Lm1;
A4: EmptyBag n in {EmptyBag n} by TARSKI:def 1;
  then
A5: p.(EmptyBag n) = a by A3,FUNCOP_1:13;
A6: dom p = {EmptyBag n} by A3,FUNCOP_1:19;
  now
    per cases;
    case
A7:   a = 0.L;
      Support p = {}
      proof
        consider u being Element of Support p;
        assume
A8:     Support p <> {};
        then u in Support p;
        then reconsider u as Element of Bags n;
        p.u <> 0.L by A8,POLYNOM1:def 9;
        hence thesis by A1,A2,A5,A7;
      end;
      then reconsider Sp = Support p as empty Subset of Bags n;
      consider y being FinSequence of the carrier of L such that
A9:   len y = len SgmX(BagOrder n, Support p) and
A10:  eval(p,x) = Sum y and
      for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (p *
SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@,x)
      by POLYNOM2:def 4;
      SgmX(BagOrder n, Sp) = {} by POLYNOM2:9,20;
      then y = <*>(the carrier of L) by A9;
      hence eval(p,x) = a by A7,A10,RLVECT_1:60;
    end;
    case
A11:  a <> 0.L;
      reconsider sp = Support p as finite Subset of Bags n;
      set sg = SgmX(BagOrder n, sp);
A12:  BagOrder n linearly_orders sp by POLYNOM2:20;
A13:  for u being set holds u in Support p implies u in {{}}
      proof
        let u be set;
        assume u in Support p;
        then reconsider u as Element of Bags n;
        u = {} by A1;
        hence thesis by TARSKI:def 1;
      end;
      for u being set holds u in {{}} implies u in Support p
      proof
        let u be set;
        assume u in {{}};
        then u = EmptyBag n by A2,TARSKI:def 1;
        hence thesis by A5,A11,POLYNOM1:def 9;
      end;
      then Support p = {{}} by A13,TARSKI:2;
      then
A14:  rng sg = {{}} by A12,PRE_POLY:def 2;
      then
A15:  {} in rng sg by TARSKI:def 1;
      then
A16:  1 in dom sg by FINSEQ_3:33;
      then sg.1 in dom p by A2,A6,A14,FUNCT_1:12;
      then 1 in dom (p * sg) by A16,FUNCT_1:21;
      then
A17:  (p * sg)/.1 = (p * sg).1 by PARTFUN1:def 8
        .= p.(sg.1) by A16,FUNCT_1:23
        .= a by A2,A3,A14,A16,FUNCOP_1:13,FUNCT_1:12;
A18:  for u being set holds u in dom sg implies u in {1}
      proof
        let u be set;
        assume
A19:    u in dom sg;
        assume
A20:    not u in {1};
        reconsider u as Element of NAT by A19;
        sg/.u = sg.u by A19,PARTFUN1:def 8;
        then
A21:    sg/.u in rng sg by A19,FUNCT_1:12;
A22:    u <> 1 by A20,TARSKI:def 1;
A23:    1 < u
        proof
          consider k being Nat such that
A24:      dom sg = Seg k by FINSEQ_1:def 2;
          Seg k = {m where m is Element of NAT : 1 <= m & m <= k} by
FINSEQ_1:def 1;
          then
          ex m9 being Element of NAT st m9 = u & 1 <= m9 & m9 <= k by A19,A24;
          hence thesis by A22,XXREAL_0:1;
        end;
        sg/.1 = sg.1 by A15,A19,FINSEQ_3:33,PARTFUN1:def 8;
        then sg/.1 in rng sg by A16,FUNCT_1:12;
        then sg/.1 = {} by A14,TARSKI:def 1
          .= sg/.u by A14,A21,TARSKI:def 1;
        hence thesis by A12,A16,A19,A23,PRE_POLY:def 2;
      end;
      for u being set holds u in {1} implies u in dom sg by A16,TARSKI:def 1;
      then dom sg = Seg 1 by A18,FINSEQ_1:4,TARSKI:2;
      then
A25:  len sg = 1 by FINSEQ_1:def 3;
      consider y being FinSequence of the carrier of L such that
A26:  len y = len sg and
A27:  Sum y = eval(p,x) and
A28:  for i being Element of NAT st 1 <= i & i <= len y holds y/.i =
      (p * sg)/.i * eval((sg/.i)@,x) by POLYNOM2:def 4;
      dom y = Seg(len y) by FINSEQ_1:def 3
        .= dom sg by A26,FINSEQ_1:def 3;
      then y.1 = y/.1 by A15,FINSEQ_3:33,PARTFUN1:def 8
        .= (p * sg)/.1 * eval((sg/.1)@,x) by A25,A26,A28
        .= (p * sg)/.1 * eval(EmptyBag n,x) by A1,A2
        .= (p * sg)/.1 * 1.L by POLYNOM2:16
        .= a by A17,VECTSP_1:def 13;
      then y = <* a *> by A25,A26,FINSEQ_1:57;
      hence eval(p,x) = a by A27,RLVECT_1:61;
    end;
  end;
  hence thesis by A3,A4,FUNCOP_1:13;
end;

theorem
  for L being right_zeroed add-associative right_complementable Abelian
  well-unital distributive associative non trivial (non trivial doubleLoopStr)
  holds Polynom-Ring({},L) is_ringisomorph_to L
proof
  set n = {};
  let L be right_zeroed add-associative right_complementable Abelian
  well-unital distributive associative non trivial (non trivial doubleLoopStr);
  set PL = Polynom-Ring(n,L);
  defpred P[set,set] means ex p being Polynomial of n,L st p = $1 & p.{} = $2;
A1: dom 0_(n,L) = Bags n by FUNCT_2:def 1;
  dom(EmptyBag n .--> 1_L) = {EmptyBag n} by FUNCOP_1:19;
  then
A2: EmptyBag n in dom(EmptyBag n .--> 1_L) by TARSKI:def 1;
A3: for b being bag of {} holds b = {}
  proof
    let b be bag of {};
    b in Bags {} by PRE_POLY:def 12;
    hence thesis by PRE_POLY:51,TARSKI:def 1;
  end;
  then
A4: EmptyBag n = {};
  then reconsider i = {} as bag of n;
A5: for x being Element of PL ex y being Element of L st P[x,y]
  proof
    let x be Element of PL;
    reconsider p = x as Polynomial of n,L by POLYNOM1:def 27;
    take p.{};
    dom p = Bags n by FUNCT_2:def 1;
    then
A6: p.{} in rng p by A4,FUNCT_1:12;
    rng p c= the carrier of L by RELAT_1:def 19;
    hence thesis by A6;
  end;
  consider f being Function of the carrier of PL,the carrier of L such that
A7: for x being Element of PL holds P[x,f.x] from FUNCT_2:sch 3(A5);
A8: dom f = the carrier of PL by FUNCT_2:def 1;
  reconsider f as Function of PL,L;
  consider p being Polynomial of n,L such that
A9: p = 1_PL and
A10: p.{} = f.(1.PL) by A7;
A11: p = 1_(n,L) by A9,POLYNOM1:90
    .= 0_(n,L)+*(EmptyBag n,1_L) by POLYNOM1:def 25;
  for x,y being Element of PL holds f.(x*y) = f.x * f.y
  proof
    let x,y be Element of PL;
    consider p being Polynomial of n,L such that
A12: p = x & p.{} = f.x by A7;
    consider q being Polynomial of n,L such that
A13: q = y & q.{} = f.y by A7;
A14: (p*'q).{} = p.i * q.i
    proof
A15:  decomp EmptyBag n = <* <*EmptyBag n, EmptyBag n*> *> by PRE_POLY:73;
      then
A16:  len decomp EmptyBag n = 1 by FINSEQ_1:56;
      set z = p.i * q.i;
      consider s being FinSequence of the carrier of L such that
A17:  (p*'q).(EmptyBag n) = Sum s and
A18:  len s = len decomp EmptyBag n and
A19:  for k being Element of NAT st k in dom s ex b1, b2 being bag of
n st (decomp EmptyBag n)/.k = <*b1, b2*> & s/.k = p.b1*q.b2 by POLYNOM1:def 26;
      len s = 1 by A15,A18,FINSEQ_1:56;
      then Seg 1 = dom s by FINSEQ_1:def 3;
      then
A20:  1 in dom s by FINSEQ_1:4,TARSKI:def 1;
      then consider b1,b2 being bag of n such that
      (decomp EmptyBag n)/.1 = <*b1, b2*> and
A21:  s/.1 = p.b1*q.b2 by A19;
      s.1 = p.b1 * q.b2 by A20,A21,PARTFUN1:def 8
        .= p.i * q.b2 by A3
        .= p.i * q.i by A3;
      then s = <* z *> by A16,A18,FINSEQ_1:57;
      then Sum s = z by RLVECT_1:61;
      hence thesis by A3,A17;
    end;
    ex pq being Polynomial of n,L st pq = x * y & pq.{} = f.( x*y) by A7;
    hence thesis by A12,A13,A14,POLYNOM1:def 27;
  end;
  then
A22: f is multiplicative by GROUP_6:def 7;
  for x,y being Element of PL holds f.(x+y) = f.x + f.y
  proof
    let x,y be Element of PL;
    consider p being Polynomial of n,L such that
A23: p = x and
A24: p.{} = f.x by A7;
    consider q being Polynomial of n,L such that
A25: q = y and
A26: q.{} = f.y by A7;
    consider a being Element of L such that
A27: p = {EmptyBag n} --> a by Lm1;
A28: ex pq being Polynomial of n,L st pq = x + y & pq.{} = f.( x+y) by A7;
    consider b being Element of L such that
A29: q = {EmptyBag n} --> b by Lm1;
A30: EmptyBag n in {EmptyBag n} by TARSKI:def 1;
    then
A31: p.{} = a by A4,A27,FUNCOP_1:13;
A32: (p+q).{} = p.i + q.i by POLYNOM1:def 21
      .= a + b by A4,A30,A31,A29,FUNCOP_1:13;
    q.{} = b by A4,A30,A29,FUNCOP_1:13;
    then f.x + f.y = a + b by A4,A24,A26,A27,A30,FUNCOP_1:13;
    hence thesis by A23,A25,A28,A32,POLYNOM1:def 27;
  end;
  then
A33: f is additive by GRCAT_1:def 13;
  p.i = p.(EmptyBag n) by A3
    .= (0_(n,L)+*(EmptyBag n .--> 1_L)).(EmptyBag n) by A11,A1,FUNCT_7:def 3
    .= (EmptyBag n .--> 1_L).(EmptyBag n) by A2,FUNCT_4:14
    .= 1_L by FUNCOP_1:87;
  then f is unity-preserving by A9,A10,GROUP_1:def 17;
  then
A34: f is RingHomomorphism by A33,A22,QUOFIELD:def 21;
A35: for u being set holds u in the carrier of L implies u in rng f
  proof
    let u be set;
    assume u in the carrier of L;
    then reconsider u as Element of L;
    set p = EmptyBag n .--> u;
    reconsider p as Function;
    dom p = {EmptyBag n} by FUNCOP_1:19;
    then rng p = {u} & dom p = Bags n by FUNCOP_1:14,PRE_POLY:51,TARSKI:def 1;
    then reconsider p as Function of Bags n, the carrier of L by FUNCT_2:4;
    reconsider p as Function of Bags n, L;
    reconsider p as Series of n, L;
    now
      per cases;
      case
A36:    u = 0.L;
        Support p = {}
        proof
          consider v being Element of Support p;
          assume Support p <> {};
          then
A37:      v in Support p;
          then v is bag of n;
          then p.v = p.(EmptyBag n) by A3,A4
            .= u by FUNCOP_1:87;
          hence thesis by A36,A37,POLYNOM1:def 9;
        end;
        hence Support p is finite;
      end;
      case
A38:    u <> 0.L;
A39:    for v being set holds v in {EmptyBag n} implies v in Support p
        proof
          let v be set;
          assume
A40:      v in {EmptyBag n};
          then reconsider v as Element of Bags n;
          p.v = p.(EmptyBag n) by A40,TARSKI:def 1
            .= u by FUNCOP_1:87;
          hence thesis by A38,POLYNOM1:def 9;
        end;
        for v being set holds v in Support p implies v in {EmptyBag n}
        proof
          let v be set;
          assume v in Support p;
          then reconsider v as bag of n;
          v = EmptyBag n by A3,A4;
          hence thesis by TARSKI:def 1;
        end;
        hence Support p is finite by A39,TARSKI:2;
      end;
    end;
    then reconsider p as Polynomial of n,L by POLYNOM1:def 10;
    reconsider p9 = p as Element of PL by POLYNOM1:def 27;
    consider q being Polynomial of n,L such that
A41: q = p9 and
A42: q.{} = f.p9 by A7;
    q.{} = p.(EmptyBag n) by A3,A41
      .= u by FUNCOP_1:87;
    hence thesis by A8,A42,FUNCT_1:12;
  end;
  rng f c= the carrier of L by RELAT_1:def 19;
  then for u being set holds u in rng f implies u in the carrier of L;
  then rng f = the carrier of L by A35,TARSKI:2;
  then
A43: f is RingEpimorphism by A34,QUOFIELD:def 22;
  for x1,x2 being set st x1 in dom f & x2 in dom f & f.x1 = f.x2 holds x1 = x2
  proof
    let x1,x2 be set;
    assume that
A44: x1 in dom f & x2 in dom f and
A45: f.x1 = f.x2;
    reconsider x1,x2 as Element of PL by A44;
    consider p being Polynomial of n,L such that
A46: p = x1 & p.{} = f.x1 by A7;
    consider q being Polynomial of n,L such that
A47: q = x2 & q.{} = f.x2 by A7;
    consider a2 being Element of L such that
A48: q = {EmptyBag n} --> a2 by Lm1;
A49: EmptyBag n in {EmptyBag n} by TARSKI:def 1;
    then
A50: q.(EmptyBag n) = a2 by A48,FUNCOP_1:13;
A51: p.{} = p.(EmptyBag n) by A3;
    consider a1 being Element of L such that
A52: p = {EmptyBag n} --> a1 by Lm1;
    p.(EmptyBag n) = a1 by A52,A49,FUNCOP_1:13;
    hence thesis by A3,A45,A46,A47,A52,A48,A50,A51;
  end;
  then f is one-to-one by FUNCT_1:def 8;
  then f is RingMonomorphism by A34,QUOFIELD:def 23;
  then f is RingIsomorphism by A43,QUOFIELD:def 24;
  hence thesis by QUOFIELD:def 26;
end;

begin :: Monomials

definition
  let X be set, L be non empty ZeroStr, p be Series of X,L;
  attr p is monomial-like means
  :Def4:
  ex b being bag of X st for b9 being bag of X st b9 <> b holds p.b9 = 0.L;
end;

registration
  let X be set, L be non empty ZeroStr;
  cluster monomial-like Series of X,L;
  existence
  proof
    set p = 0_(X,L);
    take p;
    for b9 being bag of X st b9 <> EmptyBag X holds p.b9 = 0.L by POLYNOM1:81;
    hence thesis by Def4;
  end;
end;

definition
  let X be set, L be non empty ZeroStr;
  mode Monomial of X,L is monomial-like Series of X,L;
end;

registration
  let X be set, L be non empty ZeroStr;
  cluster monomial-like -> finite-Support Series of X,L;
  coherence
  proof
    let s be Series of X,L;
    assume s is monomial-like;
    then consider b being bag of X such that
A1: for b9 being bag of X st b9 <> b holds s.b9 = 0.L by Def4;
    per cases;
    suppose
A2:   s.b = 0.L;
      now
        assume Support s <> {};
        then reconsider sp = Support s as non empty Subset of Bags X;
        consider c being Element of sp;
        s.c <> 0.L by POLYNOM1:def 9;
        hence contradiction by A1,A2;
      end;
      hence thesis by POLYNOM1:def 10;
    end;
    suppose
A3:   s.b <> 0.L;
A4:   now
        let u be set;
        assume
A5:     u in Support s;
        then reconsider u9 = u as Element of Bags X;
        s.u9 <> 0.L by A5,POLYNOM1:def 9;
        then u9 = b by A1;
        hence u in {b} by TARSKI:def 1;
      end;
      now
        let u be set;
        assume u in {b};
        then
A6:     u = b by TARSKI:def 1;
        then reconsider u9 = u as Element of Bags X by PRE_POLY:def 12;
        u9 in Support s by A3,A6,POLYNOM1:def 9;
        hence u in Support s;
      end;
      then Support s = {b} by A4,TARSKI:2;
      hence thesis by POLYNOM1:def 10;
    end;
  end;
end;

theorem Th6:
  for X being set, L being non empty ZeroStr, p being Series of X,L
  holds p is Monomial of X,L iff (Support p = {} or ex b being bag of X st
  Support p = {b})
proof
  let n be set, L be non empty ZeroStr, p be Series of n,L;
A1: now
    assume ex b being bag of n st Support p = {b};
    then consider b being bag of n such that
A2: Support p = {b};
    for b9 being bag of n st b9 <> b holds p.b9 = 0.L
    proof
      let b9 be bag of n;
      assume
A3:   b9 <> b;
      assume
A4:   p.b9 <> 0.L;
      reconsider b9 as Element of Bags n by PRE_POLY:def 12;
      b9 in Support p by A4,POLYNOM1:def 9;
      hence thesis by A2,A3,TARSKI:def 1;
    end;
    hence p is Monomial of n,L by Def4;
  end;
A5: now
    assume p is Monomial of n,L;
    then consider b being bag of n such that
A6: for b9 being bag of n st b9 <> b holds p.b9 = 0.L by Def4;
    now
      per cases;
      case
A7:     p.b <> 0.L;
A8:     for u being set holds u in {b} implies u in Support p
        proof
          let u be set;
          assume
A9:       u in {b};
          then u = b by TARSKI:def 1;
          then reconsider u9 = u as Element of Bags n by PRE_POLY:def 12;
          p.u9 <> 0.L by A7,A9,TARSKI:def 1;
          hence thesis by POLYNOM1:def 9;
        end;
        for u being set holds u in Support p implies u in {b}
        proof
          let u be set;
          assume
A10:      u in Support p;
          then reconsider u9 = u as bag of n;
          p.u <> 0.L by A10,POLYNOM1:def 9;
          then u9 = b by A6;
          hence thesis by TARSKI:def 1;
        end;
        then Support p = {b} by A8,TARSKI:2;
        hence ex b being bag of n st Support p = {b};
      end;
      case
A11:    p.b = 0.L;
        thus Support p = {}
        proof
          assume Support p <> {};
          then reconsider sp = Support p as non empty Subset of Bags n;
          consider c being Element of sp;
          p.c <> 0.L by POLYNOM1:def 9;
          hence thesis by A6,A11;
        end;
      end;
    end;
    hence Support p = {} or ex b being bag of n st Support p = {b};
  end;
  now
    consider b being bag of n;
    assume
A12: Support p = {};
    for b9 being bag of n st b9 <> b holds p.b9 = 0.L
    proof
      let b9 be bag of n;
      assume b9 <> b;
      reconsider c = b9 as Element of Bags n by PRE_POLY:def 12;
      assume p.b9 <> 0.L;
      then c in Support p by POLYNOM1:def 9;
      hence thesis by A12;
    end;
    hence p is Monomial of n,L by Def4;
  end;
  hence thesis by A1,A5;
end;

definition
  let X be set, L be non empty ZeroStr, a be Element of L, b be bag of X;
  func Monom(a,b) -> Monomial of X,L equals
  0_(X,L)+*(b,a);
  coherence
  proof
    dom(b .--> a) = {b} by FUNCOP_1:19;
    then
A1: b in dom(b .--> a) by TARSKI:def 1;
    set m = 0_(X,L)+*(b,a);
    reconsider m as Function of Bags X, the carrier of L;
    reconsider m as Function of Bags X, L;
    reconsider m as Series of X, L;
A2: b in Bags X by PRE_POLY:def 12;
A3: dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
      .= Bags X by FUNCOP_1:19;
    then
A4: m = 0_(X,L)+*(b .--> a) by A2,FUNCT_7:def 3;
A5: m.b = (0_(X,L)+*(b .--> a)).b by A3,A2,FUNCT_7:def 3
      .= (b .--> a).b by A1,FUNCT_4:14
      .= a by FUNCOP_1:87;
    now
      per cases;
      case
A6:     a <> 0.L;
A7:     for u being set holds u in Support m implies u in {b}
        proof
          let u be set;
          assume
A8:       u in Support m;
          assume not u in {b};
          then
A9:       not u in dom(b .--> a) by FUNCOP_1:19;
          reconsider u as bag of X by A8;
          m.u = (0_(X,L)).u by A4,A9,FUNCT_4:12
            .= 0.L by POLYNOM1:81;
          hence thesis by A8,POLYNOM1:def 9;
        end;
        b in Support m by A2,A5,A6,POLYNOM1:def 9;
        then for u being set holds u in {b} implies u in Support m by
TARSKI:def 1;
        then Support m = {b} by A7,TARSKI:2;
        hence thesis by Th6;
      end;
      case
A10:    a = 0.L;
        now
          assume Support m <> {};
          then reconsider sm = Support m as non empty Subset of Bags X;
          consider c being Element of sm;
          m.c <> 0.L by POLYNOM1:def 9;
          then not c in {b} by A5,A10,TARSKI:def 1;
          then
A12:      not c in dom(b .--> a) by FUNCOP_1:19;
          reconsider c as bag of X;
          m.c = (0_(X,L)).c by A4,A12,FUNCT_4:12
            .= 0.L by POLYNOM1:81;
          hence contradiction by POLYNOM1:def 9;
        end;
        hence thesis by Th6;
      end;
    end;
    hence thesis;
  end;
end;

definition
  let X be set, L be non empty ZeroStr, m be Monomial of X,L;
  func term(m) -> bag of X means
  :Def6:
  m.it <> 0.L or Support m = {} & it = EmptyBag X;
  existence
  proof
    consider b being bag of X such that
A1: for b9 being bag of X st b9 <> b holds m.b9 = 0.L by Def4;
    now
      per cases;
      case
        m.b <> 0.L;
        hence thesis;
      end;
      case
A2:     m.b = 0.L;
        Support m = {}
        proof
          assume Support m <> {};
          then reconsider sm = Support m as non empty Subset of Bags X;
          consider c being Element of sm;
          m.c <> 0.L by POLYNOM1:def 9;
          hence thesis by A1,A2;
        end;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let b1,b2 be bag of X;
    assume
A3: m.b1 <> 0.L or Support m = {} & b1 = EmptyBag X;
    consider b being bag of X such that
A4: for b9 being bag of X st b9 <> b holds m.b9 = 0.L by Def4;
    assume
A5: m.b2 <> 0.L or Support m = {} & b2 = EmptyBag X;
    now
      per cases;
      case
A6:     m.b1 <> 0.L;
        reconsider b19 = b1 as Element of Bags X by PRE_POLY:def 12;
A7:     b19 in Support m by A6,POLYNOM1:def 9;
        thus b1 = b by A4,A6
          .= b2 by A5,A4,A7;
      end;
      case
A8:     m.b1 = 0.L;
        now
          per cases by A5;
          case
A9:         m.b2 <> 0.L;
            reconsider b29 = b2 as Element of Bags X by PRE_POLY:def 12;
            b29 in Support m by A9,POLYNOM1:def 9;
            hence thesis by A3,A8;
          end;
          case
            Support m = {} & b2 = EmptyBag X;
            hence thesis by A3,A8;
          end;
        end;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
end;

definition
  let X be set, L be non empty ZeroStr, m be Monomial of X,L;
  func coefficient(m) -> Element of L equals
  m.(term(m));
  coherence;
end;

theorem Th7:
  for X being set, L being non empty ZeroStr, m being Monomial of X
  ,L holds Support(m) = {} or Support(m) = {term(m)}
proof
  let X be set, L be non empty ZeroStr, m be Monomial of X,L;
A1: term(m) is Element of Bags X by PRE_POLY:def 12;
  assume
A2: Support(m) <> {};
  then m.term(m) <> 0.L by Def6;
  then
A3: term(m) in Support(m) by A1,POLYNOM1:def 9;
  ex b being bag of X st Support(m) = {b} by A2,Th6;
  hence thesis by A3,TARSKI:def 1;
end;

theorem Th8:
  for X being set, L being non empty ZeroStr, b being bag of X
  holds coefficient(Monom(0.L,b)) = 0.L & term(Monom(0.L,b)) = EmptyBag X
proof
  let n be set, L be non empty ZeroStr, b be bag of n;
  set m = 0_(n,L)+*(b,0.L);
  reconsider m as Function of Bags n, the carrier of L;
  reconsider m as Function of Bags n, L;
  reconsider m as Series of n, L;
A1: b in Bags n by PRE_POLY:def 12;
A2: dom(0_(n,L)) = dom((Bags n) --> 0.L) by POLYNOM1:def 24
    .= Bags n by FUNCOP_1:19;
  then
A3: m = 0_(n,L)+*(b .--> 0.L) by A1,FUNCT_7:def 3;
A4: dom(b .--> 0.L) = {b} by FUNCOP_1:19;
  then
A5: b in dom(b .--> 0.L) by TARSKI:def 1;
A6: m.b = (0_(n,L)+*(b .--> 0.L)).b by A2,A1,FUNCT_7:def 3
    .= (b .--> 0.L).b by A5,FUNCT_4:14
    .= 0.L by FUNCOP_1:87;
A7: now
    let b9 be bag of n;
    now
      per cases;
      case
        b9 = b;
        hence m.b9 = 0.L by A6;
      end;
      case
        b9 <> b;
        then not b9 in dom(b .--> 0.L) by A4,TARSKI:def 1;
        hence m.b9 = (0_(n,L)).b9 by A3,FUNCT_4:12
          .= 0.L by POLYNOM1:81;
      end;
    end;
    hence m.b9 = 0.L;
  end;
  hence coefficient(Monom(0.L,b)) = 0.L;
  (Monom(0.L,b)).(term(Monom(0.L,b))) = 0.L by A7;
  hence thesis by Def6;
end;

theorem Th9:
  for X being set, L being non empty ZeroStr, a being Element of L,
  b being bag of X holds coefficient(Monom(a,b)) = a
proof
  let n be set, L be non empty ZeroStr, a be Element of L, b be bag of n;
  set m = 0_(n,L)+*(b,a);
  reconsider m as Function of Bags n, the carrier of L;
  reconsider m as Function of Bags n, L;
  reconsider m as Series of n, L;
A1: b in Bags n by PRE_POLY:def 12;
  dom(b .--> a) = {b} by FUNCOP_1:19;
  then
A2: b in dom(b .--> a) by TARSKI:def 1;
  dom(0_(n,L)) = dom((Bags n) --> 0.L) by POLYNOM1:def 24
    .= Bags n by FUNCOP_1:19;
  then
A3: m.b = (0_(n,L)+*(b .--> a)).b by A1,FUNCT_7:def 3
    .= (b .--> a).b by A2,FUNCT_4:14
    .= a by FUNCOP_1:87;
  per cases;
  suppose
    m.b <> 0.L;
    hence thesis by A3,Def6;
  end;
  suppose
    m.b = 0.L;
    hence thesis by A3,Th8;
  end;
end;

theorem Th10:
  for X being set, L being non trivial ZeroStr, a being non zero
  Element of L, b being bag of X holds term(Monom(a,b)) = b
proof
  let n be set, L be (non trivial ZeroStr), a be non zero Element of L, b be
  bag of n;
  set m = 0_(n,L)+*(b,a);
  reconsider m as Function of Bags n, the carrier of L;
  reconsider m as Function of Bags n, L;
  reconsider m as Series of n, L;
A1: b in Bags n by PRE_POLY:def 12;
  dom(b .--> a) = {b} by FUNCOP_1:19;
  then
A2: b in dom(b .--> a) by TARSKI:def 1;
  dom(0_(n,L)) = dom((Bags n) --> 0.L) by POLYNOM1:def 24
    .= Bags n by FUNCOP_1:19;
  then m.b = (0_(n,L)+*(b .--> a)).b by A1,FUNCT_7:def 3
    .= (b .--> a).b by A2,FUNCT_4:14
    .= a by FUNCOP_1:87;
  then m.b <> 0.L;
  hence thesis by Def6;
end;

theorem
  for X being set, L being non empty ZeroStr, m being Monomial of X,L
  holds Monom(coefficient(m),term(m)) = m
proof
  let X be set, L be (non empty ZeroStr), m be Monomial of X,L;
A1: dom m = Bags X & dom Monom(coefficient(m),term(m)) = Bags X by
FUNCT_2:def 1;
  per cases by Th6;
  suppose
A2: Support m = {};
A3: now
A4:   term(m) is Element of Bags X by PRE_POLY:def 12;
      assume coefficient(m) <> 0.L;
      hence contradiction by A2,A4,POLYNOM1:def 9;
    end;
A5: m = 0_(X,L) by A2,Th1;
    set m9 = Monom(coefficient(m),term(m));
A6: dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
      .= Bags X by FUNCOP_1:19;
A7: dom(EmptyBag X .--> 0.L) = {EmptyBag X} by FUNCOP_1:19;
    then
A8: EmptyBag X in dom(EmptyBag X .--> 0.L) by TARSKI:def 1;
A9: term(m) = EmptyBag X by A2,Def6;
    then
A10: m9.EmptyBag X = (0_(X,L)+*(EmptyBag X .--> 0.L)).EmptyBag X by A3,A6,
FUNCT_7:def 3
      .= (EmptyBag X .--> 0.L).EmptyBag X by A8,FUNCT_4:14
      .= 0.L by FUNCOP_1:87;
    now
      let x be set;
      assume x in Bags X;
      then reconsider x9= x as Element of Bags X;
      now
        per cases;
        case
          x9 = EmptyBag X;
          hence m9.x9 = 0.L by A10;
        end;
        case
          x <> EmptyBag X;
          then
A11:      not x9 in dom(EmptyBag X .--> 0.L) by A7,TARSKI:def 1;
          m9.x9 = (0_(X,L)+*(EmptyBag X .--> 0.L)).x9 by A9,A3,A6,FUNCT_7:def 3
            .= 0_(X,L).x9 by A11,FUNCT_4:12;
          hence m9.x9 = 0.L by POLYNOM1:81;
        end;
      end;
      hence m.x = m9.x by A5,POLYNOM1:81;
    end;
    hence thesis by A1,FUNCT_1:9;
  end;
  suppose
    ex b being bag of X st Support m = {b};
    then consider b being bag of X such that
A12: Support m = {b};
    set a = m.b;
    dom(b .--> a) = {b} by FUNCOP_1:19;
    then
A13: b in dom(b .--> a) by TARSKI:def 1;
    set m9 = Monom(coefficient(m),term(m));
A14: dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
      .= Bags X by FUNCOP_1:19;
A15: b in Support m by A12,TARSKI:def 1;
    then a <> 0.L by POLYNOM1:def 9;
    then
A16: term(m) = b by Def6;
A17: now
      let u be set;
      assume
A18:  u in Support(Monom(coefficient(m),term(m)));
      then reconsider u9 = u as Element of Bags X;
      now
A19:    dom(b .--> a) = {b} by FUNCOP_1:19;
        assume u <> b;
        then
A20:    not u9 in dom(b .--> a) by A19,TARSKI:def 1;
        b in dom 0_(X,L) by A14,PRE_POLY:def 12;
        then m9.u9 = (0_(X,L)+*(b .--> a)).u9 by A16,FUNCT_7:def 3
          .= 0_(X,L).u9 by A20,FUNCT_4:12;
        hence m9.u9 = 0.L by POLYNOM1:81;
      end;
      hence u in {b} by A18,POLYNOM1:def 9,TARSKI:def 1;
    end;
    b in Bags X by PRE_POLY:def 12;
    then
A21: m9.b = (0_(X,L)+*(b .--> a)).b by A16,A14,FUNCT_7:def 3
      .= (b .--> a).b by A13,FUNCT_4:14
      .= a by FUNCOP_1:87;
    now
      let u be set;
      assume u in {b};
      then
A22:  u = b by TARSKI:def 1;
      m9.b <> 0.L by A15,A21,POLYNOM1:def 9;
      hence u in Support(Monom(coefficient(m),term(m))) by A15,A22,
POLYNOM1:def 9;
    end;
    then
A23: Support(Monom(coefficient(m),term(m))) = {b} by A17,TARSKI:2;
    now
      let x be set;
      assume x in Bags X;
      then reconsider x9 = x as Element of Bags X;
      now
        per cases;
        case
          x = b;
          hence Monom(coefficient(m),term(m)).x9 = m.x9 by A21;
        end;
        case
A24:      x <> b;
          then
A25:      not x in Support(Monom(coefficient(m),term(m))) by A23,TARSKI:def 1;
          not x in Support m by A12,A24,TARSKI:def 1;
          hence m.x9 = 0.L by POLYNOM1:def 9
            .= Monom(coefficient(m),term(m)).x9 by A25,POLYNOM1:def 9;
        end;
      end;
      hence m.x = Monom(coefficient(m),term(m)).x;
    end;
    hence thesis by A1,FUNCT_1:9;
  end;
end;

theorem Th12:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive (non trivial doubleLoopStr), m
being Monomial of n,L, x being Function of n,L holds eval(m,x) = coefficient(m)
  * eval(term(m),x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive (non trivial doubleLoopStr), m be Monomial of n,L, x
  be Function of n,L;
  consider y being FinSequence of the carrier of L such that
A1: len y = len SgmX(BagOrder n, Support m) and
A2: eval(m,x) = Sum y and
A3: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (m *
  SgmX(BagOrder n, Support m))/.i * eval(((SgmX(BagOrder n, Support m))/.i)@,x)
  by POLYNOM2:def 4;
  consider b being bag of n such that
A4: for b9 being bag of n st b9 <> b holds m.b9 = 0.L by Def4;
  now
    per cases;
    case
A5:   m.b <> 0.L;
A6:   for u being set holds u in Support m implies u in {b}
      proof
        let u be set;
        assume
A7:     u in Support m;
        assume
A8:     not u in {b};
        reconsider u as Element of Bags n by A7;
        u <> b by A8,TARSKI:def 1;
        then m.u = 0.L by A4;
        hence thesis by A7,POLYNOM1:def 9;
      end;
A9:   b in Bags n & dom m = Bags n by FUNCT_2:def 1,PRE_POLY:def 12;
      reconsider sm = Support m as finite Subset of Bags n;
      set sg = SgmX(BagOrder n, sm);
A10:  BagOrder n linearly_orders sm by POLYNOM2:20;
      for u being set holds u in {b} implies u in Support m
      proof
        let u be set;
        assume
A11:    u in {b};
        then u = b by TARSKI:def 1;
        then reconsider u as Element of Bags n by PRE_POLY:def 12;
        m.u <> 0.L by A5,A11,TARSKI:def 1;
        hence thesis by POLYNOM1:def 9;
      end;
      then Support m = {b} by A6,TARSKI:2;
      then
A12:  rng sg = {b} by A10,PRE_POLY:def 2;
      then
A13:  b in rng sg by TARSKI:def 1;
      then
A14:  1 in dom sg by FINSEQ_3:33;
      then
A15:  sg.1 in rng sg by FUNCT_1:12;
      then sg.1 = b by A12,TARSKI:def 1;
      then 1 in dom (m * sg) by A14,A9,FUNCT_1:21;
      then
A16:  (m * sg)/.1 = (m * sg).1 by PARTFUN1:def 8
        .= m.(sg.1) by A14,FUNCT_1:23
        .= m.b by A12,A15,TARSKI:def 1
        .= coefficient(m) by A5,Def6;
A17:  for u being set holds u in dom sg implies u in {1}
      proof
        let u be set;
        assume
A18:    u in dom sg;
        assume
A19:    not u in {1};
        reconsider u as Element of NAT by A18;
        sg/.u = sg.u by A18,PARTFUN1:def 8;
        then
A20:    sg/.u in rng sg by A18,FUNCT_1:12;
A21:    u <> 1 by A19,TARSKI:def 1;
A22:    1 < u
        proof
          consider k being Nat such that
A23:      dom sg = Seg k by FINSEQ_1:def 2;
          Seg k = {l where l is Element of NAT : 1 <= l & l <= k} by
FINSEQ_1:def 1;
          then
          ex m9 being Element of NAT st m9 = u & 1 <= m9 & m9 <= k by A18,A23;
          hence thesis by A21,XXREAL_0:1;
        end;
        sg/.1 = sg.1 by A13,A18,FINSEQ_3:33,PARTFUN1:def 8;
        then sg/.1 in rng sg by A14,FUNCT_1:12;
        then sg/.1 = b by A12,TARSKI:def 1
          .= sg/.u by A12,A20,TARSKI:def 1;
        hence thesis by A10,A14,A18,A22,PRE_POLY:def 2;
      end;
      for u being set holds u in {1} implies u in dom sg by A14,TARSKI:def 1;
      then
A24:  dom sg = Seg 1 by A17,FINSEQ_1:4,TARSKI:2;
      then
A25:  1 in dom sg by FINSEQ_1:4,TARSKI:def 1;
      sg/.1 = sg.1 by A14,PARTFUN1:def 8;
      then sg/.1 in rng sg by A25,FUNCT_1:12;
      then
A26:  sg/.1 = b by A12,TARSKI:def 1;
A27:  len sg = 1 by A24,FINSEQ_1:def 3;
      dom y = Seg(len y) by FINSEQ_1:def 3
        .= dom sg by A1,FINSEQ_1:def 3;
      then y.1 = y/.1 by A25,PARTFUN1:def 8
        .= (m * sg)/.1 * eval((sg/.1)@,x) by A1,A3,A27
        .= (m * sg)/.1 * eval(b,x) by A26,POLYNOM2:def 3;
      then y = <* coefficient(m) * eval(b,x) *> by A1,A27,A16,FINSEQ_1:57;
      hence eval(m,x) = coefficient(m) * eval(b,x) by A2,RLVECT_1:61
        .= coefficient(m) * eval(term(m),x) by A5,Def6;
    end;
    case
A28:  m.b = 0.L;
A29:  Support m = {}
      proof
        assume Support m <> {};
        then reconsider sm = Support m as non empty Subset of Bags n;
        consider c being Element of sm;
        m.c <> 0.L by POLYNOM1:def 9;
        hence thesis by A4,A28;
      end;
      then term(m) = EmptyBag n & m.(EmptyBag n) = 0.L by Def6,POLYNOM1:def 9;
      then
A30:  coefficient(m) * eval(term(m),x) = 0.L by VECTSP_1:39;
      consider y being FinSequence of the carrier of L such that
A31:  len y = len SgmX(BagOrder n, Support m) and
A32:  eval(m,x) = Sum y and
      for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (m *
SgmX(BagOrder n, Support m))/.i * eval(((SgmX(BagOrder n, Support m))/.i)@,x)
      by POLYNOM2:def 4;
      BagOrder n linearly_orders Support m by POLYNOM2:20;
      then rng SgmX(BagOrder n, Support m) = {} by A29,PRE_POLY:def 2;
      then SgmX(BagOrder n, Support m) = {} by RELAT_1:64;
      then y = <*>(the carrier of L) by A31;
      hence thesis by A30,A32,RLVECT_1:60;
    end;
  end;
  hence thesis;
end;

theorem
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive (non trivial doubleLoopStr), a
being Element of L, b being bag of n, x being Function of n,L holds eval(Monom(
  a,b),x) = a * eval(b,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive (non trivial doubleLoopStr), a be Element of L, b be
  bag of n, x be Function of n,L;
  set m = Monom(a,b);
  now
    per cases;
    case
      a <> 0.L;
      then
A1:   a is non zero by STRUCT_0:def 12;
      thus eval(m,x) = coefficient(m) * eval(term(m),x) by Th12
        .= a * eval(term(m),x) by Th9
        .= a * eval(b,x) by A1,Th10;
    end;
    case
A2:   a = 0.L;
      for b9 being bag of n holds m.b9 = 0.L
      proof
        let b9 be bag of n;
        now
          per cases;
          case
A3:         b9 = b;
A4:         b in Bags n by PRE_POLY:def 12;
            dom(b .--> a) = {b} by FUNCOP_1:19;
            then
A5:         b in dom(b .--> a) by TARSKI:def 1;
            dom(0_(n,L)) = dom((Bags n) --> 0.L) by POLYNOM1:def 24
              .= Bags n by FUNCOP_1:19;
            then m = 0_(n,L)+*(b .--> a) by A4,FUNCT_7:def 3;
            hence m.b9 = (b .--> a).b by A3,A5,FUNCT_4:14
              .= 0.L by A2,FUNCOP_1:87;
          end;
          case
            b9 <> b;
            hence m.b9 = 0_(n,L).b9 by FUNCT_7:34
              .= 0.L by POLYNOM1:81;
          end;
        end;
        hence thesis;
      end;
      then
A6:   m.(term(m)) = 0.L;
      thus eval(m,x) = coefficient(m) * eval(term(m),x) by Th12
        .= 0.L by A6,VECTSP_1:39
        .= a * eval(b,x) by A2,VECTSP_1:39;
    end;
  end;
  hence thesis;
end;

begin :: Constant Polynomials

definition
  let X be set, L be non empty ZeroStr, p be Series of X,L;
  attr p is Constant means
  :Def8:
  for b being bag of X st b <> EmptyBag X holds p.b = 0.L;
end;

registration
  let X be set, L be non empty ZeroStr;
  cluster Constant Series of X,L;
  existence
  proof
    set c = 0_(X,L);
    take c;
    for b being bag of X st b <> EmptyBag X holds c.b = 0.L by POLYNOM1:81;
    hence thesis by Def8;
  end;
end;

definition
  let X be set, L be non empty ZeroStr;
  mode ConstPoly of X,L is Constant Series of X,L;
end;

registration
  let X be set, L be non empty ZeroStr;
  cluster Constant -> monomial-like Series of X,L;
  coherence
  proof
    let p be Series of X,L;
    assume p is Constant;
    then for b being bag of X st b <> EmptyBag X holds p.b = 0.L by Def8;
    hence thesis by Def4;
  end;
end;

theorem Th14:
  for X being set, L being non empty ZeroStr, p being Series of X,
  L holds p is ConstPoly of X,L iff (p = 0_(X,L) or Support p = {EmptyBag X})
proof
  let n be set, L be non empty ZeroStr, p be Series of n,L;
A1: now
    assume
A2: p is ConstPoly of n,L;
A3: for u being set holds u in Support p implies u in {EmptyBag n}
    proof
      let u be set;
      assume
A4:   u in Support p;
      then reconsider u as Element of Bags n;
      reconsider u9 = u as bag of n;
      p.u9 <> 0.L by A4,POLYNOM1:def 9;
      then u9 = EmptyBag n by A2,Def8;
      hence thesis by TARSKI:def 1;
    end;
    thus Support p = {EmptyBag n} or p = 0_(n,L)
    proof
      assume
A5:   not Support p = {EmptyBag n};
A6:   not EmptyBag n in Support p
      proof
        assume EmptyBag n in Support p;
        then
        for u being set holds u in {EmptyBag n} implies u in Support p by
TARSKI:def 1;
        hence thesis by A3,A5,TARSKI:2;
      end;
A7:   Support p = {}
      proof
        consider v being Element of Support p;
        assume Support p <> {};
        then v in Support p & v in {EmptyBag n} by A3;
        hence thesis by A6,TARSKI:def 1;
      end;
A8:   for b being bag of n holds p.b = 0.L
      proof
        let b be bag of n;
A9:     b is Element of Bags n by PRE_POLY:def 12;
        assume p.b <> 0.L;
        hence thesis by A7,A9,POLYNOM1:def 9;
      end;
A10:  for u being set holds u in rng p implies u in {0.L}
      proof
        let u be set;
        assume u in rng p;
        then consider x being set such that
A11:    x in dom p and
A12:    p.x = u by FUNCT_1:def 5;
        x is bag of n by A11;
        then u = 0.L by A8,A12;
        hence thesis by TARSKI:def 1;
      end;
A13:  dom p = Bags n by FUNCT_2:def 1;
      for u being set holds u in {0.L} implies u in rng p
      proof
        consider b being bag of n;
        let u be set;
        assume u in {0.L};
        then u = 0.L by TARSKI:def 1;
        then
A14:    p.b = u by A8;
        b in dom p by A13,PRE_POLY:def 12;
        hence thesis by A14,FUNCT_1:def 5;
      end;
      then rng p = {0.L} by A10,TARSKI:2;
      then p = (Bags n) --> 0.L by A13,FUNCOP_1:15;
      hence thesis by POLYNOM1:def 24;
    end;
  end;
  now
    assume
A15: p = 0_(n,L) or Support p = {EmptyBag n};
    per cases by A15;
    suppose
      p = 0_(n,L);
      then for b being bag of n st b <> EmptyBag n holds p.b = 0.L by
POLYNOM1:81;
      hence p is ConstPoly of n,L by Def8;
    end;
    suppose
A16:  Support p = {EmptyBag n};
      for b being bag of n st b <> EmptyBag n holds p.b = 0.L
      proof
        let b be bag of n;
        assume
A17:    b <> EmptyBag n;
        reconsider b as Element of Bags n by PRE_POLY:def 12;
        not b in Support p by A16,A17,TARSKI:def 1;
        hence thesis by POLYNOM1:def 9;
      end;
      hence p is ConstPoly of n,L by Def8;
    end;
  end;
  hence thesis by A1;
end;

registration
  let X be set, L be non empty ZeroStr;
  cluster 0_(X,L) -> Constant;
  coherence
  proof
    for b being bag of X st b <> EmptyBag X holds (0_(X,L)).b = 0.L by
POLYNOM1:81;
    hence thesis by Def8;
  end;
end;

registration
  let X be set, L be well-unital (non empty doubleLoopStr);
  cluster 1_(X,L) -> Constant;
  coherence
  proof
    for b being bag of X st b <> EmptyBag X holds (1_(X,L)).b = 0.L by
POLYNOM1:84;
    hence thesis by Def8;
  end;
end;

Lm2: for X being set, L being non empty ZeroStr, c being ConstPoly of X,L
holds term(c) = EmptyBag X & coefficient(c) = c.(EmptyBag X)
proof
  let n be set, L be non empty ZeroStr, c be ConstPoly of n,L;
  set eb = EmptyBag n;
A1: now
    per cases;
    case
      c.eb <> 0.L;
      hence term(c) = EmptyBag n by Def6;
    end;
    case
A2:   c.eb = 0.L;
      Support c = {}
      proof
        consider u being Element of Support c;
        assume
A3:     Support c <> {};
        then u in Support c;
        then reconsider u as Element of Bags n;
        c.u <> 0.L by A3,POLYNOM1:def 9;
        hence thesis by A2,Def8;
      end;
      hence term(c) = EmptyBag n by Def6;
    end;
  end;
  hence term(c) = EmptyBag n;
  thus thesis by A1;
end;

theorem Th15:
  for X being set, L being non empty ZeroStr, c being ConstPoly of
  X,L holds Support(c) = {} or Support(c) = {EmptyBag X}
proof
  let X be set, L be non empty ZeroStr, c be ConstPoly of X,L;
  assume Support(c) <> {};
  hence Support(c) = {term(c)} by Th7
    .= {EmptyBag X} by Lm2;
end;

theorem
  for X being set, L being non empty ZeroStr, c being ConstPoly of X,L
  holds term(c) = EmptyBag X & coefficient(c) = c.(EmptyBag X) by Lm2;

definition
  let X be set, L be non empty ZeroStr, a be Element of L;
  func a |(X,L) -> Series of X,L equals
  0_(X,L)+*(EmptyBag X,a);
  coherence;
end;

registration
  let X be set, L be non empty ZeroStr, a be Element of L;
  cluster a |(X,L) -> Constant;
  coherence
  proof
    set Z = 0_(X,L);
    set O = Z+*(EmptyBag X,a);
    reconsider O as Function of Bags X,the carrier of L;
    reconsider O9 = O as Function of Bags X,L;
    reconsider O9 as Series of X,L;
    now
      let b be bag of X;
A1:   dom(EmptyBag X .--> a) = {EmptyBag X} by FUNCOP_1:19;
      dom(Z) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
        .= Bags X by FUNCOP_1:19;
      then
A2:   O9 = 0_(X,L)+*(EmptyBag X .--> a) by FUNCT_7:def 3;
      assume b <> EmptyBag X;
      then not b in dom(EmptyBag X .--> a) by A1,TARSKI:def 1;
      hence (O9).b = (0_(X,L)).b by A2,FUNCT_4:12
        .= 0.L by POLYNOM1:81;
    end;
    hence thesis by Def8;
  end;
end;

Lm3: for X being set, L being non empty ZeroStr holds 0.L |(X,L) = 0_(X,L)
proof
  let X be set, L be non empty ZeroStr;
  set o1 = 0.L |(X,L), o2 = 0_(X,L);
A1: now
    set m = 0_(X,L)+*(EmptyBag X,0.L);
    let x be set;
    reconsider m as Function of Bags X, the carrier of L;
    reconsider m as Function of Bags X, L;
    reconsider m as Series of X, L;
    assume x in Bags X;
    then reconsider x9 = x as bag of X;
A2: dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
      .= Bags X by FUNCOP_1:19;
    then
A3: m = 0_(X,L)+*(EmptyBag X .--> 0.L) by FUNCT_7:def 3;
A4: dom(EmptyBag X .--> 0.L) = {EmptyBag X} by FUNCOP_1:19;
    then
A5: EmptyBag X in dom(EmptyBag X .--> 0.L) by TARSKI:def 1;
A6: m.(EmptyBag X) = (0_(X,L)+*(EmptyBag X .--> 0.L)).(EmptyBag X) by A2,
FUNCT_7:def 3
      .= (EmptyBag X .--> 0.L).(EmptyBag X) by A5,FUNCT_4:14
      .= 0.L by FUNCOP_1:87;
    per cases;
    suppose
      x9 = EmptyBag X;
      hence o1.x = o2.x by A6,POLYNOM1:81;
    end;
    suppose
      x9 <> EmptyBag X;
      then not x9 in dom(EmptyBag X .--> 0.L) by A4,TARSKI:def 1;
      hence o1.x = o2.x by A3,FUNCT_4:12;
    end;
  end;
  Bags X = dom o1 & Bags X = dom o2 by FUNCT_2:def 1;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for X being set, L being non empty ZeroStr, p being Series of X,L
  holds p is ConstPoly of X,L iff ex a being Element of L st p = a |(X,L)
proof
  let X be set, L be non empty ZeroStr, p be Series of X,L;
  now
    assume
A1: p is ConstPoly of X,L;
    now
      per cases by A1,Th14;
      case
        p = 0_(X,L);
        then p = 0.L |(X,L) by Lm3;
        hence ex a being Element of L st p = a |(X,L);
      end;
      case
A2:     Support p = {EmptyBag X};
        set q = 0_(X,L)+*(EmptyBag X,p.(EmptyBag X));
A3:     now
          let x be set;
          assume x in Bags X;
          then reconsider x9 = x as bag of X;
A4:       dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
            .= Bags X by FUNCOP_1:19;
          then
A5:       q = 0_(X,L)+*(EmptyBag X .--> p.(EmptyBag X)) by FUNCT_7:def 3;
A6:       dom(EmptyBag X .--> p.(EmptyBag X)) = {EmptyBag X} by FUNCOP_1:19;
          then
A7:       EmptyBag X in dom(EmptyBag X .--> p.(EmptyBag X)) by TARSKI:def 1;
A8:       q.(EmptyBag X) = (0_(X,L)+*(EmptyBag X .--> p.(EmptyBag X))).(
          EmptyBag X) by A4,FUNCT_7:def 3
            .= (EmptyBag X .--> p.(EmptyBag X)).(EmptyBag X) by A7,FUNCT_4:14
            .= p.(EmptyBag X) by FUNCOP_1:87;
          now
            per cases;
            case
              x9 = EmptyBag X;
              hence p.x = q.x by A8;
            end;
            case
A9:           x9 <> EmptyBag X;
A10:          x9 is Element of Bags X by PRE_POLY:def 12;
              not x9 in Support p by A2,A9,TARSKI:def 1;
              then
A11:          p.x9 = 0.L by A10,POLYNOM1:def 9;
              not x9 in dom(EmptyBag X .--> p.(EmptyBag X)) by A6,A9,
TARSKI:def 1;
              then q.x9 = (0_(X,L)).x9 by A5,FUNCT_4:12;
              hence p.x = q.x by A11,POLYNOM1:81;
            end;
          end;
          hence p.x = q.x;
        end;
A12:    Bags X = dom q by FUNCT_2:def 1;
        q = p.(EmptyBag X) |(X,L) & Bags X = dom p by FUNCT_2:def 1;
        hence ex a being Element of L st p = a |(X,L) by A12,A3,FUNCT_1:9;
      end;
    end;
    hence ex a being Element of L st p = a |(X,L);
  end;
  hence thesis;
end;

theorem Th18:
  for X being set, L being non empty multLoopStr_0, a being
  Element of L holds (a |(X,L)).EmptyBag X = a & for b being bag of X st b <>
  EmptyBag X holds (a |(X,L)).b = 0.L
proof
  let n be set, L be non empty multLoopStr_0, a be Element of L;
  set Z = 0_(n,L);
A1: Z = (Bags n --> 0.L) by POLYNOM1:def 24;
  then dom Z = Bags n by FUNCOP_1:19;
  hence (a |(n,L)).EmptyBag n = a by FUNCT_7:33;
  let b be bag of n;
A2: b in Bags n by PRE_POLY:def 12;
  assume b <> EmptyBag n;
  hence (a |(n,L)).b = Z.b by FUNCT_7:34
    .= 0.L by A1,A2,FUNCOP_1:13;
end;

theorem
  for X being set, L being non empty ZeroStr holds 0.L |(X,L) = 0_(X,L) by Lm3;

theorem
  for X being set, L being well-unital (non empty multLoopStr_0) holds (
  1.L) |(X,L) = 1_(X,L)
proof
  let X be set, L be well-unital (non empty multLoopStr_0);
  set o1 = (1.L) |(X,L), o2 = 1_(X,L);
A1: now
    set m = 0_(X,L)+*(EmptyBag X,1.L);
    let x be set;
    reconsider m as Function of Bags X, the carrier of L;
    reconsider m as Function of Bags X, L;
    reconsider m as Series of X, L;
    assume x in Bags X;
    then reconsider x9 = x as bag of X;
A2: dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
      .= Bags X by FUNCOP_1:19;
    then
A3: m = 0_(X,L)+*(EmptyBag X .--> 1.L) by FUNCT_7:def 3;
A4: dom(EmptyBag X .--> 1.L) = {EmptyBag X} by FUNCOP_1:19;
    then
A5: EmptyBag X in dom(EmptyBag X .--> 1.L) by TARSKI:def 1;
A6: m.(EmptyBag X) = (0_(X,L)+*(EmptyBag X .--> 1.L)).(EmptyBag X) by A2,
FUNCT_7:def 3
      .= (EmptyBag X .--> 1.L).(EmptyBag X) by A5,FUNCT_4:14
      .= 1.L by FUNCOP_1:87;
    per cases;
    suppose
      x9 = EmptyBag X;
      hence o1.x = o2.x by A6,POLYNOM1:84;
    end;
    suppose
A7:   x9 <> EmptyBag X;
      then not x9 in dom(EmptyBag X .--> 1.L) by A4,TARSKI:def 1;
      then m.x9 = (0_(X,L)).x9 by A3,FUNCT_4:12
        .= 0.L by POLYNOM1:81
        .= o2.x9 by A7,POLYNOM1:84;
      hence o1.x = o2.x;
    end;
  end;
  Bags X = dom o1 & Bags X = dom o2 by FUNCT_2:def 1;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for X being set, L being non empty ZeroStr, a,b being Element of L
  holds a |(X,L) = b |(X,L) iff a = b
proof
  let X be set, L be non empty ZeroStr, a,b be Element of L;
  set m = 0_(X,L)+*(EmptyBag X,a);
  reconsider m as Function of Bags X, the carrier of L;
  reconsider m as Function of Bags X, L;
  reconsider m as Series of X, L;
  set k = 0_(X,L)+*(EmptyBag X,b);
  reconsider k as Function of Bags X, the carrier of L;
  reconsider k as Function of Bags X, L;
  reconsider k as Series of X, L;
  dom(EmptyBag X .--> a) = {EmptyBag X} by FUNCOP_1:19;
  then
A1: EmptyBag X in dom(EmptyBag X .--> a) by TARSKI:def 1;
  dom(EmptyBag X .--> b) = {EmptyBag X} by FUNCOP_1:19;
  then
A2: EmptyBag X in dom(EmptyBag X .--> b) by TARSKI:def 1;
  dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
    .= Bags X by FUNCOP_1:19;
  then
A3: k.(EmptyBag X) = (0_(X,L)+*(EmptyBag X .--> b)).(EmptyBag X) by
FUNCT_7:def 3
    .= (EmptyBag X .--> b).(EmptyBag X) by A2,FUNCT_4:14
    .= b by FUNCOP_1:87;
  dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
    .= Bags X by FUNCOP_1:19;
  then m.(EmptyBag X) = (0_(X,L)+*(EmptyBag X .--> a)).(EmptyBag X) by
FUNCT_7:def 3
    .= (EmptyBag X .--> a).(EmptyBag X) by A1,FUNCT_4:14
    .= a by FUNCOP_1:87;
  hence thesis by A3;
end;

theorem
  for X being set, L being non empty ZeroStr, a being Element of L holds
  Support(a |(X,L)) = {} or Support(a |(X,L)) = {EmptyBag X} by Th15;

theorem Th23:
  for X being set, L being non empty ZeroStr, a being Element of L
  holds term(a |(X,L)) = EmptyBag X & coefficient(a |(X,L)) = a
proof
  let X be set, L be non empty ZeroStr, a be Element of L;
  set m = 0_(X,L)+*(EmptyBag X,a);
  reconsider m as Function of Bags X, the carrier of L;
  reconsider m as Function of Bags X, L;
  reconsider m as Series of X, L;
  dom(EmptyBag X .--> a) = {EmptyBag X} by FUNCOP_1:19;
  then
A1: EmptyBag X in dom(EmptyBag X .--> a) by TARSKI:def 1;
  dom(0_(X,L)) = dom((Bags X) --> 0.L) by POLYNOM1:def 24
    .= Bags X by FUNCOP_1:19;
  then m.(EmptyBag X) = (0_(X,L)+*(EmptyBag X .--> a)).(EmptyBag X) by
FUNCT_7:def 3
    .= (EmptyBag X .--> a).(EmptyBag X) by A1,FUNCT_4:14
    .= a by FUNCOP_1:87;
  hence thesis by Lm2;
end;

theorem Th24:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive (non trivial doubleLoopStr), c
being ConstPoly of n,L, x being Function of n,L holds eval(c,x) = coefficient(c
  )
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive (non trivial doubleLoopStr), c be ConstPoly of n,L, x
  be Function of n,L;
  consider y being FinSequence of the carrier of L such that
A1: len y = len SgmX(BagOrder n, Support c) and
A2: eval(c,x) = Sum y and
A3: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (c *
  SgmX(BagOrder n, Support c))/.i * eval(((SgmX(BagOrder n, Support c))/.i)@,x)
  by POLYNOM2:def 4;
  now
    per cases;
    case
A4:   coefficient(c) = 0.L;
      Support c = {}
      proof
        consider u being Element of Support c;
        assume
A5:     Support c <> {};
        then u in Support c;
        then reconsider u as Element of Bags n;
        c.u <> 0.L by A5,POLYNOM1:def 9;
        then u <> EmptyBag n by A4,Lm2;
        then c.u = 0.L by Def8;
        hence thesis by A5,POLYNOM1:def 9;
      end;
      then reconsider Sc = Support c as empty Subset of Bags n;
      SgmX(BagOrder n, Sc) = {} by POLYNOM2:9,20;
      then y = <*>(the carrier of L) by A1;
      hence thesis by A2,A4,RLVECT_1:60;
    end;
    case
A6:   coefficient(c) <> 0.L;
      reconsider sc = Support c as finite Subset of Bags n;
      set sg = SgmX(BagOrder n, sc);
A7:   BagOrder n linearly_orders sc by POLYNOM2:20;
A8:   for u being set holds u in Support c implies u in {EmptyBag n}
      proof
        let u be set;
        assume
A9:     u in Support c;
        assume
A10:    not u in {EmptyBag n};
        reconsider u as Element of Bags n by A9;
        u <> EmptyBag n by A10,TARSKI:def 1;
        then c.u = 0.L by Def8;
        hence thesis by A9,POLYNOM1:def 9;
      end;
      for u being set holds u in {EmptyBag n} implies u in Support c
      proof
        let u be set;
        assume
A11:    u in {EmptyBag n};
        then
A12:    u = EmptyBag n by TARSKI:def 1;
        reconsider u as Element of Bags n by A11;
        c.u <> 0.L by A6,A12,Lm2;
        hence thesis by POLYNOM1:def 9;
      end;
      then Support c = {EmptyBag n} by A8,TARSKI:2;
      then
A13:  rng sg = {EmptyBag n} by A7,PRE_POLY:def 2;
      then
A14:  EmptyBag n in rng sg by TARSKI:def 1;
      then
A15:  1 in dom sg by FINSEQ_3:33;
      then
A16:  sg.1 in rng sg by FUNCT_1:12;
A17:  for u being set holds u in dom sg implies u in {1}
      proof
        let u be set;
        assume
A18:    u in dom sg;
        assume
A19:    not u in {1};
        reconsider u as Element of NAT by A18;
        sg/.u = sg.u by A18,PARTFUN1:def 8;
        then
A20:    sg/.u in rng sg by A18,FUNCT_1:12;
A21:    u <> 1 by A19,TARSKI:def 1;
A22:    1 < u
        proof
          consider k being Nat such that
A23:      dom sg = Seg k by FINSEQ_1:def 2;
          Seg k = {m where m is Element of NAT : 1 <= m & m <= k} by
FINSEQ_1:def 1;
          then
          ex m9 being Element of NAT st m9 = u & 1 <= m9 & m9 <= k by A18,A23;
          hence thesis by A21,XXREAL_0:1;
        end;
        sg/.1 = sg.1 by A14,A18,FINSEQ_3:33,PARTFUN1:def 8;
        then sg/.1 in rng sg by A15,FUNCT_1:12;
        then sg/.1 = EmptyBag n by A13,TARSKI:def 1
          .= sg/.u by A13,A20,TARSKI:def 1;
        hence thesis by A7,A15,A18,A22,PRE_POLY:def 2;
      end;
      for u being set holds u in {1} implies u in dom sg by A15,TARSKI:def 1;
      then
A24:  dom sg = Seg 1 by A17,FINSEQ_1:4,TARSKI:2;
      then
A25:  1 in dom sg by FINSEQ_1:4,TARSKI:def 1;
      sg/.1 = sg.1 by A15,PARTFUN1:def 8;
      then sg/.1 in rng sg by A25,FUNCT_1:12;
      then
A26:  sg/.1 = EmptyBag n by A13,TARSKI:def 1;
A27:  len sg = 1 by A24,FINSEQ_1:def 3;
      dom c = Bags n by FUNCT_2:def 1;
      then 1 in dom (c * sg) by A13,A15,A16,FUNCT_1:21;
      then
A28:  (c * sg)/.1 = (c * sg).1 by PARTFUN1:def 8
        .= c.(sg.1) by A15,FUNCT_1:23
        .= c.(EmptyBag n) by A13,A16,TARSKI:def 1
        .= coefficient(c) by Lm2;
      dom y = Seg(len y) by FINSEQ_1:def 3
        .= dom sg by A1,FINSEQ_1:def 3;
      then y.1 = y/.1 by A25,PARTFUN1:def 8
        .= (c * sg)/.1 * eval((sg/.1)@,x) by A1,A3,A27
        .= coefficient(c) * eval(EmptyBag n,x) by A26,A28,POLYNOM2:def 3
        .= coefficient(c) * 1.L by POLYNOM2:16
        .= coefficient(c) by VECTSP_1:def 16;
      then y = <* coefficient(c) *> by A1,A27,FINSEQ_1:57;
      hence thesis by A2,RLVECT_1:61;
    end;
  end;
  hence thesis;
end;

theorem Th25:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive (non trivial doubleLoopStr), a
  being Element of L, x being Function of n,L holds eval(a |(n,L),x) = a
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive (non trivial doubleLoopStr), a be Element of L, x be
  Function of n,L;
  thus eval(a |(n,L),x) = coefficient(a |(n,L)) by Th24
    .= a by Th23;
end;

begin :: Multiplication with Coefficients

definition
  let X be set, L be non empty multLoopStr_0, p be Series of X,L, a be Element
  of L;
  func a * p -> Series of X,L means
  :Def10:
  for b being bag of X holds it.b = a * p.b;
  existence
  proof
    deffunc F(Element of Bags X) = a * p.$1;
    consider f being Function of Bags X, the carrier of L such that
A1: for x being Element of Bags X holds f.x = F(x) from FUNCT_2:sch 4;
    reconsider f as Function of Bags X,L;
    reconsider f as Series of X,L;
    reconsider f as Series of X,L;
    take f;
    let x be bag of X;
    x in Bags X by PRE_POLY:def 12;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let p1,p2 be Series of X,L such that
A2: for b being bag of X holds p1.b = a * p.b and
A3: for b being bag of X holds p2.b = a * p.b;
    now
      let b be Element of Bags X;
      reconsider b9 = b as bag of X;
      thus p1.b = a * p.b9 by A2
        .= p2.b by A3;
    end;
    hence p1 = p2 by FUNCT_2:113;
  end;
  func p * a -> Series of X,L means
  :Def11:
  for b being bag of X holds it.b = p.b * a;
  existence
  proof
    deffunc F(Element of Bags X) = p.$1 * a;
    consider f being Function of Bags X, the carrier of L such that
A4: for x being Element of Bags X holds f.x = F(x) from FUNCT_2:sch 4;
    reconsider f as Function of Bags X,L;
    reconsider f as Series of X,L;
    reconsider f as Series of X,L;
    take f;
    let x be bag of X;
    x in Bags X by PRE_POLY:def 12;
    hence thesis by A4;
  end;
  uniqueness
  proof
    let p1,p2 be Series of X,L such that
A5: for b being bag of X holds p1.b = p.b * a and
A6: for b being bag of X holds p2.b = p.b * a;
    now
      let b be Element of Bags X;
      reconsider b9 = b as bag of X;
      thus p1.b = p.b9 * a by A5
        .= p2.b by A6;
    end;
    hence p1 = p2 by FUNCT_2:113;
  end;
end;

registration
  let X be set, L be left_zeroed right_zeroed add-cancelable distributive (non
  empty doubleLoopStr), p be finite-Support Series of X,L, a be Element of L;
  cluster a * p -> finite-Support;
  coherence
  proof
    set ap = a * p;
    now
      let u be set;
      assume
A1:   u in Support ap;
      then reconsider u9 = u as Element of Bags X;
      ap.u <> 0.L by A1,POLYNOM1:def 9;
      then a * p.u9 <> 0.L by Def10;
      then p.u9 <> 0.L by BINOM:2;
      hence u in Support p by POLYNOM1:def 9;
    end;
    then Support p is finite & Support ap c= Support p by POLYNOM1:def 10
,TARSKI:def 3;
    hence thesis by POLYNOM1:def 10;
  end;
  cluster p * a -> finite-Support;
  coherence
  proof
    set ap = p * a;
    now
      let u be set;
      assume
A2:   u in Support ap;
      then reconsider u9 = u as Element of Bags X;
      ap.u <> 0.L by A2,POLYNOM1:def 9;
      then p.u9 * a <> 0.L by Def11;
      then p.u9 <> 0.L by BINOM:1;
      hence u in Support p by POLYNOM1:def 9;
    end;
    then Support p is finite & Support ap c= Support p by POLYNOM1:def 10
,TARSKI:def 3;
    hence thesis by POLYNOM1:def 10;
  end;
end;

theorem
  for X being set, L being commutative (non empty multLoopStr_0), p
  being Series of X,L, a being Element of L holds a * p = p * a
proof
  let n be set, L be commutative (non empty multLoopStr_0), p be Series of n,L
  , a be Element of L;
  now
    let b be Element of Bags n;
    reconsider b9 = b as bag of n;
    thus (a * p).b = a * p.b9 by Def10
      .= (p * a).b by Def11;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th27:
  for n being Ordinal, L being add-associative
right_complementable right_zeroed left-distributive (non empty doubleLoopStr),
  p being Series of n,L, a being Element of L holds a * p = a |(n,L) *' p
proof
  let n be Ordinal, L be add-associative right_complementable
left-distributive right_zeroed (non empty doubleLoopStr), p be Series of n,L, a
  be Element of L;
A1: for x being set st x in Bags n holds (a * p).x = (a |(n,L) *' p).x
  proof
    set O = a |(n,L), cL = the carrier of L;
    let x be set;
    assume x in Bags n;
    then reconsider b = x as bag of n;
A2: for b being Element of Bags n holds (a |(n,L) *' p).b = a * p.b
    proof
      let b be Element of Bags n;
      consider s being FinSequence of cL such that
A3:   (O*'p).b = Sum s and
A4:   len s = len decomp b and
A5:   for k being Element of NAT st k in dom s ex b1,b2 being bag of n
      st (decomp b)/.k = <*b1, b2*> & s/.k = (O.b1)*(p.b2) by POLYNOM1:def 26;
      s is non empty by A4;
      then consider
      s1 being Element of cL, t being FinSequence of cL such that
A6:   s1 = s.1 and
A7:   s = <*s1*>^t by FINSEQ_3:111;
A8:   Sum s = (Sum <*s1*>) + (Sum t) by A7,RLVECT_1:58;
A9:   now
        per cases;
        suppose
          t = <*>(cL);
          hence (Sum t) = 0.L by RLVECT_1:60;
        end;
        suppose
A10:      t <> <*>(cL);
          now
            let k be Nat;
A11:        len s = len t + len <*s1*> by A7,FINSEQ_1:35
              .= len t +1 by FINSEQ_1:56;
            assume
A12:        k in dom t;
            then
A13:        t/.k = t.k by PARTFUN1:def 8
              .= s.(k+1) by A7,A12,FINSEQ_3:112;
            1 <= k by A12,FINSEQ_3:27;
            then
A14:        1 < k+1 by NAT_1:13;
            k <= len t by A12,FINSEQ_3:27;
            then
A15:        k+1 <= len s by A11,XREAL_1:8;
            then
A16:        k+1 in dom decomp b by A4,A14,FINSEQ_3:27;
A17:        dom s = dom decomp b by A4,FINSEQ_3:31;
            then
A18:        s/.(k+1) = s.(k+1) by A16,PARTFUN1:def 8;
            per cases by A15,XXREAL_0:1;
            suppose
A19:          k+1 < len s;
              reconsider k1=k as Element of NAT by ORDINAL1:def 13;
              consider b1, b2 being bag of n such that
A20:          (decomp b)/.(k1+1) = <*b1, b2*> and
A21:          s/.(k1+1) = O.b1*p.b2 by A5,A17,A16;
              b1 <> EmptyBag n by A4,A14,A19,A20,PRE_POLY:72;
              hence t/.k = 0.L*p.b2 by A13,A18,A21,Th18
                .= 0.L by VECTSP_1:39;
            end;
            suppose
A22:          k+1 = len s;
A23:          now
                assume b = EmptyBag n;
                then decomp b = <* <*EmptyBag n, EmptyBag n*> *> by PRE_POLY:73
;
                then len t +1 = 0+1 by A4,A11,FINSEQ_1:56;
                hence contradiction by A10;
              end;
              consider b1, b2 being bag of n such that
A24:          (decomp b)/.(k+1) = <*b1, b2*> and
A25:          s/.(k+1) = O.b1*p.b2 by A5,A17,A16;
              (decomp b)/.(len s) = <*b,EmptyBag n*> by A4,PRE_POLY:71;
              then b2 = EmptyBag n & b1 = b by A22,A24,FINSEQ_1:98;
              then s.(k+1) = 0.L*(p.EmptyBag n) by A18,A25,A23,Th18
                .= 0.L by VECTSP_1:39;
              hence t/.k = 0.L by A13;
            end;
          end;
          hence Sum t = 0.L by MATRLIN:15;
        end;
      end;
A26:  s is non empty by A4;
      then consider b1, b2 being bag of n such that
A27:  (decomp b)/.1 = <*b1, b2*> and
A28:  s/.1 = O.b1*p.b2 by A5,FINSEQ_5:6;
      1 in dom s by A26,FINSEQ_5:6;
      then
A29:  s/.1 = s.1 by PARTFUN1:def 8;
      (decomp b)/.1 = <*EmptyBag n, b*> by PRE_POLY:71;
      then
A30:  b2 = b & b1 = EmptyBag n by A27,FINSEQ_1:98;
      Sum <*s1*> = s1 by RLVECT_1:61
        .= a * p.b by A6,A28,A30,A29,Th18;
      hence thesis by A3,A8,A9,RLVECT_1:10;
    end;
    b is Element of Bags n by PRE_POLY:def 12;
    then (O*'p).b = a * p.b by A2
      .= (a * p).b by Def10;
    hence thesis;
  end;
  Bags n = dom(a * p) & Bags n = dom(a |(n,L) *' p) by FUNCT_2:def 1;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th28:
  for n being Ordinal, L being add-associative
right_complementable right_zeroed right-distributive (non empty doubleLoopStr),
  p being Series of n,L, a being Element of L holds p * a = p *' (a |(n,L))
proof
  let n be Ordinal, L be add-associative right_complementable
right-distributive right_zeroed (non empty doubleLoopStr), p be Series of n,L,
  a be Element of L;
A1: for x being set st x in Bags n holds (p * a).x = (p *' (a |(n,L))).x
  proof
    set O = a |(n,L), cL = the carrier of L;
    let x be set;
    assume x in Bags n;
    then reconsider b = x as bag of n;
A2: for b being Element of Bags n holds (p *' (a |(n,L))).b = p.b * a
    proof
      let b be Element of Bags n;
      consider s being FinSequence of cL such that
A3:   (p*'O).b = Sum s and
A4:   len s = len decomp b and
A5:   for k being Element of NAT st k in dom s ex b1,b2 being bag of n
      st (decomp b)/.k = <*b1, b2*> & s/.k = (p.b1)*(O.b2) by POLYNOM1:def 26;
      consider t being FinSequence of cL,s1 being Element of cL such that
A6:   s = t^<*s1*> by A4,FINSEQ_2:22;
A7:   now
        per cases;
        suppose
          t = <*>(cL);
          hence (Sum t) = 0.L by RLVECT_1:60;
        end;
        suppose
A8:       t <> <*>(cL);
          now
            let k be Nat;
A9:         len s = len t + len <*s1*> by A6,FINSEQ_1:35
              .= len t +1 by FINSEQ_1:56;
            assume
A10:        k in dom t;
            then
A11:        t/.k = t.k by PARTFUN1:def 8
              .= s.k by A6,A10,FINSEQ_1:def 7;
            k <= len t by A10,FINSEQ_3:27;
            then
A12:        k < len s by A9,NAT_1:13;
A13:        1 <= k by A10,FINSEQ_3:27;
            then
A14:        k in dom decomp b by A4,A12,FINSEQ_3:27;
A15:        dom s = dom decomp b by A4,FINSEQ_3:31;
            then
A16:        s/.k = s.k by A14,PARTFUN1:def 8;
            per cases by A13,XXREAL_0:1;
            suppose
A17:          1 < k;
              reconsider k1=k as Element of NAT by ORDINAL1:def 13;
              consider b1, b2 being bag of n such that
A18:          (decomp b)/.k1 = <*b1, b2*> and
A19:          s/.k1 = p.b1*O.b2 by A5,A15,A14;
              b2 <> EmptyBag n by A4,A12,A17,A18,PRE_POLY:72;
              hence t/.k = p.b1*0.L by A11,A16,A19,Th18
                .= 0.L by VECTSP_1:36;
            end;
            suppose
A20:          k = 1;
A21:          now
                assume b = EmptyBag n;
                then decomp b = <* <*EmptyBag n, EmptyBag n*> *> by PRE_POLY:73
;
                then len t +1 = 0+1 by A4,A9,FINSEQ_1:56;
                hence contradiction by A8;
              end;
              consider b1, b2 being bag of n such that
A22:          (decomp b)/.k = <*b1, b2*> and
A23:          s/.k = p.b1*O.b2 by A5,A15,A14;
              (decomp b)/.1 = <*EmptyBag n, b*> by PRE_POLY:71;
              then b1 = EmptyBag n & b2 = b by A20,A22,FINSEQ_1:98;
              then s.k = (p.EmptyBag n)*0.L by A16,A23,A21,Th18
                .= 0.L by VECTSP_1:36;
              hence t/.k = 0.L by A11;
            end;
          end;
          hence Sum t = 0.L by MATRLIN:15;
        end;
      end;
A24:  s.len s = (t^<*s1*>).(len t +1) by A6,FINSEQ_2:19
        .= s1 by FINSEQ_1:59;
A25:  Sum s = (Sum t) + (Sum <*s1*>) by A6,RLVECT_1:58;
      s is non empty by A4;
      then
A26:  len s in dom s by FINSEQ_5:6;
      then consider b1, b2 being bag of n such that
A27:  (decomp b)/.len s = <*b1, b2*> and
A28:  s/.len s = p.b1*O.b2 by A5;
A29:  s/.len s = s.len s by A26,PARTFUN1:def 8;
      (decomp b)/.len s = <*b,EmptyBag n*> by A4,PRE_POLY:71;
      then
A30:  b1 = b & b2 = EmptyBag n by A27,FINSEQ_1:98;
      Sum <*s1*> = s1 by RLVECT_1:61
        .= p.b * a by A28,A30,A29,A24,Th18;
      hence thesis by A3,A25,A7,RLVECT_1:10;
    end;
    b is Element of Bags n by PRE_POLY:def 12;
    then (p*'O).b = p.b * a by A2
      .= (p * a).b by Def11;
    hence thesis;
  end;
  Bags n = dom(p * a) & Bags n = dom(p *' (a |(n,L))) by FUNCT_2:def 1;
  hence thesis by A1,FUNCT_1:9;
end;

Lm4: for n being Ordinal, L being Abelian left_zeroed right_zeroed
add-associative right_complementable well-unital associative commutative
distributive (non trivial doubleLoopStr), p being Polynomial of n,L, a being
Element of L, x being Function of n,L holds eval((a |(n,L))*'p,x) = a * eval(p,
x)
proof
  let n be Ordinal, L be left_zeroed right_zeroed add-associative
right_complementable well-unital associative commutative Abelian distributive (
non trivial doubleLoopStr), p be Polynomial of n,L, a be Element of L, x being
  Function of n,L;
  thus eval((a |(n,L))*'p,x) = eval(a |(n,L),x) * eval(p,x) by POLYNOM2:27
    .= a * eval(p,x) by Th25;
end;

Lm5: for n being Ordinal, L being Abelian left_zeroed right_zeroed
add-associative right_complementable well-unital associative commutative
distributive (non trivial doubleLoopStr), p being Polynomial of n,L, a being
Element of L, x being Function of n,L holds eval(p*'(a |(n,L)),x) = eval(p,x) *
a
proof
  let n be Ordinal, L be left_zeroed right_zeroed add-associative
right_complementable well-unital associative commutative Abelian distributive (
non trivial doubleLoopStr), p be Polynomial of n,L, a be Element of L, x being
  Function of n,L;
  thus eval(p*'(a |(n,L)),x) = eval(p,x) * eval(a |(n,L),x) by POLYNOM2:27
    .= eval(p,x) * a by Th25;
end;

theorem
  for n being Ordinal, L being Abelian left_zeroed right_zeroed
  add-associative right_complementable well-unital associative commutative
  distributive (non trivial doubleLoopStr), p being Polynomial of n,L, a being
  Element of L, x being Function of n,L holds eval(a*p,x) = a * eval(p,x)
proof
  let n be Ordinal, L be Abelian left_zeroed right_zeroed add-associative
  right_complementable well-unital associative commutative distributive (non
  trivial doubleLoopStr), p be Polynomial of n,L, a be Element of L, x be
  Function of n,L;
  thus eval(a*p,x) = eval((a |(n,L)) *' p,x) by Th27
    .= a * eval(p,x) by Lm4;
end;

theorem
  for n being Ordinal, L being left_zeroed right_zeroed
  left_add-cancelable add-associative right_complementable well-unital
  associative domRing-like distributive (non trivial doubleLoopStr), p being
Polynomial of n,L, a being Element of L, x being Function of n,L holds eval(a*p
  ,x) = a * eval(p,x)
proof
  let n be Ordinal, L be left_zeroed right_zeroed left_add-cancelable
  add-associative right_complementable well-unital associative domRing-like
distributive (non trivial doubleLoopStr), p be Polynomial of n,L, a be Element
  of L, x be Function of n,L;
  consider y being FinSequence of the carrier of L such that
A1: len y = len SgmX(BagOrder n, Support(a*p)) and
A2: eval(a*p,x) = Sum y and
A3: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = ((a*p
) * SgmX(BagOrder n, Support(a*p)))/.i * eval(((SgmX(BagOrder n, Support(a*p)))
  /.i)@,x) by POLYNOM2:def 4;
A4: BagOrder n linearly_orders Support(a*p) by POLYNOM2:20;
  consider z being FinSequence of the carrier of L such that
A5: len z = len SgmX(BagOrder n, Support p) and
A6: eval(p,x) = Sum z and
A7: for i being Element of NAT st 1 <= i & i <= len z holds z/.i = (p *
  SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@,x)
  by POLYNOM2:def 4;
  per cases;
  suppose
A8: a = 0.L;
A9: now
      let b be bag of n;
      thus (a*p).b = a * p.b by Def10
        .= 0.L by A8,BINOM:1;
    end;
    now
      assume Support(a*p) <> {};
      then reconsider sp = Support(a*p) as non empty Subset of Bags n;
      consider c being Element of sp;
      (a*p).c <> 0.L by POLYNOM1:def 9;
      hence contradiction by A9;
    end;
    then rng(SgmX(BagOrder n, Support(a*p))) = {} by A4,PRE_POLY:def 2;
    then SgmX(BagOrder n, Support(a*p)) = {} by RELAT_1:64;
    then y = <*>(the carrier of L) by A1;
    then Sum y = 0.L by RLVECT_1:60
      .= a * Sum z by A8,BINOM:1;
    hence thesis by A2,A6;
  end;
  suppose
A10: a <> 0.L;
A11: for u being set holds u in Support(a*p) implies u in Support p
    proof
      let u be set;
      assume
A12:  u in Support(a*p);
      then reconsider u9 = u as Element of Bags n;
      (a*p).u <> 0.L by A12,POLYNOM1:def 9;
      then a * p.u9 <> 0.L by Def10;
      then p.u9 <> 0.L by BINOM:2;
      hence thesis by POLYNOM1:def 9;
    end;
A13: for u being set holds u in Support p implies u in Support(a*p)
    proof
      let u be set;
      assume
A14:  u in Support p;
      then reconsider u9 = u as Element of Bags n;
      p.u <> 0.L by A14,POLYNOM1:def 9;
      then a * p.u9 <> 0.L by A10,VECTSP_2:def 5;
      then (a * p).u9 <> 0.L by Def10;
      hence thesis by POLYNOM1:def 9;
    end;
    then
A15: len z = len y by A1,A5,A11,TARSKI:2;
    then
A16: dom z = Seg(len y) by FINSEQ_1:def 3
      .= dom y by FINSEQ_1:def 3;
A17: Support(a*p) = Support(p) by A13,A11,TARSKI:2;
    now
A18:  dom(a*p) = Bags n by FUNCT_2:def 1;
      now
        let u be set;
        assume u in rng(SgmX(BagOrder n, Support(a*p)));
        then u in Support(a*p) by A4,PRE_POLY:def 2;
        hence u in dom(a*p) by A18;
      end;
      then rng SgmX(BagOrder n, Support(a*p)) c= dom(a*p) by TARSKI:def 3;
      then reconsider
      r = (a*p) * SgmX(BagOrder n, Support(a*p)) as FinSequence by FINSEQ_1:20;
      for u being set holds u in rng r implies u in the carrier of L
      proof
        let u be set;
        assume u in rng r;
        then
A19:    u in rng(a*p) by FUNCT_1:25;
        rng(a*p) c= the carrier of L by RELAT_1:def 19;
        hence thesis by A19;
      end;
      then
A20:  rng r c= the carrier of L by TARSKI:def 3;
A21:  dom p = Bags n by FUNCT_2:def 1;
      now
        let u be set;
        assume u in rng(SgmX(BagOrder n, Support(a*p)));
        then u in Support(a*p) by A4,PRE_POLY:def 2;
        hence u in dom p by A21;
      end;
      then rng SgmX(BagOrder n, Support(a*p)) c= dom p by TARSKI:def 3;
      then reconsider
      q = p * SgmX(BagOrder n, Support(a*p)) as FinSequence by FINSEQ_1:20;
      for u being set holds u in rng q implies u in the carrier of L
      proof
        let u be set;
        assume u in rng q;
        then
A22:    u in rng p by FUNCT_1:25;
        rng p c= the carrier of L by RELAT_1:def 19;
        hence thesis by A22;
      end;
      then
A23:  rng q c= the carrier of L by TARSKI:def 3;
      reconsider r as FinSequence of the carrier of L by A20,FINSEQ_1:def 4;
      reconsider q as FinSequence of the carrier of L by A23,FINSEQ_1:def 4;
      let i be set;
      assume
A24:  i in dom z;
      then i in Seg(len z) by FINSEQ_1:def 3;
      then i in { k where k is Element of NAT : 1 <= k & k <= len z } by
FINSEQ_1:def 1;
      then consider k being Element of NAT such that
A25:  i = k and
A26:  1 <= k & k <= len z;
A27:  dom z = Seg(len SgmX(BagOrder n, Support(a*p))) by A1,A16,FINSEQ_1:def 3
        .= dom(SgmX(BagOrder n, Support(a*p))) by FINSEQ_1:def 3;
      then
      (SgmX(BagOrder n, Support(a*p))).k = (SgmX(BagOrder n, Support(a*p)
      ))/.k by A24,A25,PARTFUN1:def 8;
      then k in dom q by A24,A25,A27,A21,FUNCT_1:21;
      then
A28:  (p * SgmX(BagOrder n, Support(a*p)))/.k = q.k by PARTFUN1:def 8
        .= p.(SgmX(BagOrder n, Support(a*p)).k) by A24,A25,A27,FUNCT_1:23
        .= p.(SgmX(BagOrder n, Support(a*p))/.k) by A24,A25,A27,PARTFUN1:def 8;
      reconsider c = SgmX(BagOrder n, Support(a*p))/.k as Element of Bags n;
      reconsider c as bag of n;
A29:  a * z/.k = a * ((p * SgmX(BagOrder n, Support p))/.k * eval(((SgmX(
      BagOrder n, Support p))/.k)@,x)) by A7,A26
        .= (a * (p * SgmX(BagOrder n, Support(a*p)))/.k) * eval(((SgmX(
      BagOrder n, Support(a*p)))/.k)@,x) by A17,GROUP_1:def 4;
A30:  (a*p).(SgmX(BagOrder n, Support(a*p))/.k) = (a*p).c
        .= a * (p * SgmX(BagOrder n, Support(a*p)))/.k by A28,Def10;
      (SgmX(BagOrder n, Support(a*p))).k = (SgmX(BagOrder n, Support(a*p)
      ))/.k by A24,A25,A27,PARTFUN1:def 8;
      then k in dom r by A24,A25,A27,A18,FUNCT_1:21;
      then ((a*p) * SgmX(BagOrder n, Support(a*p)))/.k = r.k by PARTFUN1:def 8
        .= (a*p).(SgmX(BagOrder n, Support(a*p)).k) by A24,A25,A27,FUNCT_1:23
        .= a * (p * SgmX(BagOrder n, Support(a*p)))/.k by A24,A25,A27,A30,
PARTFUN1:def 8;
      hence y/.i = a * z/.i by A3,A15,A25,A26,A29;
    end;
    then y = a * z by A16,POLYNOM1:def 2;
    hence thesis by A2,A6,BINOM:4;
  end;
end;

theorem
  for n being Ordinal, L being Abelian left_zeroed right_zeroed
  add-associative right_complementable well-unital associative commutative
  distributive (non trivial doubleLoopStr), p being Polynomial of n,L, a being
  Element of L, x being Function of n,L holds eval(p*a,x) = eval(p,x) * a
proof
  let n be Ordinal, L be Abelian left_zeroed right_zeroed add-associative
  right_complementable well-unital associative commutative distributive (non
  trivial doubleLoopStr), p be Polynomial of n,L, a be Element of L, x be
  Function of n,L;
  thus eval(p*a,x) = eval(p*'(a |(n,L)),x) by Th28
    .= eval(p,x) * a by Lm5;
end;

theorem
  for n being Ordinal, L being left_zeroed right_zeroed
  left_add-cancelable add-associative right_complementable well-unital
associative commutative distributive domRing-like (non trivial doubleLoopStr),
p being Polynomial of n,L, a being Element of L, x being Function of n,L holds
  eval(p*a,x) = eval(p,x) * a
proof
  let n be Ordinal, L be left_zeroed right_zeroed left_add-cancelable
  add-associative right_complementable well-unital associative commutative
distributive domRing-like (non trivial doubleLoopStr), p be Polynomial of n,L,
  a be Element of L, x be Function of n,L;
  consider y being FinSequence of the carrier of L such that
A1: len y = len SgmX(BagOrder n, Support(p*a)) and
A2: eval(p*a,x) = Sum y and
A3: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = ((p*a
) * SgmX(BagOrder n, Support(p*a)))/.i * eval(((SgmX(BagOrder n, Support(p*a)))
  /.i)@,x) by POLYNOM2:def 4;
  consider z being FinSequence of the carrier of L such that
A4: len z = len SgmX(BagOrder n, Support p) and
A5: eval(p,x) = Sum z and
A6: for i being Element of NAT st 1 <= i & i <= len z holds z/.i = (p *
  SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@,x)
  by POLYNOM2:def 4;
  now
    per cases;
    case
A7:   a = 0.L;
A8:   now
        let b be bag of n;
        thus (p*a).b = p.b * a by Def11
          .= 0.L by A7,BINOM:2;
      end;
A9:   now
        assume Support(p*a) <> {};
        then reconsider sp = Support(p*a) as non empty Subset of Bags n;
        consider c being Element of sp;
        (p*a).c <> 0.L by POLYNOM1:def 9;
        hence contradiction by A8;
      end;
      BagOrder n linearly_orders Support(p*a) by POLYNOM2:20;
      then rng(SgmX(BagOrder n, Support(p*a))) = {} by A9,PRE_POLY:def 2;
      then SgmX(BagOrder n, Support(p*a)) = {} by RELAT_1:64;
      then y = <*>(the carrier of L) by A1;
      then Sum y = 0.L by RLVECT_1:60
        .= Sum z * a by A7,BINOM:2;
      hence thesis by A2,A5;
    end;
    case
A10:  a <> 0.L;
A11:  for u being set holds u in Support(p*a) implies u in Support p
      proof
        let u be set;
        assume
A12:    u in Support(p*a);
        then reconsider u9 = u as Element of Bags n;
        (p*a).u <> 0.L by A12,POLYNOM1:def 9;
        then p.u9 * a <> 0.L by Def11;
        then p.u9 <> 0.L by BINOM:1;
        hence thesis by POLYNOM1:def 9;
      end;
A13:  for u being set holds u in Support p implies u in Support(p*a)
      proof
        let u be set;
        assume
A14:    u in Support p;
        then reconsider u9 = u as Element of Bags n;
        p.u <> 0.L by A14,POLYNOM1:def 9;
        then p.u9 * a <> 0.L by A10,VECTSP_2:def 5;
        then (p *a).u9 <> 0.L by Def11;
        hence thesis by POLYNOM1:def 9;
      end;
      then
A15:  len z = len y by A1,A4,A11,TARSKI:2;
      then
A16:  dom z = Seg(len y) by FINSEQ_1:def 3
        .= dom y by FINSEQ_1:def 3;
A17:  BagOrder n linearly_orders Support(p*a) by POLYNOM2:20;
A18:  Support(p*a) = Support(p) by A13,A11,TARSKI:2;
      now
A19:    dom(p*a) = Bags n by FUNCT_2:def 1;
        now
          let u be set;
          assume u in rng(SgmX(BagOrder n, Support(p*a)));
          then u in Support(p*a) by A17,PRE_POLY:def 2;
          hence u in dom(p*a) by A19;
        end;
        then rng SgmX(BagOrder n, Support(p*a)) c= dom(p*a) by TARSKI:def 3;
        then reconsider
        r = (p*a) * SgmX(BagOrder n, Support(p*a)) as FinSequence
        by FINSEQ_1:20;
        for u being set holds u in rng r implies u in the carrier of L
        proof
          let u be set;
          assume u in rng r;
          then
A20:      u in rng(p*a) by FUNCT_1:25;
          rng(p*a) c= the carrier of L by RELAT_1:def 19;
          hence thesis by A20;
        end;
        then
A21:    rng r c= the carrier of L by TARSKI:def 3;
A22:    dom p = Bags n by FUNCT_2:def 1;
        now
          let u be set;
          assume u in rng(SgmX(BagOrder n, Support(p*a)));
          then u in Support(p*a) by A17,PRE_POLY:def 2;
          hence u in dom p by A22;
        end;
        then rng SgmX(BagOrder n, Support(p*a)) c= dom p by TARSKI:def 3;
        then reconsider
        q = p * SgmX(BagOrder n, Support(p*a)) as FinSequence by FINSEQ_1:20;
        for u being set holds u in rng q implies u in the carrier of L
        proof
          let u be set;
          assume u in rng q;
          then
A23:      u in rng p by FUNCT_1:25;
          rng p c= the carrier of L by RELAT_1:def 19;
          hence thesis by A23;
        end;
        then
A24:    rng q c= the carrier of L by TARSKI:def 3;
        reconsider r as FinSequence of the carrier of L by A21,FINSEQ_1:def 4;
        reconsider q as FinSequence of the carrier of L by A24,FINSEQ_1:def 4;
        let i be set;
        assume
A25:    i in dom z;
        then i in Seg(len z) by FINSEQ_1:def 3;
        then
i in { k where k is Element of NAT : 1 <= k & k <= len z } by FINSEQ_1:def 1;
        then consider k being Element of NAT such that
A26:    i = k and
A27:    1 <= k & k <= len z;
A28:    dom z = Seg(len SgmX(BagOrder n, Support(p*a))) by A1,A16,
FINSEQ_1:def 3
          .= dom(SgmX(BagOrder n, Support(p*a))) by FINSEQ_1:def 3;
        then
        (SgmX(BagOrder n, Support(p*a))).k = (SgmX(BagOrder n, Support(p*
        a)))/.k by A25,A26,PARTFUN1:def 8;
        then k in dom q by A25,A26,A28,A22,FUNCT_1:21;
        then
A29:    (p * SgmX(BagOrder n, Support(p*a)))/.k = q.k by PARTFUN1:def 8
          .= p.(SgmX(BagOrder n, Support(p*a)).k) by A25,A26,A28,FUNCT_1:23
          .= p.(SgmX(BagOrder n, Support(p*a))/.k) by A25,A26,A28,
PARTFUN1:def 8;
        reconsider c = SgmX(BagOrder n, Support(p*a))/.k as Element of Bags n;
        reconsider c as bag of n;
A30:    z/.k * a = (p * SgmX(BagOrder n, Support(p*a)))/.k * (eval(((SgmX
        (BagOrder n, Support(p*a)))/.k)@,x)) * a by A6,A18,A27
          .= ((p * SgmX(BagOrder n, Support(p*a)))/.k * a) * eval(((SgmX(
        BagOrder n, Support(p*a)))/.k)@,x) by GROUP_1:def 4;
A31:    (p*a).(SgmX(BagOrder n, Support(p*a))/.k) = (p*a).c
          .= (p * SgmX(BagOrder n, Support(p*a)))/.k * a by A29,Def11;
        (SgmX(BagOrder n, Support(p*a))).k = (SgmX(BagOrder n, Support(p*
        a)))/.k by A25,A26,A28,PARTFUN1:def 8;
        then k in dom r by A25,A26,A28,A19,FUNCT_1:21;
        then ((p*a) * SgmX(BagOrder n, Support(p*a)))/.k = r.k by
PARTFUN1:def 8
          .= (p*a).(SgmX(BagOrder n, Support(p*a)).k) by A25,A26,A28,FUNCT_1:23
          .= (p * SgmX(BagOrder n, Support(p*a)))/.k * a by A25,A26,A28,A31,
PARTFUN1:def 8;
        hence y/.i = z/.i * a by A3,A15,A26,A27,A30;
      end;
      then y = z * a by A16,POLYNOM1:def 3;
      hence thesis by A2,A5,BINOM:5;
    end;
  end;
  hence thesis;
end;

theorem
  for n being Ordinal, L being Abelian left_zeroed right_zeroed
  add-associative right_complementable well-unital associative commutative
  distributive (non trivial doubleLoopStr), p being Polynomial of n,L, a being
Element of L, x being Function of n,L holds eval((a |(n,L))*'p,x) = a * eval(p,
  x) by Lm4;

theorem
  for n being Ordinal, L being Abelian left_zeroed right_zeroed
  add-associative right_complementable well-unital associative commutative
  distributive (non trivial doubleLoopStr), p being Polynomial of n,L, a being
Element of L, x being Function of n,L holds eval(p*'(a |(n,L)),x) = eval(p,x) *
  a
proof
  let n be Ordinal, L be left_zeroed right_zeroed add-associative
right_complementable well-unital associative commutative Abelian distributive (
non trivial doubleLoopStr), p be Polynomial of n,L, a be Element of L, x being
  Function of n,L;
  thus eval(p*'(a |(n,L)),x) = eval(p,x) * eval(a |(n,L),x) by POLYNOM2:27
    .= eval(p,x) * a by Th25;
end;
