:: The canonical formulae
::  by Andrzej Trybulec
::
:: Received July 4, 2000
:: Copyright (c) 2000 Association of Mizar Users
 
environ

 vocabularies INT_1, ABIAN, ARYTM_1, ZFMISC_1, FUNCT_1, RELAT_1, TARSKI,
      FUNCOP_1, FUNCT_2, FUNCT_6, XBOOLE_0, PBOOLE, SUBSET_1, NUMBERS,
      HILBERT1, CARD_1, FUNCT_3, CARD_3, MCART_1, PARTFUN1, FINSEQ_4, XBOOLEAN,
      QC_LANG1, HILBERT2, FUNCT_5, ARYTM_3, FUNCT_4, XXREAL_0, HILBERT3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, INT_1,
      RELAT_1, FUNCT_1, PBOOLE, CARD_3, ABIAN, PARTFUN1, FUNCT_2, BINOP_1,
      FUNCT_3, FUNCOP_1, FUNCT_4, FUNCT_5, FUNCT_6, PRALG_1, PRALG_2, MSUALG_3,
      HILBERT1, HILBERT2, XXREAL_0;
 constructors XXREAL_0, NAT_D, REALSET1, MSSUBFAM, ABIAN, CAT_2, PRALG_1,
      PRALG_2, MSUALG_3, HILBERT2, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, PARTFUN1,
      FUNCT_2, FUNCOP_1, FUNCT_4, NUMBERS, XREAL_0, INT_1, PBOOLE, ABIAN,
      HILBERT1, FUNCT_7, RELSET_1, ZFMISC_1, MSSUBFAM;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions PBOOLE, FUNCT_1, FUNCT_2, TARSKI, HILBERT1, ABIAN, FUNCOP_1,
      RELAT_1, XBOOLE_0, BINOP_1, SUBSET_1;
 theorems PBOOLE, ZFMISC_1, MSUALG_3, FUNCT_2, RELAT_1, RELSET_1, FUNCT_1,
      FUNCT_3, TARSKI, FUNCOP_1, PARTFUN2, PRALG_2, REALSET1, CARD_3, FUNCT_6,
      MSSUBFAM, FUNCT_5, FUNCTOR0, CAT_2, HILBERT1, FUNCT_4, INT_1, TOPREAL6,
      PRALG_1, XBOOLE_0, XBOOLE_1, XCMPLX_1, ABIAN, XREAL_1, XXREAL_0, CARD_1,
      PARTFUN1;
 schemes HILBERT2, FUNCT_2;

begin :: Preliminaries

theorem
  for i being Integer holds i is even iff i-1 is odd;

theorem
  for i being Integer holds i is odd iff i-1 is even;

theorem Th3:
  for X being trivial set, x being set st x in X for f being
  Function of X,X holds x is_a_fixpoint_of f
proof
  let X be trivial set, x be set;
  assume
A1: x in X;
  then consider y being set such that
A2: X = {y} by REALSET1:def 4;
  let f be Function of X,X;
  thus x in dom f by A1,FUNCT_2:67;
  then
A3: f.x in rng f by FUNCT_1:def 5;
A4: rng f c= X by RELAT_1:def 19;
  thus x = y by A1,A2,TARSKI:def 1
    .= f.x by A2,A3,A4,TARSKI:def 1;
end;

registration
  let A,B,C be set;
  cluster -> Function-yielding Function of A, Funcs(B,C);
  coherence
  proof
    let f be Function of A, Funcs(B,C);
    let x be set;
    assume x in dom f;
    then
A1: f.x in rng f by FUNCT_1:def 5;
    rng f c= Funcs(B,C) by RELAT_1:def 19;
    hence thesis by A1;
  end;
end;

theorem Th4:
  for f being Function-yielding Function holds SubFuncs rng f = rng f
proof
  let f be Function-yielding Function;
  for x being set holds x in rng f implies x is Function
  proof
    let x be set;
    assume x in rng f;
    then ex y being set st y in dom f & x = f.y by FUNCT_1:def 5;
    hence thesis;
  end;
  then for x being set holds x in rng f iff x in rng f & x is Function;
  hence thesis by FUNCT_6:def 1;
end;

theorem Th5:
  for A,B,x being set, f being Function st x in A & f in Funcs(A,B)
  holds f.x in B
proof
  let A,B,x be set, f be Function such that
A1: x in A;
  assume
A2: f in Funcs(A,B);
  then
A3: f is Function of A,B by FUNCT_2:121;
  B = {} implies A = {} by A2;
  hence thesis by A1,A3,FUNCT_2:7;
end;

theorem Th6:
  for A,B,C being set st C = {} implies B = {} or A = {} for f
  being Function of A, Funcs(B,C) holds doms f = A --> B
proof
  let A,B,C be set;
  assume C = {} implies B = {} or A = {};
  then
A1: Funcs(B,C) = {} implies A = {} by FUNCT_2:11;
  let f be Function of A, Funcs(B,C);
  reconsider g = f as ManySortedFunction of A by A1;
  now
    let i be set;
    assume
A2: i in A;
    then
A3: g.i in Funcs(B,C) by A1,FUNCT_2:7;
    thus (doms g).i = dom(g.i) by A2,MSSUBFAM:14
      .= B by A3,FUNCT_2:169
      .= (A-->B).i by A2,FUNCOP_1:13;
  end;
  hence thesis by PBOOLE:3;
end;

reserve n for Element of NAT,
  p,q,r,s for Element of HP-WFF;

theorem Th7:
  for x being set holds ({}).x = {}
proof
  let x be set;
  not x in dom {};
  hence thesis by FUNCT_1:def 4;
end;

registration
  let A be set, B be functional set;
  cluster -> Function-yielding Function of A,B;
  coherence
  proof
    let f be Function of A,B, x be set;
    assume x in dom f;
    then
A1: f.x in rng f by FUNCT_1:def 5;
    rng f c= B by RELAT_1:def 19;
    hence thesis by A1;
  end;
end;

theorem Th8:
  for X being set, A being Subset of X holds ((0,1) --> (1,0))*chi(
  A,X) = chi(A`,X)
proof
  let X be set, A be Subset of X;
  set f = ((0,1) --> (1,0))*chi(A,X);
A1: dom chi(A,X) = X by FUNCT_3:def 3;
A2: for x being set st x in X holds (x in A` implies f.x = 1) & (not x in A`
  implies f.x = 0)
  proof
    let x be set such that
A3: x in X;
    thus x in A` implies f.x = 1
    proof
      assume x in A`;
      then not x in A by XBOOLE_0:def 5;
      then chi(A,X).x = 0 by A3,FUNCT_3:def 3;
      then f.x = ((0,1) --> (1,0)).0 by A1,A3,FUNCT_1:23;
      hence thesis by FUNCT_4:66;
    end;
    assume not x in A`;
    then x in A by A3,XBOOLE_0:def 5;
    then chi(A,X).x = 1 by FUNCT_3:def 3;
    then f.x = ((0,1) --> (1,0)).1 by A1,A3,FUNCT_1:23;
    hence thesis by FUNCT_4:66;
  end;
  dom((0,1) --> (1,0)) = {0,1} by FUNCT_4:65;
  then rng chi(A,X) c= dom((0,1) --> (1,0)) by FUNCT_3:48;
  then dom f = X by A1,RELAT_1:46;
  hence thesis by A2,FUNCT_3:def 3;
end;

theorem Th9:
  for X being set, A being Subset of X holds ((0,1) --> (1,0))*chi(
  A`,X) = chi(A,X)
proof
  let X be set, A be Subset of X;
  thus ((0,1) --> (1,0))*chi(A`,X) = chi(A``,X) by Th8
    .= chi(A,X);
end;

theorem Th10:
  for a,b,x,y,x9,y9 being set st a <> b & (a,b) --> (x,y) = (a,b)
  --> (x9,y9) holds x = x9 & y = y9
proof
  let a,b,x,y,x9,y9 be set such that
A1: a <> b and
A2: (a,b) --> (x,y) = (a,b) --> (x9,y9);
  thus x = ((a,b) --> (x,y)).a by A1,FUNCT_4:66
    .= x9 by A1,A2,FUNCT_4:66;
  thus y = ((a,b) --> (x,y)).b by FUNCT_4:66
    .= y9 by A2,FUNCT_4:66;
end;

theorem Th11:
  for a,b,x,y,X,Y being set st a<>b & x in X & y in Y holds (a,b)
  --> (x,y) in product((a,b) --> (X,Y))
proof
  let a,b,x,y,X,Y be set such that
A1: a<>b and
A2: x in X & y in Y;
  {x} c= X & {y} c= Y by A2,ZFMISC_1:37;
  then product((a,b) --> ({x},{y})) c= product((a,b) --> (X,Y)) by
  TOPREAL6:
  29;
  then {(a,b) -->(x,y)} c= product((a,b) --> (X,Y)) by A1,CARD_3:63;
  hence thesis by ZFMISC_1:37;
end;

theorem Th12:
  for D being non empty set for f being Function of 2, D ex d1,d2
  being Element of D st f = (0,1) --> (d1,d2)
proof
  let D be non empty set;
  let f be Function of 2, D;
  0 in 2 & 1 in 2 by CARD_1:88,TARSKI:def 2;
  then reconsider d1 = f.0, d2 = f.1 as Element of D by FUNCT_2:7;
  take d1,d2;
  dom f = {0,1} by CARD_1:88,FUNCT_2:def 1;
  hence thesis by FUNCT_4:69;
end;

theorem Th13:
  for a,b,c,d being set st a <> b holds ((a,b) --> (c,d))*((a,b)
  --> (b,a)) = (a,b) --> (d,c)
proof
  let a,b,c,d be set such that
A1: a <> b;
  set f = ((a,b) --> (c,d))*((a,b) --> (b,a));
A2: dom((a,b) --> (b,a)) = {a,b} by FUNCT_4:65;
  b in {a,b} by TARSKI:def 2;
  then
A3: f.b = ((a,b) --> (c,d)).(((a,b) --> (b,a)).b) by A2,FUNCT_1:23
    .= ((a,b) --> (c,d)).a by FUNCT_4:66
    .= c by A1,FUNCT_4:66;
  a in {a,b} by TARSKI:def 2;
  then
A4: f.a = ((a,b) --> (c,d)).(((a,b) --> (b,a)).a) by A2,FUNCT_1:23
    .= ((a,b) --> (c,d)).b by A1,FUNCT_4:66
    .= d by FUNCT_4:66;
  rng((a,b) --> (b,a)) = {a,b} by A1,FUNCT_4:67
    .= dom((a,b) --> (c,d)) by FUNCT_4:65;
  then dom f = {a,b} by A2,RELAT_1:46;
  hence thesis by A4,A3,FUNCT_4:69;
end;

theorem Th14:
  for a,b,c,d being set, f being Function st a <> b & c in dom f &
  d in dom f holds f*((a,b) --> (c,d)) = (a,b) --> (f.c,f.d)
proof
  let a,b,c,d be set, f be Function such that
A1: a <> b and
A2: c in dom f & d in dom f;
A3: dom((a,b) --> (c,d)) = {a,b} by FUNCT_4:65;
  then a in dom((a,b) --> (c,d)) by TARSKI:def 2;
  then
A4: (f*((a,b) --> (c,d))).a = f.(((a,b) --> (c,d)).a) by FUNCT_1:23
    .= f.c by A1,FUNCT_4:66;
  b in dom((a,b) --> (c,d)) by A3,TARSKI:def 2;
  then
A5: (f*((a,b) --> (c,d))).b = f.(((a,b) --> (c,d)).b) by FUNCT_1:23
    .= f.d by FUNCT_4:66;
A6: rng((a,b) --> (c,d)) c= {c,d} by FUNCT_4:65;
  {c,d} c= dom f by A2,ZFMISC_1:38;
  then dom(f*((a,b) --> (c,d))) = {a,b} by A3,A6,RELAT_1:46,XBOOLE_1:1;
  hence thesis by A4,A5,FUNCT_4:69;
end;

begin :: the Cartesian product of functions and the Frege function

registration
  let f,g be one-to-one Function;
  cluster [:f,g:] -> one-to-one;
  coherence
  proof
    let x,y be set such that
A1: x in dom[:f,g:] and
A2: y in dom[:f,g:] and
A3: [:f,g:].x = [:f,g:].y;
A4: dom[:f,g:] = [:dom f, dom g:] by FUNCT_3:def 9;
    then consider x1,x2 being set such that
A5: x1 in dom f and
A6: x2 in dom g and
A7: x = [x1,x2] by A1,ZFMISC_1:def 2;
A8: [:f,g:].(x1,x2) = [f.x1,g.x2] by A5,A6,FUNCT_3:def 9;
    consider y1,y2 being set such that
A9: y1 in dom f and
A10: y2 in dom g and
A11: y = [y1,y2] by A2,A4,ZFMISC_1:def 2;
A12: [:f,g:].(y1,y2) = [f.y1,g.y2] by A9,A10,FUNCT_3:def 9;
    then f.x1 = f.y1 by A3,A7,A11,A8,ZFMISC_1:33;
    then
A13: x1 = y1 by A5,A9,FUNCT_1:def 8;
    g.x2 = g.y2 by A3,A7,A11,A8,A12,ZFMISC_1:33;
    hence thesis by A6,A7,A10,A11,A13,FUNCT_1:def 8;
  end;
end;

theorem Th15:
  for A,B being non empty set, C,D being set, f being Function of
  C,A, g being Function of D,B holds pr1(A,B)*[:f,g:] = f*pr1(C,D)
proof
  let A,B be non empty set, C,D be set;
  let f be Function of C,A, g be Function of D,B;
  C = {} implies A = {} or [:C,D:] = {};
  then reconsider F = f*pr1(C,D) as Function of [:C,D:], A;
  D = {} implies A = {} or [:C,D:] = {};
  then reconsider G = g*pr2(C,D) as Function of [:C,D:], B;
  thus pr1(A,B)*[:f,g:] = pr1(A,B)*<:F,G:> by FUNCT_3:98
    .= f*pr1(C,D) by FUNCT_3:82;
end;

theorem Th16:
  for A,B being non empty set, C,D being set, f being Function of
  C,A, g being Function of D,B holds pr2(A,B)*[:f,g:] = g*pr2(C,D)
proof
  let A,B be non empty set, C,D be set;
  let f be Function of C,A, g be Function of D,B;
  C = {} implies A = {} or [:C,D:] = {};
  then reconsider F = f*pr1(C,D) as Function of [:C,D:], A;
  D = {} implies A = {} or [:C,D:] = {};
  then reconsider G = g*pr2(C,D) as Function of [:C,D:], B;
  thus pr2(A,B)*[:f,g:] = pr2(A,B)*<:F,G:> by FUNCT_3:98
    .= g*pr2(C,D) by FUNCT_3:82;
end;

theorem
  for g being Function holds ({})..g = {}
proof
  let g be Function;
  dom {} = {};
  then dom(({})..g) = {} by PRALG_1:def 17;
  hence thesis;
end;

theorem Th18:
  for f being Function-yielding Function, g,h being Function holds
  (f..g)*h = (f*h)..(g*h)
proof
  let f be Function-yielding Function, g,h be Function;
A1: for x being set st x in dom(f*h) holds ((f..g)*h).x = ((f*h).x).((g*h).x )
  proof
    let x be set;
    assume
A2: x in dom(f*h);
    then
A3: x in dom h by FUNCT_1:21;
A4: h.x in dom f by A2,FUNCT_1:21;
    thus ((f..g)*h).x = (f..g).(h.x) by A3,FUNCT_1:23
      .= (f.(h.x)).(g.(h.x)) by A4,PRALG_1:def 17
      .= ((f*h).x).(g.(h.x)) by A3,FUNCT_1:23
      .= (f*h).x .((g*h).x) by A3,FUNCT_1:23;
  end;
  dom(f..g) = dom f by PRALG_1:def 17;
  then dom((f..g)*h) = dom(f*h) by RELAT_1:198;
  hence thesis by A1,PRALG_1:def 17;
end;

theorem
  for C being set, A being non empty set for f being Function of A,
  Funcs({} qua set,C), g being Function of A,{} holds rng(f..g) = {{}}
proof
  let C be set, A be non empty set;
  let f be Function of A, Funcs({} qua set,C), g be Function of A,{};
  consider a being Element of A;
A1: Funcs({} qua set,C) = {{}} by FUNCT_5:64;
  then
A2: dom f = A by FUNCT_2:def 1;
A3: dom(f..g) = dom f by PRALG_1:def 17;
A4: rng(f..g) c= {{}}
  proof
    let x be set;
A5: rng f c= Funcs({} qua set,C) by RELAT_1:def 19;
    assume x in rng(f..g);
    then consider y being set such that
A6: y in dom(f..g) and
A7: (f..g).y = x by FUNCT_1:def 5;
    f.y in rng f by A3,A6,FUNCT_1:def 5;
    then
A8: f.y = {} by A1,A5,TARSKI:def 1;
    x = (f.y).(g.y) by A3,A6,A7,PRALG_1:def 17;
    then x = {} by A8,Th7;
    hence thesis by TARSKI:def 1;
  end;
  f.a = {} by A1,TARSKI:def 1;
  then (f..g).a = ({}).(g.a) by A2,PRALG_1:def 17
    .= {} by Th7;
  then {} in rng(f..g) by A3,A2,FUNCT_1:def 5;
  hence thesis by A4,ZFMISC_1:39;
end;

theorem Th20:
  for A,B,C being set st B = {} implies A = {} for f being
  Function of A, Funcs(B,C), g being Function of A,B holds rng(f..g) c= C
proof
  let A,B,C be set such that
A1: B = {} implies A = {};
  let f be Function of A, Funcs(B,C), g be Function of A,B;
  let x be set;
  assume x in rng(f..g);
  then consider y being set such that
A2: y in dom(f..g) and
A3: (f..g).y = x by FUNCT_1:def 5;
A4: dom(f..g) = dom f by PRALG_1:def 17;
  then
A5: Funcs(B,C) <> {} by A2;
  then
A6: dom f = A by FUNCT_2:def 1;
  then reconsider fy = f.y as Function of B,C by A2,A4,A5,FUNCT_2:7,121;
A7: C <> {} by A1,A2,A6,PRALG_1:def 17;
  g.y in B by A1,A2,A4,A6,FUNCT_2:7;
  then fy.(g.y) in C by A7,FUNCT_2:7;
  hence thesis by A2,A3,A4,PRALG_1:def 17;
end;

theorem Th21:
  for A,B,C being set st C = {} implies B = {} or A = {} for f
  being Function of A, Funcs(B,C) holds dom Frege f = Funcs(A,B)
proof
  let A,B,C be set such that
A1: C = {} implies B = {} or A = {};
  let f be Function of A, Funcs(B,C);
  thus dom Frege f = product doms f by PARTFUN1:def 4
    .= product(A --> B) by A1,Th6
    .= Funcs(A,B) by CARD_3:20;
end;

canceled;

theorem Th23:
  for A,B,C being set st C = {} implies B = {} or A = {} for f
  being Function of A, Funcs(B,C) holds rng Frege f c= Funcs(A,C)
proof
  let A,B,C be set;
  assume C = {} implies B = {} or A = {};
  then
A1: Funcs(B,C) = {} implies A = {} by FUNCT_2:11;
  let f be Function of A, Funcs(B,C);
A2: SubFuncs rng f = rng f by Th4;
  then
A3: dom rngs f = f"rng f by FUNCT_6:def 3;
  then
A4: dom rngs f = dom f by RELAT_1:169
    .= A by A1,FUNCT_2:def 1;
A5: for x being set st x in dom rngs f holds (rngs f).x c= (A-->C).x
  proof
    let x be set such that
A6: x in dom rngs f;
A7: (rngs f).x = proj2(f.x) by A2,A3,A6,FUNCT_6:def 3
      .= rng(f.x);
    f.x in Funcs(B,C) by A1,A4,A6,FUNCT_2:7;
    then (rngs f).x c= C by A7,FUNCT_2:169;
    hence thesis by A4,A6,FUNCOP_1:13;
  end;
  dom rngs f = dom(A-->C) by A4,FUNCOP_1:19;
  then product rngs f c= product(A --> C) by A5,CARD_3:38;
  then product rngs f c= Funcs(A,C) by CARD_3:20;
  hence thesis by FUNCT_6:58;
end;

theorem Th24:
  for A,B,C being set st C = {} implies B = {} or A = {} for f
being Function of A, Funcs(B,C) holds Frege f is Function of Funcs(A,B), Funcs(
  A,C)
proof
  let A,B,C be set;
  assume
A1: C = {} implies B = {} or A = {};
  then
A2: Funcs(A,C) = {} implies Funcs(A,B) = {} by FUNCT_2:11;
  let f be Function of A, Funcs(B,C);
  dom Frege f = Funcs(A,B) & rng Frege f c= Funcs(A,C) by A1,Th21,Th23;
  hence thesis by A2,FUNCT_2:def 1,RELSET_1:11;
end;

begin :: about permutations

theorem Th25:
  for A,B being set, P being Permutation of A, Q being Permutation
  of B holds [:P,Q:] is bijective
proof
  let A,B be set, P be Permutation of A, Q be Permutation of B;
  thus [:P,Q:] is one-to-one;
  rng P = A & rng Q = B by FUNCT_2:def 3;
  hence rng [:P,Q:] = [:A,B:] by FUNCT_3:88;
end;

definition
  let A,B be non empty set;
  let P be Permutation of A, Q be Function of B,B;
  func P => Q -> Function of Funcs(A,B), Funcs(A,B) means
  :Def1:
  for f being Function of A,B holds it.f = Q*f*P";
  existence
  proof
    deffunc F1(Element of Funcs(A,B))=Q*$1*P";
A1: for f being Element of Funcs(A,B) holds F1(f) in Funcs(A,B) by FUNCT_2
    :11;
    consider F being Function of Funcs(A,B), Funcs(A,B) such that
A2: for f being Element of Funcs(A,B) holds F.f = F1(f) from FUNCT_2:
    sch 8(A1);
    take F;
    let f be Function of A,B;
    f in Funcs(A,B) by FUNCT_2:11;
    hence thesis by A2;
  end;
  uniqueness
  proof
    let F,G be Function of Funcs(A,B), Funcs(A,B) such that
A3: for f being Function of A,B holds F.f = Q*f*P" and
A4: for f being Function of A,B holds G.f = Q*f*P";
    now
      let f be Element of Funcs(A,B);
      thus F.f = Q*f*P" by A3
        .= G.f by A4;
    end;
    hence F = G by FUNCT_2:113;
  end;
end;

registration
  let A,B be non empty set;
  let P be Permutation of A, Q be Permutation of B;
  cluster P => Q -> bijective;
  coherence
  proof
    thus P => Q is one-to-one
    proof
      let x1,x2 be set;
      assume x1 in dom(P => Q) & x2 in dom(P => Q);
      then reconsider f1 = x1, f2 = x2 as Element of Funcs(A,B) by
      FUNCT_2:def 1;
      assume (P => Q).x1 = (P => Q).x2;
      then
A1:   Q*f1*P" = (P => Q).f2 by Def1
        .= Q*f2*P" by Def1;
A2:   Q*f1 = Q*f1*id A by FUNCT_2:23
        .= Q*f1*(P"*P) by FUNCT_2:88
        .= Q*f2*P"*P by A1,RELAT_1:55
        .= Q*f2*(P"*P) by RELAT_1:55
        .= Q*f2*id A by FUNCT_2:88
        .= Q*f2 by FUNCT_2:23;
      f1 = (id B)*f1 by FUNCT_2:23
        .= Q"*Q*f1 by FUNCT_2:88
        .= Q"*(Q*f2) by A2,RELAT_1:55
        .= Q"*Q*f2 by RELAT_1:55
        .= (id B)*f2 by FUNCT_2:88
        .= f2 by FUNCT_2:23;
      hence thesis;
    end;
    thus rng(P => Q) c= Funcs(A,B) by RELAT_1:def 19;
    let x be set;
    assume x in Funcs(A,B);
    then x is Element of Funcs(A,B);
    then reconsider f = x as Function of A,B;
    dom(P => Q) = Funcs(A,B) by FUNCT_2:def 1;
    then
A3: Q"*f*P in dom(P => Q) by FUNCT_2:11;
    (P => Q).(Q"*f*P) = Q*(Q"*f*P)*P" by Def1
      .= Q*(Q"*f)*P*P" by RELAT_1:55
      .= Q*Q"*f*P*P" by RELAT_1:55
      .= (id B)*f*P*P" by FUNCT_2:88
      .= f*P*P" by FUNCT_2:23
      .= f*(P*P") by RELAT_1:55
      .= f*id A by FUNCT_2:88
      .= f by FUNCT_2:23;
    hence x in rng(P => Q) by A3,FUNCT_1:def 5;
  end;
end;

theorem Th26:
  for A,B being non empty set for P being Permutation of A, Q
  being Permutation of B for f being Function of A,B holds (P => Q)".f = Q"*f*P
proof
  let A,B be non empty set;
  let P be Permutation of A, Q be Permutation of B;
  let f be Function of A,B;
  reconsider h = f as Element of Funcs(A,B) by FUNCT_2:11;
  reconsider g = Q"*f*P as Function of A,B;
  f in Funcs(A,B) by FUNCT_2:11;
  then
A1: (P => Q)"".((P => Q)".f) = f by FUNCT_2:32
    .= f*id A by FUNCT_2:23
    .= f*(P*P") by FUNCT_2:88
    .= f*P*P" by RELAT_1:55
    .= (id B)*f*P*P" by FUNCT_2:23
    .= Q*Q"*f*P*P" by FUNCT_2:88
    .= Q*(Q"*f)*P*P" by RELAT_1:55
    .= Q*(Q"*f*P)*P" by RELAT_1:55
    .= (P => Q).g by Def1
    .= (P => Q)"".(Q"*f*P) by FUNCT_1:65;
  (P => Q)".h in Funcs(A,B) & g in Funcs(A,B) by FUNCT_2:11;
  hence thesis by A1,FUNCT_2:25;
end;

theorem Th27:
  for A,B being non empty set for P being Permutation of A, Q
  being Permutation of B holds (P => Q)" = P" => (Q")
proof
  let A,B be non empty set;
  let P be Permutation of A, Q be Permutation of B;
  now
    let f be Element of Funcs(A,B);
    thus (P => Q)".f = Q"*f*P by Th26
      .= Q"*f*P"" by FUNCT_1:65
      .= (P" => (Q")).f by Def1;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th28:
  for A,B,C being non empty set, f being Function of A, Funcs(B,C)
  , g being Function of A,B, P being Permutation of B, Q being Permutation of C
  holds ((P => Q)*f)..(P*g) = Q*(f..g)
proof
  let A,B,C be non empty set;
  let f be Function of A, Funcs(B,C), g be Function of A,B, P be Permutation
  of B, Q be Permutation of C;
A1: dom((P => Q)*f) = A by FUNCT_2:def 1;
A2: dom Q = C & rng(f..g) c= C by Th20,FUNCT_2:def 1;
A3: dom f = A by FUNCT_2:def 1;
  then dom(f..g) = A by PRALG_1:def 17;
  then
A4: dom(Q*(f..g)) = A by A2,RELAT_1:46;
  for x be set st x in dom((P => Q)*f) holds (Q*(f..g)).x = (((P => Q)*f).
  x).((P*g).x)
  proof
    let x be set such that
A5: x in dom((P => Q)*f);
    reconsider fx = f.x as Function of B,C by A1,A5,FUNCT_2:7,121;
    g.x in B by A1,A5,FUNCT_2:7;
    then
A6: g.x in dom fx by FUNCT_2:def 1;
    (P*g).x in B by A1,A5,FUNCT_2:7;
    then
A7: (P*g).x in dom(P") by FUNCT_2:def 1;
    thus (Q*(f..g)).x = Q.((f..g).x) by A4,A1,A5,FUNCT_1:22
      .= Q.(fx.(g.x)) by A3,A1,A5,PRALG_1:def 17
      .= (Q*fx).(g.x) by A6,FUNCT_1:23
      .= (Q*fx).(((id B)*g).x) by FUNCT_2:23
      .= (Q*fx).((P"*P*g).x) by FUNCT_2:88
      .= (Q*fx).((P"*(P*g)).x) by RELAT_1:55
      .= (Q*fx).(P".((P*g).x)) by A1,A5,FUNCT_2:21
      .= (Q*fx*P").((P*g).x) by A7,FUNCT_1:23
      .= ((P => Q).fx).((P*g).x) by Def1
      .= (((P => Q)*f).x).((P*g).x) by A1,A5,FUNCT_2:21;
  end;
  hence thesis by A4,A1,PRALG_1:def 17;
end;

begin ::  set valuations

definition
  mode SetValuation is non-empty ManySortedSet of NAT;
end;

reserve V for SetValuation;

definition
  let V;
  func SetVal V -> ManySortedSet of HP-WFF means
  :Def2:
  it.VERUM = 1 & (for n
holds it.prop n = V.n) & for p,q holds it.(p '&' q) = [:it.p, it.q:] & it.(p =>
  q) = Funcs(it.p,it.q);
  existence
  proof
    deffunc F(Element of NAT)=V.$1;
    consider M being ManySortedSet of HP-WFF such that
A1: ( M.VERUM = 1 & for n holds M.prop n = F(n) )& for p,q holds M.(p
    '&' q) = [:M.p,M.q:] & M.(p => q) = Funcs(M.p,M.q) from HILBERT2:sch 4;
    take M;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let M1,M2 be ManySortedSet of HP-WFF such that
A2: M1.VERUM = 1 and
A3: for n holds M1.prop n = V.n and
A4: for p,q holds M1.(p '&' q) = [:M1.p, M1.q:] & M1.(p => q) = Funcs(
    M1.p,M1.q) and
A5: M2.VERUM = 1 and
A6: for n holds M2.prop n = V.n and
A7: for p,q holds M2.(p '&' q) = [:M2.p, M2.q:] & M2.(p => q) = Funcs(
    M2.p,M2.q);
    defpred P[Element of HP-WFF] means M1.$1 = M2.$1;
A8: for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
    proof
      let r,s such that
A9:   M1.r=M2.r & M1.s = M2.s;
      thus M1.(r '&' s) = [:M2.r, M2.s:] by A4,A9
        .= M2.(r '&' s) by A7;
      thus M1.(r => s) = Funcs(M2.r,M2.s) by A4,A9
        .= M2.(r => s) by A7;
    end;
A10: for n holds P[prop n]
    proof
      let n;
      thus M1.prop n = V.n by A3
        .= M2.prop n by A6;
    end;
A11: P[VERUM] by A2,A5;
    for r holds P[r] from HILBERT2:sch 2(A11,A10,A8);
    then for r being set st r in HP-WFF holds M1.r = M2.r;
    hence M1 = M2 by PBOOLE:3;
  end;
end;

definition
  let V,p;
  func SetVal(V,p) equals
  (SetVal V).p;
  correctness;
end;

registration
  let V,p;
  cluster SetVal(V,p) -> non empty;
  coherence
  proof
    defpred P[Element of HP-WFF] means (SetVal V).$1 is non empty;
A1: for n holds P[prop n]
    proof
      let n;
      (SetVal V).prop n = V.n by Def2;
      hence thesis;
    end;
A2: for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
    proof
      let r,s such that
A3:   (SetVal V).r is non empty and
A4:   (SetVal V).s is non empty;
      (SetVal V).(r '&' s) = [:(SetVal V).r,(SetVal V).s:] by Def2;
      hence (SetVal V).(r '&' s) is non empty by A3,A4;
      (SetVal V).(r => s) = Funcs((SetVal V).r,(SetVal V).s) by Def2;
      hence thesis by A4;
    end;
A5: P[VERUM] by Def2;
    for r holds P[r] from HILBERT2:sch 2(A5,A1,A2);
    hence thesis;
  end;
end;

theorem
  SetVal(V,VERUM) = 1 by Def2;

theorem
  SetVal(V,prop n) = V.n by Def2;

theorem
  SetVal(V,p '&' q) = [:SetVal(V,p), SetVal(V,q):] by Def2;

theorem
  SetVal(V,p => q) = Funcs(SetVal(V,p),SetVal(V,q)) by Def2;

registration
  let V,p,q;
  cluster SetVal(V,p => q) -> functional;
  coherence
  proof
    let x be set;
    assume x in SetVal(V,p => q);
    then x in Funcs(SetVal(V,p),SetVal(V,q)) by Def2;
    hence thesis;
  end;
end;

registration
  let V,p,q,r;
  cluster -> Function-yielding Element of SetVal(V,p => (q => r));
  coherence
  proof
    let e be Element of SetVal(V,p => (q => r)), x be set such that
    x in dom e;
    e in SetVal(V,p => (q => r));
    then e in Funcs(SetVal(V,p),SetVal(V,q => r)) by Def2;
    then e is Function of SetVal(V,p),SetVal(V,q => r) by FUNCT_2:121;
    hence thesis;
  end;
end;

registration
  let V,p,q,r;
  cluster Function-yielding Function of SetVal(V,p => q),SetVal(V,p => r);
  existence
  proof
    consider e being Function of SetVal(V,p => q),SetVal(V,p => r);
    e is Function-yielding;
    hence thesis;
  end;
  cluster Function-yielding Element of SetVal(V,p => (q => r));
  existence
  proof
    consider e being Element of SetVal(V,p => (q => r));
    e is Function-yielding;
    hence thesis;
  end;
end;

begin :: permuting set valuations

definition
  let V;
  mode Permutation of V -> Function means
    :Def4:
    dom it = NAT & for n holds it .n is Permutation of V.n;
  existence
  proof
    take id V;
    thus dom id V = NAT by PARTFUN1:def 4;
    let n;
    (id V).n = id (V.n) by MSUALG_3:def 1;
    hence thesis;
  end;
end;

reserve P for Permutation of V;

definition
  let V,P;
  func Perm P -> ManySortedFunction of SetVal V, SetVal V means
  :Def5:
  it.
VERUM = id 1 & (for n holds it.prop n = P.n) & for p,q ex p9 being Permutation
of SetVal(V,p), q9 being Permutation of SetVal(V,q) st p9 = it.p & q9 = it.q &
  it.(p '&' q) = [:p9,q9:] & it.(p => q) = p9 => q9;
  existence
  proof
    deffunc F(Element of NAT)=P.$1;
    defpred I[Element of HP-WFF,Element of HP-WFF,set,set,set] means ($3 is
Permutation of SetVal(V,$1) & $4 is Permutation of SetVal(V,$2) implies ex p9
being Permutation of SetVal(V,$1), q9 being Permutation of SetVal(V,$2) st p9 =
$3 & q9 = $4 & $5 = p9 => q9) & ($3 is not Permutation of SetVal(V,$1) or $4 is
    not Permutation of SetVal(V,$2) implies $5 = {});
    defpred C[Element of HP-WFF,Element of HP-WFF,set,set,set] means ($3 is
Permutation of SetVal(V,$1) & $4 is Permutation of SetVal(V,$2) implies ex p9
being Permutation of SetVal(V,$1), q9 being Permutation of SetVal(V,$2) st p9 =
$3 & q9 = $4 & $5 = [:p9,q9:]) & ($3 is not Permutation of SetVal(V,$1) or $4
    is not Permutation of SetVal(V,$2) implies $5 = {});
A1: for p,q for a,b being set ex c being set st C[p,q,a,b,c]
    proof
      let p,q;
      let a,b be set;
      per cases;
      suppose that
A2:     a is Permutation of SetVal(V,p) and
A3:     b is Permutation of SetVal(V,q);
        reconsider q9 = b as Permutation of SetVal(V,q) by A3;
        reconsider p9 = a as Permutation of SetVal(V,p) by A2;
        take [:p9,q9:];
        thus thesis;
      end;
      suppose
        a is not Permutation of SetVal(V,p) or b is not Permutation of
        SetVal(V,q);
        hence thesis;
      end;
    end;
A4: for p,q for a,b being set ex d being set st I[p,q,a,b,d]
    proof
      let p,q;
      let a,b be set;
      per cases;
      suppose that
A5:     a is Permutation of SetVal(V,p) and
A6:     b is Permutation of SetVal(V,q);
        reconsider q9 = b as Permutation of SetVal(V,q) by A6;
        reconsider p9 = a as Permutation of SetVal(V,p) by A5;
        take p9 => q9;
        thus thesis;
      end;
      suppose
        a is not Permutation of SetVal(V,p) or b is not Permutation of
        SetVal(V,q);
        hence thesis;
      end;
    end;
A7: for p,q for a,b,c,d being set st I[p,q,a,b,c] & I[p,q,a,b,d] holds c = d;
A8: for p,q for a,b,c,d being set st C[p,q,a,b,c] & C[p,q,a,b,d] holds c = d;
    consider M being ManySortedSet of HP-WFF such that
A9: M.VERUM = id 1 and
A10: for n holds M.prop n = F(n) and
A11: for p,q holds C[p,q,M.p,M.q,M.(p '&' q)] & I[p,q,M.p,M.q,M.(p =>
    q)] from HILBERT2:sch 3(A1,A4,A8,A7);
    defpred P[Element of HP-WFF] means M.$1 is Permutation of (SetVal V).$1;
A12: for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
    proof
      let r,s such that
A13:  M.r is Permutation of (SetVal V).r & M.s is Permutation of ( SetVal V).s;
A14:  (SetVal V).(r '&' s) = [:SetVal(V,r),SetVal(V,s):] by Def2;
      ex p9 being Permutation of SetVal(V,r), q9 being Permutation of
      SetVal(V,s) st p9 = M.r & q9 = M.s & M.(r '&' s) = [:p9,q9:] by A11,A13;
      hence M.(r '&' s) is Permutation of (SetVal V).(r '&' s) by A14,Th25;
A15:  (SetVal V).(r => s) = Funcs(SetVal(V,r),SetVal(V,s)) by Def2;
      ex p9 being Permutation of SetVal(V,r), q9 being Permutation of
      SetVal(V,s) st p9 = M.r & q9 = M.s & M.(r => s) = p9 => q9 by A11,A13;
      hence thesis by A15;
    end;
    take M;
A16: for n holds P[prop n]
    proof
      let n;
      M.prop n = P.n & (SetVal V).prop n = V.n by A10,Def2;
      hence thesis by Def4;
    end;
    (SetVal V).VERUM = 1 by Def2;
    then
A17: P[VERUM] by A9;
A18: for p holds P[p] from HILBERT2:sch 2(A17,A16,A12);
    thus M is ManySortedFunction of SetVal V, SetVal V
    proof
      let p be set;
      thus thesis by A18;
    end;
    thus M.VERUM = id 1 by A9;
    thus for n holds M.prop n = P.n by A10;
    let p,q;
A19: M.p is Permutation of (SetVal V).p & M.q is Permutation of (SetVal V)
    .q by A18;
    then consider p9 being Permutation of SetVal(V,p), q9 being Permutation of
    SetVal(V,q) such that
A20: p9 = M.p & q9 = M.q and
A21: M.(p '&' q) = [:p9,q9:] by A11;
    take p9,q9;
    thus p9 = M.p & q9 = M.q & M.(p '&' q) = [:p9,q9:] by A20,A21;
    ex p9 being Permutation of SetVal(V,p), q9 being Permutation of
    SetVal(V,q) st p9 = M.p & q9 = M.q & M.(p => q) = p9 => q9 by A11,A19;
    hence M.(p => q) = p9 => q9 by A20;
  end;
  uniqueness
  proof
    let M1,M2 be ManySortedFunction of SetVal V, SetVal V such that
A22: M1.VERUM = id 1 and
A23: for n holds M1.prop n = P.n and
A24: for p,q ex p9 being Permutation of SetVal(V,p), q9 being
Permutation of SetVal(V,q) st p9 = M1.p & q9 = M1.q & M1.(p '&' q) = [:p9,q9:]
    & M1.(p => q) = p9 => q9 and
A25: M2.VERUM = id 1 and
A26: for n holds M2.prop n = P.n and
A27: for p,q ex p9 being Permutation of SetVal(V,p), q9 being
Permutation of SetVal(V,q) st p9 = M2.p & q9 = M2.q & M2.(p '&' q) = [:p9,q9:]
    & M2.(p => q) = p9 => q9;
    defpred P[Element of HP-WFF] means M1.$1=M2.$1;
A28: for n holds P[prop n]
    proof
      let n;
      thus M1.prop n = P.n by A23
        .= M2.prop n by A26;
    end;
A29: for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
    proof
      let r,s such that
A30:  M1.r=M2.r & M1.s=M2.s;
A31:  (ex p9 being Permutation of SetVal(V,r), q9 being Permutation of
SetVal(V,s) st p9 = M1.r & q9 = M1.s & M1.(r '&' s) = [:p9, q9:] & M1.(r => s)
= p9 => q9 ) & ex p9 being Permutation of SetVal(V,r), q9 being Permutation of
SetVal(V,s) st p9 = M2.r & q9 = M2.s & M2.(r '&' s) = [:p9, q9:] & M2.(r => s)
      = p9 => q9 by A24,A27;
      hence M1.(r '&' s) = M2.(r '&' s) by A30;
      thus thesis by A30,A31;
    end;
A32: P[VERUM] by A22,A25;
    for r holds P[r] from HILBERT2:sch 2(A32,A28,A29);
    then for r being set st r in HP-WFF holds M1.r=M2.r;
    hence M1 = M2 by PBOOLE:3;
  end;
end;

definition
  let V,P,p;
  func Perm(P,p) -> Function of SetVal(V,p), SetVal(V,p) equals
  (Perm P).p;
  correctness;
end;

theorem Th33:
  Perm(P,VERUM) = id SetVal(V,VERUM)
proof
  thus Perm(P,VERUM) = id 1 by Def5
    .= id SetVal(V,VERUM) by Def2;
end;

theorem
  Perm(P,prop n) = P.n by Def5;

theorem Th35:
  Perm(P,p '&' q) = [:Perm(P,p),Perm(P,q):]
proof
  ex p9 being Permutation of SetVal(V,p), q9 being Permutation of SetVal(V,
  q) st p9 = (Perm P).p & q9 = (Perm P).q & (Perm P). (p '&' q) = [:p9,q9:] & (
  Perm P).(p => q) = p9 => q9 by Def5;
  hence thesis;
end;

theorem Th36:
  for p9 being Permutation of SetVal(V,p), q9 being Permutation of
SetVal(V,q) st p9 = Perm(P,p) & q9 = Perm(P,q) holds Perm(P,p => q) = p9 => q9
proof
A1: ex p9 being Permutation of SetVal(V,p), q9 being Permutation of SetVal(V
  ,q) st p9 = (Perm P).p & q9 = (Perm P).q & (Perm P).(p '&' q) = [:p9,q9:] & (
  Perm P).(p => q) = p9 => q9 by Def5;
  let p9 be Permutation of SetVal(V,p), q9 be Permutation of SetVal(V,q);
  assume p9 = Perm(P,p) & q9 = Perm(P,q);
  hence thesis by A1;
end;

registration
  let V,P,p;
  cluster Perm(P,p) -> bijective;
  coherence
  proof
    defpred P[Element of HP-WFF] means Perm(P,$1) is bijective;
A1: for n holds P[prop n]
    proof
      let n;
      SetVal(V,prop n) = V.n & Perm(P,prop n) = P.n by Def2,Def5;
      hence thesis by Def4;
    end;
A2: for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
    proof
      let r,s;
      assume Perm(P,r) is bijective;
      then reconsider r9 = Perm(P,r) as Permutation of SetVal(V,r);
      assume Perm(P,s) is bijective;
      then reconsider s9 = Perm(P,s) as Permutation of SetVal(V,s);
      SetVal(V,r '&' s) = [:SetVal(V,r), SetVal(V,s):] & Perm(P,r '&' s) =
      [:r9,s9 :] by Def2,Th35;
      hence Perm(P,r '&' s) is bijective by Th25;
      SetVal(V,r => s) = Funcs(SetVal(V,r),SetVal(V,s)) & Perm(P,r => s) =
      r9 => s9 by Def2,Th36;
      hence thesis;
    end;
    Perm(P,VERUM) = id SetVal(V,VERUM) by Th33;
    then
A3: P[VERUM];
    for p holds P[p] from HILBERT2:sch 2(A3,A1,A2);
    hence thesis;
  end;
end;

theorem Th37:
  for g being Function of SetVal(V,p), SetVal(V,q) holds Perm(P,p
  => q).g = Perm(P,q)*g*Perm(P,p)"
proof
  let g be Function of SetVal(V,p), SetVal(V,q);
  thus Perm(P,p => q).g = (Perm(P,p) => Perm(P,q)).g by Th36
    .= Perm(P,q)*g*Perm(P,p)" by Def1;
end;

theorem Th38:
  for g being Function of SetVal(V,p), SetVal(V,q) holds Perm(P,p
  => q)".g = Perm(P,q)"*g*Perm(P,p)
proof
  let g be Function of SetVal(V,p), SetVal(V,q);
  thus Perm(P,p => q)".g = (Perm(P,p) => Perm(P,q))".g by Th36
    .= Perm(P,q)"*g*Perm(P,p) by Th26;
end;

theorem Th39:
  for f,g being Function of SetVal(V,p), SetVal(V,q) st f = Perm(P
  ,p => q).g holds Perm(P,q)*g = f*Perm(P,p)
proof
  let f,g be Function of SetVal(V,p), SetVal(V,q) such that
A1: f = Perm(P,p => q).g;
  thus Perm(P,q)*g = Perm(P,q)*g*(id SetVal(V,p)) by FUNCT_2:23
    .= Perm(P,q)*g*(Perm(P,p)"*Perm(P,p)) by FUNCT_2:88
    .= Perm(P,q)*g*Perm(P,p)"*Perm(P,p) by RELAT_1:55
    .= f*Perm(P,p) by A1,Th37;
end;

theorem Th40:
  for V for P being Permutation of V for x being set st x
is_a_fixpoint_of Perm(P,p) for f being Function st f is_a_fixpoint_of Perm(P,p
  => q) holds f.x is_a_fixpoint_of Perm(P,q)
proof
  let V;
  let P be Permutation of V;
  let x be set such that
A1: x is_a_fixpoint_of Perm(P,p);
  let f be Function such that
A2: f is_a_fixpoint_of Perm(P,p => q);
  dom Perm(P,p => q) = SetVal(V,p => q) by FUNCT_2:67
    .= Funcs(SetVal(V,p),SetVal(V,q)) by Def2;
  then f in Funcs(SetVal(V,p),SetVal(V,q)) by A2,ABIAN:def 3;
  then reconsider g = f as Function of SetVal(V,p), SetVal(V,q) by
  FUNCT_2:121;
  set h = Perm(P,p => q).f;
  h = Perm(P,q)*g*Perm(P,p)" by Th37;
  then reconsider h as Function of SetVal(V,p), SetVal(V,q);
A3: h = f by A2,ABIAN:def 3;
  dom Perm(P,p) = SetVal(V,p) by FUNCT_2:67;
  then
A4: x in SetVal(V,p) by A1,ABIAN:def 3;
  dom Perm(P,p => q) = SetVal(V,p => q) by FUNCT_2:67
    .= Funcs(SetVal(V,p),SetVal(V,q)) by Def2;
  then f in Funcs(SetVal(V,p),SetVal(V,q)) by A2,ABIAN:def 3;
  then f.x in SetVal(V,q) by A4,Th5;
  hence f.x in dom Perm(P,q) by FUNCT_2:67;
  thus Perm(P,q).(f.x) = (Perm(P,q)*g).x by A4,FUNCT_2:21
    .= (f*Perm(P,p)).x by A3,Th39
    .= f.(Perm(P,p).x) by A4,FUNCT_2:21
    .= f.x by A1,ABIAN:def 3;
end;

begin :: canonical formulae

definition
  let p;
  attr p is canonical means
  :Def7:
  for V ex x being set st for P being
  Permutation of V holds x is_a_fixpoint_of Perm(P,p);
end;

registration
  cluster VERUM -> canonical;
  coherence
  proof
    let V;
    take 0;
    let P be Permutation of V;
    SetVal(V,VERUM) = 1 & 0 in 1 by Def2,CARD_1:87,TARSKI:def 1;
    hence thesis by Th3,CARD_1:87;
  end;
end;

theorem Th41:
  p => (q => p) is canonical
proof
  let V;
  deffunc F(set)=SetVal(V,q) --> $1;
A1: for x being Element of SetVal(V,p) holds F(x) in SetVal(V,q => p)
  proof
    let x be Element of SetVal(V,p);
    SetVal(V,q) --> x in Funcs(SetVal(V,q),SetVal(V,p)) by FUNCT_2:11;
    hence thesis by Def2;
  end;
  consider f being Function of SetVal(V,p), SetVal(V,q => p) such that
A2: for x being Element of SetVal(V,p) holds f.x = F(x) from FUNCT_2:sch
  8(A1);
  take f;
  let P be Permutation of V;
  f in Funcs(SetVal(V,p),SetVal(V,q => p)) by FUNCT_2:11;
  then f in SetVal(V,p => (q => p)) by Def2;
  hence f in dom Perm(P,p => (q => p)) by FUNCT_2:def 1;
  now
    let x be Element of SetVal(V,p);
    reconsider g = SetVal(V,q)-->(Perm(P,p)".x) as Function of SetVal(V,q),
    SetVal(V,p);
    x in SetVal(V,p);
    then x in rng Perm(P,p) by FUNCT_2:def 3;
    then
A3: Perm(P,p)".x in dom Perm(P,p) by PARTFUN2:79;
    thus f.x = SetVal(V,q) --> x by A2
      .= (SetVal(V,q)-->(id SetVal(V,p)).x) by FUNCT_1:34
      .= (SetVal(V,q)-->((Perm(P,p)*Perm(P,p)").x)) by FUNCT_2:88
      .= (SetVal(V,q)-->(Perm(P,p).(Perm(P,p)".x))) by FUNCT_2:21
      .= Perm(P,p)*(SetVal(V,q)-->(Perm(P,p)".x)) by A3,FUNCOP_1:23
      .= Perm(P,p)*(Perm(P,q)""SetVal(V,q)-->(Perm(P,p)".x)) by FUNCT_2:48
      .= Perm(P,p)*(g*Perm(P,q)") by FUNCOP_1:25
      .= Perm(P,p)*g*Perm(P,q)" by RELAT_1:55
      .= Perm(P,q => p).g by Th37
      .= (Perm(P,q => p).(f.(Perm(P,p)".x))) by A2
      .= (Perm(P,q => p)*f).(Perm(P,p)".x) by FUNCT_2:21
      .= (Perm(P,q => p)*f*Perm(P,p)").x by FUNCT_2:21;
  end;
  hence f = Perm(P,q => p)*f*Perm(P,p)" by FUNCT_2:113
    .= Perm(P,p => (q => p)).f by Th37;
end;

theorem Th42:
  (p => (q => r)) => ((p => q) => (p => r)) is canonical
proof
  deffunc G(Function)=Frege $1;
  let V;
A1: SetVal(V,p => q) = Funcs(SetVal(V,p),SetVal(V,q)) & SetVal(V,p => r) =
  Funcs (SetVal(V,p),SetVal(V,r)) by Def2;
A2: for x being Element of SetVal(V,p => (q => r)) holds G(x) in SetVal(V,(p
  => q) => (p => r))
  proof
    let x be Element of SetVal(V,p => (q => r));
    x is Element of Funcs(SetVal(V,p),SetVal(V,q => r)) by Def2;
    then x is Element of Funcs(SetVal(V,p),Funcs(SetVal(V,q),SetVal(V,r))) by
    Def2;
    then Frege x is Function of SetVal(V,p => q),SetVal(V,p => r) by A1,
    Th24;
    then Frege x in Funcs(SetVal(V,p => q),SetVal(V,p => r)) by
    FUNCT_2:11;
    hence Frege x in SetVal(V,(p => q) => (p => r)) by Def2;
  end;
  consider F being Function of SetVal(V,p => (q => r)), SetVal(V,(p => q) => (
  p => r)) such that
A3: for x being Element of SetVal(V,p => (q => r)) holds F.x = G(x) from
  FUNCT_2:sch 8(A2);
  take F;
  let P be Permutation of V;
  F in Funcs(SetVal(V,p => (q => r)), SetVal(V,(p => q) => (p => r))) by
  FUNCT_2:11;
  then F in SetVal(V,(p => (q => r)) => ((p => q) => (p => r))) by Def2;
  hence F in dom Perm(P,(p => (q => r)) => ((p => q) => (p => r))) by
  FUNCT_2:def 1;
  now
    reconsider X = Perm(P,q => r)" as Function of SetVal(V,q => r), SetVal(V,q
    => r);
    let f be Element of SetVal(V,p => (q => r));
    set Yf = Perm(P,p => (q => r))".f;
A4: SetVal(V,q => r) =Funcs(SetVal(V,q),SetVal(V,r)) by Def2;
    f in SetVal(V,p => (q => r));
    then f in Funcs(SetVal(V,p),SetVal(V,q => r)) by Def2;
    then reconsider ff = f as Function of SetVal(V,p),SetVal(V,q => r) by
    FUNCT_2:121;
    Yf = Perm(P,q => r)"*ff*Perm(P,p) by Th38;
    then reconsider
    h = Frege Yf as Function-yielding Function of SetVal(V,p => q),
    SetVal(V,p => r) by A1,A4,Th24;
    set M = Perm(P,p => r)*h*Perm(P,p => q)";
A5: product doms ff = product(SetVal(V,p) --> SetVal(V,q)) by A4,Th6
      .= Funcs(SetVal(V,p),SetVal(V,q)) by CARD_3:20;
    then
A6: product doms ff = SetVal(V,p => q) by Def2;
    then reconsider M as ManySortedFunction of product doms f;
A7: for g be Function st g in product doms f holds M.g = f..g
    proof
      Yf in SetVal(V,p => (q => r));
      then Yf in Funcs(SetVal(V,p),SetVal(V,q => r)) by Def2;
      then Yf is Function of SetVal(V,p), Funcs(SetVal(V,q),SetVal(V,r)) by
      A4,FUNCT_2:121;
      then
A8:   product doms Yf = product(SetVal(V,p) --> SetVal(V,q)) by Th6
        .= Funcs(SetVal(V,p),SetVal(V,q)) by CARD_3:20
        .= SetVal(V,p => q) by Def2;
      reconsider FF = ff as Function of SetVal(V,p),Funcs(SetVal(V,q),SetVal(V
      ,r)) by Def2;
      let g be Function such that
A9:   g in product doms f;
      reconsider G = g as Function of SetVal(V,p),SetVal(V,q) by A5,A9,
      FUNCT_2:121;
      dom FF = SetVal(V,p) by FUNCT_2:def 1;
      then
A10:  dom(FF..G) = SetVal(V,p) by PRALG_1:def 17;
A11:  rng(FF..G) c= SetVal(V,r) by Th20;
      then reconsider
      GG = FF..G as Function of SetVal(V,p), SetVal(V,r) by A10,
      FUNCT_2:def 1,RELSET_1:11;
      FF..G is Function of SetVal(V,p),SetVal(V,r) by A10,A11,FUNCT_2:def
      1,RELSET_1:11;
      then FF..G in Funcs(SetVal(V,p),SetVal(V,r)) by FUNCT_2:11;
      then
A12:  FF..G in SetVal(V,p => r) by Def2;
      Perm(P,q)"*G*Perm(P,p) in Funcs(SetVal(V,p),SetVal(V,q)) by FUNCT_2
      :11;
      then
A13:  Perm(P,q)"*g*Perm(P,p) in product doms Yf by A8,Def2;
      then
A14:  Perm(P,p => q)".G in SetVal(V,p => q) by A8,Th38;
A15:  X = (Perm(P,q) => Perm(P,r))" by Th36
        .= Perm(P,q)" => (Perm(P,r)") by Th27;
A16:  h.(Perm(P,p => q)".g) = h.(Perm(P,q)"*G*Perm(P,p)) by Th38
        .= Yf..(Perm(P,q)"*g*Perm(P,p)) by A13,PRALG_2:def 8
        .= (X*ff*Perm(P,p))..(Perm(P,q)"*g*Perm(P,p)) by Th38
        .= (X*FF)..(Perm(P,q)"*g)*Perm(P,p) by Th18
        .= (Perm(P,r)"*(FF..G))*Perm(P,p) by A15,Th28
        .= Perm(P,p => r)".GG by Th38;
      thus M.g = (Perm(P,p => r)*h).(Perm(P,p => q)".g) by A6,A9,FUNCT_2:21
        .= Perm(P,p => r).(Perm(P,p => r)".GG) by A14,A16,FUNCT_2:21
        .= (Perm(P,p => r)*(Perm(P,p => r)")).GG by A12,FUNCT_2:21
        .= (id SetVal(V,p => r)).GG by FUNCT_2:88
        .= f..g by A12,FUNCT_1:35;
    end;
    thus F.f = Frege f by A3
      .= Perm(P,p => r)*h*Perm(P,p => q)" by A7,PRALG_2:def 8
      .= Perm(P,p => q => (p=>r)).h by Th37
      .= Perm(P,p => q => (p=>r)).(F.(Perm(P,p => (q=>r))".f)) by A3
      .= (Perm(P,p => q => (p=>r))*F).(Perm(P,p => (q=>r))".f) by FUNCT_2:21
      .= (Perm(P,(p => q) => (p => r))*F*Perm(P,p => (q => r))").f by
    FUNCT_2:21;
  end;
  hence F = Perm(P,(p => q) => (p => r))*F*Perm(P,p => (q => r))" by
  FUNCT_2:113
    .= Perm(P,(p => (q => r)) => ((p => q) => (p => r))).F by Th37;
end;

theorem Th43:
  (p '&' q) => p is canonical
proof
  let V;
  take f = pr1(SetVal(V,p),SetVal(V,q));
  let P be Permutation of V;
A1: dom Perm(P,(p '&' q) => p) = SetVal(V,(p '&' q) => p) by FUNCT_2:def 1
    .= Funcs(SetVal(V,p '&' q), SetVal(V,p)) by Def2
    .= Funcs([:SetVal(V,p), SetVal(V,q):], SetVal(V,p)) by Def2;
  hence f in dom Perm(P,(p '&' q) => p) by FUNCT_2:11;
  then f in Funcs(SetVal(V,p '&' q), SetVal(V,p)) by A1,Def2;
  then reconsider F = f as Function of SetVal(V,p '&' q), SetVal(V,p) by
  FUNCT_2
  :121;
  thus Perm(P,(p '&' q) => p).f = Perm(P,p)*F*Perm(P,p '&' q)" by Th37
    .= Perm(P,p)*F*[:Perm(P,p),Perm(P,q):]" by Th35
    .= Perm(P,p)*F*[:Perm(P,p)",Perm(P,q)":] by FUNCTOR0:7
    .= Perm(P,p)*(F*[:Perm(P,p)",Perm(P,q)":]) by RELAT_1:55
    .= Perm(P,p)*(Perm(P,p)"*F) by Th15
    .= Perm(P,p)*Perm(P,p)"*F by RELAT_1:55
    .= (id SetVal(V,p))*F by FUNCT_2:88
    .= f by FUNCT_2:23;
end;

theorem Th44:
  (p '&' q) => q is canonical
proof
  let V;
  take f = pr2(SetVal(V,p),SetVal(V,q));
  let P be Permutation of V;
A1: dom Perm(P,(p '&' q) => q) = SetVal(V,(p '&' q) => q) by FUNCT_2:def 1
    .= Funcs(SetVal(V,p '&' q), SetVal(V,q)) by Def2
    .= Funcs([:SetVal(V,p), SetVal(V,q):], SetVal(V,q)) by Def2;
  hence f in dom Perm(P,(p '&' q) => q) by FUNCT_2:11;
  then f in Funcs(SetVal(V,p '&' q), SetVal(V,q)) by A1,Def2;
  then reconsider F = f as Function of SetVal(V,p '&' q), SetVal(V,q) by
  FUNCT_2
  :121;
  thus Perm(P,(p '&' q) => q).f = Perm(P,q)*F*Perm(P,p '&' q)" by Th37
    .= Perm(P,q)*F*[:Perm(P,p),Perm(P,q):]" by Th35
    .= Perm(P,q)*F*[:Perm(P,p)",Perm(P,q)":] by FUNCTOR0:7
    .= Perm(P,q)*(F*[:Perm(P,p)",Perm(P,q)":]) by RELAT_1:55
    .= Perm(P,q)*(Perm(P,q)"*F) by Th16
    .= Perm(P,q)*Perm(P,q)"*F by RELAT_1:55
    .= (id SetVal(V,q))*F by FUNCT_2:88
    .= f by FUNCT_2:23;
end;

theorem Th45:
  p => (q => (p '&' q)) is canonical
proof
  let V;
  take f = curry [:id SetVal(V,p),id SetVal(V,q):];
  let P be Permutation of V;
  f is Function of SetVal(V,p), Funcs(SetVal(V,q),[:SetVal(V,p),SetVal(V,q
  ) :] ) by CAT_2:1;
  then
  f in Funcs(SetVal(V,p), Funcs(SetVal(V,q), [:SetVal(V,p), SetVal(V,q):])
  ) by FUNCT_2:11;
  then f in Funcs(SetVal(V,p), Funcs(SetVal(V,q), SetVal(V,p '&' q))) by
  Def2;
  then
A1: f in Funcs(SetVal(V,p), SetVal(V,q => (p '&' q))) by Def2;
  then reconsider
  F = f as Function of SetVal(V,p), SetVal(V,q => (p '&' q)) by
  FUNCT_2:121;
  f in SetVal(V,p => (q => (p '&' q))) by A1,Def2;
  hence f in dom Perm(P,p => (q => (p '&' q))) by FUNCT_2:def 1;
A2: now
    let x be Element of SetVal(V,p);
    set fx = f.x;
    F.x in SetVal(V,q => (p '&' q));
    then fx in Funcs(SetVal(V,q),SetVal(V,p '&' q)) by Def2;
    then reconsider fx as Function of SetVal(V,q), SetVal(V,p '&' q) by
    FUNCT_2
    :121;
    set Fx = F.(Perm(P,p)".x);
    Fx in SetVal(V,q => (p '&' q));
    then Fx in Funcs(SetVal(V,q),SetVal(V,p '&' q)) by Def2;
    then reconsider Fx as Function of SetVal(V,q), SetVal(V,p '&' q) by
    FUNCT_2:
    121;
    now
      let y be Element of SetVal(V,q);
      thus fx.y = [:id SetVal(V,p),id SetVal(V,q):].(x,y) by CAT_2:3
        .= [(id SetVal(V,p)).x,(id SetVal(V,q)).y] by FUNCT_3:96
        .= [(id SetVal(V,p)).x,(Perm(P,q)*Perm(P,q)").y] by FUNCT_2:88
        .= [(id SetVal(V,p)).x,Perm(P,q).(Perm(P,q)".y)] by FUNCT_2:21
        .= [(Perm(P,p)*Perm(P,p)").x,Perm(P,q).(Perm(P,q)".y)] by FUNCT_2:88
        .= [Perm(P,p).(Perm(P,p)".x),Perm(P,q).(Perm(P,q)".y)] by FUNCT_2:21
        .= [:Perm(P,p),Perm(P,q):].(Perm(P,p)".x,Perm(P,q)".y) by FUNCT_3:96
        .= Perm(P,p '&' q).[Perm(P,p)".x,Perm(P,q)".y] by Th35
        .= Perm(P,p '&' q).[Perm(P,p)".x,(id SetVal(V,q)).(Perm(P,q)".y)] by
      FUNCT_1:35
        .= Perm(P,p '&' q). [(id SetVal(V,p)).(Perm(P,p)".x),(id SetVal(V,q)
      ).(Perm(P,q)".y)] by FUNCT_1:35
        .= Perm(P,p '&' q).([:id SetVal(V,p),id SetVal(V,q):]. (Perm(P,p)".x
      ,Perm(P,q)".y)) by FUNCT_3:96
        .= Perm(P,p '&' q).(Fx.(Perm(P,q)".y)) by CAT_2:3
        .= (Perm(P,p '&' q)*Fx).(Perm(P,q)".y) by FUNCT_2:21
        .= (Perm(P,p '&' q)*Fx*Perm(P,q)").y by FUNCT_2:21;
    end;
    hence f.x = Perm(P,p '&' q)*Fx*Perm(P,q)" by FUNCT_2:113
      .= Perm(P,q => (p '&' q)).(F.(Perm(P,p)".x)) by Th37
      .= (Perm(P,q => (p '&' q))*F).(Perm(P,p)".x) by FUNCT_2:21
      .= (Perm(P,q => (p '&' q))*F*Perm(P,p)").x by FUNCT_2:21;
  end;
  thus Perm(P,p => (q => (p '&' q))).f = Perm(P,q => (p '&' q))*F*Perm(P,p)"
  by Th37
    .= f by A2,FUNCT_2:113;
end;

theorem Th46:
  p is canonical & p => q is canonical implies q is canonical
proof
  assume that
A1: p is canonical and
A2: p => q is canonical;
  let V;
  consider x being set such that
A3: for P being Permutation of V holds x is_a_fixpoint_of Perm(P,p) by
  A1,Def7;
  consider P being Permutation of V;
A4: dom Perm(P,p => q) = SetVal(V,p => q) by FUNCT_2:67
    .= Funcs(SetVal(V,p),SetVal(V,q)) by Def2;
  consider f being set such that
A5: for P being Permutation of V holds f is_a_fixpoint_of Perm(P,p => q)
  by A2,Def7;
  f is_a_fixpoint_of Perm(P,p => q) by A5;
  then f in Funcs(SetVal(V,p),SetVal(V,q)) by A4,ABIAN:def 3;
  then reconsider f as Function of SetVal(V,p), SetVal(V,q) by FUNCT_2:121;
  take f.x;
  let P be Permutation of V;
A6: f is_a_fixpoint_of Perm(P,p => q) by A5;
  x is_a_fixpoint_of Perm(P,p) by A3;
  hence thesis by A6,Th40;
end;

theorem
  p in HP_TAUT implies p is canonical
proof
  set X = {q: q is canonical};
  X c= HP-WFF
  proof
    let x be set;
    assume x in X;
    then ex p st p = x & p is canonical;
    hence thesis;
  end;
  then reconsider X as Subset of HP-WFF;
  X is Hilbert_theory
  proof
    thus VERUM in X;
    let p,q,r;
    p => (q => p) is canonical by Th41;
    hence p => (q => p) in X;
    (p => (q => r)) => ((p => q) => (p => r)) is canonical by Th42;
    hence (p => (q => r)) => ((p => q) => (p => r)) in X;
    (p '&' q) => p is canonical by Th43;
    hence (p '&' q) => p in X;
    (p '&' q) => q is canonical by Th44;
    hence (p '&' q) => q in X;
    p => (q => (p '&' q)) is canonical by Th45;
    hence p => (q => (p '&' q)) in X;
    assume p in X;
    then
A1: ex s st s = p & s is canonical;
    assume p => q in X;
    then ex s st s = p => q & s is canonical;
    then q is canonical by A1,Th46;
    hence thesis;
  end;
  then
A2: HP_TAUT c= X by HILBERT1:13;
  assume p in HP_TAUT;
  then p in X by A2;
  then ex q st p = q & q is canonical;
  hence thesis;
end;

registration
  cluster canonical Element of HP-WFF;
  existence
  proof
    take VERUM;
    thus thesis;
  end;
end;

begin :: pseudo-canonical formulae

definition
  let p;
  attr p is pseudo-canonical means
  :Def8:
  for V for P being Permutation of V
  ex x being set st x is_a_fixpoint_of Perm(P,p);
end;

registration
  cluster canonical -> pseudo-canonical Element of HP-WFF;
  coherence
  proof
    let p;
    assume
A1: p is canonical;
    let V;
    consider x being set such that
A2: for P being Permutation of V holds x is_a_fixpoint_of Perm(P,p) by
    A1,Def7;
    let P be Permutation of V;
    take x;
    thus thesis by A2;
  end;
end;

theorem
  p => (q => p) is pseudo-canonical
proof
  reconsider s = p => (q => p) as canonical Element of HP-WFF by Th41;
  s is pseudo-canonical;
  hence thesis;
end;

theorem
  (p => (q => r)) => ((p => q) => (p => r)) is pseudo-canonical
proof
  reconsider s = (p => (q => r)) => ((p => q) => (p => r)) as canonical
  Element of HP-WFF by Th42;
  s is pseudo-canonical;
  hence thesis;
end;

theorem
  (p '&' q) => p is pseudo-canonical
proof
  reconsider s = (p '&' q) => p as canonical Element of HP-WFF by Th43;
  s is pseudo-canonical;
  hence thesis;
end;

theorem
  (p '&' q) => q is pseudo-canonical
proof
  reconsider s = (p '&' q) => q as canonical Element of HP-WFF by Th44;
  s is pseudo-canonical;
  hence thesis;
end;

theorem
  p => (q => (p '&' q)) is pseudo-canonical
proof
  reconsider s = p => (q => (p '&' q)) as canonical Element of HP-WFF by Th45;
  s is pseudo-canonical;
  hence thesis;
end;

theorem
  p is pseudo-canonical & p => q is pseudo-canonical implies q is
  pseudo-canonical
proof
  assume that
A1: p is pseudo-canonical and
A2: p => q is pseudo-canonical;
  let V;
  let P be Permutation of V;
  consider x being set such that
A3: x is_a_fixpoint_of Perm(P,p) by A1,Def8;
  consider f being set such that
A4: f is_a_fixpoint_of Perm(P,p => q) by A2,Def8;
  dom Perm(P,p => q) = SetVal(V,p => q) by FUNCT_2:67
    .= Funcs(SetVal(V,p),SetVal(V,q)) by Def2;
  then f in Funcs(SetVal(V,p),SetVal(V,q)) by A4,ABIAN:def 3;
  then reconsider f as Function of SetVal(V,p), SetVal(V,q) by FUNCT_2:121;
  take f.x;
  thus thesis by A3,A4,Th40;
end;

theorem Th54:
  for p,q for V for P being Permutation of V st (ex f being set st
f is_a_fixpoint_of Perm(P,p)) & not (ex f being set st f is_a_fixpoint_of Perm(
  P,q)) holds p => q is not pseudo-canonical
proof
  let p,q;
  let V;
  let P be Permutation of V;
  given x being set such that
A1: x is_a_fixpoint_of Perm(P,p);
  assume
A2: for x being set holds not x is_a_fixpoint_of Perm(P,q);
  assume p => q is pseudo-canonical;
  then consider f being set such that
A3: f is_a_fixpoint_of Perm(P,p => q) by Def8;
  f in dom Perm(P,p => q) by A3,ABIAN:def 3;
  then f in SetVal(V,p => q) by FUNCT_2:def 1;
  then reconsider f as Function;
  f.x is_a_fixpoint_of Perm(P,q) by A1,A3,Th40;
  hence contradiction by A2;
end;

theorem
  (prop 0) => (prop 1) => (prop 0) => prop 0 is not pseudo-canonical
proof
  set A = { (0,1) -->(i,j) where i,j is Element of INT: i < j or i is even & i
  = j}, X = product ((0,1) --> (INT,INT));
  A c= X
  proof
    let x be set;
    assume x in A;
    then ex i,j being Element of INT st x = (0,1) -->(i,j) &( i < j or i is
    even & i = j);
    hence thesis by Th11;
  end;
  then reconsider A as Subset of X;
  set p1 = (0,1) --> (1,0);
A1: not 1 in dom(0 .--> 2) by FUNCOP_1:90;
A2: dom p1 = 2 by CARD_1:88,FUNCT_4:65;
A3: p1 is one-to-one
  proof
    let x1,x2 be set;
    assume that
A4: x1 in dom p1 and
A5: x2 in dom p1;
A6: x2 = 0 or x2 = 1 by A2,A5,CARD_1:88,TARSKI:def 2;
A7: p1.0 = 1 by FUNCT_4:66;
    x1 = 0 or x1 = 1 by A2,A4,CARD_1:88,TARSKI:def 2;
    hence thesis by A6,A7,FUNCT_4:66;
  end;
A8: rng p1 = 2 by CARD_1:88,FUNCT_4:67;
  then p1 is Function of 2,2 by A2,FUNCT_2:def 1,RELSET_1:11;
  then reconsider p1 as Permutation of 2 by A8,A3,FUNCT_2:83;
  defpred P[set,set] means ex i being Integer st $1 = i & $2 = i+1;
  set V = (NAT --> INT) +* (0 .--> 2);
  dom V = dom(NAT --> INT) \/ dom(0 .--> 2) by FUNCT_4:def 1
    .= dom(NAT --> INT) \/ {0} by FUNCOP_1:19
    .= NAT \/ {0} by FUNCOP_1:19
    .= NAT by ZFMISC_1:46;
  then reconsider V as ManySortedSet of NAT by PARTFUN1:def 4;
  reconsider V as SetValuation;
A9: 0 in dom(0 .--> 2) by FUNCOP_1:89;
A10: 2 = (0 .--> 2).0 by FUNCOP_1:87
    .= V.0 by A9,FUNCT_4:14
    .= SetVal(V,prop 0) by Def2;
A11: for e being Element of INT holds ex u being Element of INT st P[e,u]
  proof
    let e be Element of INT;
    reconsider e as Integer;
    reconsider u = e+1 as Element of INT by INT_1:def 2;
    take u;
    thus thesis;
  end;
  consider p0 being Function of INT, INT such that
A12: for e being Element of INT holds P[e,p0.e] from FUNCT_2:sch 3(A11);
A13: dom p0 = INT by FUNCT_2:def 1;
  for y being set holds y in INT iff ex x being set st x in dom p0 & y = p0.x
  proof
    let y be set;
    hereby
      assume y in INT;
      then reconsider i = y as Integer;
      reconsider x = i-1 as set;
      take x;
      thus x in dom p0 by A13,INT_1:def 2;
      then ex j being Integer st x = j & p0.x = j+1 by A12,A13;
      hence y = p0.x by XCMPLX_1:27;
    end;
    given x being set such that
A14: x in dom p0 and
A15: y = p0.x;
    ex i being Integer st x = i & p0.x = i + 1 by A12,A13,A14;
    hence thesis by A15,INT_1:def 2;
  end;
  then
A16: rng p0 = INT by FUNCT_1:def 5;
A17: p0 is one-to-one
  proof
    let x1,x2 be set;
    assume x1 in dom p0 & x2 in dom p0;
    then reconsider I1 = x1, I2 = x2 as Element of INT by FUNCT_2:def 1;
    assume
A18: p0.x1 = p0.x2;
    (ex i1 being Integer st I1 = i1 & p0.I1 = i1 + 1 )& ex i2 being
    Integer st I2 = i2 & p0.I2 = i2 + 1 by A12;
    hence thesis by A18,XCMPLX_1:2;
  end;
A19: SetVal(V,prop 1) = V.1 by Def2
    .= (NAT --> INT).1 by A1,FUNCT_4:12
    .= INT by FUNCOP_1:13;
A20: X = product(2 --> INT) by CARD_1:88,FUNCT_4:68
    .= Funcs(2,INT) by CARD_3:20
    .= SetVal(V,(prop 0) => prop 1) by A10,A19,Def2;
  then reconsider
  f = chi(A,X) as Function of SetVal(V,(prop 0) => prop 1), SetVal(
  V,prop 0) by A10,CARD_1:88;
A21: 0 in dom(0 .--> p1) by FUNCOP_1:89;
  reconsider p0 as Permutation of INT by A17,A16,FUNCT_2:83;
  set P = (NAT --> p0) +* (0 .--> p1);
A22: dom P = dom(NAT --> p0) \/ dom(0 .--> p1) by FUNCT_4:def 1
    .= dom(NAT --> p0) \/ {0} by FUNCOP_1:19
    .= NAT \/ {0} by FUNCOP_1:19
    .= NAT by ZFMISC_1:46;
  for n holds P.n is Permutation of V.n
  proof
    let n;
    per cases;
    suppose
A23:  n = 0;
      then n in dom(0 .--> 2) by FUNCOP_1:89;
      then
A24:  V.n = (0 .--> 2).0 by A23,FUNCT_4:14
        .= 2 by FUNCOP_1:87;
      n in dom(0 .--> p1) by A23,FUNCOP_1:89;
      then P.n = (0 .--> p1).0 by A23,FUNCT_4:14
        .= p1 by FUNCOP_1:87;
      hence thesis by A24;
    end;
    suppose
A25:  n <> 0;
      then not n in dom(0 .--> 2) by FUNCOP_1:90;
      then
A26:  V.n = (NAT --> INT).n by FUNCT_4:12
        .= INT by FUNCOP_1:13;
      not n in dom(0 .--> p1) by A25,FUNCOP_1:90;
      then P.n = (NAT --> p0).n by FUNCT_4:12
        .= p0 by FUNCOP_1:13;
      hence thesis by A26;
    end;
  end;
  then reconsider P as Permutation of V by A22,Def4;
A27: Perm(P,prop 0) = P.0 by Def5
    .= (0 .--> p1).0 by A21,FUNCT_4:14
    .= p1 by FUNCOP_1:87;
A28: f is_a_fixpoint_of Perm(P,(prop 0) => (prop 1) => prop 0)
  proof
    set Q = Perm(P,(prop 0) => (prop 1) => prop 0);
    f in Funcs(SetVal(V,(prop 0) => prop 1),SetVal(V,prop 0)) by FUNCT_2:
    11;
    then f in SetVal(V,(prop 0) => (prop 1) => prop 0) by Def2;
    hence f in dom Q by FUNCT_2:def 1;
    rng(Perm(P,(prop 0) => prop 1)") = dom(Perm(P,(prop 0) => prop 1)"")
    by FUNCT_1:54
      .= X by A20,FUNCT_2:def 1
      .= dom f by FUNCT_2:def 1;
    then
A29: dom(f*Perm(P,(prop 0) => prop 1)") = dom(Perm(P,(prop 0) => prop 1)")
    by RELAT_1:46
      .= rng Perm(P,(prop 0) => prop 1) by FUNCT_1:54
      .= X by A20,FUNCT_2:def 3
      .= dom chi(A`,X) by FUNCT_3:def 3;
    for x being set st x in dom chi(A`,X) holds (f*Perm(P,(prop 0) =>
    prop 1)").x = chi(A`,X).x
    proof
A30:  dom(p0") = INT by A16,FUNCT_1:54;
      let x be set;
A31:  not 1 in dom(0 .--> p1) by FUNCOP_1:90;
      assume
A32:  x in dom chi(A`,X);
      then x in X by FUNCT_3:def 3;
      then x in Funcs(SetVal(V,prop 0),SetVal(V,prop 1)) by A20,Def2;
      then reconsider
      g = x as Function of SetVal(V,prop 0), SetVal(V,prop 1) by
      FUNCT_2:121;
      consider i0,j0 being Element of INT such that
A33:  g = (0,1) --> (i0,j0) by A10,A19,Th12;
      reconsider i0, j0 as Integer;
A34:  j0-1 in dom p0 by A13,INT_1:def 2;
      then ex i being Integer st j0-1 = i & p0.(j0-1) = i+1 by A12,A13;
      then
A35:  p0.(j0-1) = j0 by XCMPLX_1:27;
A36:  i0-1 in dom p0 by A13,INT_1:def 2;
      then ex i being Integer st i0-1 = i & p0.(i0-1) = i+1 by A12,A13;
      then p0.(i0-1) = i0 by XCMPLX_1:27;
      then
A37:  p0".i0 = i0-1 by A36,FUNCT_1:56;
      Perm(P,prop 1) = P.1 by Def5
        .= (NAT --> p0).1 by A31,FUNCT_4:12
        .= p0 by FUNCOP_1:13;
      then
A38:  Perm(P,prop 1)"*g = (0,1) --> (p0".i0,p0".j0) by A33,A30,Th14
        .= (0,1) --> (i0-1,j0-1) by A37,A34,A35,FUNCT_1:56;
A39:  (f*Perm(P,(prop 0) => prop 1)").x = f.((Perm(P,(prop 0) => prop 1)"
      ).x) by A29,A32,FUNCT_1:22
        .= f.(Perm(P,prop 1)"*g*Perm(P,prop 0)) by Th38
        .= f.((0,1) --> (j0-1,i0-1)) by A27,A38,Th13;
      per cases;
      suppose
A40:    x in A;
        then consider i,j being Element of INT such that
A41:    x = (0,1) -->(i,j) and
A42:    i < j or i is even & i = j;
A43:    i = i0 & j = j0 by A33,A41,Th10;
A44:    now
          assume (0,1) --> (j0-1,i0-1) in A;
          then consider i,j being Element of INT such that
A45:      (0,1) --> (j0-1,i0-1) = (0,1) --> (i,j) and
A46:      i < j or i is even & i = j;
A47:      i = j0-1 & j = i0-1 by A45,Th10;
          per cases by A46;
          suppose
            i < j;
            hence contradiction by A42,A43,A47,XREAL_1:11;
          end;
          suppose
            i is even & i = j;
            hence contradiction by A42,A43,A47,XCMPLX_1:19;
          end;
        end;
A48:    x in A`` by A40;
        j0-1 in INT & i0-1 in INT by INT_1:def 2;
        then (0,1) --> (j0-1,i0-1) in X by Th11;
        then (0,1) --> (j0-1,i0-1) in X \ A by A44,XBOOLE_0:def 5;
        hence (f*Perm(P,(prop 0) => prop 1)").x = 0 by A39,FUNCT_3:43
          .= chi(A`,X).x by A48,FUNCT_3:43;
      end;
      suppose
A49:    not x in A;
        x in X by A33,Th11;
        then
A50:    x in X \ A by A49,XBOOLE_0:def 5;
A51:    j0-1 is Element of INT by INT_1:def 2;
A52:    i0 is odd or i0 <> j0 by A33,A49;
A53:    i0-1 is Element of INT by INT_1:def 2;
A54:    i0 >= j0 by A33,A49;
        now
          per cases by A54,A52,XXREAL_0:1;
          suppose
            i0 > j0;
            then j0-1 < i0-1 by XREAL_1:11;
            hence (0,1) --> (j0-1,i0-1) in A by A51,A53;
          end;
          suppose
            i0 = j0 & i0 is odd;
            hence (0,1) --> (j0-1,i0-1) in A by A51;
          end;
        end;
        hence (f*Perm(P,(prop 0) => prop 1)").x = 1 by A39,FUNCT_3:def 3
          .= chi(A`,X).x by A50,FUNCT_3:def 3;
      end;
    end;
    then f*Perm(P,(prop 0) => prop 1)" = chi(A`,X) by A29,FUNCT_1:9;
    hence f = Perm(P,prop 0)*(f*Perm(P,(prop 0) => prop 1)") by A27,Th9
      .= Perm(P,prop 0)*f*Perm(P,(prop 0) => prop 1)" by RELAT_1:55
      .= Q.f by Th37;
  end;
  for x being set holds not x is_a_fixpoint_of Perm(P,prop 0)
  proof
    let x be set;
    0 in dom(0 .--> 2) by FUNCOP_1:89;
    then V.0 = (0 .--> 2).0 by FUNCT_4:14;
    then
A55: V.0 = 2 by FUNCOP_1:87;
    assume x in dom Perm(P,prop 0);
    then x in SetVal(V,prop 0) by FUNCT_2:def 1;
    then x in V.0 by Def2;
    then x = 0 or x = 1 by A55,CARD_1:88,TARSKI:def 2;
    hence thesis by A27,FUNCT_4:66;
  end;
  hence thesis by A28,Th54;
end;
