:: Product of Families of Groups and Vector Spaces
::  by Anna Lango and Grzegorz Bancerek
::
:: Received December 29, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies RLVECT_1, ALGSTR_0, XBOOLE_0, STRUCT_0, VECTSP_1, SUPINF_2,
      BINOP_1, SUBSET_1, FUNCT_1, ARYTM_3, FINSEQOP, ARYTM_1, RELAT_1, GROUP_1,
      NAT_1, FINSEQ_2, CARD_3, FUNCOP_1, SETWISEO, ZFMISC_1, PARTFUN1, TARSKI,
      FINSEQ_1, MESFUNC1, MCART_1, FUNCT_6, GROUP_2, NUMBERS, PRVECT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, CARD_3,
      RELAT_1, FUNCT_1, STRUCT_0, ALGSTR_0, PARTFUN1, FUNCT_2, FUNCT_3,
      BINOP_1, FUNCOP_1, RLVECT_1, GROUP_1, VECTSP_1, FINSEQOP, FINSEQ_1,
      FUNCT_6, SETWISEO, FINSEQ_2;
 constructors PARTFUN1, BINOP_1, FUNCT_3, SETWISEO, FUNCT_5, CARD_3, FINSEQOP,
      FUNCT_6, VECTSP_1, RLVECT_1, RELSET_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2, FINSEQ_1,
      FINSEQ_2, CARD_3, STRUCT_0, VECTSP_1, RELSET_1;
 requirements BOOLE, SUBSET;
 definitions TARSKI, BINOP_1, FINSEQOP, VECTSP_1, STRUCT_0, RELAT_1, RLVECT_1,
      ALGSTR_0;
 theorems BINOP_1, FUNCT_1, FUNCT_2, FUNCT_3, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQOP, FUNCOP_1, VECTSP_1, ZFMISC_1, SETWISEO, TARSKI, CARD_3,
      FUNCT_6, RLVECT_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, FVSUM_1,
      GROUP_1;
 schemes FUNCT_1, BINOP_1, FUNCT_2, FINSEQ_1, CLASSES1;

begin :: Abelian Groups and Fields

reserve G for Abelian add-associative right_complementable right_zeroed (non
  empty addLoopStr);

deffunc car(1-sorted) = the carrier of $1;
deffunc ad(addLoopStr) = the addF of $1;
deffunc cc(non empty addLoopStr) = comp $1;
deffunc zr(addLoopStr) = 0.$1;

canceled 2;

theorem Th3:
  0.G is_a_unity_wrt the addF of G
proof
  now
    let x be Element of G;
    thus (the addF of G).(0.G,x)=0.G + x .= x by RLVECT_1:10;
    thus (the addF of G).(x,0.G)= x + 0.G .= x by RLVECT_1:10;
  end;
  hence thesis by BINOP_1:11;
end;

theorem Th4:
  for G being AbGroup holds comp G is_an_inverseOp_wrt the addF of G
proof
  let G be AbGroup;
A1: 0.G is_a_unity_wrt the addF of G by Th3;
  now
    let x be Element of G;
    thus (the addF of G).(x,(comp G).x)= x+(-x) by VECTSP_1:def 25
      .= 0.G by RLVECT_1:16
      .= the_unity_wrt the addF of G by A1,BINOP_1:def 8;
    thus (the addF of G).((comp G).x,x)=((comp G).x)+x
      .= x+(-x) by VECTSP_1:def 25
      .= 0.G by RLVECT_1:16
      .= the_unity_wrt the addF of G by A1,BINOP_1:def 8;
  end;
  hence thesis by FINSEQOP:def 1;
end;

Lm1: comp G is_an_inverseOp_wrt the addF of G
proof
A1: 0.G is_a_unity_wrt the addF of G by Th3;
  now
    let x be Element of G;
    thus (the addF of G).(x,(comp G).x)= x+(-x) by VECTSP_1:def 25
      .= 0.G by RLVECT_1:16
      .= the_unity_wrt the addF of G by A1,BINOP_1:def 8;
    thus (the addF of G).((comp G).x,x)=((comp G).x)+x
      .= x+(-x) by VECTSP_1:def 25
      .= 0.G by RLVECT_1:16
      .= the_unity_wrt the addF of G by A1,BINOP_1:def 8;
  end;
  hence thesis by FINSEQOP:def 1;
end;

reserve GS for non empty addLoopStr;

theorem
  the addF of GS is commutative associative & 0.GS is_a_unity_wrt the
  addF of GS & comp GS is_an_inverseOp_wrt the addF of GS implies GS is AbGroup
proof
  assume that
A1: the addF of GS is commutative & the addF of GS is associative and
A2: 0.GS is_a_unity_wrt the addF of GS and
A3: comp GS is_an_inverseOp_wrt the addF of GS;
A4: GS is right_complementable
  proof
    let x be Element of GS;
    reconsider b = (comp GS).x as Element of GS;
    take b;
    thus x+b = the_unity_wrt the addF of GS by A3,FINSEQOP:def 1
      .= (0.GS) by A2,BINOP_1:def 8;
  end;
  for x,y,z being Element of GS holds x+y = y+x & (x+y)+z = x+(y+z) & x+(
  0.GS) = x by A1,A2,BINOP_1:11,def 2,def 3;
  hence thesis by A4,RLVECT_1:def 5,def 6,def 7;
end;

Lm2: the addF of GS is commutative associative implies GS is Abelian
add-associative
proof
  assume that
A1: the addF of GS is commutative and
A2: the addF of GS is associative;
  thus GS is Abelian
  proof
    let x,y be Element of GS;
    thus thesis by A1,BINOP_1:def 2;
  end;
  let x,y,z be Element of GS;
  thus thesis by A2,BINOP_1:def 3;
end;

Lm3: 0.GS is_a_unity_wrt the addF of GS implies GS is right_zeroed
proof
  assume
A1: 0.GS is_a_unity_wrt the addF of GS;
  let x be Element of GS;
  thus thesis by A1,BINOP_1:11;
end;

reserve F for Field;

Lm4: the multF of F is associative
proof
  let x,y,z be Element of F;
  thus (the multF of F).(x,(the multF of F).(y,z)) = x*(y*z)
    .= (x*y)*z by GROUP_1:def 4
    .= (the multF of F).((the multF of F).(x,y),z);
end;

canceled 4;

theorem
  0.F is_a_unity_wrt the addF of F
proof
  now
    let x be Element of F;
    thus (the addF of F).(0.F,x) = x+(0.F) by RLVECT_1:5
      .= x by RLVECT_1:10;
    thus (the addF of F).(x,0.F) = x+(0.F) .= x by RLVECT_1:10;
  end;
  hence thesis by BINOP_1:11;
end;

theorem Th11:
  1_F is_a_unity_wrt the multF of F
proof
  now
    let x be Element of F;
    thus (the multF of F).(1_F,x) = (1_F)*x .= x by VECTSP_1:def 19;
    thus (the multF of F).(x,1_F) = x*(1_F) .= x by VECTSP_1:def 19;
  end;
  hence thesis by BINOP_1:11;
end;

Lm5: the multF of F is_distributive_wrt the addF of F
proof
  now
    let x,y,z be Element of F;
    thus (the multF of F).(x,(the addF of F).(y,z)) = x*(y + z)
      .= x*y + x*z by VECTSP_1:def 18
      .= (the addF of F).((the multF of F).(x,y),(the multF of F).(x,z));
    thus (the multF of F).((the addF of F).(x,y),z) = (x + y)*z
      .= x*z + y*z by VECTSP_1:def 18
      .= (the addF of F).((the multF of F).(x,z),(the multF of F).(y,z));
  end;
  hence thesis by BINOP_1:23;
end;

begin :: The $n$-Product of a Binary and Unary Operation

reserve F for Field,
  n for Nat,
  D for non empty set,
  d for Element of D,
  B for BinOp of D,
  C for UnOp of D;

definition
  let D,n;
  let F be BinOp of D;
  let x,y be Element of n-tuples_on D;
  redefine func F.:(x,y) -> Element of n-tuples_on D;
  coherence by FINSEQ_2:140;
end;

definition
  let D be non empty set;
  let F be BinOp of D;
  let n be Nat;
  func product(F,n) -> BinOp of n-tuples_on D means
  :Def1:
  for x,y being Element of n-tuples_on D holds it.(x,y)=F.:(x,y);
  existence
  proof
    defpred P[set,set,set] means ex x9,y9 be Element of n-tuples_on D st $1=x9
    & $2=y9 & $3=F.:(x9,y9);
A1: for x,y being Element of (n-tuples_on D) qua non empty set ex z being
    Element of (n-tuples_on D) qua non empty set st P[x,y,z]
    proof
      let x,y be Element of (n-tuples_on D) qua non empty set;
      reconsider x9=x,y9=y as Element of n-tuples_on D;
      reconsider z = F.:(x9,y9) as Element of (n-tuples_on D) qua non empty
      set;
      take z;
      take x9,y9;
      thus thesis;
    end;
    consider G being BinOp of n-tuples_on D such that
A2: for x,y being Element of (n-tuples_on D) qua non empty set holds P
    [x,y,G.(x,y)] from BINOP_1:sch 3(A1);
    take G;
    let p1,p2 be Element of n-tuples_on D;
    reconsider x=p1,y=p2 as Element of (n-tuples_on D) qua non empty set;
    ex x9,y9 being Element of n-tuples_on D st x=x9 & y=y9 & G.(x,y)=F.:(
    x9,y9) by A2;
    hence thesis;
  end;
  uniqueness
  proof
    let G,H be BinOp of n-tuples_on D;
    assume that
A3: for x,y being Element of n-tuples_on D holds G.(x,y)=F.:(x,y) and
A4: for x,y being Element of n-tuples_on D holds H.(x,y)=F.:(x,y);
    now
      let x,y be Element of n-tuples_on D;
      G.(x,y)=F.:(x,y) by A3;
      hence G.(x,y)=H.(x,y) by A4;
    end;
    hence G=H by BINOP_1:2;
  end;
end;

definition
  let D;
  let F be UnOp of D;
  let n;
  func product(F,n) -> UnOp of n-tuples_on D means
  :Def2:
  for x being Element of n-tuples_on D holds it.x=F*x;
  existence
  proof
    defpred P[set,set] means ex x9 being Element of n-tuples_on D st x9=$1 &
    $2=F*x9;
A1: for x being Element of (n-tuples_on D) qua non empty set ex y being
    Element of (n-tuples_on D) qua non empty set st P[x,y]
    proof
      let x be Element of (n-tuples_on D) qua non empty set;
      reconsider x9=x as Element of n-tuples_on D;
      reconsider y=F*x9 as Element of (n-tuples_on D) qua non empty set by
FINSEQ_2:133;
      take y, x9;
      thus thesis;
    end;
    consider G being UnOp of n-tuples_on D such that
A2: for x being Element of (n-tuples_on D) qua non empty set holds P[x
    ,G.x] from FUNCT_2:sch 3(A1);
    take G;
    let p1 be Element of n-tuples_on D;
    reconsider x=p1 as Element of (n-tuples_on D) qua non empty set;
    ex x9 being Element of n-tuples_on D st x9=x & G.x=F*x9 by A2;
    hence thesis;
  end;
  uniqueness
  proof
    let G,H be UnOp of n-tuples_on D;
    assume that
A3: for x being Element of n-tuples_on D holds G.x=F*x and
A4: for x being Element of n-tuples_on D holds H.x=F*x;
    now
      let x be Element of n-tuples_on D;
      G.x=F*x by A3;
      hence G.x=H.x by A4;
    end;
    hence thesis by FUNCT_2:113;
  end;
end;

definition
  let D be non empty set;
  let n;
  let x be Element of D;
  redefine func n |-> x -> Element of n-tuples_on D;
  correctness by FINSEQ_2:132;
end;

canceled 2;

theorem Th14:
  B is commutative implies product(B,n) is commutative
proof
  assume
A1: B is commutative;
  now
    let x,y be Element of n-tuples_on D;
    thus product(B,n).(x,y) = B.:(x,y) by Def1
      .= B.:(y,x) by A1,FINSEQOP:34
      .= product(B,n).(y,x) by Def1;
  end;
  hence thesis by BINOP_1:def 2;
end;

theorem Th15:
  B is associative implies product(B,n) is associative
proof
  assume
A1: B is associative;
  now
    let x,y,z be Element of n-tuples_on D;
    thus product(B,n).(product(B,n).(x,y),z) = product(B,n).(B.:(x,y),z) by
Def1
      .= B.:(B.:(x,y),z) by Def1
      .= B.:(x,B.:(y,z)) by A1,FINSEQOP:29
      .= product(B,n).(x,B.:(y,z)) by Def1
      .= product(B,n).(x,product(B,n).(y,z)) by Def1;
  end;
  hence thesis by BINOP_1:def 3;
end;

theorem Th16:
  d is_a_unity_wrt B implies n |-> d is_a_unity_wrt product(B,n)
proof
  assume d is_a_unity_wrt B;
  then
A1: B is having_a_unity & d = the_unity_wrt B by BINOP_1:def 8,SETWISEO:def 2;
  now
    let b be Element of (n-tuples_on D) qua non empty set;
    reconsider b9 = b as Element of n-tuples_on D;
    thus product(B,n).(n |-> d,b) = B.:(n |-> d,b9) by Def1
      .= b by A1,FINSEQOP:57;
    thus product(B,n).(b,n |-> d) = B.:(b9,n |-> d) by Def1
      .= b by A1,FINSEQOP:57;
  end;
  hence thesis by BINOP_1:11;
end;

theorem Th17:
  B is having_a_unity & B is associative & C is_an_inverseOp_wrt B
  implies product(C,n) is_an_inverseOp_wrt product(B,n)
proof
  assume that
A1: B is having_a_unity and
A2: B is associative and
A3: C is_an_inverseOp_wrt B;
A4: B is having_an_inverseOp by A3,FINSEQOP:def 2;
  then
A5: C = the_inverseOp_wrt B by A1,A2,A3,FINSEQOP:def 3;
A6: now
    let f be Element of (n-tuples_on D) qua non empty set;
    reconsider f9 = f as Element of n-tuples_on D;
    reconsider cf = C*f9 as Element of n-tuples_on D by FINSEQ_2:133;
    thus product(B,n).(f,product(C,n).f) = product(B,n).(f9,C*f9) by Def2
      .= B.:(f9,cf) by Def1
      .= n |->the_unity_wrt B by A1,A2,A4,A5,FINSEQOP:77;
    thus product(B,n).(product(C,n).f,f) = product(B,n).(C*f9,f9) by Def2
      .= B.:(cf,f9) by Def1
      .= n |->the_unity_wrt B by A1,A2,A4,A5,FINSEQOP:77;
  end;
  ex d st d is_a_unity_wrt B by A1,SETWISEO:def 2;
  then the_unity_wrt B is_a_unity_wrt B by BINOP_1:def 8;
  then n |->the_unity_wrt B is_a_unity_wrt product(B,n) by Th16;
  then n |->the_unity_wrt B = the_unity_wrt product(B,n) by BINOP_1:def 8;
  hence thesis by A6,FINSEQOP:def 1;
end;

begin :: The $n$-Power of a Group and of a Field

definition
  let F be non empty addLoopStr, n;
  assume
A1: F is Abelian add-associative right_zeroed right_complementable;
  func n -Group_over F -> strict AbGroup equals
  :Def3:
  addLoopStr(# n
-tuples_on the carrier of F, product(the addF of F,n), (n |-> 0.F) qua Element
    of n-tuples_on the carrier of F#);
  coherence
  proof
    set G = addLoopStr(# n-tuples_on the carrier of F,product(the addF of F,n)
      , (n |-> 0.F) qua Element of n-tuples_on the carrier of F#);
    reconsider G as non empty addLoopStr;
    the addF of F is commutative associative by A1,FVSUM_1:2,3;
    then
A2: product(the addF of F,n) is commutative associative by Th14,Th15;
A3: 0.F is_a_unity_wrt the addF of F by A1,Th3;
A4: G is right_complementable
    proof
      set B = the addF of F;
      set C = comp F;
      let x be Element of G;
      reconsider y = (product (comp F,n)).x as Element of G by FUNCT_2:7;
      take y;
      B is associative & B is having_a_unity by A1,A3,FVSUM_1:3,SETWISEO:def 2;
      then product(C,n) is_an_inverseOp_wrt product(B,n) by A1,Lm1,Th17;
      then
A5:   x + y = the_unity_wrt product(B,n) by FINSEQOP:def 1;
      0.G is_a_unity_wrt the addF of G by A1,Th3,Th16;
      hence thesis by A5,BINOP_1:def 8;
    end;
    0.G = (n |-> 0.F) & (n |-> 0.F) qua Element of n-tuples_on the
    carrier of F is_a_unity_wrt product(the addF of F,n) by A1,Th3,Th16;
    hence thesis by A2,A4,Lm2,Lm3;
  end;
end;

registration
  let F be AbGroup, n;
  cluster n-Group_over F -> non empty;
  coherence;
end;

reserve x,y for set;

definition
  let F,n;
  func n -Mult_over F -> Function of [:the carrier of F,n-tuples_on the
  carrier of F:], n-tuples_on the carrier of F means
  :Def4:
  for x being Element
  of F, v being Element of n-tuples_on the carrier of F holds it.(x,v) = (the
  multF of F)[;](x,v);
  existence
  proof
    defpred P[set,set] means (ex x1 being Element of F, v being Element of n
    -tuples_on the carrier of F st $1=[x1,v] & $2=(the multF of F)[;](x1,v));
A1: for x st x in [:the carrier of F,n-tuples_on the carrier of F:] ex y
    st y in n-tuples_on the carrier of F & P[x,y]
    proof
      let x;
      assume x in [:the carrier of F,n-tuples_on the carrier of F:];
      then consider x1,v being set such that
A2:   x1 in the carrier of F and
A3:   v in n-tuples_on the carrier of F and
A4:   [x1,v] = x by ZFMISC_1:103;
      reconsider v as Element of n-tuples_on the carrier of F by A3;
      reconsider x1 as Element of F by A2;
      take y = (the multF of F)[;](x1,v);
      y is Element of n-tuples_on the carrier of F by FINSEQ_2:141;
      hence y in n-tuples_on the carrier of F;
      take x1,v;
      thus thesis by A4;
    end;
    consider f be Function of [:the carrier of F,n-tuples_on the carrier of F
    :], n-tuples_on the carrier of F such that
A5: for x st x in [:the carrier of F,n-tuples_on the carrier of F:]
    holds P[x,f.x] from FUNCT_2:sch 1(A1);
    take f;
    let x be Element of F, v be Element of n-tuples_on the carrier of F;
    [x,v] in [:the carrier of F,n-tuples_on the carrier of F:] by ZFMISC_1:106;
    then consider x1 being Element of F, v1 being Element of n-tuples_on the
    carrier of F such that
A6: [x,v]=[x1,v1] and
A7: f.[x,v]=(the multF of F)[;](x1,v1) by A5;
    x1 = x by A6,ZFMISC_1:33;
    hence thesis by A6,A7,ZFMISC_1:33;
  end;
  uniqueness
  proof
    let f,g be Function of [:the carrier of F,n-tuples_on the carrier of F:],
    n-tuples_on the carrier of F;
    assume that
A8: for x being Element of F,v being Element of n-tuples_on the
    carrier of F holds f.(x,v) = (the multF of F)[;](x,v) and
A9: for x being Element of F,v being Element of n-tuples_on the
    carrier of F holds g.(x,v) = (the multF of F)[;](x,v);
    now
      let x be Element of F, v be Element of n-tuples_on the carrier of F;
      f.(x,v) = (the multF of F)[;](x,v) by A8;
      hence f.(x,v)=g.(x,v) by A9;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

definition
  let F,n;
  func n -VectSp_over F -> strict VectSpStr over F means
  :Def5:
  the addLoopStr of it = n -Group_over F & the lmult of it = n -Mult_over F;
  existence
  proof
    n-Group_over F = addLoopStr(# n-tuples_on the carrier of F, product(
the addF of F,n), (n |-> 0.F) qua Element of n-tuples_on the carrier of F#)
by Def3;
    then reconsider d = n-Mult_over F as Function of [:the carrier of F, the
    carrier of n-Group_over F:], the carrier of n-Group_over F;
    set G = n-Group_over F;
    take VectSpStr(#car(G), ad(G), zr(G), d#);
    thus thesis;
  end;
  uniqueness;
end;

registration
  let F,n;
  cluster n -VectSp_over F -> non empty;
  coherence
  proof
    the addLoopStr of n -VectSp_over F = n -Group_over F by Def5;
    hence the carrier of n -VectSp_over F is non empty;
  end;
end;

reserve D for non empty set,
  H,G for BinOp of D,
  d for Element of D,
  t1,t2 for Element of n-tuples_on D;

theorem Th18:
  H is_distributive_wrt G implies H[;](d,G.:(t1,t2)) = G.: (H[;](d
  ,t1),H[;](d,t2))
proof
A1: H[;](d,G.:(t1,t2)) = H[;](d,G*<:t1,t2:>) by FUNCOP_1:def 3
    .= H*<:dom (G*<:t1,t2:>) --> d,G*<:t1,t2:>:> by FUNCOP_1:def 5;
  rng (H*<:dom t1 -->d,t1:>) c= rng H & rng (H*<:dom t2 -->d,t2:>) c= rng
  H by RELAT_1:45;
  then rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c= [:rng (H*<:dom t1
-->d, t1:>),rng (H*<:dom t2 -->d,t2:>):] & [:rng (H*<:dom t1 -->d,t1:>),rng (H*
  <:dom t2 -->d,t2:>):] c= [:rng H, rng H:] by FUNCT_3:71,ZFMISC_1:119;
  then
A2: rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c= [:rng H,rng H:] by
XBOOLE_1:1;
  rng H c= D by RELAT_1:def 19;
  then [:rng H,rng H:] c= [:D,D:] by ZFMISC_1:119;
  then rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c= [:D,D:] by A2,
XBOOLE_1:1;
  then
A3: rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c= dom G by FUNCT_2:def 1
;
A4: dom t2 = Seg (len t2) by FINSEQ_1:def 3
    .= Seg n by FINSEQ_1:def 18;
  rng t1 c= D & rng t2 c= D by FINSEQ_1:def 4;
  then
A5: [:rng t1,rng t2:] c= [:D,D:] by ZFMISC_1:119;
  rng <:t1,t2:> c= [:rng t1,rng t2:] by FUNCT_3:71;
  then rng <:t1,t2:> c= [:D,D:] by A5,XBOOLE_1:1;
  then
A6: rng <:t1,t2:> c= dom G by FUNCT_2:def 1;
A7: dom (dom t2 -->d) = dom t2 by FUNCOP_1:19
    .= Seg (len t2) by FINSEQ_1:def 3
    .= Seg n by FINSEQ_1:def 18;
  dom t1 = Seg (len t1) by FINSEQ_1:def 3
    .= Seg n by FINSEQ_1:def 18;
  then dom <:t1,t2:> = Seg n by A4,FUNCT_3:70;
  then
A8: dom (G*<:t1,t2:>) = Seg n by A6,RELAT_1:46;
  then dom (dom (G*<:t1,t2:>) -->d) = Seg n by FUNCOP_1:19;
  then
A9: dom <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> = Seg n by A8,FUNCT_3:70;
  rng t2 c= D by FINSEQ_1:def 4;
  then rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),rng t2:] & [:rng (dom t2
  -->d) ,rng t2:] c= [:rng (dom t2 -->d),D:] by FUNCT_3:71,ZFMISC_1:119;
  then
A10: rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),D:] by XBOOLE_1:1;
  rng (dom t2 -->d) c= {d} by FUNCOP_1:19;
  then [:rng (dom t2 -->d),D:] c= [:{d},D:] by ZFMISC_1:119;
  then
A11: rng <:dom t2 -->d,t2:> c= [:{d},D:] by A10,XBOOLE_1:1;
A12: dom t1 = Seg (len t1) by FINSEQ_1:def 3
    .= Seg n by FINSEQ_1:def 18;
  rng t1 c= D by FINSEQ_1:def 4;
  then rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),rng t1:] & [:rng (dom t1
  -->d) ,rng t1:] c= [:rng (dom t1 -->d),D:] by FUNCT_3:71,ZFMISC_1:119;
  then
A13: rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),D:] by XBOOLE_1:1;
  rng (dom t1 -->d) c= {d} by FUNCOP_1:19;
  then [:rng (dom t1 -->d),D:] c= [:{d},D:] by ZFMISC_1:119;
  then
A14: rng <:dom t1 -->d,t1:> c= [:{d},D:] by A13,XBOOLE_1:1;
A15: dom (dom t1 -->d) = dom t1 by FUNCOP_1:19
    .= Seg (len t1) by FINSEQ_1:def 3
    .= Seg n by FINSEQ_1:def 18;
  {d} c= D by ZFMISC_1:37;
  then
A16: [:{d},D:] c= [:D,D:] by ZFMISC_1:119;
  rng (dom (G*<:t1,t2:>) -->d) c= {d} & {d} c= D by FUNCOP_1:19,ZFMISC_1:37;
  then
A17: rng (dom (G*<:t1,t2:>) -->d) c= D by XBOOLE_1:1;
A18: dom t2 = Seg (len t2) by FINSEQ_1:def 3
    .= Seg n by FINSEQ_1:def 18;
  dom H = [:D,D:] by FUNCT_2:def 1;
  then
A19: dom (H*<:dom t2-->d,t2:>) = dom <:dom t2 -->d,t2:> by A11,A16,RELAT_1:46
,XBOOLE_1:1
    .= Seg n by A7,A18,FUNCT_3:70;
  {d} c= D by ZFMISC_1:37;
  then
A20: [:{d},D:] c= [:D,D:] by ZFMISC_1:119;
  set A = H*<:dom (G*<:t1,t2:>) --> d,G*<:t1,t2:>:>;
A21: G.:(H[;](d,t1),H[;](d,t2)) = G.:(H*<:dom t1 -->d,t1:>,H[;](d,t2)) by
FUNCOP_1:def 5
    .= G.:(H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>) by FUNCOP_1:def 5
    .= G*<:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> by FUNCOP_1:def 3;
  dom H = [:D,D:] by FUNCT_2:def 1;
  then dom (H*<:dom t1 -->d,t1:>) = dom <:dom t1 -->d,t1:> by A14,A20,
RELAT_1:46,XBOOLE_1:1
    .= Seg n by A15,A12,FUNCT_3:70;
  then dom <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> = Seg n by A19,
FUNCT_3:70;
  then
A22: dom (G*<:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:>) = Seg n by A3,
RELAT_1:46;
  rng (G*<:t1,t2:>) c= D by RELAT_1:def 19;
  then
  rng <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> c= [:rng (dom (G*<:t1,t2:>)
-->d) ,rng (G*<:t1,t2:>):] & [:rng (dom (G*<:t1,t2:>) -->d),rng (G*<:t1,t2:>):]
  c= [:D,D:] by A17,FUNCT_3:71,ZFMISC_1:119;
  then rng <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> c= [:D,D:] by XBOOLE_1:1;
  then
A23: rng <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> c= dom H by FUNCT_2:def 1;
  then
A24: dom A = Seg n by A9,RELAT_1:46;
  assume
A25: H is_distributive_wrt G;
  for x st x in dom A holds H[;](d,G.:(t1,t2)).x = G.:(H[;](d,t1),H[;](d,
  t2 ) ) . x
  proof
    rng t1 c= D by FINSEQ_1:def 4;
    then rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),rng t1:] & [:rng (dom
    t1 -->d) ,rng t1:] c= [:rng (dom t1 -->d),D:] by FUNCT_3:71,ZFMISC_1:119;
    then
A26: rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),D:] by XBOOLE_1:1;
    rng (dom t1 -->d) c= {d} by FUNCOP_1:19;
    then [:rng (dom t1 -->d),D:] c= [:{d},D:] by ZFMISC_1:119;
    then
A27: rng <:dom t1 -->d,t1:> c= [:{d},D:] by A26,XBOOLE_1:1;
A28: rng t1 c= D & rng t2 c= D by FINSEQ_1:def 4;
    {d} c= D by ZFMISC_1:37;
    then
A29: [:{d},D:] c= [:D,D:] by ZFMISC_1:119;
A30: dom (dom t2 -->d) = dom t2 by FUNCOP_1:19
      .= Seg (len t2) by FINSEQ_1:def 3
      .= Seg n by FINSEQ_1:def 18;
    {d} c= D by ZFMISC_1:37;
    then
A31: [:{d},D:] c= [:D,D:] by ZFMISC_1:119;
A32: dom t1 = Seg (len t1) by FINSEQ_1:def 3
      .= Seg n by FINSEQ_1:def 18;
    rng t2 c= D by FINSEQ_1:def 4;
    then rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),rng t2:] & [:rng (dom
    t2 -->d) ,rng t2:] c= [:rng (dom t2 -->d),D:] by FUNCT_3:71,ZFMISC_1:119;
    then
A33: rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),D:] by XBOOLE_1:1;
    rng (dom t2 -->d) c= {d} by FUNCOP_1:19;
    then [:rng (dom t2 -->d),D:] c= [:{d},D:] by ZFMISC_1:119;
    then
A34: rng <:dom t2 -->d,t2:> c= [:{d},D:] by A33,XBOOLE_1:1;
A35: dom (dom t1 -->d) = dom t1 by FUNCOP_1:19
      .= Seg (len t1) by FINSEQ_1:def 3
      .= Seg n by FINSEQ_1:def 18;
    let x;
A36: dom <:dom (G.:(t1,t2)) -->d,G.:(t1,t2):> = dom (dom (G.:(t1,t2)) -->d
    ) /\ dom (G.:(t1,t2)) by FUNCT_3:def 8;
    assume
A37: x in dom A;
    then x in dom (H*<:dom (G.:(t1,t2)) -->d,G.: (t1,t2):>) by A1,
FUNCOP_1:def 5;
    then x in dom <:dom (G.:(t1,t2)) -->d,G.:(t1,t2):> by FUNCT_1:21;
    then
A38: x in dom (G.:(t1,t2)) by A36,XBOOLE_0:def 4;
    dom t1 = Seg (len t1) by FINSEQ_1:def 3
      .= Seg n by FINSEQ_1:def 18;
    then
A39: t1.x in rng t1 by A24,A37,FUNCT_1:def 5;
A40: dom t2 = Seg (len t2) by FINSEQ_1:def 3
      .= Seg n by FINSEQ_1:def 18;
    dom H = [:D,D:] by FUNCT_2:def 1;
    then dom (H*<:dom t1 -->d,t1:>) = dom <:dom t1 -->d,t1:> by A27,A31,
RELAT_1:46,XBOOLE_1:1
      .= Seg n by A35,A32,FUNCT_3:70;
    then
A41: x in dom (H[;](d,t1)) by A24,A37,FUNCOP_1:def 5;
    dom t2 = Seg (len t2) by FINSEQ_1:def 3
      .= Seg n by FINSEQ_1:def 18;
    then
A42: t2.x in rng t2 by A24,A37,FUNCT_1:def 5;
    dom H = [:D,D:] by FUNCT_2:def 1;
    then dom (H*<:dom t2-->d,t2:>) = dom <:dom t2 -->d,t2:> by A34,A29,
RELAT_1:46,XBOOLE_1:1
      .= Seg n by A30,A40,FUNCT_3:70;
    then
A43: x in dom (H[;](d,t2)) by A24,A37,FUNCOP_1:def 5;
    H[;](d,G.:(t1,t2)).x = H.(d,G.:(t1,t2).x) by A1,A37,FUNCOP_1:42
      .= H.(d,G.(t1.x,t2.x)) by A38,FUNCOP_1:28
      .= G.(H.(d,t1.x),H.(d,t2.x)) by A25,A39,A28,A42,BINOP_1:23
      .= G.((H[;](d,t1)).x,H.(d,t2.x)) by A41,FUNCOP_1:42
      .= G.((H[;](d,t1)).x,(H[;](d,t2)).x) by A43,FUNCOP_1:42
      .= (G.: (H[;](d,t1),H[;](d,t2))).x by A21,A24,A22,A37,FUNCOP_1:28;
    hence thesis;
  end;
  hence thesis by A1,A21,A9,A23,A22,FUNCT_1:9,RELAT_1:46;
end;

definition
  let D be non empty set, n be Nat, F be BinOp of D, x be Element of D, v be
  Element of n-tuples_on D;
  redefine func F[;](x,v) -> Element of n-tuples_on D;
  coherence by FINSEQ_2:141;
end;

registration
  let F,n;
  cluster n -VectSp_over F -> vector-distributive scalar-distributive
  scalar-associative scalar-unital;
  coherence
  proof
A1: the addLoopStr of n -VectSp_over F=n-Group_over F & n-Group_over F=
addLoopStr(# n-tuples_on the carrier of F, product(the addF of F,n), (n |-> 0.
      F) qua Element of n-tuples_on the carrier of F#) by Def3,Def5;
    1_F is_a_unity_wrt the multF of F by Th11;
    then
A2: the multF of F is having_a_unity & the_unity_wrt the multF of F = 1_F
    by BINOP_1:def 8,SETWISEO:def 2;
X1:    n-VectSp_over F is vector-distributive
    proof
      let x be Element of F;
      let v,w be Element of n -VectSp_over F;
      reconsider v9=v,w9=w as Element of n-tuples_on the carrier of F by A1;
      thus x*(v+w) = (n-Mult_over F).(x,product(the addF of F,n).(v,w)) by A1
,Def5
        .= (n-Mult_over F).(x,(the addF of F).:(v9,w9)) by Def1
        .= (the multF of F)[;](x,(the addF of F).:(v9,w9)) by Def4
        .= (the addF of F).: ((the multF of F)[;](x,v9),(the multF of F)[;](
      x,w9)) by Lm5,Th18
        .= product(the addF of F,n).((the multF of F)[;](x,v9), (the multF
      of F)[;](x,w9)) by Def1
        .= product(the addF of F,n).((n-Mult_over F).(x,v9), (the multF of F
      )[;](x,w9)) by Def4
        .= product(the addF of F,n).((n-Mult_over F).(x,v9), (n-Mult_over F)
      .(x,w9)) by Def4
        .= product(the addF of F,n).((the lmult of n-VectSp_over F).(x,v), (
      n-Mult_over F).(x,w9)) by Def5
        .= x*v + x*w by A1,Def5;
    end;
X2:   n-VectSp_over F is scalar-distributive
    proof
      let x,y be Element of F;
      let v be Element of n -VectSp_over F;
      reconsider v9=v as Element of n-tuples_on the carrier of F by A1;
      thus (x+y)*v = (n-Mult_over F).(x+y,v9) by Def5
        .= (the multF of F)[;]((the addF of F).(x,y),v9) by Def4
        .= (the addF of F).: ((the multF of F)[;](x,v9),(the multF of F)[;](
      y,v9)) by Lm5,FINSEQOP:47
        .= product(the addF of F,n).((the multF of F)[;](x,v9), (the multF
      of F)[;](y,v9)) by Def1
        .= product(the addF of F,n).((n-Mult_over F).(x,v9), (the multF of F
      )[;](y,v9)) by Def4
        .= product(the addF of F,n).((n-Mult_over F).(x,v9), (n-Mult_over F)
      .(y,v9)) by Def4
        .= product(the addF of F,n).((the lmult of n-VectSp_over F).(x,v), (
      n-Mult_over F).(y,v9)) by Def5
        .= x*v + y*v by A1,Def5;
    end;
X3:   n-VectSp_over F is scalar-associative
    proof
      let x,y be Element of F;
      let v be Element of n -VectSp_over F;
      reconsider v9=v as Element of n-tuples_on the carrier of F by A1;
      thus (x*y)*v = (n-Mult_over F).(x*y,v9) by Def5
        .= (the multF of F)[;](x*y,v9) by Def4
        .= (the multF of F)[;](x,(the multF of F)[;](y,v9)) by Lm4,FINSEQOP:32
        .= (n-Mult_over F).(x,(the multF of F)[;](y,v9)) by Def4
        .= (n-Mult_over F).(x,(n-Mult_over F).(y,v9)) by Def4
        .= (n-Mult_over F).(x,(the lmult of n-VectSp_over F).(y,v)) by Def5
        .= x*(y*v) by Def5;
    end;
    n-VectSp_over F is scalar-unital
    proof
      let v be Element of n -VectSp_over F;
      reconsider v9=v as Element of n-tuples_on the carrier of F by A1;
      thus (1.F)*v = (n-Mult_over F).(1.F,v9) by Def5
        .= (the multF of F)[;](1.F,v9) by Def4
        .= v by A2,FINSEQOP:58;
    end;
    hence thesis by X1,X2,X3;
  end;
end;

begin :: Sequences of domains

reserve x,y,z for set,
  A for AbGroup;

definition
  mode Domain-Sequence is non empty non-empty FinSequence;
end;

scheme
  NEFinSeqLambda {w()-> non empty FinSequence, F(set)->set}: ex p being non
empty FinSequence st len p = len w() & for i being Element of dom w() holds p.i
  = F(i) proof
  consider x being Element of dom w();
  consider p being FinSequence such that
A1: len p = len w() & for i being Nat st i in dom p holds p.i = F(i)
  from FINSEQ_1:sch 2;
  dom p = dom w() by A1,FINSEQ_3:31;
  then reconsider p9=p as non empty FinSequence;
  take p9;
  thus len p9 = len w() by A1;
  let i be Element of dom w();
A2: dom w() = Seg len w() by FINSEQ_1:def 3;
  dom p = Seg len w() by A1,FINSEQ_1:def 3;
  hence thesis by A1,A2;
end;

definition
  let a be non-empty non empty Function;
  let f be Element of product a;
  let i be Element of dom a;
  redefine func f.i -> Element of a.i;
  coherence by CARD_3:18;
end;

begin :: The Product of Families of Operations

reserve a for Domain-Sequence,
  i for Element of dom a,
  p for FinSequence;

definition
  let a be non-empty non empty Function;
  canceled 2;
  mode BinOps of a -> Function means
    :Def8:
    dom it = dom a & for i being Element of dom a holds it.i is BinOp of a.i;
  existence
  proof
    deffunc F(set) = pr1(a.$1,a.$1);
    consider f being Function such that
A1: dom f = dom a & for x st x in dom a holds f.x = F(x) from FUNCT_1:
    sch 3;
    take f;
    thus dom f = dom a by A1;
    let i be Element of dom a;
    f.i = pr1(a.i,a.i) by A1;
    hence thesis;
  end;
  mode UnOps of a -> Function means
    : Def9:
    dom it = dom a & for i being Element of dom a holds it.i is UnOp of a.i;
  existence
  proof
    deffunc F(set) = id (a.$1);
    consider f being Function such that
A2: dom f = dom a & for x st x in dom a holds f.x = F(x) from FUNCT_1:
    sch 3;
    take f;
    thus dom f = dom a by A2;
    let i be Element of dom a;
    f.i = id (a.i) by A2;
    hence thesis;
  end;
end;

registration
  let a;
  cluster -> FinSequence-like BinOps of a;
  coherence
  proof
    let f be BinOps of a;
    dom a = dom f & dom a = Seg len a by Def8,FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
  end;
  cluster -> FinSequence-like UnOps of a;
  coherence
  proof
    let f be UnOps of a;
    dom a = dom f & dom a = Seg len a by Def9,FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
  end;
end;

theorem Th19:
  p is BinOps of a iff len p = len a & for i holds p.i is BinOp of a.i
proof
  dom p = dom a iff len p = len a by FINSEQ_3:31;
  hence thesis by Def8;
end;

theorem Th20:
  p is UnOps of a iff len p = len a & for i holds p.i is UnOp of a .i
proof
  dom p = dom a iff len p = len a by FINSEQ_3:31;
  hence thesis by Def9;
end;

definition
  let a;
  let b be BinOps of a;
  let i;
  redefine func b.i -> BinOp of a.i;
  coherence by Th19;
end;

definition
  let a;
  let u be UnOps of a;
  let i;
  redefine func u.i -> UnOp of a.i;
  coherence by Th20;
end;

theorem
  for d,d9 being UnOp of product a st for f being Element of product a,
  i being Element of dom a holds (d.f).i = (d9.f).i holds d = d9
proof
  let d,d9 be UnOp of product a such that
A1: for f being Element of product a, i being Element of dom a holds (d.
  f).i = (d9.f).i;
  now
    let f be Element of product a;
A2: dom (d.f) = dom a & dom (d9.f) = dom a by CARD_3:18;
    for x st x in dom a holds (d.f).x = (d9.f).x by A1;
    hence d.f = d9.f by A2,FUNCT_1:9;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th22:
  for u being UnOps of a holds doms u = a & product rngs u c= product a
proof
  let u be UnOps of a;
A1: dom doms u = u"SubFuncs rng u by FUNCT_6:def 2;
A2: dom a = Seg len a & dom u = Seg len u by FINSEQ_1:def 3;
A3: len u = len a by Th20;
A4: dom u c= u"SubFuncs rng u
  proof
    let x;
    assume x in dom u;
    then reconsider x as Element of dom a by A2,Th20;
    u.x is UnOp of a.x;
    hence thesis by A2,A3,FUNCT_6:28;
  end;
  u"SubFuncs rng u c= dom u by RELAT_1:167;
  then
A5: dom doms u = dom u by A1,A4,XBOOLE_0:def 10;
A6: now
    let x;
    assume x in dom u;
    then reconsider i = x as Element of dom a by A2,Th20;
    (rngs u).i = rng (u.i) by A2,A3,FUNCT_6:31;
    hence (rngs u).x c= a.x by RELAT_1:def 19;
  end;
  now
    let x;
    assume x in dom u;
    then reconsider i = x as Element of dom a by A2,Th20;
    (doms u).i = dom (u.i) by A2,A3,FUNCT_6:31
      .= a.i by FUNCT_2:def 1;
    hence (doms u).x = a.x;
  end;
  hence doms u = a by A2,A3,A5,FUNCT_1:9;
  dom rngs u = u"SubFuncs rng u by FUNCT_6:def 3;
  hence thesis by A1,A2,A3,A5,A6,CARD_3:38;
end;

definition
  let a;
  let u be UnOps of a;
  redefine func Frege u -> UnOp of product a;
  coherence
  proof
A1: product rngs u c= product a & rng Frege u = product rngs u by Th22,
FUNCT_6:58;
    dom Frege u = product doms u & doms u = a by Th22,FUNCT_6:def 7;
    hence thesis by A1,FUNCT_2:def 1,RELSET_1:11;
  end;
end;

theorem Th23:
  for u being UnOps of a for f being Element of product a, i being
  Element of dom a holds (Frege u).f.i = (u.i).(f.i)
proof
  let u be UnOps of a, f be Element of product a;
  let i be Element of dom a;
A1: dom u = Seg len u & doms u = a by Th22,FINSEQ_1:def 3;
  dom a = Seg len a & len a = len u by Th20,FINSEQ_1:def 3;
  hence thesis by A1,FUNCT_6:57;
end;

definition
  let F be functional non empty set;
  let b be BinOp of F, f,g be Element of F;
  redefine func b.(f,g) -> Element of F;
  coherence
  proof
    b.(f,g) is Element of F;
    hence thesis;
  end;
end;

theorem Th24:
  for d,d9 being BinOp of product a st for f,g being Element of
product a, i being Element of dom a holds (d.(f,g)).i = (d9.(f,g)).i holds d =
  d9
proof
  let d,d9 be BinOp of product a such that
A1: for f,g be Element of product a, i be Element of dom a holds (d.(f,g
  )).i = (d9.(f,g)).i;
  now
    let f,g be Element of product a;
A2: dom (d.(f,g)) = dom a & dom (d9.(f,g)) = dom a by CARD_3:18;
    for x st x in dom a holds (d.(f,g)).x = (d9.(f,g)).x by A1;
    hence d.(f,g) = d9.(f,g) by A2,FUNCT_1:9;
  end;
  hence thesis by BINOP_1:2;
end;

reserve i for Element of dom a;

definition
  let a;
  let b be BinOps of a;
  func [:b:] -> BinOp of product a means
  :Def10:
  for f,g being Element of
  product a, i being Element of dom a holds (it.(f,g)).i = (b.i).(f.i,g.i);
  existence
  proof
    defpred Q[Element of product a,Element of product a,Element of product a]
    means for i being Element of dom a holds $3.i = (b.i).($1.i,$2.i);
A1: for f,g being Element of product a ex z being Element of product a st
    Q[f,g,z]
    proof
      let f,g be Element of product a;
      defpred P[set,set] means ex i st $1 =i & $2 = (b.i).(f.i,g.i);
A2:   for x st x in dom a ex z st P[x,z]
      proof
        let x;
        assume x in dom a;
        then reconsider i = x as Element of dom a;
        take (b.i).(f.i,g.i);
        thus thesis;
      end;
      consider z being Function such that
A3:   dom z = dom a & for x being set st x in dom a holds P[x,z.x]
      from CLASSES1:sch 1(A2);
      now
        let x;
        assume x in dom a;
        then ex i st x = i & z.x = (b.i).(f.i,g.i) by A3;
        hence z.x in a.x;
      end;
      then reconsider z9 = z as Element of product a by A3,CARD_3:18;
      take z9;
      let i;
      ex j being Element of dom a st j = i & z.i = (b.j).(f.j,g.j) by A3;
      hence thesis;
    end;
    consider d being BinOp of product a such that
A4: for f,g being Element of product a holds Q[f,g,d.(f,g)] from
    BINOP_1:sch 3 (A1);
    take d;
    thus thesis by A4;
  end;
  uniqueness
  proof
    let d,d9 be BinOp of product a such that
A5: for f,g being Element of product a,i being Element of dom a holds
    (d.(f,g)).i = (b.i).(f.i,g.i) and
A6: for f,g being Element of product a,i being Element of dom a holds
    (d9.(f,g)).i = (b.i).(f.i,g.i);
    now
      let f,g be Element of product a;
      let i be Element of dom a;
      thus (d.(f,g)).i = (b.i).(f.i,g.i) by A5
        .= (d9.(f,g)).i by A6;
    end;
    hence thesis by Th24;
  end;
end;

theorem Th25:
  for b being BinOps of a st for i holds b.i is commutative holds
  [:b:] is commutative
proof
  let b be BinOps of a such that
A1: for i holds b.i is commutative;
  let x,y be Element of product a;
A2: now
    let z;
    assume z in dom a;
    then reconsider i = z as Element of dom a;
A3: [:b:].(y,x).i = (b.i).(y.i,x.i) by Def10;
    b.i is commutative & [:b:].(x,y).i = (b.i).(x.i,y.i) by A1,Def10;
    hence [:b:].(x,y).z = [:b:].(y,x).z by A3,BINOP_1:def 2;
  end;
  dom ([:b:].(x,y)) = dom a & dom ([:b:].(y,x)) = dom a by CARD_3:18;
  hence thesis by A2,FUNCT_1:9;
end;

theorem Th26:
  for b being BinOps of a st for i holds b.i is associative holds
  [:b:] is associative
proof
  let b be BinOps of a such that
A1: for i holds b.i is associative;
  let x,y,z be Element of product a;
A2: now
    set xy = [:b:].(x,y), yz = [:b:].(y,z);
    let v be set;
    assume v in dom a;
    then reconsider i = v as Element of dom a;
A3: [:b:].(y,z).i = (b.i).(y.i,z.i) & [:b:].(x,yz).i = (b.i).(x.i,yz.i) by
Def10;
A4: [:b:].(xy,z).i = (b.i).(xy.i,z.i) by Def10;
    b.i is associative & [:b:].(x,y).i = (b.i).(x.i,y.i) by A1,Def10;
    hence [:b:].(x,[:b:].(y,z)).v = [:b:].([:b:].(x,y),z).v by A3,A4,
BINOP_1:def 3;
  end;
  dom ([:b:].(x,[:b:].(y,z))) = dom a & dom ([:b:].([:b:].(x,y),z)) = dom
  a by CARD_3:18;
  hence thesis by A2,FUNCT_1:9;
end;

theorem Th27:
  for b being BinOps of a, f being Element of product a st for i
  holds f.i is_a_unity_wrt b.i holds f is_a_unity_wrt [:b:]
proof
  let b be BinOps of a, f be Element of product a such that
A1: for i holds f.i is_a_unity_wrt b.i;
  now
    let x be Element of product a;
A2: dom x = dom a by CARD_3:18;
A3: now
      let y;
      assume y in dom a;
      then reconsider i = y as Element of dom a;
      [:b:].(f,x).i = (b.i).(f.i,x.i) & f.i is_a_unity_wrt b.i by A1,Def10;
      hence [:b:].(f,x).y = x.y by BINOP_1:11;
    end;
    dom ([:b:].(f,x)) = dom a by CARD_3:18;
    hence [:b:].(f,x) = x by A2,A3,FUNCT_1:9;
A4: now
      let y;
      assume y in dom a;
      then reconsider i = y as Element of dom a;
      [:b:].(x,f).i = (b.i).(x.i,f.i) & f.i is_a_unity_wrt b.i by A1,Def10;
      hence [:b:].(x,f).y = x.y by BINOP_1:11;
    end;
    dom ([:b:].(x,f)) = dom a by CARD_3:18;
    hence [:b:].(x,f) = x by A2,A4,FUNCT_1:9;
  end;
  hence thesis by BINOP_1:11;
end;

theorem Th28:
  for b being BinOps of a, u being UnOps of a st for i holds u.i
  is_an_inverseOp_wrt b.i & b.i is having_a_unity holds Frege u
  is_an_inverseOp_wrt [:b:]
proof
  let b be BinOps of a, u be UnOps of a such that
A1: for i holds u.i is_an_inverseOp_wrt b.i & b.i is having_a_unity;
  defpred P[set,set] means ex i st $1 = i & $2 = the_unity_wrt (b.i);
A2: for x st x in dom a ex y st P[x,y]
  proof
    let x;
    assume x in dom a;
    then reconsider i = x as Element of dom a;
    take the_unity_wrt (b.i);
    thus thesis;
  end;
  consider f being Function such that
A3: dom f = dom a & for x st x in dom a holds P[x,f.x] from CLASSES1:sch
  1( A2);
  now
    let x;
    assume x in dom a;
    then ex i st x = i & f.x = the_unity_wrt (b.i) by A3;
    hence f.x in a.x;
  end;
  then reconsider f as Element of product a by A3,CARD_3:18;
  let x be Element of product a;
A4: dom f = dom a by CARD_3:18;
A5: now
    let y;
    assume y in dom a;
    then reconsider i = y as Element of dom a;
A6: (Frege u).x.i = (u.i).(x.i) & u.i is_an_inverseOp_wrt b.i by A1,Th23;
    ( ex j being Element of dom a st i = j & f.i = the_unity_wrt (b.j))&
    [:b:].(x, (Frege u).x).i = (b.i).(x.i,(Frege u).x.i) by A3,Def10;
    hence [:b:].(x,(Frege u).x).y = f.y by A6,FINSEQOP:def 1;
  end;
  now
    let i;
    ( ex j being Element of dom a st i = j & f.i = the_unity_wrt (b.j))& b
    .i is having_a_unity by A1,A3;
    hence f.i is_a_unity_wrt b.i by SETWISEO:22;
  end;
  then f is_a_unity_wrt [:b:] by Th27;
  then
A7: f = the_unity_wrt [:b:] by BINOP_1:def 8;
A8: now
    let y;
    assume y in dom a;
    then reconsider i = y as Element of dom a;
A9: (Frege u).x.i = (u.i).(x.i) & u.i is_an_inverseOp_wrt b.i by A1,Th23;
    ( ex j being Element of dom a st i = j & f.i = the_unity_wrt (b.j))&
    [:b:].(( Frege u).x,x).i = (b.i).((Frege u).x.i,x.i) by A3,Def10;
    hence [:b:].((Frege u).x,x).y = f.y by A9,FINSEQOP:def 1;
  end;
  dom ([:b:].(x,(Frege u).x)) = dom a by CARD_3:18;
  hence [:b:].(x,(Frege u).x) = the_unity_wrt [:b:] by A7,A4,A5,FUNCT_1:9;
  dom ([:b:].((Frege u).x,x)) = dom a by CARD_3:18;
  hence [:b:].((Frege u).x,x) = the_unity_wrt [:b:] by A7,A4,A8,FUNCT_1:9;
end;

begin :: The Product of Groups

definition
  let F be Relation;
  attr F is AbGroup-yielding means
  :Def11:
  x in rng F implies x is AbGroup;
end;

registration
  cluster non empty AbGroup-yielding FinSequence;
  existence
  proof
    consider A;
    take <*A*>;
    thus <*A*> is non empty;
    let x;
    assume that
A1: x in rng <*A*> and
A2: not x is AbGroup;
    x in {A} by A1,FINSEQ_1:55;
    hence contradiction by A2,TARSKI:def 1;
  end;
end;

definition
  mode Group-Sequence is non empty AbGroup-yielding FinSequence;
end;

definition
  let g be Group-Sequence;
  let i be Element of dom g;
  redefine func g.i -> AbGroup;
  coherence
  proof
    g.i in rng g by FUNCT_1:def 5;
    hence thesis by Def11;
  end;
end;

definition
  let g be Group-Sequence;
  func carr g -> Domain-Sequence means
  :Def12:
  len it = len g & for j be Element of dom g holds it.j = the carrier of g.j;
  existence
  proof
    defpred P[set,set] means ex j9 being Element of dom g st j9 = $1 & $2 =
    the carrier of g.j9;
A1: for j being Nat st j in Seg len g ex x st P[j,x]
    proof
      let j be Nat;
      assume j in Seg len g;
      then reconsider j9 = j as Element of dom g by FINSEQ_1:def 3;
      take the carrier of g.j9;
      thus thesis;
    end;
    consider p being FinSequence such that
A2: dom p = Seg (len g) & for j being Nat st j in Seg len g holds P[j,
    p.j] from FINSEQ_1:sch 1(A1);
    p is non-empty
    proof
      assume {} in rng p;
      then consider x such that
A3:   x in dom p and
A4:   {} = p.x by FUNCT_1:def 5;
      reconsider x as Element of NAT by A3;
      ex x9 being Element of dom g st x9 = x & p.x = the carrier of g.x9 by A2
,A3;
      hence contradiction by A4;
    end;
    then reconsider p9 = p as Domain-Sequence by A2,FINSEQ_1:def 3;
    take p9;
    thus len p9 = len g by A2,FINSEQ_1:def 3;
    let j be Element of dom g;
    reconsider k = j as Element of NAT;
    dom g = Seg len g by FINSEQ_1:def 3;
    then ex j9 being Element of dom g st j9 = k & p9.k = the carrier of g.j9
    by A2;
    hence thesis;
  end;
  uniqueness
  proof
    let f,h be Domain-Sequence such that
A5: len f = len g and
A6: for j be Element of dom g holds f.j = the carrier of g.j and
A7: len h = len g and
A8: for j be Element of dom g holds h.j = the carrier of g.j;
    reconsider f9 = f,h9 = h as FinSequence;
A9: now
      let j be Nat;
      assume j in dom f9;
      then reconsider j9 = j as Element of dom g by A5,FINSEQ_3:31;
      f9.j = the carrier of g.j9 by A6;
      hence f9.j = h9.j by A8;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A5,A7,A9,FINSEQ_1:17;
  end;
end;

reserve g for Group-Sequence,
  i for Element of dom carr g;

definition
  let g,i;
  redefine func g.i -> AbGroup;
  coherence
  proof
    dom g = Seg len g & Seg len(carr g) = dom carr g by FINSEQ_1:def 3;
    then reconsider i9 = i as Element of dom g by Def12;
    g.i9 is AbGroup;
    hence thesis;
  end;
end;

definition
  let g;
  func addop g -> BinOps of carr g means
  :Def13:
  len it = len carr g & for i holds it.i = the addF of g.i;
  existence
  proof
    deffunc F(Element of dom carr g) = the addF of g.$1;
    consider p being non empty FinSequence such that
A1: len p = len carr g & for i holds p.i = F(i) from NEFinSeqLambda;
    now
      let i;
      len g = len (carr g) by Def12;
      then reconsider j = i as Element of dom g by FINSEQ_3:31;
      p.i = the addF of g.i & the carrier of g.j = (carr g).j by A1,Def12;
      hence p.i is BinOp of (carr g).i;
    end;
    then reconsider p9 = p as BinOps of carr g by A1,Th19;
    take p9;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let f,h be BinOps of carr g;
    assume that
A2: len f = len carr g and
A3: for i holds f.i = the addF of g.i and
A4: len h = len carr g and
A5: for i holds h.i = the addF of g.i;
    reconsider f9 = f,h9 = h as FinSequence;
A6: now
      let i be Nat;
      assume i in dom f9;
      then reconsider i9 = i as Element of dom carr g by A2,FINSEQ_3:31;
      f9.i = the addF of g.i9 by A3;
      hence f9.i = h9.i by A5;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A2,A4,A6,FINSEQ_1:17;
  end;
  func complop g -> UnOps of carr g means
  :Def14:
  len it = len carr g & for i holds it.i = comp g.i;
  existence
  proof
    deffunc F(Element of dom carr g) = comp g.$1;
    consider p being non empty FinSequence such that
A7: len p = len carr g & for i holds p.i = F(i) from NEFinSeqLambda;
    now
      let i;
      len g = len (carr g) by Def12;
      then reconsider j = i as Element of dom g by FINSEQ_3:31;
      p.i = comp g.i & the carrier of g.j = (carr g).j by A7,Def12;
      hence p.i is UnOp of (carr g).i;
    end;
    then reconsider p9 = p as UnOps of carr g by A7,Th20;
    take p9;
    thus thesis by A7;
  end;
  uniqueness
  proof
    let f,h be UnOps of carr g;
    assume that
A8: len f = len carr g and
A9: for i holds f.i = comp g.i and
A10: len h = len carr g and
A11: for i holds h.i = comp g.i;
    reconsider f9 = f,h9 = h as FinSequence;
A12: now
      let i be Nat;
      assume i in dom f9;
      then reconsider i9 = i as Element of dom carr g by A8,FINSEQ_3:31;
      f.i = comp g.i9 by A9;
      hence f.i = h.i by A11;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A8,A10,A12,FINSEQ_1:17;
  end;
  func zeros g -> Element of product carr g means
  :Def15:
  for i holds it.i = 0.(g.i);
  existence
  proof
    deffunc F(Element of dom carr g) = 0.(g.$1);
A13: dom (carr g) = Seg len (carr g) by FINSEQ_1:def 3;
    consider p being non empty FinSequence such that
A14: len p = len carr g & for i holds p.i = F(i) from NEFinSeqLambda;
A15: dom g = Seg len g by FINSEQ_1:def 3;
A16: now
      let i be set;
      assume i in dom (carr g);
      then reconsider x = i as Element of dom carr g;
      reconsider x9 = x as Element of dom g by A15,A13,Def12;
      p.x = 0.(g.x) & (carr g).x9 = the carrier of g.x9 by A14,Def12;
      hence p.i in (carr g).i;
    end;
    dom p = Seg len p by FINSEQ_1:def 3;
    then reconsider t = p as Element of product (carr g) by A14,A13,A16,
CARD_3:18;
    take t;
    thus thesis by A14;
  end;
  uniqueness
  proof
    let f,h be Element of product carr g;
    assume that
A17: for i holds f.i = 0.(g.i) and
A18: for i holds h.i = 0.(g.i);
    reconsider f9 = f, h9 = h as Function;
A19: now
      let x;
      assume x in dom carr g;
      then reconsider i = x as Element of dom carr g;
      thus f9.x = 0.(g.i) by A17
        .= h9.x by A18;
    end;
    dom f9 = dom carr g & dom h9 = dom carr g by CARD_3:18;
    hence thesis by A19,FUNCT_1:9;
  end;
end;

definition
  let G be Group-Sequence;
  func product G -> strict AbGroup equals
  addLoopStr(# product carr G, [:addop
    G:], zeros G #);
  coherence
  proof
    reconsider GS = addLoopStr(# product carr G, [:addop G:], zeros G #) as
    non empty addLoopStr;
A1: now
      let i be Element of dom carr G;
      dom G = Seg len G by FINSEQ_1:def 3
        .= Seg len carr G by Def12
        .= dom carr G by FINSEQ_1:def 3;
      hence (carr G).i = car(G.i) by Def12;
    end;
    now
      let i be Element of dom carr G;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def13;
      hence (addop G).i is associative by FVSUM_1:3;
    end;
    then
A2: [:addop G:] is associative by Th26;
    now
      let i be Element of dom carr G;
A3:   (carr G).i = car(G. i ) by A1;
      (addop G).i = ad(G.i) & (zeros G).i = zr(G.i) by Def13,Def15;
      hence (zeros G).i is_a_unity_wrt (addop G).i by A3,Th3;
    end;
    then
A4: zeros G is_a_unity_wrt [:addop G:] by Th27;
A5: GS is right_complementable
    proof
      let x be Element of GS;
      reconsider y = (Frege complop G).x as Element of GS by FUNCT_2:7;
      take y;
      now
        let i be Element of dom carr G;
A6:     (addop G).i = ad(G.i) & (complop G).i = cc(G.i) by Def13,Def14;
        zr(G.i) is_a_unity_wrt ad(G.i) & (carr G).i = car(G.i) by A1,Th3;
        hence (complop G).i is_an_inverseOp_wrt (addop G).i & (addop G).i is
        having_a_unity by A6,Th4,SETWISEO:def 2;
      end;
      then Frege complop G is_an_inverseOp_wrt [:addop G:] by Th28;
      then x + y = the_unity_wrt [:addop G:] by FINSEQOP:def 1;
      hence thesis by A4,BINOP_1:def 8;
    end;
    now
      let i be Element of dom carr G;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def13;
      hence (addop G).i is commutative by FVSUM_1:2;
    end;
    then 0.GS = zeros G & [:addop G:] is commutative by Th25;
    hence thesis by A2,A4,A5,Lm2,Lm3;
  end;
end;
