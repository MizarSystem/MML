:: Product of Families of Groups and Vector Spaces
::  by Anna Lango and Grzegorz Bancerek
::
:: Received December 29, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies RLVECT_1, VECTSP_1, BINOP_1, FUNCT_1, FINSEQOP, ARYTM_1,
      FINSEQ_2, RELAT_1, CARD_3, CAT_1, SETWISEO, FUNCOP_1, PARTFUN1, FINSEQ_1,
      BOOLE, ZF_REFLE, FRAENKEL, FUNCT_3, FUNCT_6, GROUP_2, PRVECT_1, GROUP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, CARD_3,
      RELAT_1, FUNCT_1, STRUCT_0, PARTFUN1, FUNCT_2, FUNCT_3, BINOP_1,
      FUNCOP_1, RLVECT_1, GROUP_1, VECTSP_1, FINSEQOP, FINSEQ_1, FRAENKEL,
      FUNCT_6, SETWISEO, FINSEQ_2;
 constructors PARTFUN1, FUNCT_3, BINOP_1, SETWISEO, FRAENKEL, FUNCT_5, CARD_3,
      FINSEQOP, FUNCT_6, VECTSP_1;
 registrations FUNCT_1, VECTSP_1, FRAENKEL, STRUCT_0, FINSEQ_2, GROUP_1,
      RELSET_1, FUNCOP_1, FINSEQ_1, ARYTM_3, FUNCT_2, ORDINAL1, CARD_3;
 requirements BOOLE, SUBSET;
 definitions TARSKI, BINOP_1, FINSEQOP, VECTSP_1, STRUCT_0, RELAT_1, RLVECT_1;
 theorems BINOP_1, FUNCT_1, FUNCT_2, FUNCT_3, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQOP, FUNCOP_1, VECTSP_1, ZFMISC_1, SETWISEO, TARSKI, CARD_3,
      FUNCT_6, RLVECT_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, FVSUM_1,
      GROUP_1, ORDINAL1;
 schemes FUNCT_1, BINOP_1, FUNCT_2, FINSEQ_1;

begin :: Abelian Groups and Fields

reserve G for Abelian add-associative right_complementable right_zeroed
    (non empty LoopStr);

 deffunc car(1-sorted) = the carrier of $1;
 deffunc ad(LoopStr) = the add of $1;
 deffunc cc(non empty LoopStr) = comp $1;
 deffunc zr(LoopStr) = the Zero of $1;

canceled 2;

theorem Th3:
 the Zero of G is_a_unity_wrt the add of G
  proof
        now let x be Element of G;
      thus (the add of G).(the Zero of G,x)=0.G + x by RLVECT_1:5
                    .= x by RLVECT_1:10;
      thus (the add of G).(x,the Zero of G)= x + 0.G by RLVECT_1:5
                    .= x by RLVECT_1:10;
     end;
    hence thesis by BINOP_1:11;
  end;

theorem Th4:
 for G being AbGroup holds comp G is_an_inverseOp_wrt the add of G
  proof
  let G be AbGroup;
A1:    the Zero of G is_a_unity_wrt the add of G by Th3;
      now let x be Element of G;
   thus (the add of G).(x,(comp G).x)=x + ((comp G).x) by RLVECT_1:5
                 .= x+(-x) by VECTSP_1:def 25
                 .= 0.G by RLVECT_1:16
                 .= the_unity_wrt the add of G by A1,BINOP_1:def 8;
   thus (the add of G).((comp G).x,x)=((comp G).x)+x
                                          by RLVECT_1:5
                         .= x+(-x) by VECTSP_1:def 25
                         .= 0.G by RLVECT_1:16
                         .= the_unity_wrt the add of G by A1,BINOP_1:def 8;
   end;
   hence thesis by FINSEQOP:def 1;
  end;

Lm1:
 comp G is_an_inverseOp_wrt the add of G
  proof
A1:    the Zero of G is_a_unity_wrt the add of G by Th3;
      now let x be Element of G;
   thus (the add of G).(x,(comp G).x)=x + ((comp G).x)
                                         by RLVECT_1:5
                 .= x+(-x) by VECTSP_1:def 25
                 .= 0.G by RLVECT_1:16
                 .= the_unity_wrt the add of G by A1,BINOP_1:def 8;
   thus (the add of G).((comp G).x,x)=((comp G).x)+x
                                          by RLVECT_1:5
                         .= x+(-x) by VECTSP_1:def 25
                         .= 0.G by RLVECT_1:16
                         .= the_unity_wrt the add of G by A1,BINOP_1:def 8;
   end;
   hence thesis by FINSEQOP:def 1;
  end;

reserve GS for non empty LoopStr;

theorem
     the add of GS is commutative associative &
  the Zero of GS is_a_unity_wrt the add of GS &
  comp GS is_an_inverseOp_wrt the add of GS implies
   GS is AbGroup
  proof assume that
A1:  the add of GS is commutative and
A2:  the add of GS is associative and
A3:  the Zero of GS is_a_unity_wrt the add of GS and
A4:  comp GS is_an_inverseOp_wrt the add of GS;
      now
   let x,y,z be Element of GS;
   thus x+y = (the add of GS).(x,y) by RLVECT_1:5
              .= (the add of GS).(y,x) by A1,BINOP_1:def 2
              .= y+x by RLVECT_1:5;
   thus (x+y)+z = (the add of GS).(x+y,z) by RLVECT_1:5
           .= (the add of GS).((the add of GS).(x,y),z) by RLVECT_1:5
           .= (the add of GS).(x,(the add of GS).(y,z)) by A2,BINOP_1:def 3
           .= (the add of GS).(x,y+z) by RLVECT_1:5
           .= x+(y+z) by RLVECT_1:5;
   thus x+(0.GS) = (the add of GS).(x,the Zero of GS) by RLVECT_1:5
           .= x by A3,BINOP_1:11;
   reconsider b = (comp GS).x as Element of GS;
   take b;
   thus x+b = (the add of GS).(x,(comp GS).x) by RLVECT_1:5
           .= the_unity_wrt the add of GS by A4,FINSEQOP:def 1
           .= (0.GS) by A3,BINOP_1:def 8;
   end;
   hence thesis by VECTSP_1:7;
  end;

Lm2:
  the add of GS is commutative associative implies
    GS is Abelian add-associative
  proof assume that
A1:  the add of GS is commutative and
A2:  the add of GS is associative;
   thus GS is Abelian
   proof
     let x,y be Element of GS;
     thus x+y = (the add of GS).(x,y) by RLVECT_1:5
              .= (the add of GS).(y,x) by A1,BINOP_1:def 2
              .= y+x by RLVECT_1:5;
   end;
   let x,y,z be Element of GS;
     thus (x+y)+z = (the add of GS).(x+y,z) by RLVECT_1:5
           .= (the add of GS).((the add of GS).(x,y),z) by RLVECT_1:5
           .= (the add of GS).(x,(the add of GS).(y,z)) by A2,BINOP_1:def 3
           .= (the add of GS).(x,y+z) by RLVECT_1:5
           .= x+(y+z) by RLVECT_1:5;
  end;

Lm3:
  the Zero of GS is_a_unity_wrt the add of GS implies
    GS is right_zeroed
  proof assume that
A1:  the Zero of GS is_a_unity_wrt the add of GS;
   let x be Element of GS;
   thus x+(0.GS) = (the add of GS).(x,the Zero of GS) by RLVECT_1:5
           .= x by A1,BINOP_1:11;
  end;

reserve F for Field;

 Lm4:
  the mult of F is associative
  proof
  let x,y,z be Element of F;
  thus (the mult of F).(x,(the mult of F).(y,z)) = (the mult of F).(x,y*z)
                                 by GROUP_1:def 1
              .= x*(y*z) by GROUP_1:def 1
              .= (x*y)*z by GROUP_1:def 4
              .= (the mult of F).(x*y,z) by GROUP_1:def 1
              .= (the mult of F).((the mult of F).(x,y),z) by GROUP_1:def 1;
  end;

canceled 4;

theorem
     the Zero of F is_a_unity_wrt the add of F
  proof
      now let x be Element of F;
   thus (the add of F).(the Zero of F,x) = x+(0.F) by RLVECT_1:5
                    .= x by RLVECT_1:10;
   thus (the add of F).(x,the Zero of F) = x+(0.F) by RLVECT_1:5
                    .= x by RLVECT_1:10;
   end;
   hence thesis by BINOP_1:11;
  end;

theorem Th11:
 1.F is_a_unity_wrt the mult of F
 proof
     now let x be Element of F;
  thus (the mult of F).(1.F,x) = (1.F)*x by GROUP_1:def 1
                    .= x by VECTSP_1:def 19;
  thus (the mult of F).(x,1.F) = x*(1.F) by GROUP_1:def 1
                    .= x by VECTSP_1:def 19;
  end;
  hence thesis by BINOP_1:11;
 end;

 Lm5:
   the mult of F is_distributive_wrt the add of F
   proof
       now let x,y,z be Element of F;
    thus (the mult of F).(x,(the add of F).(y,z)) =
           x*((the add of F).(y,z)) by GROUP_1:def 1
           .= x*(y + z) by RLVECT_1:5
           .= x*y + x*z by VECTSP_1:def 18
           .= (the add of F).(x*y,x*z) by RLVECT_1:5
           .= (the add of F).((the mult of F).(x,y),x*z)
                                       by GROUP_1:def 1
           .= (the add of F).((the mult of F).(x,y),(the mult of F).(x,z))
                                       by GROUP_1:def 1;
    thus (the mult of F).((the add of F).(x,y),z) =
           ((the add of F).(x,y))*z by GROUP_1:def 1
           .= (x + y)*z by RLVECT_1:5
           .= x*z + y*z by VECTSP_1:def 18
           .= (the add of F).(x*z,y*z) by RLVECT_1:5
           .= (the add of F).((the mult of F).(x,z),y*z)
                                         by GROUP_1:def 1
           .= (the add of F).((the mult of F).(x,z),(the mult of F).(y,z))
                                         by GROUP_1:def 1;
    end;
    hence thesis by BINOP_1:23;
   end;

begin :: The $n$-Product of a Binary and Unary Operation

 reserve F for Field,
         n for Nat,
         D for non empty set,
         d for Element of D,
         B for BinOp of D,
         C for UnOp of D;

definition let D,n;
  let F be BinOp of D;
  let x,y be Element of n-tuples_on D;
  redefine func F.:(x,y) -> Element of n-tuples_on D;
   coherence
   proof
     n in NAT by ORDINAL1:def 13;
     hence thesis by FINSEQ_2:140;
end;
 end;

definition let D be non empty set;
           let F be BinOp of D;
           let n be Nat;
  func product(F,n) -> BinOp of n-tuples_on D means :Def1:
   for x,y being Element of n-tuples_on D holds
              it.(x,y)=F.:(x,y);
   existence
    proof
        defpred P[set,set,set] means ex x',y' be Element of n-tuples_on D st
         $1=x' & $2=y' & $3=F.:(x',y');
A1:     for x,y being Element of (n-tuples_on D) qua non empty set
        ex z being Element of (n-tuples_on D) qua non empty set st P[x,y,z]
        proof
         let x,y be Element of (n-tuples_on D) qua non empty set;
         reconsider x'=x,y'=y as Element of n-tuples_on D;
         reconsider z = F.:(x',y') as Element of (n-tuples_on D) qua
non empty set;
         take z;
         take x',y';
          thus x=x' & y=y' & z=F.:(x',y');
        end;
       consider G being BinOp of n-tuples_on D such that
A2:      for x,y being Element of (n-tuples_on D) qua non empty set holds
        P[x,y,G.(x,y)] from BINOP_1:sch 3(A1);
       take G;
       let p1,p2 be Element of n-tuples_on D;
       reconsider x=p1,y=p2 as Element of (n-tuples_on D) qua non empty set;
          ex x',y' being Element of n-tuples_on D st
       x=x' & y=y' & G.(x,y)=F.:(x',y') by A2;
       hence thesis;
    end;
   uniqueness
    proof
     let G,H be BinOp of n-tuples_on D;
     assume that A3: (for x,y being Element of n-tuples_on D holds
     G.(x,y)=F.:(x,y)) and A4: (for x,y being Element of n-tuples_on D
     holds H.(x,y)=F.:(x,y));
        now let x,y be Element of n-tuples_on D;
          G.(x,y)=F.:(x,y) by A3;
      hence G.(x,y)=H.(x,y) by A4;
     end;
     hence G=H by BINOP_1:2;
   end;
  end;

definition let D;
           let F be UnOp of D;
           let n;
  func product(F,n) -> UnOp of n-tuples_on D means :Def2:
     for x being Element of n-tuples_on D holds it.x=F*x;
  existence
  proof
     defpred P[set,set] means
      ex x' being Element of n-tuples_on D st x'=$1 & $2=F*x';
A1:   for x being Element of (n-tuples_on D) qua non empty set
     ex y being Element of (n-tuples_on D) qua non empty set st P[x,y]
      proof
       let x be Element of (n-tuples_on D) qua non empty set;
       reconsider x'=x as Element of n-tuples_on D;
       n in NAT by ORDINAL1:def 13;
       then reconsider y=F*x' as Element of (n-tuples_on D) qua non empty set
         by FINSEQ_2:133;
       take y, x'; thus thesis;
      end;
     consider G being UnOp of n-tuples_on D such that
A2:   for x being Element of (n-tuples_on D) qua non empty set holds P[x,G.x]
       from FUNCT_2:sch 3(A1);
     take G;
     let p1 be Element of n-tuples_on D;
     reconsider x=p1 as Element of (n-tuples_on D) qua non empty set;
        ex x' being Element of n-tuples_on D st
        x'=x & G.x=F*x' by A2;
     hence thesis;
  end;
  uniqueness
   proof
    let G,H be UnOp of n-tuples_on D;
    assume that A3: for x being Element of n-tuples_on D holds G.x=F*x
       and A4: for x being Element of n-tuples_on D holds H.x=F*x;
        now let x be Element of n-tuples_on D;
          G.x=F*x by A3;
      hence G.x=H.x by A4;
     end;
    hence thesis by FUNCT_2:113;
   end;
 end;

notation let D be non empty set;
 let n; let x be Element of D;
 synonym n .--> x for n |-> x;
end;

definition let D be non empty set;
 let n; let x be Element of D;
 redefine func n .--> x -> Element of n-tuples_on D;
  correctness
  proof
    n in NAT by ORDINAL1:def 13;
    hence thesis by FINSEQ_2:132;
  end;
 end;

canceled 2;

theorem Th14:
  B is commutative implies product(B,n) is commutative
  proof
A1: n in NAT by ORDINAL1:def 13;
   assume A2: B is commutative;
      now let x,y be Element of n-tuples_on D;
    thus product(B,n).(x,y) = B.:(x,y) by Def1
                           .= B.:(y,x) by A1,A2,FINSEQOP:34
                           .= product(B,n).(y,x) by Def1;
   end;
   hence thesis by BINOP_1:def 2;
  end;

theorem Th15:
  B is associative implies product(B,n) is associative
  proof
A1: n in NAT by ORDINAL1:def 13;
   assume A2: B is associative;
      now let x,y,z be Element of n-tuples_on D;
    thus product(B,n).(product(B,n).(x,y),z) = product(B,n).(B.:(x,y),z)
                                                 by Def1
                     .= B.:(B.:(x,y),z) by Def1
                     .= B.:(x,B.:(y,z)) by A1,A2,FINSEQOP:29
                     .= product(B,n).(x,B.:(y,z)) by Def1
                     .= product(B,n).(x,product(B,n).(y,z)) by Def1;
   end;
   hence thesis by BINOP_1:def 3;
  end;

theorem Th16:
  d is_a_unity_wrt B implies n .--> d is_a_unity_wrt product(B,n)
  proof
A1: n in NAT by ORDINAL1:def 13;
   assume d is_a_unity_wrt B;
   then A2: B has_a_unity & d = the_unity_wrt B by BINOP_1:def 8,SETWISEO:def 2
;
      now let b be Element of (n-tuples_on D) qua non empty set;
    reconsider b' = b as Element of n-tuples_on D;
    thus product(B,n).(n .--> d,b) = B.:(n .--> d,b') by Def1
                     .= b by A1,A2,FINSEQOP:57;
    thus product(B,n).(b,n .--> d) = B.:(b',n .--> d) by Def1
                     .= b by A2,A1,FINSEQOP:57;
   end;
   hence thesis by BINOP_1:11;
  end;

theorem Th17:
  B has_a_unity & B is associative & C is_an_inverseOp_wrt B implies
   product(C,n) is_an_inverseOp_wrt product(B,n)
   proof
A1: n in NAT by ORDINAL1:def 13;
     assume
   A2: B has_a_unity & B is associative & C is_an_inverseOp_wrt B;
   then A3: B has_an_inverseOp by FINSEQOP:def 2;
   then A4: C = the_inverseOp_wrt B by A2,FINSEQOP:def 3;
        ex d st d is_a_unity_wrt B by A2,SETWISEO:def 2;
     then the_unity_wrt B is_a_unity_wrt B by BINOP_1:def 8;
     then n .-->the_unity_wrt B is_a_unity_wrt product(B,n) by Th16;
   then A5: n |->the_unity_wrt B = the_unity_wrt product(B,n) by BINOP_1:def 8;
       now let f be Element of (n-tuples_on D) qua non empty set;
    reconsider f' = f as Element of n-tuples_on D;
    reconsider cf = C*f' as Element of n-tuples_on D by A1,FINSEQ_2:133;
    thus product(B,n).(f,product(C,n).f) = product(B,n).(f',C*f') by Def2
         .= B.:(f',cf) by Def1
         .= n |->the_unity_wrt B by A1,A2,A3,A4,FINSEQOP:77;
    thus product(B,n).(product(C,n).f,f) = product(B,n).(C*f',f') by Def2
         .= B.:(cf,f') by Def1
         .= n |->the_unity_wrt B by A1,A2,A3,A4,FINSEQOP:77;
    end;
    hence thesis by A5,FINSEQOP:def 1;
   end;

begin :: The $n$-Power of a Group and of a Field

definition let F be non empty LoopStr, n;
  assume A1:F is Abelian add-associative right_zeroed right_complementable;
  func n -Group_over F -> strict AbGroup equals :Def3:
     LoopStr(# n-tuples_on the carrier of F,
        product(the add of F,n),
        (n .--> the Zero of F) qua Element of n-tuples_on the carrier of F#);
  coherence
   proof
     set G = LoopStr(# n-tuples_on the carrier of F,product(the add of F,n),
       (n .--> the Zero of F) qua Element of n-tuples_on the carrier of F#);
     reconsider G as non empty LoopStr;
        the add of F is commutative associative by A1,FVSUM_1:2,3;
     then A2: product(the add of F,n) is commutative associative by Th14,Th15;
A3:   the Zero of F is_a_unity_wrt the add of F by A1,Th3;
     then A4: (n .--> the Zero of F) qua Element of n-tuples_on the carrier of
F
       is_a_unity_wrt product(the add of F,n) by Th16;
        G is right_complementable
     proof
       let x be Element of G;
       set C = comp F; set B = the add of F;
A5:    B is associative & C is_an_inverseOp_wrt B by A1,Lm1,FVSUM_1:3;
          B has_a_unity by A3,SETWISEO:def 2;
then A6:    product(C,n) is_an_inverseOp_wrt product(B,n) by A5,Th17;
       reconsider y = (product (comp F,n)).x as Element of G by FUNCT_2:7;
          the Zero of F is_a_unity_wrt the add of F by A1,Th3;
then A7:    the Zero of G is_a_unity_wrt the add of G by Th16;
          product(B,n).(x,product(C,n).x) = the_unity_wrt product(B,n)
         by A6,FINSEQOP:def 1;
       then x + y = the_unity_wrt product(B,n) by RLVECT_1:5;
       then x + y = the Zero of G by A7,BINOP_1:def 8;
       then x + y = 0.G;
       hence thesis;
     end;
     hence thesis by A2,A4,Lm2,Lm3;
  end;
end;

registration let F be AbGroup, n;
 cluster n-Group_over F -> non empty;
 coherence;
end;

reserve x,y for set;

definition let F,n;
  func n -Mult_over F -> Function of
    [:the carrier of F,n-tuples_on the carrier of F:],
    n-tuples_on the carrier of F means :Def4:
   for x being Element of F,
       v being Element of n-tuples_on the carrier of F holds
    it.(x,v) = (the mult of F)[;](x,v);
  existence
  proof
     defpred P[set,set] means (ex x1 being Element of F,
      v being Element of n-tuples_on the carrier of F st $1=[x1,v] &
       $2=(the mult of F)[;](x1,v));
A1:  for x st x in [:the carrier of F,n-tuples_on the carrier of F:]
      ex y st y in n-tuples_on the carrier of F & P[x,y]
     proof
     let x;
     assume x in [:the carrier of F,n-tuples_on the carrier of F:];
     then consider x1,v being set such that
A2:      x1 in the carrier of F &
     v in n-tuples_on the carrier of F & [x1,v] = x by ZFMISC_1:103;
     reconsider x1 as Element of F by A2;
     reconsider v as Element of n-tuples_on the carrier of F by A2;
     take y = (the mult of F)[;](x1,v);
     n in NAT by ORDINAL1:def 13;
     then y is Element of n-tuples_on the carrier of F by FINSEQ_2:141;
     hence y in n-tuples_on the carrier of F;
     take x1,v; thus thesis by A2;
     end;
   consider f be Function of [:the carrier of F,n-tuples_on the carrier of F:],
   n-tuples_on the carrier of F such that
A3: for x st x in [:the carrier of F,n-tuples_on the carrier of F:] holds
     P[x,f.x] from FUNCT_2:sch 1(A1);
     take f;let x be Element of F,
       v be Element of n-tuples_on the carrier of F;
         [x,v] in [:the carrier of F,n-tuples_on the carrier of F:]
          by ZFMISC_1:106;
     then consider x1 being Element of F ,
     v1 being Element of n-tuples_on the carrier of F such that
A4:      [x,v]=[x1,v1] & f.[x,v]=(the mult of F)[;](x1,v1) by A3;
         x1 = x & v1 = v by A4,ZFMISC_1:33;
   hence f.(x,v) = (the mult of F)[;](x,v) by A4;
  end;
  uniqueness
  proof
   let f,g be Function of [:the carrier of F,n-tuples_on the carrier of F:],
                          n-tuples_on the carrier of F;
   assume that
A5:   for x being Element of F,v being Element of n-tuples_on
   the carrier of F holds f.(x,v) = (the mult of F)[;](x,v) and
A6:   for x being Element of F,v being Element of n-tuples_on
   the carrier of F holds g.(x,v) = (the mult of F)[;](x,v);
      now let x be Element of F,
           v be Element of n-tuples_on the carrier of F;
        f.(x,v) = (the mult of F)[;](x,v) by A5;
    hence f.(x,v)=g.(x,v) by A6;
   end;
   hence thesis by BINOP_1:2;
  end;
 end;

definition let F,n;
  func n -VectSp_over F -> strict VectSpStr over F means :Def5:
   the LoopStr of it = n -Group_over F &
   the lmult of it = n -Mult_over F;
  existence
   proof
       the carrier of n-Group_over F = n-tuples_on the carrier of F
       proof
            n-Group_over F = LoopStr(# n-tuples_on the carrier of F,
          product(the add of F,n),
          (n .--> the Zero of F) qua Element of n-tuples_on the carrier of F#)
          by Def3;
        hence thesis;
       end;
    then reconsider d = n-Mult_over F as Function of
     [:the carrier of F, the carrier of n-Group_over F:],
      the carrier of n-Group_over F;
    set G = n-Group_over F;
    take VectSpStr(#car(G), ad(G), zr(G), d#); thus thesis;
   end;
  uniqueness;
 end;

registration let F,n;
 cluster n -VectSp_over F -> non empty;
 coherence
  proof
A1:  the carrier of n -Group_over F is non empty;
       the LoopStr of n -VectSp_over F = n -Group_over F by Def5;
   hence the carrier of n -VectSp_over F is non empty by A1;
  end;
end;

 reserve D for non empty set,
         H,G for BinOp of D,
         d for Element of D,
         t1,t2 for Element of n-tuples_on D;

theorem Th18:
  H is_distributive_wrt G implies H[;](d,G.:(t1,t2)) = G.:
(H[;](d,t1),H[;](d,t2))
  proof
  assume A1: H is_distributive_wrt G;
A2:    H[;](d,G.:(t1,t2)) = H[;](d,G*<:t1,t2:>) by FUNCOP_1:def 3
           .= H*<:dom (G*<:t1,t2:>) --> d,G*<:t1,t2:>:> by FUNCOP_1:def 5;
   set A = H*<:dom (G*<:t1,t2:>) --> d,G*<:t1,t2:>:>;
A3:    G.:(H[;](d,t1),H[;](d,t2)) = G.:(H*<:dom t1 -->d,t1:>,H[;](d,t2))
                                         by FUNCOP_1:def 5
            .= G.:(H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>)
                                         by FUNCOP_1:def 5
            .= G*<:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:>
                                         by FUNCOP_1:def 3;
A4:    dom A = Seg n
   proof
A5:     dom t1 = Seg (len t1) by FINSEQ_1:def 3
              .= Seg n by FINSEQ_2:109;
       dom t2 = Seg (len t2) by FINSEQ_1:def 3
              .= Seg n by FINSEQ_2:109;
    then A6: dom <:t1,t2:> = Seg n by A5,FUNCT_3:70;
       rng t1 c= D & rng t2 c= D by FINSEQ_1:def 4;
    then A7: [:rng t1,rng t2:] c= [:D,D:] by ZFMISC_1:119;
       rng <:t1,t2:> c= [:rng t1,rng t2:] by FUNCT_3:71;
    then rng <:t1,t2:> c= [:D,D:] by A7,XBOOLE_1:1;
    then rng <:t1,t2:> c= dom G by FUNCT_2:def 1;
    then A8: dom (G*<:t1,t2:>) = Seg n by A6,RELAT_1:46;
    then dom (dom (G*<:t1,t2:>) -->d) = Seg n by FUNCOP_1:19;
    then A9: dom <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:>
               = Seg n by A8,FUNCT_3:70;
        rng <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> c= dom H
        proof
A10:         rng <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> c=
             [:rng (dom (G*<:t1,t2:>) -->d),rng (G*<:t1,t2:>):]
                    by FUNCT_3:71;
           rng (dom (G*<:t1,t2:>) -->d) c= {d} & {d} c= D
                              by FUNCOP_1:19,ZFMISC_1:37;
        then A11: rng (dom (G*<:t1,t2:>) -->d) c= D by XBOOLE_1:1;
A12:         rng (G*<:t1,t2:>) c= rng G by RELAT_1:45;
           rng G c= D by RELSET_1:12;
        then rng (G*<:t1,t2:>) c= D by A12,XBOOLE_1:1;
        then [:rng (dom (G*<:t1,t2:>) -->d),rng (G*<:t1,t2:>):] c= [:D,D:]
                             by A11,ZFMISC_1:119;
        then rng <: dom (G*<:t1,t2:>) -->d,G*<:t1,t2:>:> c= [:D,D:] &
             dom H = [:D,D:] by A10,FUNCT_2:def 1,XBOOLE_1:1;
        hence thesis;
        end;
     hence thesis by A9,RELAT_1:46;
    end;
A13:     dom (G*<:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:>) = Seg n
    proof
A14:      rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c= dom G
         proof
             rng (H*<:dom t1 -->d,t1:>) c= rng H &
          rng (H*<:dom t2 -->d,t2:>) c= rng H by RELAT_1:45;
          then A15: rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c=
          [:rng (H*<:dom t1 -->d,t1:>),rng (H*<:dom t2 -->d,t2:>):]
          & [:rng (H*<:dom t1 -->d,t1:>),rng (H*<:dom t2 -->d,t2:>):]
          c= [:rng H,rng H:] by FUNCT_3:71,ZFMISC_1:119;
             rng H c= D by RELSET_1:12;
          then rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> c=
           [:rng H,rng H:] & [:rng H,rng H:] c= [:D,D:]
              by A15,XBOOLE_1:1,ZFMISC_1:119;
          then rng <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:>
               c= [:D,D:] & dom G = [:D,D:] by FUNCT_2:def 1,XBOOLE_1:1;
          hence thesis;
         end;
         dom (H*<:dom t1 -->d,t1:>) = Seg n
          & dom (H*<:dom t2 -->d,t2:>) = Seg n
         proof
            rng t1 c= D by FINSEQ_1:def 4;
         then A16: rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),rng t1:]
           & [:rng (dom t1 -->d),rng t1:] c= [:rng (dom t1 -->d),D:]
                          by FUNCT_3:71,ZFMISC_1:119;
            rng (dom t1 -->d) c= {d} by FUNCOP_1:19;
         then A17: rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),D:]
           & [:rng (dom t1 -->d),D:] c= [:{d},D:]
                          by A16,XBOOLE_1:1,ZFMISC_1:119;
            {d} c= D by ZFMISC_1:37;
         then A18: rng <:dom t1 -->d,t1:> c= [:{d},D:]
           & [:{d},D:] c= [:D,D:] by A17,XBOOLE_1:1,ZFMISC_1:119;
            dom H = [:D,D:] by FUNCT_2:def 1;
         then A19: rng <:dom t1 -->d,t1:> c= dom H by A18,XBOOLE_1:1;
A20:          dom (dom t1 -->d) = dom t1 by FUNCOP_1:19
                   .= Seg (len t1) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
A21:          dom t1 = Seg (len t1) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
A22:          dom (H*<:dom t1 -->d,t1:>) = dom <:dom t1 -->d,t1:>
                          by A19,RELAT_1:46
                   .= Seg n by A20,A21,FUNCT_3:70;
            rng t2 c= D by FINSEQ_1:def 4;
         then A23: rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),rng t2:]
           & [:rng (dom t2 -->d),rng t2:] c= [:rng (dom t2 -->d),D:]
                          by FUNCT_3:71,ZFMISC_1:119;
            rng (dom t2 -->d) c= {d} by FUNCOP_1:19;
         then A24: rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),D:]
           & [:rng (dom t2 -->d),D:] c= [:{d},D:]
                          by A23,XBOOLE_1:1,ZFMISC_1:119;
            {d} c= D by ZFMISC_1:37;
         then A25: rng <:dom t2 -->d,t2:> c= [:{d},D:]
           & [:{d},D:] c= [:D,D:] by A24,XBOOLE_1:1,ZFMISC_1:119;
            dom H = [:D,D:] by FUNCT_2:def 1;
         then A26: rng <: dom t2 -->d,t2:> c= dom H by A25,XBOOLE_1:1;
A27:          dom (dom t2 -->d) = dom t2 by FUNCOP_1:19
                   .= Seg (len t2) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
A28:          dom t2 = Seg (len t2) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
            dom (H*<:dom t2-->d,t2:>) = dom <:dom t2 -->d,t2:>
                          by A26,RELAT_1:46
                   .= Seg n by A27,A28,FUNCT_3:70;
         hence thesis by A22;
         end;
     then dom <:H*<:dom t1 -->d,t1:>,H*<:dom t2 -->d,t2:>:> = Seg n
                  by FUNCT_3:70;
     hence thesis by A14,RELAT_1:46;
    end;
     for x st x in dom A holds H[;](d,G.:(t1,t2)).x = G.:(H[;](d,t1),H[;](d,t2)
)
.
x
     proof
     let x;assume A29: x in dom A;
     then x in dom (H*<:dom (G.:(t1,t2)) -->d,G.:
(t1,t2):>) by A2,FUNCOP_1:def 5;
     then A30: x in dom <:dom (G.:(t1,t2)) -->d,G.:(t1,t2):> by FUNCT_1:21;
        dom <:dom (G.:(t1,t2)) -->d,G.:(t1,t2):> =
          dom (dom (G.:(t1,t2)) -->d) /\ dom (G.:(t1,t2)) by FUNCT_3:def 8;
     then A31: x in dom (G.:(t1,t2)) by A30,XBOOLE_0:def 3;
A32:      t1.x in D & t2.x in D
         proof
A33:       dom t1 = Seg (len t1) by FINSEQ_1:def 3
               .= Seg n by FINSEQ_2:109;
A34:       rng t1 c= D by FINSEQ_1:def 4;
A35:      t1.x in rng t1 by A4,A29,A33,FUNCT_1:def 5;
A36:       dom t2 = Seg (len t2) by FINSEQ_1:def 3
               .= Seg n by FINSEQ_2:109;
A37:       rng t2 c= D by FINSEQ_1:def 4;
              t2.x in rng t2 by A4,A29,A36,FUNCT_1:def 5;
          hence thesis by A34,A35,A37;
         end;
A38:      x in dom (H[;](d,t1)) & x in dom (H[;](d,t2))
         proof
             dom (H*<:dom t1 -->d,t1:>) = Seg n
          & dom (H*<:dom t2 -->d,t2:>) = Seg n
         proof
            rng t1 c= D by FINSEQ_1:def 4;
         then A39: rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),rng t1:]
           & [:rng (dom t1 -->d),rng t1:] c= [:rng (dom t1 -->d),D:]
                          by FUNCT_3:71,ZFMISC_1:119;
            rng (dom t1 -->d) c= {d} by FUNCOP_1:19;
         then A40: rng <:dom t1 -->d,t1:> c= [:rng (dom t1 -->d),D:]
           & [:rng (dom t1 -->d),D:] c= [:{d},D:]
                          by A39,XBOOLE_1:1,ZFMISC_1:119;
            {d} c= D by ZFMISC_1:37;
         then A41: rng <:dom t1 -->d,t1:> c= [:{d},D:]
           & [:{d},D:] c= [:D,D:] by A40,XBOOLE_1:1,ZFMISC_1:119;
            dom H = [:D,D:] by FUNCT_2:def 1;
         then A42: rng <:dom t1 -->d,t1:> c= dom H by A41,XBOOLE_1:1;
A43:          dom (dom t1 -->d) = dom t1 by FUNCOP_1:19
                   .= Seg (len t1) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
A44:          dom t1 = Seg (len t1) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
A45:          dom (H*<:dom t1 -->d,t1:>) = dom <:dom t1 -->d,t1:>
                          by A42,RELAT_1:46
                   .= Seg n by A43,A44,FUNCT_3:70;
            rng t2 c= D by FINSEQ_1:def 4;
         then A46: rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),rng t2:]
           & [:rng (dom t2 -->d),rng t2:] c= [:rng (dom t2 -->d),D:]
                          by FUNCT_3:71,ZFMISC_1:119;
            rng (dom t2 -->d) c= {d} by FUNCOP_1:19;
         then A47: rng <:dom t2 -->d,t2:> c= [:rng (dom t2 -->d),D:]
           & [:rng (dom t2 -->d),D:] c= [:{d},D:]
                          by A46,XBOOLE_1:1,ZFMISC_1:119;
            {d} c= D by ZFMISC_1:37;
         then A48: rng <:dom t2 -->d,t2:> c= [:{d},D:]
           & [:{d},D:] c= [:D,D:] by A47,XBOOLE_1:1,ZFMISC_1:119;
            dom H = [:D,D:] by FUNCT_2:def 1;
         then A49: rng <: dom t2 -->d,t2:> c= dom H by A48,XBOOLE_1:1;
A50:          dom (dom t2 -->d) = dom t2 by FUNCOP_1:19
                   .= Seg (len t2) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
A51:          dom t2 = Seg (len t2) by FINSEQ_1:def 3
                   .= Seg n by FINSEQ_2:109;
            dom (H*<:dom t2-->d,t2:>) = dom <:dom t2 -->d,t2:>
                          by A49,RELAT_1:46
                   .= Seg n by A50,A51,FUNCT_3:70;
         hence thesis by A45;
         end;
         hence thesis by A4,A29,FUNCOP_1:def 5;
         end;
        H[;](d,G.:(t1,t2)).x = H.(d,G.:(t1,t2).x) by A2,A29,FUNCOP_1:42
                 .= H.(d,G.(t1.x,t2.x)) by A31,FUNCOP_1:28
                 .= G.(H.(d,t1.x),H.(d,t2.x)) by A1,A32,BINOP_1:23
                 .= G.((H[;](d,t1)).x,H.(d,t2.x)) by A38,FUNCOP_1:42
                 .= G.((H[;](d,t1)).x,(H[;](d,t2)).x) by A38,FUNCOP_1:42
                 .= (G.:
(H[;](d,t1),H[;](d,t2))).x by A3,A4,A13,A29,FUNCOP_1:28;
     hence thesis;
     end;
  hence thesis by A2,A3,A4,A13,FUNCT_1:9;
  end;

definition let D be non empty set,
             n be Nat,
             F be BinOp of D,
             x be Element of D,
             v be Element of n-tuples_on D;
  redefine func F[;](x,v) -> Element of n-tuples_on D;
   coherence
   proof
     n in NAT by ORDINAL1:def 13;
     hence thesis by FINSEQ_2:141;
   end;
 end;

registration let F,n;
  cluster n -VectSp_over F -> VectSp-like;
   coherence
   proof
A1:       1.F is_a_unity_wrt the mult of F by Th11;
then A2:  the mult of F has_a_unity by SETWISEO:def 2;
A3:       the_unity_wrt the mult of F = 1.F by A1,BINOP_1:def 8;
A4:       the mult of F is associative by Lm4;
A5:       the mult of F is_distributive_wrt the add of F by Lm5;
A6:       the LoopStr of n -VectSp_over F=n-Group_over F by Def5;
A7:       n-Group_over F=LoopStr(# n-tuples_on the carrier of F,
        product(the add of F,n),
        (n .--> the Zero of F) qua Element of n-tuples_on the carrier of F#)
        by Def3;
     n-VectSp_over F is VectSp-like proof
   let x,y be Element of F;
   let v,w be Element of n -VectSp_over F;
   reconsider v'=v,w'=w as Element of n-tuples_on the carrier of F by A6,A7;
   thus x*(v+w) = (the lmult of n-VectSp_over F).(x,
               (the add of n-Group_over F).(v,w)) by A6,RLVECT_1:5
          .= (n-Mult_over F).(x,product(the add of F,n).(v,w))
                by A7,Def5
          .= (n-Mult_over F).(x,(the add of F).:(v',w')) by Def1
          .= (the mult of F)[;](x,(the add of F).:(v',w')) by Def4
          .= (the add of F).:
((the mult of F)[;](x,v'),(the mult of F)[;](x,w'))
                by A5,Th18
          .= product(the add of F,n).((the mult of F)[;](x,v'),
                (the mult of F)[;](x,w')) by Def1
          .= product(the add of F,n).((n-Mult_over F).(x,v'),
                (the mult of F)[;](x,w')) by Def4
          .= product(the add of F,n).((n-Mult_over F).(x,v'),
                (n-Mult_over F).(x,w')) by Def4
          .= product(the add of F,n).((the lmult of n-VectSp_over F).(x,v),
                (n-Mult_over F).(x,w')) by Def5
          .= (the add of n-Group_over F).(x*v,(the lmult of n-VectSp_over F).
                (x,w)) by A7,Def5
          .= x*v + x*w by A6,RLVECT_1:5;
A8: n in NAT by ORDINAL1:def 13;
thus (x+y)*v = (n-Mult_over F).(x+y,v') by Def5
          .= (the mult of F)[;](x+y,v') by Def4
          .= (the mult of F)[;]((the add of F).(x,y),v') by RLVECT_1:5
          .= (the add of F).:
((the mult of F)[;](x,v'),(the mult of F)[;](y,v'))
                by A8,A5,FINSEQOP:47
          .= product(the add of F,n).((the mult of F)[;](x,v'),
                (the mult of F)[;](y,v')) by Def1
          .= product(the add of F,n).((n-Mult_over F).(x,v'),
                (the mult of F)[;](y,v')) by Def4
          .= product(the add of F,n).((n-Mult_over F).(x,v'),
                (n-Mult_over F).(y,v')) by Def4
          .= product(the add of F,n).((the lmult of n-VectSp_over F).(x,v),
                (n-Mult_over F).(y,v')) by Def5
          .= (the add of n-Group_over F).(x*v,(the lmult of n-VectSp_over F).
                (y,v)) by A7,Def5
          .= x*v + y*v by A6,RLVECT_1:5;
   thus (x*y)*v = (n-Mult_over F).(x*y,v') by Def5
          .= (the mult of F)[;](x*y,v') by Def4
          .= (the mult of F)[;]((the mult of F).(x,y),v') by GROUP_1:def 1
          .= (the mult of F)[;](x,(the mult of F)[;](y,v'))
          by A8,A4,FINSEQOP:32
          .= (n-Mult_over F).(x,(the mult of F)[;](y,v')) by Def4
          .= (n-Mult_over F).(x,(n-Mult_over F).(y,v')) by Def4
          .= (n-Mult_over F).(x,(the lmult of n-VectSp_over F).(y,v)) by Def5
          .= x*(y*v) by Def5;
  thus (1.F)*v = (n-Mult_over F).(1.F,v') by Def5
          .= (the mult of F)[;](1.F,v') by Def4
          .= v by A8,A2,A3,FINSEQOP:58;
   thus thesis;
   end;
   hence thesis;
   end;
 end;

begin :: Sequences of domains

reserve x,y,y1,y2,z for set,

         A for AbGroup,
         D for non empty set;

registration
  cluster non empty non-empty FinSequence;
   existence
    proof consider D;
     take <*D*>;
     thus <*D*> is non empty;
     assume {} in rng <*D*>;
     then {} in {D} by FINSEQ_1:55;
     hence contradiction by TARSKI:def 1;
    end;
 end;

definition
  mode Domain-Sequence is non empty non-empty FinSequence;
 end;

registration
  let a be non empty Function;
  cluster dom a -> non empty;
   coherence
   proof
    consider x being Element of a;
    consider y,z such that A1: x = [y,z] by RELAT_1:def 1;
    thus thesis by A1,RELAT_1:def 4;
   end;
 end;

scheme NEFinSeqLambda {w()-> non empty FinSequence, F(set)->set}:
 ex p being non empty FinSequence st len p = len w() &
  for i being Element of dom w() holds p.i = F(i)
proof
   consider p being FinSequence such that
A1:    len p = len w() &
       for i being Element of NAT st i in Seg len w() holds p.i = F(i)
               from FINSEQ_1:sch 2;
     consider x being Element of dom w();
         dom p = dom w() by A1,FINSEQ_3:31;
      then [x,p.x] in p & p = p by FUNCT_1:def 4;
    then reconsider p'=p as non empty FinSequence;
    take p';
    thus len p' = len w() by A1;
    let i be Element of dom w();
        dom w() = Seg len w() by FINSEQ_1:def 3;
    hence p'.i = F(i) by A1;
  end;

registration
  let a be non-empty non empty Function;
  let i be Element of dom a;
  cluster a.i -> non empty;
   coherence
    proof
        a.i in rng a by FUNCT_1:def 5;
     hence thesis by RELAT_1:def 9;
    end;
end;

definition let a be non-empty non empty Function;
 let f be Element of product a;
 let i be Element of dom a;
 redefine func f.i -> Element of a.i;
  coherence by CARD_3:18;
end;

begin :: The Product of Families of Operations

reserve a for Domain-Sequence,
        i for Element of dom a,
        p for FinSequence;

definition let a be non-empty non empty Function;
 canceled 2;

  mode BinOps of a -> Function means:Def8:
   dom it = dom a & for i being Element of dom a holds it.i is BinOp of a.i;
   existence
    proof
     deffunc F(set) = pr1(a.$1,a.$1);
     consider f being Function such that
A1:    dom f = dom a & for x st x in dom a holds f.x = F(x) from FUNCT_1:sch 3;
     take f; thus dom f = dom a by A1;
     let i be Element of dom a;
         f.i = pr1(a.i,a.i) by A1;
     hence thesis;
    end;
  mode UnOps of a -> Function means:
Def9:
   dom it = dom a & for i being Element of dom a holds it.i is UnOp of a.i;
   existence
    proof
     deffunc F(set) = id (a.$1);
     consider f being Function such that
A2:    dom f = dom a & for x st x in dom a holds f.x = F(x) from FUNCT_1:sch 3;
     take f; thus dom f = dom a by A2;
     let i be Element of dom a;
         f.i = id (a.i) by A2;
     hence thesis;
    end;
end;

registration let a;
 cluster -> FinSequence-like BinOps of a;
  coherence
   proof let f be BinOps of a;
        dom a = dom f & dom a = Seg len a by Def8,FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
   end;
 cluster -> FinSequence-like UnOps of a;
  coherence
   proof let f be UnOps of a;
        dom a = dom f & dom a = Seg len a by Def9,FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
   end;
end;

theorem Th19:
 p is BinOps of a iff len p = len a &
  for i holds p.i is BinOp of a.i
  proof
       dom p = dom a iff len p = len a by FINSEQ_3:31;
   hence thesis by Def8;
  end;

theorem Th20:
 p is UnOps of a iff len p = len a &
  for i holds p.i is UnOp of a.i
  proof
       dom p = dom a iff len p = len a by FINSEQ_3:31;
   hence thesis by Def9;
  end;

definition let a;
  let b be BinOps of a;
  let i;
  redefine func b.i -> BinOp of a.i;
   coherence by Th19;
 end;

definition let a;
 let u be UnOps of a;
 let i;
 redefine func u.i -> UnOp of a.i;
  coherence by Th20;
end;

theorem
    for d,d' being UnOp of product a st
  for f being Element of product a, i being Element of dom a
    holds (d.f).i = (d'.f).i holds d = d'
  proof let d,d' be UnOp of product a such that
A1:  for f being Element of product a,
        i being Element of dom a holds (d.f).i = (d'.f).i;
       now let f be Element of product a;
         dom (d.f) = dom a & dom (d'.f) = dom a &
      for x st x in dom a holds (d.f).x = (d'.f).x by A1,CARD_3:18;
     hence d.f = d'.f by FUNCT_1:9;
    end;
   hence thesis by FUNCT_2:113;
  end;

theorem Th22:
 for u being UnOps of a holds
  doms u = a & product rngs u c= product a
  proof let u be UnOps of a;
A1:  dom doms u = u"SubFuncs rng u & dom rngs u = u"SubFuncs rng u &
    dom a = Seg len a & dom u = Seg len u & len u = len a
     by Th20,FINSEQ_1:def 3,FUNCT_6:def 2,def 3;
A2:  dom u c= u"SubFuncs rng u
     proof let x; assume x in dom u;
      then reconsider x as Element of dom a by A1;
          u.x is UnOp of a.x;
      hence thesis by A1,FUNCT_6:28;
     end;
       u"SubFuncs rng u c= dom u by RELAT_1:167;
then A3:  dom doms u = dom u by A1,A2,XBOOLE_0:def 10;
       now let x; assume x in dom u;
     then reconsider i = x as Element of dom a by A1;
         (doms u).i = dom (u.i) by A1,FUNCT_6:31 .= a.i by FUNCT_2:def 1;
     hence (doms u).x = a.x;
    end;
   hence doms u = a by A1,A3,FUNCT_1:9;
       now let x; assume x in dom u;
     then reconsider i = x as Element of dom a by A1;
         (rngs u).i = rng (u.i) & rng (u.i) c= a.i by A1,FUNCT_6:31,RELSET_1:12
;
     hence (rngs u).x c= a.x;
    end;
   hence thesis by A1,A3,CARD_3:38;
  end;

definition let a;
 let u be UnOps of a;
 redefine func Frege u -> UnOp of product a;
  coherence
   proof
        dom Frege u = product doms u & doms u = a & product rngs u c= product a
&
     rng Frege u = product rngs u by Th22,FUNCT_6:58,def 7;
    hence thesis by FUNCT_2:def 1,RELSET_1:11;
   end;
end;

theorem Th23:
 for u being UnOps of a for f being Element of product a,
     i being Element of dom a holds (Frege u).f.i = (u.i).(f.i)
  proof let u be UnOps of a, f be Element of product a;
   let i be Element of dom a;
       dom a = Seg len a & len a = len u & dom u = Seg len u & doms u = a
     by Th20,Th22,FINSEQ_1:def 3;
   hence thesis by FUNCT_6:57;
  end;

definition let F be functional non empty set;
 let b be BinOp of F, f,g be Element of F;
 redefine func b.(f,g) -> Element of F;
  coherence
   proof b.(f,g) is Element of F;
    hence thesis;
   end;
end;

theorem Th24:
 for d,d' being BinOp of product a st
  for f,g being Element of product a, i being Element of dom a
      holds (d.(f,g)).i = (d'.(f,g)).i holds d = d'
  proof let d,d' be BinOp of product a such that
A1:  for f,g be Element of product a, i be Element of dom a
             holds (d.(f,g)).i = (d'.(f,g)).i;
       now let f,g be Element of product a;
         dom (d.(f,g)) = dom a & dom (d'.(f,g)) = dom a &
      for x st x in dom a holds (d.(f,g)).x = (d'.(f,g)).x by A1,CARD_3:18;
     hence d.(f,g) = d'.(f,g) by FUNCT_1:9;
    end;
   hence thesis by BINOP_1:2;
  end;

reserve i for Element of dom a;

definition let a;
 let b be BinOps of a;
 func [:b:] -> BinOp of product a means :Def10:
  for f,g being Element of product a,
      i being Element of dom a holds (it.(f,g)).i = (b.i).(f.i,g.i);
  existence
   proof
    defpred Q[Element of product a,Element of product a,Element of product a]
     means for i being Element of dom a holds $3.i = (b.i).($1.i,$2.i);
A1:  for f,g being Element of product a ex z being Element of product a st
      Q[f,g,z]
      proof let f,g be Element of product a;
        defpred P[set,set] means ex i st $1 =i & $2 = (b.i).(f.i,g.i);
A2:      for x,z1,z2 being set st x in dom a & P[x,z1] & P[x,z2] holds z1 = z2;
A3:      for x st x in dom a ex z st P[x,z]
         proof let x; assume x in dom a;
          then reconsider i = x as Element of dom a;
          take (b.i).(f.i,g.i);
          thus thesis;
         end;
       consider z being Function such that
A4:     dom z = dom a & for x being set st x in dom a holds P[x,z.x]
        from FUNCT_1:sch 2(A2,A3);
           now let x; assume x in dom a;
         then ex i st x = i & z.x = (b.i).(f.i,g.i) by A4;
         hence z.x in a.x;
        end;
       then reconsider z' = z as Element of product a by A4,CARD_3:18;
       take z'; let i;
           ex j being Element of dom a st j = i & z.i = (b.j).(f.j,g.j) by A4;
       hence thesis;
      end;
     consider d being BinOp of product a such that
A5:  for f,g being Element of product a holds Q[f,g,d.(f,g)] from BINOP_1:sch 3
(A1);
     take d; thus thesis by A5;
   end;
  uniqueness
   proof let d,d' be BinOp of product a such that
A6:   for f,g being Element of product a,i being Element of dom a holds
      (d.(f,g)).i = (b.i).(f.i,g.i) and
A7:   for f,g being Element of product a,i being Element of dom a holds
      (d'.(f,g)).i = (b.i).(f.i,g.i);
        now let f,g be Element of product a; let i be Element of dom a;
      thus (d.(f,g)).i = (b.i).(f.i,g.i) by A6 .= (d'.(f,g)).i by A7;
     end;
    hence thesis by Th24;
   end;
end;

theorem Th25:
 for b being BinOps of a st for i holds b.i is commutative
  holds [:b:] is commutative
  proof let b be BinOps of a such that
A1:  for i holds b.i is commutative;
   let x,y be Element of product a;
A2:  dom ([:b:].(x,y)) = dom a & dom ([:b:].(y,x)) = dom a by CARD_3:18;
       now let z; assume z in dom a;
     then reconsider i = z as Element of dom a;
         b.i is commutative & [:b:].(x,y).i = (b.i).(x.i,y.i) &
      [:b:].(y,x).i = (b.i).(y.i,x.i) by A1,Def10;
     hence [:b:].(x,y).z = [:b:].(y,x).z by BINOP_1:def 2;
    end;
   hence thesis by A2,FUNCT_1:9;
  end;

theorem Th26:
 for b being BinOps of a st for i holds b.i is associative
  holds [:b:] is associative
  proof let b be BinOps of a such that
A1:  for i holds b.i is associative;
   let x,y,z be Element of product a;
A2:  dom ([:b:].(x,[:b:].(y,z))) = dom a & dom ([:b:].([:b:].(x,y),z)) = dom a
     by CARD_3:18;
       now let v be set; assume v in dom a;
     then reconsider i = v as Element of dom a;
     set xy = [:b:].(x,y), yz = [:b:].(y,z);
         b.i is associative & [:b:].(x,y).i = (b.i).(x.i,y.i) &
      [:b:].(y,z).i = (b.i).(y.i,z.i) & [:b:].(x,yz).i = (b.i).(x.i,yz.i) &
      [:b:].(xy,z).i = (b.i).(xy.i,z.i) by A1,Def10;
     hence [:b:].(x,[:b:].(y,z)).v = [:b:].([:b:].(x,y),z).v by BINOP_1:def 3;
    end;
   hence thesis by A2,FUNCT_1:9;
  end;

theorem Th27:
 for b being BinOps of a, f being Element of product a st
  for i holds f.i is_a_unity_wrt b.i holds f is_a_unity_wrt [:b:]
  proof let b be BinOps of a, f be Element of product a such that
A1:  for i holds f.i is_a_unity_wrt b.i;
       now let x be Element of product a;
A2:    dom ([:b:].(x,f)) = dom a & dom ([:b:].(f,x)) = dom a & dom x = dom a
       by CARD_3:18;
         now let y; assume y in dom a;
       then reconsider i = y as Element of dom a;
       [:b:].(f,x).i = (b.i).(f.i,x.i) & f.i is_a_unity_wrt b.i by A1,Def10;
       hence [:b:].(f,x).y = x.y by BINOP_1:11;
      end;
     hence [:b:].(f,x) = x by A2,FUNCT_1:9;
         now let y; assume y in dom a;
       then reconsider i = y as Element of dom a;
       [:b:].(x,f).i = (b.i).(x.i,f.i) & f.i is_a_unity_wrt b.i by A1,Def10;
       hence [:b:].(x,f).y = x.y by BINOP_1:11;
      end;
     hence [:b:].(x,f) = x by A2,FUNCT_1:9;
    end;
   hence thesis by BINOP_1:11;
  end;

theorem Th28:
 for b being BinOps of a, u being UnOps of a st
  for i holds u.i is_an_inverseOp_wrt b.i & b.i has_a_unity holds
   Frege u is_an_inverseOp_wrt [:b:]
  proof let b be BinOps of a, u be UnOps of a such that
A1:  for i holds u.i is_an_inverseOp_wrt b.i & b.i has_a_unity;
defpred P[set,set] means ex i st $1 = i & $2 = the_unity_wrt (b.i);
A2: for x st x in dom a ex y st P[x,y]
     proof let x; assume x in dom a;
      then reconsider i = x as Element of dom a;
      take the_unity_wrt (b.i); thus thesis;
     end;
A3: for x,y1,y2 st x in dom a & P[x,y1] & P[x,y2] holds y1 = y2;
   consider f being Function such that
A4:  dom f = dom a & for x st x in dom a holds P[x,f.x] from FUNCT_1:sch 2
(A3,A2);
       now let x; assume x in dom a;
      then ex i st x = i & f.x = the_unity_wrt (b.i) by A4;
     hence f.x in a.x;
    end;
   then reconsider f as Element of product a by A4,CARD_3:18;
       now let i;
         ex j being Element of dom a st i = j & f.i = the_unity_wrt (b.j)
       by A4;
      then f.i = the_unity_wrt (b.i) & b.i has_a_unity by A1;
     hence f.i is_a_unity_wrt b.i by SETWISEO:22;
    end;
    then f is_a_unity_wrt [:b:] by Th27;
then A5:  f = the_unity_wrt [:b:] by BINOP_1:def 8;
   let x be Element of product a;
A6: dom ([:b:].(x,(Frege u).x)) = dom a & dom ([:b:].((Frege u).x,x)) = dom a &
    dom f = dom a by CARD_3:18;
       now let y; assume y in dom a;
     then reconsider i = y as Element of dom a;
         ex j being Element of dom a st i = j & f.i = the_unity_wrt (b.j)
       by A4;
      then [:b:].(x,(Frege u).x).i = (b.i).(x.i,(Frege u).x.i) &
      (Frege u).x.i = (u.i).(x.i) &
      f.i = the_unity_wrt (b.i) & u.i is_an_inverseOp_wrt b.i
       by A1,Def10,Th23;
     hence [:b:].(x,(Frege u).x).y = f.y by FINSEQOP:def 1;
    end;
   hence [:b:].(x,(Frege u).x) = the_unity_wrt [:b:] by A5,A6,FUNCT_1:9;
       now let y; assume y in dom a;
     then reconsider i = y as Element of dom a;
         ex j being Element of dom a st i = j & f.i = the_unity_wrt (b.j)
       by A4;
      then [:b:].((Frege u).x,x).i = (b.i).((Frege u).x.i,x.i) &
      (Frege u).x.i = (u.i).(x.i) &
      f.i = the_unity_wrt (b.i) & u.i is_an_inverseOp_wrt b.i
       by A1,Def10,Th23;
     hence [:b:].((Frege u).x,x).y = f.y by FINSEQOP:def 1;
    end;
   hence [:b:].((Frege u).x,x) = the_unity_wrt [:b:] by A5,A6,FUNCT_1:9;
  end;

begin :: The Product of Groups

definition let F be Relation;
  attr F is AbGroup-yielding means:Def11:
    x in rng F implies x is AbGroup;
end;

registration
  cluster non empty AbGroup-yielding FinSequence;
   existence
    proof consider A;
     take <*A*>;
     thus <*A*> is non empty; let x;
     assume A1: x in rng <*A*> & not x is AbGroup;
      then x in {A} by FINSEQ_1:55;
     hence contradiction by A1,TARSKI:def 1;
    end;
end;

definition
 mode Group-Sequence is non empty AbGroup-yielding FinSequence;
end;

definition
  let g be Group-Sequence;
  let i be Element of dom g;
  redefine func g.i -> AbGroup;
   coherence
    proof
        g.i in rng g by FUNCT_1:def 5;
     hence thesis by Def11;
    end;
 end;

definition let g be Group-Sequence;
 func carr g -> Domain-Sequence means :Def12:
  len it = len g & for j be Element of dom g holds it.j = the carrier of g.j;
  existence
   proof
        defpred P[set,set] means ex j' being Element of dom g st j' = $1 &
         $2 = the carrier of g.j';
A1:     for j be Element of NAT,y1,y2 st j in Seg len g & P[j,y1] & P[j,y2]
        holds y1=y2;
A2:     for j being Element of NAT st j in Seg len g ex x st P[j,x]
        proof let j be Element of NAT;
          assume j in Seg len g;
          then reconsider j' = j as Element of dom g by FINSEQ_1:def 3;
          take the carrier of g.j'; thus thesis;
        end;
     consider p being FinSequence such that
A3:   dom p = Seg (len g) &
      for j being Element of NAT st j in Seg len g holds P[j,p.j]
       from FINSEQ_1:sch 1(A1,A2);
A4:   dom g = Seg len g by FINSEQ_1:def 3;
A5:    p is non empty
      proof consider i being Element of dom g;
          dom p = dom g by A3,FINSEQ_1:def 3;
        then [i,p.i] in p & p = p by FUNCT_1:def 4;
     hence p is non empty;
      end;
       p is non-empty
      proof
       assume {} in rng p;
       then consider x such that
A6:         x in dom p & {} = p.x by FUNCT_1:def 5;
       reconsider x as Element of NAT by A6;
       consider x' being Element of dom g such that
A7:       x' = x & p.x = the carrier of g.x' by A3,A6;
       thus contradiction by A6,A7;
      end;
   then reconsider p' = p as Domain-Sequence by A5;
   take p';
   thus len p' = len g by A3,FINSEQ_1:def 3;
   let j be Element of dom g;
   reconsider k = j as Element of NAT;
      ex j' being Element of dom g st j' = k & p'.k = the carrier of g.j'
                                                               by A3,A4;
   hence thesis;
   end;
  uniqueness
   proof let f,h be Domain-Sequence such that
A8:   len f = len g & for j be Element of dom g holds f.j = the carrier of g.j
   and
A9:   len h = len g & for j be Element of dom g holds h.j = the carrier of g.j;
    reconsider f' = f ,h' = h as FinSequence;
A10:       dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
         now let j be Element of NAT;
        assume j in dom f';
        then reconsider j' = j as Element of dom g by A8,FINSEQ_3:31;
             f'.j = the carrier of g.j' by A8;
        hence f'.j = h'.j by A9;
      end;
     hence f = h by A8,A9,A10,FINSEQ_1:17;
   end;
end;

reserve g for Group-Sequence, i for Element of dom carr g;

definition let g,i;
 redefine func g.i -> AbGroup;
  coherence
   proof
       dom g = Seg len g & Seg len(carr g) = dom carr g by FINSEQ_1:def 3;
    then reconsider i' = i as Element of dom g by Def12;
        g.i' is AbGroup;
    hence thesis;
   end;
end;

definition let g;
 func addop g -> BinOps of carr g means :Def13:
  len it = len carr g & for i holds it.i = the add of g.i;
  existence
   proof
    deffunc F(Element of dom carr g) = the add of g.$1;
    consider p being non empty FinSequence such that
A1:      len p = len carr g & for i holds p.i = F(i) from NEFinSeqLambda;
        now let i;
         len g = len (carr g) by Def12;
      then reconsider j = i as Element of dom g by FINSEQ_3:31;
         p.i = the add of g.i & the carrier of g.j = (carr g).j by A1,Def12;
      hence p.i is BinOp of (carr g).i;
     end;
     then reconsider p' = p as BinOps of carr g by A1,Th19;
     take p';
     thus thesis by A1;
   end;
  uniqueness
   proof
    let f,h be BinOps of carr g;
    assume that A2: (len f = len carr g & for i holds f.i = the add of g.i)
            and A3: (len h = len carr g & for i holds h.i = the add of g.i);
     reconsider f' = f,h' = h as FinSequence;
A4:      dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
         now let i be Element of NAT;
       assume i in dom f';
      then reconsider i' = i as Element of dom carr g by A2,FINSEQ_3:31;
           f'.i = the add of g.i' by A2;
       hence f'.i = h'.i by A3;
      end;
     hence f = h by A2,A3,A4,FINSEQ_1:17;
   end;
 func complop g -> UnOps of carr g means:Def14:
  len it = len carr g & for i holds it.i = comp g.i;
  existence
   proof
    deffunc F(Element of dom carr g) = comp g.$1;
    consider p being non empty FinSequence such that
A5:     len p = len carr g & for i holds p.i = F(i) from NEFinSeqLambda;
       now let i;
         len g = len (carr g) by Def12;
      then reconsider j = i as Element of dom g by FINSEQ_3:31;
         p.i = comp g.i & the carrier of g.j = (carr g).j by A5,Def12;
      hence p.i is UnOp of (carr g).i;
    end;
    then reconsider p' = p as UnOps of carr g by A5,Th20;
    take p';
    thus thesis by A5;
   end;
  uniqueness
   proof
    let f,h be UnOps of carr g;
    assume that A6: len f = len carr g & for i holds f.i = comp g.i
            and A7: len h = len carr g & for i holds h.i = comp g.i;
     reconsider f' = f,h' = h as FinSequence;
A8:      dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
           now let i be Element of NAT;
         assume i in dom f';
         then reconsider i' = i as Element of dom carr g by A6,FINSEQ_3:31;
              f.i = comp g.i' by A6;
         hence f.i = h.i by A7;
        end;
      hence f = h by A6,A7,A8,FINSEQ_1:17;
   end;
 func zeros g -> Element of product carr g means :Def15:
  for i holds it.i = the Zero of g.i;
  existence
   proof
      deffunc F(Element of dom carr g) = the Zero of g.$1;
      consider p being non empty FinSequence such that
A9:   len p = len carr g & for i holds p.i = F(i) from NEFinSeqLambda;
A10:dom g = Seg len g & dom (carr g) = Seg len (carr g) & len g = len carr g &
      dom p = Seg len p by Def12,FINSEQ_1:def 3;
        now let i be set; assume i in dom (carr g);
      then reconsider x = i as Element of dom carr g;
      reconsider x' = x as Element of dom g by A10;
      p.x = the Zero of g.x & (carr g).x' = the carrier of g.x' by A9,Def12;
      hence p.i in (carr g).i;
     end;
    then reconsider t = p as Element of product (carr g) by A9,A10,CARD_3:18;
    take t;
    thus thesis by A9;
   end;
  uniqueness
   proof
    let f,h be Element of product carr g;
    assume that A11: (for i holds f.i = the Zero of g.i) and
A12:                 (for i holds h.i = the Zero of g.i);
     reconsider f' = f , h' = h as Function;
A13:       dom f' = dom carr g & dom h' = dom carr g by CARD_3:18;
         now let x; assume x in dom carr g;
       then reconsider i = x as Element of dom carr g;
       thus f'.x = the Zero of g.i by A11 .= h'.x by A12;
      end;
      hence thesis by A13,FUNCT_1:9;
   end;
end;

definition
 let G be Group-Sequence;
 func product G -> strict AbGroup equals
      LoopStr(# product carr G, [:addop G:], zeros G #);
  coherence
   proof
     reconsider GS = LoopStr(# product carr G, [:addop G:], zeros G #)
       as non empty LoopStr;
A1:  now let i be Element of dom carr G;
          dom G = Seg len G by FINSEQ_1:def 3
            .= Seg len carr G by Def12
            .= dom carr G by FINSEQ_1:def 3;
       hence (carr G).i = car(G.i) by Def12;
     end;
        now let i be Element of dom carr G;
          (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def13;
       hence (addop G).i is commutative by FVSUM_1:2;
     end;
then A2:  [:addop G:] is commutative by Th25;
        now let i be Element of dom carr G;
          (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def13;
      hence (addop G).i is associative by FVSUM_1:3;
     end;
     then A3: [:addop G:] is associative by Th26;
        now let i be Element of dom carr G;
          (addop G).i = ad(G.i) & (zeros G).i = zr(G.i) & (carr G).i = car(G.i)
         by A1,Def13,Def15;
       hence (zeros G).i is_a_unity_wrt (addop G).i by Th3;
     end;
then A4:  zeros G is_a_unity_wrt [:addop G:] by Th27;
        GS is right_complementable
     proof
       let x be Element of GS;
       reconsider y = (Frege complop G).x as Element of GS by FUNCT_2:7;
       take y;
          now let i be Element of dom carr G;
            zr(G.i) is_a_unity_wrt ad(G.i) & (carr G).i = car(G.i) &
         (addop G).i = ad(G.i) & (complop G).i = cc(G.i)
          by A1,Def13,Def14,Th3;
         hence (complop G).i is_an_inverseOp_wrt (addop G).i &
           (addop G).i has_a_unity by Th4,SETWISEO:def 2;
       end;
       then Frege complop G is_an_inverseOp_wrt [:addop G:] by Th28;
       then [:addop G:].(x,y) = the_unity_wrt [:addop G:] by FINSEQOP:def 1;
       then x + y = the_unity_wrt [:addop G:] by RLVECT_1:5;
       then x + y = the Zero of GS by A4,BINOP_1:def 8;
       hence thesis;
     end;
     hence thesis by A2,A3,A4,Lm2,Lm3;
   end;
end;

