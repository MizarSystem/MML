:: On the Composition of Macro Instructions of Standard Computers
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      XXREAL_0, AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5,
      AMISTD_1, FINSEQ_1, ZFMISC_1, UNIALG_1, FUNCT_1, VALUED_0,
      CARD_3, CARD_5, FRECHET, RCOMP_1, NAT_1, STRUCT_0, FINSET_1, VALUED_1,
      FSM_1, FUNCT_4, FUNCT_7, TURING_1, CIRCUIT2, AMISTD_2,
      PARTFUN1, CAT_1, RELOC, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, ZFMISC_1, MCART_1, SETFAM_1,
      MEMBERED, FINSET_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, CARD_1,
      NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1, NAT_D,
      FUNCT_7, XXREAL_2, VALUED_0, VALUED_1, AFINSQ_1, STRUCT_0,
      COMPOS_1, AMI_1,
      AMISTD_1;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, RECDEF_2, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMI_1, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions RELAT_1, FUNCT_1, WELLORD2, FUNCT_7,
      COMPOS_1, AMI_1, YELLOW_8,
      AMISTD_1, XBOOLE_0, FUNCOP_1, CARD_3, NAT_1, AFINSQ_1, MCART_1, VALUED_1,
      TARSKI;
 theorems AMI_1, CARD_1, CARD_2, AMISTD_1, FUNCOP_1, FINSEQ_1, FUNCT_1,
      FUNCT_4, GRFUNC_1, INT_1, MCART_1, NAT_1, PRE_CIRC, REALSET1, RELAT_1,
      SETFAM_1, TARSKI, YELLOW_8, ZFMISC_1, CARD_3, ORDINAL1, XBOOLE_0,
      XBOOLE_1, FINSET_1, XREAL_1, XXREAL_0, FUNCT_7, XREAL_0, NAT_D,
      PBOOLE, PARTFUN1, AFINSQ_1, RECDEF_2, VALUED_1, COMPOS_1;
 schemes CLASSES1;

begin

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set,
  N for with_non-empty_elements non empty set;

Lm1: -1 < k
proof
  -1 < 0;
  hence thesis;
end;

Lm2: for a, b, c being Element of NAT st 1 <= a & 2 <= b holds
k < a - 1 or a <= k & k <= a + b - 3 or k = a + b - 2 or
a + b - 2 < k or k = a - 1
proof
  let a, b, c be Element of NAT such that
A1: 1 <= a and
A2: 2 <= b and
A3: a - 1 <= k and
A4: a > k or k > a + b - 3 and
A5: k <> a + b - 2 and
A6: k <= a + b - 2;
A7: a - 1 is Element of NAT by A1,INT_1:18;
  now per cases by A4;
    case k < a;
      then k < a - 1 + 1;
      hence k <= a - 1 by A7,NAT_1:13;
    end;
    case
A8:   a + b - 3 < k;
      1 + 2 <= a + b by A1,A2,XREAL_1:9;
      then
A9:   a + b - 3 is Element of NAT by INT_1:18;
      k < a + b - 3 + 1 by A5,A6,XXREAL_0:1;
      hence k <= a - 1 by A8,A9,NAT_1:13;
    end;
  end;
  hence thesis by A3,XXREAL_0:1;
end;

begin  :: Properties of AMI-Struct

definition
  canceled 2;
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  i1, i2 be Element of NAT,
  I1, I2 be Element of the Instructions of S;
  redefine func (i1,i2) --> (I1,I2) -> FinPartState of S;
  coherence
  proof
    (i1,i2) --> (I1,I2) = (i1.-->I1) +* (i2 .-->I2) by FUNCT_4:def 4;
    hence thesis;
  end;
end;

registration

  let N be with_non-empty_elements set;
  let S be halting (stored-program AMI-Struct over N);
  cluster halting Instruction of S;
  existence
  proof
    take halt S;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be standard-ins AMI-Struct over N;
  let T be InsType of S;
  func JumpParts T equals
  { JumpPart I where I is Instruction of S: InsCode I = T };
  coherence;
end;

registration
  let N be set;
  let S be standard-ins AMI-Struct over N;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> Function-like Relation-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by COMPOS_1:def 17;
    I in the Instructions of S;
    then AddressPart I in X* by A1,RECDEF_2:2;
    hence thesis;
  end;
  cluster JumpPart I -> Function-like Relation-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by COMPOS_1:def 17;
    I in the Instructions of S;
    then JumpPart I in NAT* by A1,RECDEF_2:2;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be standard-ins AMI-Struct over N;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> FinSequence-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by COMPOS_1:def 17;
    I in the Instructions of S;
    then AddressPart I in X* by A1,RECDEF_2:2;
    hence thesis;
  end;
  cluster JumpPart I -> FinSequence-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by COMPOS_1:def 17;
    I in the Instructions of S;
    then JumpPart I in NAT* by A1,RECDEF_2:2;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be standard-ins AMI-Struct over N;
  attr S is homogeneous means
:Def4:
  for I, J being Instruction of S st InsCode I = InsCode J holds
  dom JumpPart I = dom JumpPart J;
end;

canceled 16;

theorem Th17:
  for I being Instruction of STC N holds JumpPart I = 0
proof
  let I be Instruction of STC N;
  the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
  then I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
  hence thesis by RECDEF_2:def 2;
end;

definition
  let N be set;
  let S be standard-ins AMI-Struct over N;
  let T be InsType of S;
  func AddressParts T equals
  { AddressPart I where I is Instruction of S: InsCode I = T };
  coherence;
end;

registration
  let N be set;
  let S be standard-ins AMI-Struct over N;
  let T be InsType of S;
  cluster AddressParts T -> functional;
  coherence
  proof
    let f be set;
    assume f in AddressParts T;
    then ex I being Instruction of S st f = AddressPart I & InsCode I = T;
    hence thesis;
  end;
  cluster JumpParts T -> non empty functional;
  coherence
  proof
    consider y being set such that
B1:  [T,y] in proj1 the Instructions of S by RELAT_1:def 4;
    consider x being set such that
A1:  [[T,y],x] in the Instructions of S by B1,RELAT_1:def 4;
    reconsider I = [T,y,x] as Instruction of S by A1;
    InsCode I = T by RECDEF_2:def 1;
    then JumpPart I in JumpParts T;
   hence JumpParts T is non empty;
    let f be set;
    assume f in JumpParts T;
    then ex I being Instruction of S st f = JumpPart I & InsCode I = T;
    hence thesis;
  end;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite standard-ins
  (non empty stored-program AMI-Struct over N), I be Instruction of S;
  attr I is with_explicit_jumps means
:Def6: JUMP I c= rng JumpPart I;
  attr I is without_implicit_jumps means
:Def7: rng JumpPart I c= JUMP I;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  attr S is with_explicit_jumps means
:Def8: for I being Instruction of S holds I is with_explicit_jumps;
  attr S is without_implicit_jumps means
:Def9: for I being Instruction of S holds I is without_implicit_jumps;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard -> (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard standard-ins (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

theorem Th18:
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I being Instruction of S
  st for f being Element of NAT holds NIC(I,f)={succ f}
  holds JUMP I is empty
proof
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  assume
A1: for f being Element of NAT holds NIC(I,f)={succ f};
  set p=1, q=2;
  reconsider p,q as Element of NAT;
  set X = { NIC(I,f) where f is Element of NAT:
  not contradiction };
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
A3: NIC(I,p) = {succ p} by A1;
A4: NIC(I,q) = {succ q} by A1;
A5: {succ p} in X by A3;
A6: {succ q} in X by A4;
A7: x in {succ p} by A2,A5,SETFAM_1:def 1;
A8: x in {succ q} by A2,A6,SETFAM_1:def 1;
    x = succ p by A7,TARSKI:def 1;
  hence contradiction by A8,TARSKI:def 1;
end;

registration
  let N be with_non-empty_elements non empty set,
  I be Instruction of STC N;
  cluster JUMP I -> empty;
  coherence
  proof
    per cases by AMISTD_1:22;
    suppose InsCode I = 0;
      then for f being Element of NAT holds NIC(I,f)={f} by AMISTD_1:15,20;
      hence thesis by AMISTD_1:14;
    end;
    suppose InsCode I = 1;
      then for f being Element of NAT holds NIC(I,f)={succ f} by AMISTD_1:39;
      hence thesis by Th18;
    end;
  end;
end;

definition
  let N be set;
  let S be standard-ins AMI-Struct over N;
  canceled;
  attr S is regular means
  :Def11:
  for I being Instruction of S, k being set st k in dom JumpPart I
   holds (product" JumpParts InsCode I).k = NAT;
  attr S is J/A-independent means
:Dfs: for T being InsType of S, f1,f2 being Function,
     p being set
    st f1 in JumpParts T & f2 in product product" JumpParts T &
    [T,f1,p] in the Instructions of S
    holds [T,f2,p] in the Instructions of S;
end;

theorem Th19:
  for T being InsType of STC N holds JumpParts T = {0}
proof
  let T be InsType of STC N;
  set A = { JumpPart I where I is Instruction of STC N: InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
A2:   the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
      then
A3:   InsCodes STC N = {0,1} by MCART_1:96;
      per cases by A3,TARSKI:def 2;
      suppose
A4:     T = 0;
        reconsider I = [0,0,0] as Instruction of STC N by A2,TARSKI:def 2;
A5:     JumpPart I = 0 by Th17;
        InsCode I = 0 by RECDEF_2:def 1;
        hence a in A by A1,A4,A5;
      end;
      suppose
A6:     T = 1;
        reconsider I = [1,0,0] as Instruction of STC N by A2,TARSKI:def 2;
A7:     JumpPart I = 0 by Th17;
        InsCode I = 1 by RECDEF_2:def 1;
        hence a in A by A1,A6,A7;
      end;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of STC N st a = JumpPart I & InsCode I = T;
    then a = 0 by Th17;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

Lm3: for I being Instruction of Trivial-AMI N holds JumpPart I = 0
proof
  let I be Instruction of Trivial-AMI N;
  the Instructions of Trivial-AMI N = {[0,0,{}]} by AMI_1:def 2;
  then I = [0,0,0] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 2;
end;

Lm4: for T being InsType of Trivial-AMI N holds JumpParts T = {0}
proof
  let T be InsType of Trivial-AMI N;
  set A = { JumpPart I
   where I is Instruction of Trivial-AMI N: InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
A2:   the Instructions of Trivial-AMI N = {[0,0,{}]} by AMI_1:def 2;
      then InsCodes Trivial-AMI N = {0} by MCART_1:97;
      then
A3:   T = 0 by TARSKI:def 1;
      reconsider I = [0,0,0] as Instruction of Trivial-AMI N
      by A2,TARSKI:def 1;
A4:   JumpPart I = 0 by Lm3;
      InsCode I = 0 by RECDEF_2:def 1;
      hence a in A by A1,A3,A4;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of Trivial-AMI N
    st a = JumpPart I & InsCode I = T;
    then a = 0 by Lm3;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N ->
   with_explicit_jumps without_implicit_jumps homogeneous
    regular J/A-independent;
  coherence
  proof
    thus STC N is with_explicit_jumps
    proof
      let I be Instruction of STC N;
      let f be set;
      thus thesis;
    end;
    thus STC N is without_implicit_jumps
    proof
      let I be Instruction of STC N;
      let f be set;
      the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
      then I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
      hence thesis by RECDEF_2:def 2,RELAT_1:60;
    end;
    thus STC N is homogeneous
     proof let I, J be Instruction of STC N;
       JumpPart I = {} & JumpPart J = {} by Th17;
      hence thesis;
     end;
    thus STC N is regular
     proof let I be Instruction of STC N;
       JumpPart I = {} by Th17;
      hence thesis;
     end;
    let T be InsType of STC N;
    let f1,f2 be Function, p be set;
    assume f1 in JumpParts T;
     then
A:    f1 in {0} by Th19;
     assume
Z:    f2 in product product" JumpParts T;
     product" JumpParts T = {} by Th19,CARD_3:156;
     then f1 = 0 & f2 = 0 by A,Z,CARD_3:19,TARSKI:def 1;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard regular J/A-independent homogeneous
   halting realistic steady-programmed
    with_explicit_jumps without_implicit_jumps
    (IC-Ins-separated definite standard-ins
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let S be regular homogeneous (standard-ins AMI-Struct over N);
 let T being InsType of S;
 cluster JumpParts T ->  with_common_domain;
 coherence
  proof let f,g be Function;
   assume f in JumpParts T;
    then
A: ex I being Instruction of S st f = JumpPart I & InsCode I = T;
   assume g in JumpParts T;
    then ex J being Instruction of S st g = JumpPart J & InsCode J = T;
   hence dom f = dom g by Def4,A;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let S be regular homogeneous (standard-ins AMI-Struct over N);
 let I be Instruction of S;
 cluster JumpPart I -> NAT-valued Function;
 coherence
proof
 JumpPart I is NAT-valued
 proof let x;
 assume x in rng JumpPart I;
  then consider k being set such that
W1: k in dom JumpPart I and
W2: (JumpPart I).k = x by FUNCT_1:def 5;
  set X = JumpParts InsCode I;
A:  JumpPart I in X;
  then k in dom product" X by W1,CARD_3:150;
  then (JumpPart I).k in (product" X).k by A,CARD_3:151;
 hence x in NAT by W1,W2,Def11;
 end;
 hence thesis;
end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins AMI-Struct over N);
  let T be InsType of S;
  cluster JumpParts T -> product-like;
  coherence
proof
  consider y being set such that
B1: [T,y] in proj1 the Instructions of S by RELAT_1:def 4;
  consider z being set such that
A1: [[T,y],z] in the Instructions of S by B1,RELAT_1:def 4;
  reconsider I = [T,y,z] as Instruction of S by A1;
X1: InsCode I = T by RECDEF_2:def 1;
X4: JumpPart I = y by RECDEF_2:def 2;
  set f = (dom JumpPart I) --> NAT;
D1:   dom f = dom JumpPart I by FUNCOP_1:19;
  for x being set holds x in JumpParts T iff
   ex g being Function st x = g & dom g = dom f &
     for y st y in dom f holds g.y in f.y
   proof let x be set;
    thus x in JumpParts T implies
      ex g being Function st x = g & dom g = dom f &
     for y st y in dom f holds g.y in f.y
    proof assume x in JumpParts T;
      then consider K being Instruction of S such that
W1:    x = JumpPart K and
W2:    InsCode K = T;
     take g = JumpPart K;
     thus x = g by W1;
     thus
K:    dom g = dom f by W2,X1,Def4,D1;
     let y;
     assume
Z:    y in dom f;
      then f.y = NAT by D1,FUNCOP_1:13;
     hence g.y in f.y by K,Z,FUNCT_1:172;
    end;
     given g being Function such that
G1:   x = g and
G2:   dom g = dom f and
G3:   for y st y in dom f holds g.y in f.y;
X3:   dom g = dom JumpPart I by G2,FUNCOP_1:19;
   set J = [T,g,z];
Y1: y in JumpParts T by X4,X1;
   then
X6: dom g = dom product" JumpParts T by X3,X4,CARD_3:150;
    for x st x in dom(product" JumpParts T)
     holds g.x in (product" JumpParts T).x
    proof let x;
     assume
Z:    x in dom(product" JumpParts T);
      f.x = NAT by X6,X3,Z,FUNCOP_1:13;
      then g.x in NAT by G3,X6,Z,G2;
     hence g.x in (product" JumpParts T).x by Z,X6,X1,X3,Def11;
    end;
   then
X5: g in product product" JumpParts T by X6,CARD_3:18;
    reconsider J as Instruction of S by Y1,Dfs,X4,X5;
X2: InsCode J = T by RECDEF_2:def 1;
     g = JumpPart J by RECDEF_2:def 2;
    hence x in JumpParts T by X2,G1;
   end;
  then JumpParts T = product f by CARD_3:def 5;
 hence JumpParts T is product-like;
end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> regular J/A-independent;
  coherence
  proof
   thus Trivial-AMI N is regular
    proof
    let I be Instruction of Trivial-AMI N;
     JumpPart I = {} by Lm3;
    hence thesis;
    end;
    let T be InsType of Trivial-AMI N;
    let f1,f2 be Function, p be set;
    assume f1 in JumpParts T;
     then
A:    f1 in {0} by Lm4;
     assume
Z:    f2 in product product" JumpParts T;
     product" JumpParts T = {} by Lm4,CARD_3:156;
     then f1 = 0 & f2 = 0 by A,Z,CARD_3:19,TARSKI:def 1;
    hence thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster regular J/A-independent (standard-ins AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be homogeneous (standard-ins AMI-Struct over N);
  let T be InsType of S;
  cluster JumpParts T -> with_common_domain;
  coherence
  proof
    let f, g be Function;
    assume that
A1: f in JumpParts T and
A2: g in JumpParts T;
A3: ex I being Instruction of S st f = JumpPart I & InsCode I = T by A1;
    ex J being Instruction of S st g = JumpPart J & InsCode J = T by A2;
    hence thesis by A3,Def4;
  end;
end;

registration

  let N be with_non-empty_elements non empty set,
  I be Instruction of Trivial-AMI N;
  cluster JUMP I -> empty;
  coherence
  proof
    for f being Element of NAT holds NIC(I,f)={f} by AMISTD_1:15,56;
    hence thesis by AMISTD_1:14;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N
    -> with_explicit_jumps without_implicit_jumps;
  coherence
  proof
    thus Trivial-AMI N is with_explicit_jumps
    proof
      let I be Instruction of Trivial-AMI N;
      let f be set;
      thus thesis;
    end;
    thus Trivial-AMI N is without_implicit_jumps
    proof
      let I be Instruction of Trivial-AMI N;
      let f be set;
      the Instructions of Trivial-AMI N = {[0,0,{}]} by AMI_1:def 2;
      then I = [0,0,0] by TARSKI:def 1;
      hence thesis by RECDEF_2:def 2,RELAT_1:60;
    end;
  end;
end;

registration
  let N;
  cluster regular J/A-independent
    (non empty stored-program standard-ins AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

theorem
  for S being homogeneous regular
  (non empty stored-program standard-ins AMI-Struct over N),
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x is Element of NAT
proof
  let S be homogeneous regular
  (non empty stored-program standard-ins AMI-Struct over N),
  I be Instruction of S, x be set such that
A1: x in dom JumpPart I;
A2: JumpPart I in JumpParts InsCode I;
A3: (product" JumpParts InsCode I).x = NAT by A1,Def11;
  for f being Function st f in JumpParts InsCode I holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts InsCode I;
    then ex J being Instruction of S st f = JumpPart J & InsCode I =
    InsCode J;
    hence thesis by A1,Def4;
  end;
  then x in dom product" JumpParts InsCode I by CARD_3:def 13;
  then (product" JumpParts InsCode I).x = pi(JumpParts InsCode I,x)
  by CARD_3:def 13;
  hence thesis by A2,A3,CARD_3:def 6;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster without_implicit_jumps with_explicit_jumps halting realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be with_explicit_jumps (IC-Ins-separated
  definite (non empty stored-program standard-ins AMI-Struct over N));
  cluster -> with_explicit_jumps Instruction of S;
  coherence by Def8;
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster -> without_implicit_jumps Instruction of S;
  coherence by Def9;
end;

theorem Th21:
  for S being realistic IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N),
  I being Instruction of S st I is halting holds JUMP I is empty
proof

  let S be realistic IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N), I be Instruction of S;
  assume I is halting;
  then for l being Element of NAT holds NIC(I,l)={l}
  by AMISTD_1:15;
  hence thesis by AMISTD_1:14;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be halting realistic
  steady-programmed
  (IC-Ins-separated definite (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S;
  cluster JUMP I -> empty;
  coherence by Th21;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  cluster non trivial NAT-defined FinPartState of S;
  existence
  proof
    consider l1, l2 being Element of NAT such that
A1: l1 <> l2 by YELLOW_8:def 1;
    reconsider l1,l2 as Element of NAT;
    consider I being Instruction of S;
    take f = (l1,l2) --> (I,I);
    thus f is non trivial
    proof
      f = { [l1,I], [l2,I] } by A1,FUNCT_4:71;
      then reconsider x = [l1,I], y = [l2,I] as Element of f by TARSKI:def 2;
      take x, y;
      thus thesis by A1,ZFMISC_1:33;
    end;
    let a be set;
    assume a in dom f;
    then a in {l1,l2} by FUNCT_4:65;
    then a = l1 or a = l2 by TARSKI:def 2;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster trivial -> unique-halt (non empty NAT-defined FinPartState of S);
  coherence
  proof
    let F be non empty NAT-defined FinPartState of S;
    assume
A1: F is trivial;
    let f be Element of NAT such that F.f = halt S and
A2: f in dom F;
    consider x being set such that
A3: F = {x} by A1,REALSET1:def 4;
    x in F by A3,TARSKI:def 1;
    then consider a, b being set such that
A4: [a,b] = x by RELAT_1:def 1;
A5: LastLoc F in dom F by VALUED_1:31;
A6: dom F = {a} by A3,A4,RELAT_1:23;
    hence f = a by A2,TARSKI:def 1
      .= LastLoc F by A5,A6,TARSKI:def 1;
  end;
end;

definition
  let N be set;
  let S be standard-ins AMI-Struct over N;
  let I be Instruction of S;
  attr I is ins-loc-free means
   JumpPart I is empty;
end;

::registration
::  let N be set;
::  let S be standard-ins AMI-Struct over N;
::  let I be ins-loc-free Instruction of S;
::  cluster JumpPart I -> empty;
::  coherence by Def12;
::end;

theorem
  for S being halting with_explicit_jumps
  realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds JUMP I is empty
proof
  let S be halting with_explicit_jumps realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N)),
  I be Instruction of S such that
A1: JumpPart I is empty;
B1: rng JumpPart I = {} by A1;
   JUMP I c= rng JumpPart I by Def6;
  hence thesis by B1,XBOOLE_1:3;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N));
  cluster halting -> ins-loc-free Instruction of S;
  coherence
proof
  let I be Instruction of S;
  assume I is halting;
   then
A1:  JUMP I is empty by Th21;
   rng JumpPart I c= JUMP I by Def7;
  hence JumpPart I is empty by A1,XBOOLE_1:3;
end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard without_implicit_jumps standard-ins (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N));
  cluster sequential -> ins-loc-free Instruction of S;
  coherence
proof
  let I be Instruction of S;
  assume I is sequential;
   then
A1: JUMP I is empty by AMISTD_1:43;
   rng JumpPart I c= JUMP I by Def7;
  hence JumpPart I is empty by A1,XBOOLE_1:3;
end;
end;

Lm5: now
  let N be with_non-empty_elements non empty set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  thus dom Stop S = {0} by FUNCOP_1:19;
  hence 0 in dom Stop S by TARSKI:def 1;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster Stop S ->
   initial non empty NAT-defined (the Instructions of S)-valued trivial;
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard realistic halting
  (IC-Ins-separated steady-programmed definite
  (non empty stored-program AMI-Struct over N));
  cluster Stop S -> closed;
  coherence by AMISTD_1:46;
end;

canceled 2;

theorem Th25:
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)) holds card Stop S = 1
proof
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  thus card Stop S = card {[0,halt S]} by FUNCT_4:87
    .= 1 by CARD_1:50;
end;

theorem Th26:
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F being pre-Macro of S st card F = 1 holds F = Stop S
proof
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), F be pre-Macro of S;
  assume
A1: card F = 1;
  then consider x being set such that
A2: F = {x} by CARD_2:60;
  x in F by A2,TARSKI:def 1;
  then consider a, b being set such that
A3: [a,b] = x by RELAT_1:def 1;
A4: dom F = {a} by A2,A3,RELAT_1:23;
A5: 0 in dom F by AFINSQ_1:69;
  then
A6: a = 0 by A4;
  card F -' 1 = card F - 1 by PRE_CIRC:25
    .= 0 by A1;
  then LastLoc F = 0 by AFINSQ_1:74;
  then F.0 = halt S by COMPOS_1:def 25;
  then halt S in rng F by A5,FUNCT_1:def 5;
  then halt S in {b} by A2,A3,RELAT_1:23;
  then F = {[0,halt S]} by A2,A3,A6,TARSKI:def 1
    .= 0 .--> halt S by FUNCT_4:87;
  hence thesis;
end;

Lm6: for S being standard halting (IC-Ins-separated definite
(non empty stored-program AMI-Struct over N)) holds card Stop S -' 1 = 0
proof
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  thus card Stop S -' 1 = card Stop S - 1 by PRE_CIRC:25
    .= 1 - 1 by Th25
    .= 0;
end;

theorem Th27:
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N))
  holds LastLoc Stop S = 0
proof
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  card Stop S -' 1 = 0 by Lm6;
  hence thesis by AFINSQ_1:74;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster Stop S -> halt-ending unique-halt;
  coherence
  proof
    thus (Stop S).(LastLoc Stop S) = (0 .--> halt S).0 by Th27
      .= halt S by FUNCOP_1:87;
    let l be Element of NAT such that (Stop S).l = halt S;
    assume l in dom Stop S;
    then l in {0} by Lm5;
    then l = 0 by TARSKI:def 1;
    hence thesis by Th27;
  end;
end;

begin  :: On the composition of macro instructions

registration
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  let I be Element of the Instructions of S;
 cluster JumpPart I -> natural-valued Function;
 coherence;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  let I be Element of the Instructions of S;
  let k be natural number;
  func IncAddr(I,k) -> Instruction of S means
:Def14:
  InsCode it = InsCode I &
  AddressPart it = AddressPart I &
  JumpPart it = k + JumpPart I;
  existence
  proof
    consider D0 being non empty set such that
W:   the Instructions of S c= [:NAT,NAT*,D0*:] by COMPOS_1:def 17;
    set p = k + JumpPart I;
    set f = product" JumpParts InsCode I;
A8: JumpPart I in JumpParts InsCode I;
A9: JumpParts InsCode I = product f by CARD_3:95;
A10: dom p = dom JumpPart I by VALUED_1:def 2;
     then
B10: dom p  = DOM JumpParts InsCode I by A8,CARD_3:def 12
      .= dom f by CARD_3:92;
    for z being set st z in dom p holds p.z in f.z
    proof
      let z be set;
      assume
A11:  z in dom p;
      reconsider z as Element of NAT by A11;
A13:    f.z = NAT by A11,A10,Def11;
        reconsider il = (JumpPart I).z as Element of NAT by ORDINAL1:def 13;
        p.z = k + il by A11,VALUED_1:def 2;
        hence thesis by A13;
    end;
    then p in JumpParts InsCode I by A9,B10,CARD_3:18;
    then consider II being Instruction of S such that
A14: p = JumpPart II and
A15: InsCode I = InsCode II;
X1:  JumpPart I in JumpParts InsCode I;
     product product" JumpParts InsCode I = JumpParts InsCode I by CARD_3:95;
     then
X2:  JumpPart II in product product" JumpParts InsCode I by A15;
     I in the Instructions of S;
     then [InsCode I, JumpPart I, AddressPart I] = I by W,RECDEF_2:3;
     then reconsider IT = [InsCode I, JumpPart II, AddressPart I]
                       as Instruction of S by X1,X2,Dfs;
    take IT;
    thus InsCode IT = InsCode I by RECDEF_2:def 1;
    thus AddressPart IT = AddressPart I by RECDEF_2:def 3;
    thus JumpPart IT = k + JumpPart I by A14,RECDEF_2:def 2;
  end;
  uniqueness by COMPOS_1:7;
end;

theorem Th28:
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Element of the Instructions of S holds IncAddr(I, 0) = I
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I be Element of the Instructions of S;
A1: InsCode IncAddr(I, 0) = InsCode I by Def14;
XX: AddressPart IncAddr(I, 0) = AddressPart I by Def14;
YY:  JumpPart IncAddr(I, 0) = (0 qua Nat) + JumpPart I by Def14;
   then
A2: dom JumpPart I = dom JumpPart IncAddr(I, 0) by VALUED_1:def 2;
  for k being Nat st k in dom JumpPart I holds
  (JumpPart IncAddr(I, 0)).k = (JumpPart I).k
  proof
    let k be Nat;
    assume k in dom JumpPart I;
    hence (JumpPart IncAddr(I, 0)).k
        = (0 qua Nat) + (JumpPart I).k by A2,YY,VALUED_1:def 2
       .= (JumpPart I).k;
  end;
   then JumpPart IncAddr(I, 0) = JumpPart I by A2,FINSEQ_1:17;
  hence thesis by A1,XX,COMPOS_1:7;
end;

theorem Th29:
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds IncAddr(I, k) = I
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I be Instruction of S such that
A1: JumpPart I is empty;
  set f = IncAddr(I, k);
A2: InsCode f = InsCode I by Def14;
XX: AddressPart f = AddressPart I by Def14;
    JumpPart f = k + JumpPart I by Def14;
    then
A3: dom JumpPart f = dom JumpPart I by VALUED_1:def 2;
   JumpPart f = JumpPart I by A1,A3;
  hence thesis by A2,XX,COMPOS_1:7;
end;

theorem
  for S being halting standard without_implicit_jumps realistic
  regular homogeneous J/A-independent
  (standard-ins IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N))
  holds IncAddr(halt S, k) = halt S by Th29;

registration
  let N be with_non-empty_elements non empty set,
  S be halting standard without_implicit_jumps steady-programmed
  realistic regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S, k be natural number;
  cluster IncAddr(I,k) -> halting;
  coherence by Th29;
end;

theorem
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I being Instruction of S
  holds JumpParts InsCode I = JumpParts InsCode IncAddr(I,k)
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  set A = { JumpPart J where J is Instruction of S:
  InsCode I = InsCode J }, B = { JumpPart J where J is Instruction of S:
  InsCode IncAddr(I,k) = InsCode J };
  A = B
  proof
    hereby
      let a be set;
      assume a in A;
      then consider J being Instruction of S such that
A1:   a = JumpPart J and
A2:   InsCode J = InsCode I;
      InsCode J = InsCode IncAddr(I,k) by A2,Def14;
      hence a in B by A1;
    end;
    let a be set;
    assume a in B;
    then consider J being Instruction of S such that
A3: a = JumpPart J and
A4: InsCode J = InsCode IncAddr(I,k);
    InsCode J = InsCode I by A4,Def14;
    hence thesis by A3;
  end;
  hence thesis;
end;

canceled 2;

theorem Th34:
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I, J being Instruction of S st
  ex k being natural number st IncAddr(I,k) = IncAddr(J,k) holds I = J
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I, J be Instruction of S;
  given k being natural number such that
A1: IncAddr(I,k) = IncAddr(J,k);
A2: InsCode I = InsCode IncAddr(I,k) by Def14
    .= InsCode J by A1,Def14;
XX: AddressPart I = AddressPart IncAddr(I,k) by Def14
       .= AddressPart J by A1,Def14;
X1: JumpPart IncAddr(I,k) = k + JumpPart I by Def14;
    then
Y1: dom JumpPart I = dom  JumpPart IncAddr(I,k) by VALUED_1:def 2;
X2: JumpPart IncAddr(J,k) = k + JumpPart J by Def14;
    then
Y2: dom JumpPart J = dom  JumpPart IncAddr(J,k) by VALUED_1:def 2;
A3: dom JumpPart I = dom JumpPart J by A2,Def4;
  for x being set st x in dom JumpPart I holds
  (JumpPart I).x = (JumpPart J).x
  proof
    let x be set;
    assume
A4: x in dom JumpPart I;
A7:   (JumpPart IncAddr(I,k)).x = k + (JumpPart I).x
             by X1,Y1,A4,VALUED_1:def 2;
A9:   (JumpPart IncAddr(J,k)).x = k + (JumpPart J).x
             by X2,A3,A4,Y2,VALUED_1:def 2;
      thus thesis by A1,A7,A9;
  end;
   then JumpPart I = JumpPart J by A3,FUNCT_1:9;
  hence thesis by A2,XX,COMPOS_1:7;
end;

theorem Th35:
  for S being regular homogeneous J/A-independent standard halting
   without_implicit_jumps steady-programmed
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Instruction of S st IncAddr(I,k) = halt S holds I = halt S
proof
  let S be regular homogeneous J/A-independent standard halting
  without_implicit_jumps steady-programmed
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  assume IncAddr(I,k) = halt S;
  then IncAddr(I,k) = IncAddr(halt S,k) by Th29;
  hence thesis by Th34;
end;

theorem
  for S being regular homogeneous J/A-independent standard halting
  without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is sequential
  holds IncAddr(I,k) is sequential by Th29;

theorem Th37:
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I being Instruction of S
  holds IncAddr(IncAddr(I,k),m) = IncAddr(I,k+m)
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
A1: InsCode IncAddr(IncAddr(I,k),m) = InsCode IncAddr(I,k) by Def14
    .= InsCode I by Def14
    .= InsCode IncAddr(I,k+m) by Def14;
XX: AddressPart IncAddr(IncAddr(I,k),m) = AddressPart IncAddr(I,k) by Def14
    .= AddressPart I by Def14
    .= AddressPart IncAddr(I,k+m) by Def14;
Y3: JumpPart IncAddr(IncAddr(I,k),m) = m + JumpPart IncAddr(I,k) by Def14;
Y2: JumpPart IncAddr(I,k) = k + JumpPart I by Def14;
Y1: JumpPart IncAddr(I,k+m) = k+m + JumpPart I by Def14;
    then
A2: dom JumpPart IncAddr(I,k+m) = dom JumpPart I by VALUED_1:def 2
    .= dom JumpPart IncAddr(I,k) by Y2,VALUED_1:def 2
    .= dom JumpPart IncAddr(IncAddr(I,k),m) by Y3,VALUED_1:def 2;
  for n being set st n in dom JumpPart IncAddr(IncAddr(I,k),m) holds
  (JumpPart IncAddr(IncAddr(I,k),m)).n = (JumpPart IncAddr(I,k+m)).n
  proof
    let n be set;
    assume
Z:   n in dom JumpPart IncAddr(IncAddr(I,k),m);
    then
A3: n in dom JumpPart IncAddr(I,k) by Y3,VALUED_1:def 2;
    then
A4: n in dom JumpPart I by Y2,VALUED_1:def 2;
A7:   (JumpPart IncAddr(I,k)).n = k + (JumpPart I).n
            by Y2,A3,VALUED_1:def 2;
A9:   (JumpPart IncAddr(IncAddr(I,k),m)).n = m + (JumpPart IncAddr(I,k)).n
      by Z,Y3,VALUED_1:def 2;
      n in dom JumpPart IncAddr(I,k+m) by Y1,A4,VALUED_1:def 2;
      then (JumpPart IncAddr(I,k+m)).n = k + m + (JumpPart I).n
       by Y1,VALUED_1:def 2;
      hence thesis by A9,A7;
  end;
   then JumpPart IncAddr(IncAddr(I,k),m) = JumpPart IncAddr(I,k+m)
                   by A2,FUNCT_1:9;
  hence thesis by A1,XX,COMPOS_1:7;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  p be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
A1: dom p c= NAT by RELAT_1:def 18;
  func IncAddr(p,k) -> FinPartState of S means
  :Def15:
  dom it = dom p &
  for m being natural number st m in dom p holds it.m = IncAddr(p/.m,k);
  existence
  proof
    defpred P[set,set] means ex m being Element of NAT st $1 = m &
    $2 = IncAddr(p/.m,k);
A2: for e being set st e in dom p ex u being set st P[e,u]
    proof
      let e be set;
      assume e in dom p;
      then reconsider l=e as Element of NAT by A1;
      consider m being natural number such that
A3:   l = m;
      take IncAddr(p/.m,k);
      thus thesis by A3;
    end;
    consider f being Function such that
A4: dom f = dom p and
A5: for e being set st e in dom p holds P[e,f.e] from CLASSES1:sch 1(A2);
XX: NAT c= the carrier of S by COMPOS_1:def 2;
    dom f c= NAT by A4,RELAT_1:def 18;
    then
A6: dom f c= the carrier of S by XX,XBOOLE_1:1;
     for x being set st x in dom f holds f.x in (the Object-Kind of S).x
    proof
      let x be set;
      assume
A7:   x in dom f;
      then
A8:   ex m being Element of NAT st x = m & f.x =
       IncAddr(p/.m,k) by A4,A5;
      reconsider y = x as Element of NAT by A1,A4,A7;
      (the Object-Kind of S).y
        = the Instructions of S by COMPOS_1:def 8;
      hence thesis by A8;
    end;
    then
UU:  f is (the Object-Kind of S)-compatible by FUNCT_1:def 20;
    f is (the carrier of S)-defined Function by A6,RELAT_1:def 18;
    then reconsider f as finite Element of sproduct the Object-Kind of S
    by A4,UU,CARD_3:153,FINSET_1:29;
    reconsider f as FinPartState of S;
    take f;
    thus dom f = dom p by A4;
    let m be natural number;
    assume m in dom p;
    then ex j being Element of NAT st m = j &
    f.m = IncAddr(p/.j,k) by A5;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be FinPartState of S such that
A9: dom IT1 = dom p and
A10: for m being natural number st m in dom p holds
    IT1.m = IncAddr(p/.m,k) and
A11: dom IT2 = dom p and
A12: for m being natural number st m in dom p holds
    IT2.m = IncAddr(p/.m,k);
    for x being set st x in dom p holds IT1.x = IT2.x
    proof
      let x be set;
      assume
A13:  x in dom p;
      then reconsider l=x as Element of NAT by A1;
      consider m being natural number such that
A14:  l = m;
      reconsider m as Element of NAT by ORDINAL1:def 13;
      thus IT1.x = IncAddr(p/.m,k) by A10,A13,A14
        .= IT2.x by A12,A13,A14;
    end;
    hence thesis by A9,A11,FUNCT_1:9;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> NAT-defined (the Instructions of S)-valued;
  coherence
  proof
E:   dom IncAddr(F,k) = dom F by Def15;
    hence dom IncAddr(F,k) c= NAT by RELAT_1:def 18;
   let x be set;
   assume x in rng IncAddr(F,k);
    then consider y being set such that
W1:  y in dom F and
W2:  x = IncAddr(F,k).y by E,FUNCT_1:def 5;
    x = IncAddr(F/.y,k) by W1,W2,Def15;
   hence x in the Instructions of S;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster empty NAT-defined FinPartState of S;
  existence
  proof
   take the empty FinPartState of S;
   thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be empty (the Instructions of S)-valued NAT-defined FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> empty;
  coherence
  proof
    assume not thesis;
    then reconsider f = IncAddr(F,k) as non empty Function;
A1: dom f <> {};
    dom IncAddr(F,k) = dom F by Def15;
    hence thesis by A1;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be non empty (the Instructions of S)-valued NAT-defined FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> non empty;
  coherence
  proof
    dom IncAddr(F,k) = dom F by Def15;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be initial NAT-defined (the Instructions of S)-valued FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> initial;
  coherence
  proof
    dom IncAddr(F,k) = dom F by Def15;
    hence thesis by AFINSQ_1:71;
  end;
end;

theorem Th38:
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F being NAT-defined (the Instructions of S)-valued FinPartState of S
   holds IncAddr(F,0) = F
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued FinPartState of S;
  for m being natural number st m in dom F holds
  F.m = IncAddr(F/.m,0)
  proof
    let m be natural number;
    assume m in dom F;
    then F/.m = F.m by PARTFUN1:def 8;
    hence thesis by Th28;
  end;
  hence thesis by Def15;
end;

theorem
  for S being regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F being NAT-defined (the Instructions of S)-valued finite Function
  holds IncAddr(IncAddr(F,k),m) = IncAddr(F,k+m)
proof
  let S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued finite Function;
A1: dom IncAddr(IncAddr(F,k),m) = dom IncAddr(F,k) by Def15
    .= dom F by Def15;
A2: dom IncAddr(F,k+m) = dom F by Def15;
  for x being set st x in dom F holds
  IncAddr(IncAddr(F,k),m).x = IncAddr(F,k+m).x
  proof
    let x be set such that
A3: x in dom F;
    reconsider x as Element of NAT by A3,ORDINAL1:def 13;
A5: x in dom IncAddr(F,k) by A3,Def15;
A6: IncAddr(F/.x,k) = IncAddr(F,k).x
    by A3,Def15
      .= IncAddr(F,k)/.x by A5,PARTFUN1:def 8;
    IncAddr(IncAddr(F,k),m).x
    = IncAddr(IncAddr(F,k)/.x,m) by A5,Def15
      .= IncAddr(F/.x,k+m) by A6,Th37
      .= IncAddr(F,k+m).x by A3,Def15;
    hence thesis;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
 let p be finite NAT-defined (the Instructions of S)-valued Function,
     k be Element of NAT;
 func Reloc(p,k) ->
   finite NAT-defined (the Instructions of S)-valued Function
   equals IncAddr(Shift(p,k),k);
 coherence;
end;

definition
 canceled;
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  attr I is IC-good means
  :Def17:
  for k being natural number, s1 being State of S
  holds IC Exec(I,s1) + k = IC Exec(IncAddr(I,k),IncrIC(s1,k));
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  attr S is IC-good means
  :Def18:
  for I being Instruction of S holds I is IC-good;
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N, I be Instruction of S;
  attr I is Exec-preserving means
  :Def19:
  for s1, s2 being State of S
  st s1, s2 equal_outside NAT holds Exec(I,s1), Exec(I,s2) equal_outside NAT;
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N;
  attr S is Exec-preserving means
  :Def20:
  for I being Instruction of S holds I is Exec-preserving;
end;

canceled 4;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard without_implicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster sequential -> IC-good Instruction of S;
  coherence
proof
  let I be Instruction of S such that
A1: I is sequential;
  let k be natural number, s1 be State of S;
  set s2 = IncrIC(s1,k);
  dom (IC S .--> (IC s1 + k)) = {IC S} by FUNCOP_1:19;
  then IC S in dom (IC S .--> (IC s1 + k)) by TARSKI:def 1;
  then
A3: IC s2 = (IC S .--> (IC s1 + k)).IC S by FUNCT_4:14
    .= IC s1 + k by FUNCOP_1:87;
A4: IC Exec(I, s2) = succ IC s2 by A1,AMISTD_1:def 16
    .= IC s1 + 1 + k by A3;
  IC Exec(I,s1) = succ IC s1 by A1,AMISTD_1:def 16
    .= IC s1 + 1;
  hence IC Exec(I,s1) + k = IC Exec(IncAddr(I,k), s2) by A1,A4,Th29;
end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
  without_implicit_jumps realistic
  (standard-ins IC-Ins-separated definite steady-programmed halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster halting -> IC-good Instruction of S;
  coherence
proof
  let I be Instruction of S such that
A1: I is halting;
  let k be natural number, s1 be State of S;
  set s2 = IncrIC(s1,k);
  dom (IC S .--> (IC s1 + k)) = {IC S} by FUNCOP_1:19;
  then
A3: IC S in dom (IC S .--> (IC s1 + k)) by TARSKI:def 1;
  thus IC Exec(I,s1) + k = IC s1 + k by A1,AMI_1:def 8
    .= (IC S .--> (IC s1 + k)).IC S by FUNCOP_1:87
    .= IC s2 by A3,FUNCT_4:14
    .= IC Exec(I,s2) by A1,AMI_1:def 8
    .= IC Exec(IncAddr(I,k), s2) by A1,Th29;
end;
end;

canceled 2;

registration

  let N be with_non-empty_elements non empty set,
  S be stored-program AMI-Struct over N;
  cluster halting -> Exec-preserving Instruction of S;
  coherence
proof
  let I be Instruction of S such that
A1: for s being State of S holds Exec(I,s) = s;
  let s1, s2 be State of S such that
A2: s1, s2 equal_outside NAT;
  Exec(I,s1) = s1 by A1;
  hence thesis by A1,A2;
end;
end;

theorem Th46:
  for S being stored-program AMI-Struct over N,
  I being Instruction of S st I is halting holds I is Exec-preserving;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> IC-good Exec-preserving;
  coherence
  proof
    thus STC N is IC-good
    proof
      let I be Instruction of STC N, k be natural number,
      s1 be State of STC N;
      set s2 = IncrIC(s1,k);
      {IC STC N} = dom (IC STC N .--> (IC s1 + k)) by FUNCOP_1:19;
      then IC STC N in dom (IC STC N .--> (IC s1 + k)) by TARSKI:def 1;
      then
A2:   IC s2 = (IC STC N .--> (IC s1 + k)).IC STC N by FUNCT_4:14
        .= IC s1 + k by FUNCOP_1:87;
      per cases by AMISTD_1:22;
      suppose
A3:     InsCode I = 1;
        then
A4:     InsCode IncAddr(I,k) = 1 by Def14;
        Exec(I,s1).IC STC N = succ IC s1 by A3,AMISTD_1:38
          .= IC s1 + 1;
        hence IC Exec(I,s1) + k = succ IC s2 by A2
          .= IC Exec(IncAddr(I,k), s2) by A4,AMISTD_1:38;
      end;
      suppose InsCode I = 0;
        then
A5:     I is halting by AMISTD_1:20;
        hence IC Exec(I,s1) + k = IC s1 + k by AMI_1:def 8
          .= IC Exec(IncAddr(I,k), s2) by A2,A5,AMI_1:def 8;
      end;
    end;
    let I be Instruction of STC N;
    per cases by AMISTD_1:22;
    suppose
A6:   InsCode I = 1;
      the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
      then
A7:   I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
      let s1, s2 be State of STC N such that
A8:   s1, s2 equal_outside NAT;
      consider f being Function of product the Object-Kind of STC N,
      product the Object-Kind of STC N such that
A9:   for s being Element of product the Object-Kind of STC N
      holds f.s = s+*(NAT .-->succ(s.NAT)) and
A10:  the Execution of STC N
      = ([1,0,0] .--> f) +* ([0,0,0] .--> id product the Object-Kind of STC N)
      by AMISTD_1:def 11;
B9:   for s being State of STC N
      holds f.s = s+*(NAT .-->succ(s.NAT))
       proof let s be State of STC N;
        reconsider s as Element of product the Object-Kind of STC N
         by PBOOLE:155;
        f.s = s+*(NAT .-->succ(s.NAT)) by A9;
       hence thesis;
       end;
      [0,0,0] <> [1,0,0] by MCART_1:28;
      then not I in {[0,0,0]} by A6,A7,RECDEF_2:def 1,TARSKI:def 1;
      then not I in dom ([0,0,0] .--> id product the Object-Kind of STC N)
      by FUNCOP_1:19;
      then
A11:  (the Execution of STC N).I = ([1,0,0] .--> f).I by A10,FUNCT_4:12;
A12:  I in {[1,0,0]} by A6,A7,RECDEF_2:def 1,TARSKI:def 1;
      then
A13:  Exec(I,s1) = f.s1 by A11,FUNCOP_1:13
        .= s1+*(NAT .-->succ(s1.NAT)) by B9;
A14:  Exec(I,s2) = f.s2 by A11,A12,FUNCOP_1:13
        .= s2+*(NAT .-->succ(s2.NAT)) by B9;
A15:  dom Exec(I,s1) = the carrier of STC N by PARTFUN1:def 4
           .= dom Exec(I,s2) by PARTFUN1:def 4;
      for x being set st x in dom Exec(I,s1) \ NAT
      holds Exec(I,s1).x = Exec(I,s2).x
      proof
        let x be set;
        assume
A16:    x in dom Exec(I,s1) \ NAT;
        then
A17:    not x in NAT by XBOOLE_0:def 5;
A18:    s1.NAT = IC s1 by AMISTD_1:def 11
          .= IC s2 by A8,COMPOS_1:24
          .= s2.NAT by AMISTD_1:def 11;
        x in dom Exec(I,s1) by A16;
        then x in the carrier of STC N by PARTFUN1:def 4;
        then x in NAT \/ {NAT} by AMISTD_1:def 11;
        then
A19:    x in {NAT} by A17,XBOOLE_0:def 3;
        then
A20:    x in dom (NAT .-->succ(s2.NAT)) by FUNCOP_1:19;
        x in dom (NAT .-->succ(s1.NAT)) by A19,FUNCOP_1:19;
        hence Exec(I,s1).x = (NAT .-->succ(s1.NAT)).x by A13,FUNCT_4:14
          .= Exec(I,s2).x by A14,A18,A20,FUNCT_4:14;
      end;
      hence Exec(I,s1)|(dom Exec(I,s1) \ NAT) =
      Exec(I,s2)|(dom Exec(I,s2) \ NAT) by A15,FUNCT_1:165;
    end;
    suppose InsCode I = 0;
      hence thesis by Th46,AMISTD_1:20;
    end;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster homogeneous realistic steady-programmed halting
    with_explicit_jumps without_implicit_jumps Exec-preserving
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N)));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster IC-good (homogeneous realistic steady-programmed
    with_explicit_jumps without_implicit_jumps Exec-preserving halting
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N))));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster J/A-independent regular (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> Exec-preserving;
  coherence
  proof
    let I be Instruction of Trivial-AMI N;
    thus thesis by Th46,AMISTD_1:56;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster halting realistic steady-programmed
    with_explicit_jumps without_implicit_jumps Exec-preserving
    (regular J/A-independent (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N)));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-good (regular homogeneous J/A-independent standard
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N)));
  cluster -> IC-good Instruction of S;
  coherence by Def18;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be Exec-preserving (stored-program AMI-Struct over N);
  cluster -> Exec-preserving Instruction of S;
  coherence by Def20;
end;

canceled 3;

theorem Th50:
  for S being regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F being initial non empty NAT-defined FinPartState of S,
  G being non empty
   NAT-defined (the Instructions of S)-valued FinPartState of S
  holds dom CutLastLoc F misses dom Shift(IncAddr(G,card F -' 1),card F -' 1)
proof
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be initial non empty NAT-defined FinPartState of S,
  G be non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
  assume not thesis;
  then consider il being set such that
A1: il in dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) by XBOOLE_0:4;
A2: il in dom CutLastLoc F by A1,XBOOLE_0:def 4;
A3: il in dom Shift(IncAddr(G,k),k) by A1,XBOOLE_0:def 4;
  dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
  m in dom IncAddr(G,k) } by VALUED_1:def 12;
  then consider m being Element of NAT such that
A4: il = (m+k) and m in dom IncAddr(G,k) by A3;
  reconsider f = CutLastLoc F as non empty NAT-defined FinPartState of S
  by A1,RELAT_1:60;
  m+k <= LastLoc f by A2,A4,VALUED_1:33;
  then
A5: m+k <= card f -' 1 by AFINSQ_1:74;
A6: card f = card F - 1 by VALUED_1:39
    .= card F -' 1 by PRE_CIRC:25;
  per cases;
  suppose k - 1 >= 0;
    then m + k <= k - 1 by A5,A6,XREAL_0:def 2;
    then m + k - k <= k - 1 - k by XREAL_1:11;
    hence thesis by Lm1;
  end;
  suppose k - 1 < 0;
    then m + k = 0 or m + k < 0 by A5,A6,XREAL_0:def 2;
    hence thesis by A6;
  end;
end;

theorem Th51:
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F being unique-halt (initial non empty NAT-defined FinPartState of S),
  I being Element of NAT st I in dom CutLastLoc F
  holds (CutLastLoc F).I <> halt S
proof
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be unique-halt (initial non empty NAT-defined FinPartState of S),
  I be Element of NAT such that
A1: I in dom CutLastLoc F and
A2: (CutLastLoc F).I = halt S;
A3: dom CutLastLoc F c= dom F by GRFUNC_1:8;
  F.I = halt S by A1,A2,GRFUNC_1:8;
  then
A4: I = LastLoc F by A1,A3,COMPOS_1:def 26;
  dom CutLastLoc F = (dom F) \ {LastLoc F} by VALUED_1:37;
  then not I in {LastLoc F} by A1,XBOOLE_0:def 5;
  hence thesis by A4,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  func F ';' G -> (the Instructions of S)-valued NAT-defined FinPartState of S
   equals
  CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1);
  coherence
   proof set f = CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1);
XX: NAT c= the carrier of S by COMPOS_1:def 2;
    dom f c= NAT by RELAT_1:def 18;
    then dom f c= the carrier of S by XX,XBOOLE_1:1;
    hence thesis by RELAT_1:def 18;
   end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  cluster F ';' G -> non empty
  (the Instructions of S)-valued NAT-defined;
  coherence;
end;

theorem Th52:
  for S being regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  G being non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S
  holds card (F ';' G) = card F + card G - 1 &
  card (F ';' G) = card F + card G -' 1
proof
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  set k = card F -' 1;
  dom IncAddr(G,k),dom Shift(IncAddr(G,k),k) are_equipotent by VALUED_1:28;
  then
A1: IncAddr(G,k),Shift(IncAddr(G,k),k) are_equipotent by PRE_CIRC:26;
  dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th50;
  hence card (F ';' G)
  = card CutLastLoc F + card Shift(IncAddr(G,k),k) by PRE_CIRC:27
    .= card CutLastLoc F + card IncAddr(G,k) by A1,CARD_1:21
    .= card CutLastLoc F + card dom IncAddr(G,k) by CARD_1:104
    .= card CutLastLoc F + card dom G by Def15
    .= card CutLastLoc F + card G by CARD_1:104
    .= card F - 1 + card G by VALUED_1:39
    .= card F + card G - 1;
  hence thesis by XREAL_0:def 2;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  let F, G be initial non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  cluster F ';' G -> initial;
  coherence
  proof
    set P = F ';' G;
    let f,n be Nat such that
A1: n in dom P and
A2: f < n;
    set k = card F -' 1;
A3: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
    per cases by A1,A3,XBOOLE_0:def 3;
    suppose n in dom CutLastLoc F;
      then f in dom CutLastLoc F by A2,AFINSQ_1:def 13;
      hence thesis by A3,XBOOLE_0:def 3;
    end;
    suppose n in dom Shift(IncAddr(G,k),k);
      then n in { w+k where w is Element of NAT:
      w in dom IncAddr(G,k) } by VALUED_1:def 12;
      then consider m being Element of NAT such that
A4:   n = (m+k) and
A5:   m in dom IncAddr(G,k);
A7:   m in dom G by A5,Def15;
      now per cases;
        case
A8:       f < k;
          then f < card F - 1 by PRE_CIRC:25;
          then 1+f < 1 + (card F - 1) by XREAL_1:8;
          then
A9:       1+f in dom F by AFINSQ_1:70;
          f < 1+f by NAT_1:19;
          then
A10:      f in dom F by A9,AFINSQ_1:def 13;
          f <> LastLoc F by A8,AFINSQ_1:74;
          then not f in {LastLoc F} by TARSKI:def 1;
          then f in (dom F) \ {LastLoc F} by A10,XBOOLE_0:def 5;
          hence f in dom CutLastLoc F by VALUED_1:37;
        end;
        case f >= k;
          then consider l1 being Nat such that
A11:      f = k + l1 by NAT_1:10;
          reconsider l1 as Element of NAT by ORDINAL1:def 13;
A12:      dom Shift(IncAddr(G,k),k) =
{ w+k where w is Element of NAT: w in dom IncAddr(G,k) }
          by VALUED_1:def 12;
          l1 < m or l1 = m by A11,A4,A2,XREAL_1:8;
          then l1 in dom G by A7,AFINSQ_1:def 13;
          then l1 in dom IncAddr(G,k) by Def15;
          hence f in dom Shift(IncAddr(G,k),k) by A12,A11;
        end;
      end;
      hence thesis by A3,XBOOLE_0:def 3;
    end;
  end;
end;

theorem Th53:
  for S being regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds dom F c= dom (F ';' G)
proof
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set P = F ';' G;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,card F -' 1),card F -' 1)
  by FUNCT_4:def 1;
A2: dom F = dom CutLastLoc F \/ {LastLoc F} by VALUED_1:38;
  let x be set;
  assume
A3: x in dom F;
  per cases by A2,A3,XBOOLE_0:def 3;
  suppose x in dom CutLastLoc F;
    hence thesis by A1,XBOOLE_0:def 3;
  end;
  suppose
A4: x in {LastLoc F};
    then
A5: x = LastLoc F by TARSKI:def 1;
    reconsider f = x as Element of NAT by A4,TARSKI:def 1;
A6: f = card F -' 1 by A5,AFINSQ_1:74
      .= card F - 1 + (0 qua Nat) by PRE_CIRC:25;
    card P = card F + card G - 1 by Th52
      .= card F - 1 + card G;
    then f < card P by A6,XREAL_1:8;
    hence thesis by AFINSQ_1:70;
  end;
end;

theorem Th54:
  for S being regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds CutLastLoc F c= CutLastLoc (F ';' G)
proof
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
  set P = F ';' G;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A2: dom CutLastLoc F =
  { m where m is Element of NAT: m < card CutLastLoc F } by AFINSQ_1:72;
A3: card CutLastLoc P = card P - 1 by VALUED_1:39
    .= card F + card G - 1 - 1 by Th52
    .= card F - 1 + (card G - 1);
A4: for m being Element of NAT
  st m < card CutLastLoc F holds m < card CutLastLoc P
  proof
    let m be Element of NAT such that
A5: m < card CutLastLoc F;
A6: card CutLastLoc F = card F - 1 by VALUED_1:39;
    1 <= card G by NAT_1:14;
    then 1 - 1 <= card G - 1 by XREAL_1:11;
    then card F - 1 + (0 qua Nat) <= card F - 1 + (card G - 1) by XREAL_1:8;
    hence thesis by A3,A5,A6,XXREAL_0:2;
  end;
A7: dom CutLastLoc F c= dom CutLastLoc P
  proof
    let x be set;
    assume x in dom CutLastLoc F;
    then consider m being Element of NAT such that
A8: x = m and
A9: m < card CutLastLoc F by A2;
    m < card CutLastLoc P by A4,A9;
    hence thesis by A8,AFINSQ_1:70;
  end;
  for x being set st x in dom CutLastLoc F holds
  (CutLastLoc F).x = (CutLastLoc P).x
  proof
    let x be set;
    assume
A10: x in dom CutLastLoc F;
    then consider m being Element of NAT such that
A11: x = m and
A12: m < card CutLastLoc F by A2;
A13: dom Shift(IncAddr(G,k),k) = { w+k where w is Element of NAT:
    w in dom IncAddr(G,k) } by VALUED_1:def 12;
A14: now
      assume x in dom Shift(IncAddr(G,k),k);
      then consider w being Element of NAT such that
A15:  x = w+k and w in dom IncAddr(G,k) by A13;
      m < card F - 1 by A12,VALUED_1:39;
      then
      m < k by PRE_CIRC:25;
      hence contradiction by A11,A15,NAT_1:11;
    end;
A17: x in dom P by A1,A10,XBOOLE_0:def 3;
    now
      assume x = LastLoc P;
      then
A18:  m = card P -' 1 by A11,AFINSQ_1:74
        .= card P - 1 by PRE_CIRC:25;
      card CutLastLoc P = card P - 1 by VALUED_1:39;
      hence contradiction by A4,A12,A18;
    end;
    then not x in {LastLoc P} by TARSKI:def 1;
    then not x in dom ( LastLoc P .--> P.LastLoc P ) by FUNCOP_1:19;
    then x in dom P \ dom ( LastLoc P .--> P.LastLoc P ) by A17,XBOOLE_0:def 5;
    hence (CutLastLoc P).x = (CutLastLoc F +* Shift(IncAddr(G,k),k)).x
    by GRFUNC_1:93
      .= (CutLastLoc F).x by A14,FUNCT_4:12;
  end;
  hence thesis by A7,GRFUNC_1:8;
end;

theorem Th55:
  for S being regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds (F ';' G).LastLoc F = IncAddr(G,card F -' 1).0
proof
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
A1: LastLoc F = (0 qua Nat)+k by AFINSQ_1:74;
A2: 0 in dom IncAddr(G,k) by AFINSQ_1:69;
  dom Shift(IncAddr(G,k),k) =
  {(m+k) where m is Element of NAT: m in dom IncAddr(G,k)}
  by VALUED_1:def 12;
  then LastLoc F in dom Shift(IncAddr(G,k),k) by A1,A2;
  hence (F ';' G).LastLoc F = (Shift(IncAddr(G,k),k)).LastLoc F by FUNCT_4:14
    .= IncAddr(G,k).0 by A1,A2,VALUED_1:def 12;
end;

theorem
  for S being regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  f being Element of NAT st f < card F - 1
  holds IncAddr(F,card F -' 1).f = IncAddr(F ';' G, card F -' 1).f
proof
  let S be regular  homogeneous J/A-independent standard
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  f be Element of NAT;
  set k = card F -' 1, P = F ';' G;
  assume f < card F - 1;
  then f < card CutLastLoc F by VALUED_1:39;
  then
A1: f in dom CutLastLoc F by AFINSQ_1:70;
A3: dom CutLastLoc F c= dom F by GRFUNC_1:8;
  CutLastLoc F c= CutLastLoc P by Th54;
  then CutLastLoc F c= P by XBOOLE_1:1;
  then
A4: dom CutLastLoc F c= dom P by GRFUNC_1:8;
A5: F.f = F/.f by A1,A3,PARTFUN1:def 8;
  dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th50;
  then dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) = {} by XBOOLE_0:def 7;
  then not f in dom Shift(IncAddr(G,k),k)
  by A1,XBOOLE_0:def 4;
  then
A6: P.f = (CutLastLoc F).f by FUNCT_4:12
    .= F.f by A1,GRFUNC_1:8;
  thus IncAddr(F,k).f = IncAddr(F/.f,k) by A1,A3,Def15
    .= IncAddr(P/.f,k) by A1,A4,A5,A6,PARTFUN1:def 8
    .= IncAddr(P,k).f by A1,A4,Def15;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent standard realistic halting
  steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  let F be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  let G be halt-ending (initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> halt-ending;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
A1: dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
    m in dom IncAddr(G,k) } by VALUED_1:def 12;
A2: card G -' 1 = LastLoc G by AFINSQ_1:74;
    then
A3: card G -' 1 in dom G by VALUED_1:31;
    then
A4: card G -' 1 in dom IncAddr(G,k) by Def15;
    then
A5: k + (card G -' 1) in dom Shift(IncAddr(G,k),k) by A1;
A6: G/.(card G -' 1) = G.(card G -' 1) by A2,PARTFUN1:def 8,VALUED_1:31
      .= halt S by A2,COMPOS_1:def 25;
A7: card G - 1 >= 0 by NAT_1:14,XREAL_1:50;
    then k + (card G - 1) >= k+(0 qua Nat) by XREAL_1:8;
    then
A8: k + card G -' 1 = k + card G - 1 by XREAL_0:def 2
      .= k + (card G - 1)
      .= k + (card G -' 1) by A7,XREAL_0:def 2;
    thus P.(LastLoc P) = P.(card P -' 1) by AFINSQ_1:74
      .= P.(card F + card G -' 1 -' 1) by Th52
      .= P.(k + card G -' 1) by NAT_1:14,NAT_D:38
      .= Shift(IncAddr(G,k),k).(k + (card G -' 1)) by A5,A8,FUNCT_4:14
      .= IncAddr(G,k).(card G -' 1) by A4,VALUED_1:def 12
      .= IncAddr(G/.(card G -' 1),k) by A3,Def15
      .= halt S by A6,Th29;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent standard realistic halting
  steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  let F, G be halt-ending unique-halt
  (initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> unique-halt;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A2: dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
    m in dom IncAddr(G,k) } by VALUED_1:def 12;
A3: card G - 1 >= 0 by NAT_1:14,XREAL_1:50;
    then k + (card G - 1) >= k+(0 qua Nat) by XREAL_1:8;
    then
A4: k + card G -' 1 = k + card G - 1 by XREAL_0:def 2
      .= k + (card G - 1)
      .= k + (card G -' 1) by A3,XREAL_0:def 2;
    let f be Element of NAT such that
A5: P.f = halt S and
A6: f in dom P;
    per cases by A1,A6,XBOOLE_0:def 3;
    suppose
A7:   f in dom CutLastLoc F;
      then
A8:   (CutLastLoc F).f <> halt S by Th51;
      dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th50;
      then CutLastLoc F c= P by FUNCT_4:33;
      hence thesis by A5,A7,A8,GRFUNC_1:8;
    end;
    suppose
A9:   f in dom Shift(IncAddr(G,k),k);
      then consider m being Element of NAT such that
A10:  f = (m+k) and
A11:  m in dom IncAddr(G,k) by A2;
A12:  m in dom G by A11,Def15;
      then
A13:  G/.m = G.m by PARTFUN1:def 8;
      IncAddr(G/.m,k) = IncAddr(G,k).m by A12,Def15
        .= Shift(IncAddr(G,k),k).(m+k) by A11,VALUED_1:def 12
        .= halt S by A5,A9,A10,FUNCT_4:14;
      then m = LastLoc G by A12,A13,Th35,COMPOS_1:def 26
        .= (card G -' 1) by AFINSQ_1:74;
      then m+k = card F + card G -' 1 -' 1 by A4,NAT_1:14,NAT_D:38
        .= card P -' 1 by Th52;
      hence thesis by A10,AFINSQ_1:74;
    end;
  end;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be regular homogeneous J/A-independent standard realistic halting
  steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  let F, G be pre-Macro of S;
  redefine func F ';' G -> pre-Macro of S;
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-good (homogeneous steady-programmed Exec-preserving
  (regular J/A-independent standard realistic halting (standard-ins
  IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)))),
  F, G be closed initial non empty (NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> closed;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
    let f be Element of NAT such that
A1: f in dom P;
A2: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
    dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th50;
    then
A3: dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) = {} by XBOOLE_0:def 7;
A4: dom CutLastLoc F c= dom F by GRFUNC_1:8;
A5: dom Shift(IncAddr(G,k),k) =
    {(m+k) where m is Element of NAT: m in dom IncAddr(G,k)}
    by VALUED_1:def 12;
    let x be set;
    assume x in NIC(P/.f,f);
    then consider s2 being Element of product the Object-Kind of S
    such that
A6: x = IC Following(ProgramPart s2,s2) and
A7: IC s2 = f and
A8: (ProgramPart s2)/.f = P/.f;
A9: P/.f = P.f by A1,PARTFUN1:def 8;
    per cases by A1,A2,XBOOLE_0:def 3;
    suppose
A10:  f in dom CutLastLoc F;
      then
A11:  NIC(F/.f,f) c= dom F by A4,AMISTD_1:def 17;
X:  (ProgramPart s2)/.f = s2.f by COMPOS_1:38;
      not f in dom Shift(IncAddr(G,k),k) by A3,A10,XBOOLE_0:def 4;
      then s2.f = (CutLastLoc F).f by A8,A9,X,FUNCT_4:12
        .= F.f by A10,GRFUNC_1:8
        .= F/.f by A4,A10,PARTFUN1:def 8;
      then IC Following(ProgramPart s2,s2) in NIC(F/.f,f) by A7,X;
      then
A12:  x in dom F by A6,A11;
      dom F c= dom P by Th53;
      hence thesis by A12;
    end;
    suppose
A13:  f in dom Shift(IncAddr(G,k),k);
      then consider m being Element of NAT such that
A14:  f = (m+k) and
A15:  m in dom IncAddr(G,k) by A5;
A16:  m in dom G by A15,Def15;
      then
A17:  NIC(G/.m,m) c= dom G by AMISTD_1:def 17;
A18:  ObjectKind IC S = NAT by COMPOS_1:def 6;
      reconsider v = IC S .--> m as FinPartState of S
      by A18,COMPOS_1:5;
      set s1 = s2 +* v;
A19:  P/.f = Shift(IncAddr(G,k),k).f by A9,A13,FUNCT_4:14
        .= IncAddr(G,k).m by A14,A15,VALUED_1:def 12;
A20:  (IC S .--> m).IC S = m by FUNCOP_1:87;
A21:  IC S in {IC S} by TARSKI:def 1;
A22:  dom (IC S .--> m) = {IC S} by FUNCOP_1:19;
      reconsider w = IC S .--> (IC s1 + k) as FinPartState of S
      by A18,COMPOS_1:5;
      s1 +* w is State of S;
      then
A24:  dom (s1 +* (IC S .--> (IC s1 + k))) = the carrier of S by PARTFUN1:def 4;
X:    dom s2 = the carrier of S by PARTFUN1:def 4;
      for a being set st a in dom s2 holds
      s2.a = (s1 +* (IC S .--> (IC s1 + k))).a
      proof
        let a be set such that a in dom s2;
A25:    dom (IC S .--> (IC s1 + k)) = {IC S} by FUNCOP_1:19;
        per cases;
        suppose
A26:      a = IC S;
          hence s2.a = IC s1 + k by A7,A14,A22,A20,A21,FUNCT_4:14
            .= (IC S .--> (IC s1 + k)).a by A26,FUNCOP_1:87
            .= (s1 +* (IC S .--> (IC s1 + k))).a by A21,A25,A26,FUNCT_4:14;
        end;
        suppose
A27:      a <> IC S;
          then
A28:      not a in dom (IC S .--> (IC s1 + k)) by A25,TARSKI:def 1;
          not a in dom (IC S .--> m) by A22,A27,TARSKI:def 1;
          then s1.a = s2.a by FUNCT_4:12;
          hence thesis by A28,FUNCT_4:12;
        end;
      end;
      then
A29:  s2 = IncrIC(s1,k) by A24,X,FUNCT_1:9;
      set s3 = s1 +* (m .--> G/.m);
A30:  dom (m .--> G/.m) = {m} by FUNCOP_1:19;
      then
A31:  m in dom (m .--> G/.m) by TARSKI:def 1;
      now
        assume IC S in dom (m .--> G/.m);
        then reconsider l=IC S as Element of NAT
        by A30,TARSKI:def 1;
        l=IC S;
        hence contradiction by COMPOS_1:3;
      end;
      then
A32:  IC s3 = s1.IC S by FUNCT_4:12
        .= m by A20,A21,A22,FUNCT_4:14;
A33:  s3.m = (m .--> G/.m).m by A31,FUNCT_4:14
        .= G/.m by FUNCOP_1:87;
X:    (ProgramPart s3)/.m = s3.m by COMPOS_1:38;
A34:  dom s1 = the carrier of S by PARTFUN1:def 4;
A35:  dom s3 = the carrier of S by PARTFUN1:def 4;
      for x being set st x in dom s1 \ NAT holds s1.x = s3.x
      proof
        let x be set;
A36:    dom (m .--> G/.m) c= NAT by RELAT_1:def 18;
        assume x in dom s1 \ NAT;
        then not x in dom (m .--> G/.m)
        by A36,XBOOLE_0:def 5;
        hence thesis by FUNCT_4:12;
      end;
      then s1|(dom s1 \ NAT) = s3|(dom s3 \ NAT) by A34,A35,FUNCT_1:165;
      then s1, s3 equal_outside NAT by FUNCT_7:def 2;
      then
A37:  Exec(G/.m,s1), Exec(G/.m,s3)
      equal_outside NAT by Def19;
      reconsider s3 as Element of product the Object-Kind of S by PBOOLE:155;
      reconsider k,m as Element of NAT;
A38:  x = IC Exec(IncAddr(G/.m,k),s2) by A6,A7,A8,A16,A19,Def15
        .= IC Exec(G/.m, s1) + k by A29,Def17
        .= IC Exec(G/.m, s3) + k by A37,COMPOS_1:24;
      IC Following(ProgramPart s3,s3)
       = IC Exec(G/.m, s3)
      by A32,A33,COMPOS_1:38;
then IC Exec(G/.m, s3) in NIC(G/.m,m) by A32,A33,X;
      then IC Exec(G/.m, s3) in dom G by A17;
      then IC Exec(G/.m, s3) in dom IncAddr(G,k) by Def15;
      then x in dom Shift(IncAddr(G,k),k) by A5,A38;
      hence thesis by A2,XBOOLE_0:def 3;
    end;
  end;
end;

theorem Th57:
  for S being regular homogeneous J/A-independent standard halting
  without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N))
  holds IncAddr(Stop S, k) = Stop S
proof
  let S be regular homogeneous J/A-independent standard halting
  without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N));
A1: dom IncAddr(Stop S, k) = dom Stop S by Def15
    .= {0} by Lm5;
A2: dom Stop S = {0} by Lm5;
  for x being set st x in {0} holds IncAddr(Stop S, k).x = (Stop S). x
  proof
    let x be set;
    assume
A3: x in {0};
    then
A4: x = 0 by TARSKI:def 1;
    then
A5: (Stop S)/.0 = (Stop S).0 by A2,A3,PARTFUN1:def 8
      .= halt S by FUNCOP_1:87;
    thus IncAddr(Stop S, k).x
    = IncAddr((Stop S)/.0,k) by A2,A3,A4,Def15
      .= halt S by A5,Th29
      .= (Stop S).x by A4,FUNCOP_1:87;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

theorem Th58:
  for k being Element of NAT
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N))
  holds Shift(Stop S, k) = k .--> halt S
proof
  let k be Element of NAT;
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
A1: dom Shift(Stop S,k) =
  {(m+k) where m is Element of NAT: m in dom Stop S} by VALUED_1:def 12;
A2: 0 in dom Stop S by Lm5;
A3: dom Shift(Stop S,k) = {k}
  proof
    hereby
      let x be set;
      assume x in dom Shift(Stop S,k);
      then consider m being Element of NAT such that
A4:   x = (m+k) and
A5:   m in dom Stop S by A1;
      m in {0} by A5,Lm5;
      then m = 0 by TARSKI:def 1;
      hence x in {k} by A4,TARSKI:def 1;
    end;
    let x be set;
    assume x in {k};
    then x = (0 qua Nat)+k by TARSKI:def 1;
    hence thesis by A1,A2;
  end;
A6: dom (k .--> halt S) = {k} by FUNCOP_1:19;
  for x being set st x in {k} holds
  (Shift(Stop S, k)).x = (k .--> halt S).x
  proof
    let x be set;
    assume x in {k};
    then
A7: x = (0 qua Nat)+k by TARSKI:def 1;
    0 in dom Stop S by Lm5;
    hence (Shift(Stop S, k)).x = (Stop S).0 by A7,VALUED_1:def 12
      .= halt S by FUNCOP_1:87
      .= (k .--> halt S).x by A7,FUNCOP_1:87;
  end;
  hence thesis by A3,A6,FUNCT_1:9;
end;

theorem Th59:
  for S being regular homogeneous J/A-independent standard halting
  without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N)), F being pre-Macro of S
  holds F ';' Stop S = F
proof
  let S be regular homogeneous J/A-independent standard halting
  without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N)), F be pre-Macro of S;
  set k = card F -' 1;
A1: F ';' Stop S = CutLastLoc F +* Shift(Stop S,k) by Th57;
A2: dom F = dom CutLastLoc F \/ {LastLoc F} by VALUED_1:38;
  dom Shift(Stop S,k) = dom (k .--> halt S) by Th58
    .= {k} by FUNCOP_1:19
    .= {LastLoc F} by AFINSQ_1:74;
  then
A3: dom (F ';' Stop S) = dom F by A1,A2,FUNCT_4:def 1;
  for x being set st x in dom F holds (F ';' Stop S).x = F.x
  proof
    let x be set such that
A4: x in dom F;
    dom CutLastLoc F misses dom Shift(IncAddr(Stop S,k),k) by Th50;
    then
A5: {} = dom CutLastLoc F /\ dom Shift(IncAddr(Stop S,k),k) by XBOOLE_0:def 7;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A6:   x in dom CutLastLoc F;
      then not x in dom Shift(IncAddr(Stop S,k),k) by A5,XBOOLE_0:def 4;
      hence (F ';' Stop S).x = (CutLastLoc F).x by FUNCT_4:12
        .= F.x by A6,GRFUNC_1:8;
    end;
    suppose x in {LastLoc F};
      then
A7:   x = LastLoc F by TARSKI:def 1;
      then
A8:   x = k by AFINSQ_1:74;
A9:   0 in dom Stop S by Lm5;
      dom Shift(Stop S,k)
      = { (m+k) where m is Element of NAT: m in dom Stop S }
      by VALUED_1:def 12;
      then (0 qua Nat)+k in dom Shift(Stop S,k) by A9;
      hence (F ';' Stop S).x = Shift(Stop S,(0 qua Nat)+k).x
       by A1,A8,FUNCT_4:14
        .= (Stop S).0 by A8,A9,VALUED_1:def 12
        .= halt S by FUNCOP_1:87
        .= F.x by A7,COMPOS_1:def 25;
    end;
  end;
  hence thesis by A3,FUNCT_1:9;
end;

theorem Th60:
  for S being regular homogeneous J/A-independent standard halting
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), F being pre-Macro of S
  holds Stop S ';' F = F
proof
  let S be regular homogeneous J/A-independent standard halting
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), F be pre-Macro of S;
  set k = card Stop S -' 1;
A1: k = 0 by Lm6;
  hence Stop S ';' F = CutLastLoc Stop S +* Shift(F,k) by Th38
    .= CutLastLoc Stop S +* F by A1,VALUED_1:29
    .= F by FUNCT_4:21;
end;

theorem
  for S being regular homogeneous J/A-independent standard realistic halting
  steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)),
  F, G, H being pre-Macro of S holds F ';' G ';' H = F ';' (G ';' H)
proof
  let S be regular homogeneous J/A-independent standard realistic halting
  steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)),
  F, G, H be pre-Macro of S;
  per cases;
  suppose
A1: F = Stop S;
    hence F ';' G ';' H = G ';' H by Th60
      .= F ';' (G ';' H) by A1,Th60;
  end;
  suppose
A2: G = Stop S;
    hence F ';' G ';' H = F ';' H by Th59
      .= F ';' (G ';' H) by A2,Th60;
  end;
  suppose that
A3: F <> Stop S and
A4: G <> Stop S;
    set X = {k where k is Element of NAT:
    k < card F + card G + card H - 1 - 1};
A5: card (F ';' G ';' H) = card (F ';' G) + card H - 1 by Th52
      .= card F + card G - 1 + card H - 1 by Th52
      .= card F + card G + card H - 1 - 1;
A6: card (F ';' (G ';' H)) = card F + card (G ';' H) - 1 by Th52
      .= card F + (card G + card H - 1) - 1 by Th52
      .= card F + card G + card H - 1 - 1;
A7: dom (F ';' G ';' H) = X by A5,AFINSQ_1:72;
A8: dom (F ';' (G ';' H)) = X by A6,AFINSQ_1:72;
    for x being set st x in X holds (F ';' G ';' H).x = (F ';' (G ';' H)) . x
    proof
      let x be set;
      assume x in X;
      then consider k being Element of NAT such that
A9:   x = k and
A10:  k < card F + card G + card H - 1 - 1;
A11:  dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) =
      { m+(card F -' 1) where m is Element of NAT:
      m in dom IncAddr(G ';' H,card F -' 1) } by VALUED_1:def 12;
A12:  dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1) =
      { m+(card (F ';' G) -' 1) where m is Element of NAT:
      m in dom IncAddr(H,card (F ';' G) -' 1) } by VALUED_1:def 12;
A13:  dom Shift(IncAddr(H,card G -' 1),card G -' 1) =
      { m+(card G -' 1) where m is Element of NAT:
      m in dom IncAddr(H,card G -' 1) } by VALUED_1:def 12;
A14:  card (F ';' G) -' 1 = card (F ';' G) - 1 by PRE_CIRC:25
        .= card F + card G - 1 - 1 by Th52;
      then card (F ';' G) -' 1 = card F - 1 + (card G - 1);
      then
A15:  card (F ';' G) -' 1 = (card G -' 1) + (card F - 1) by PRE_CIRC:25
        .= (card G -' 1) + (card F -' 1) by PRE_CIRC:25;
A16:  dom Shift(IncAddr(G,card F -' 1),card F -' 1) =
      { m+(card F -' 1) where m is Element of NAT:
      m in dom IncAddr(G,card F -' 1) } by VALUED_1:def 12;
A17:  card F -' 1 = card F - 1 by PRE_CIRC:25;
A18:  card G -' 1 = card G - 1 by PRE_CIRC:25;
A19:  for W being pre-Macro of S st W <> Stop S holds 2 <= card W
      proof
        let W be pre-Macro of S;
        assume
A20:    W <> Stop S;
        assume 2 > card W;
        then 1 + 1 > card W;
        then card W <= 1 by NAT_1:13;
        hence contradiction by A20,Th26,NAT_1:26;
      end;
      then 2 <= card F by A3;
      then
A21:  1 <= card F by XXREAL_0:2;
A22:  2 <= card G by A4,A19;
      per cases by A21,A22,Lm2;
      suppose
A23:    k < card F - 1;
A24:    CutLastLoc F c= CutLastLoc (F ';' G) by Th54;
A25:    now
          assume x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1);
          then consider m being Element of NAT such that
A26:      x = m+(card F -' 1) and
          m in dom IncAddr(G ';' H,card F -' 1) by A11;
          k = m + (card F - 1) by A9,A26,PRE_CIRC:25;
          then m + (card F - 1) < card F -' 1 by A23,PRE_CIRC:25;
          then m + (card F -' 1) < card F -' 1 by PRE_CIRC:25;
          hence contradiction by NAT_1:11;
        end;
A27:    now
          assume x in dom
          Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A28:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + (card G -' 1) + (card F -' 1) < card F -' 1
          by A23,A9,A15,A28,PRE_CIRC:25;
          hence contradiction by NAT_1:11;
        end;
        k < card CutLastLoc F by A23,VALUED_1:39;
        then
A29:    x in dom CutLastLoc F by A9,AFINSQ_1:70;
        thus (F ';' G ';' H).x = (CutLastLoc (F ';' G)).x by A27,FUNCT_4:12
          .= (CutLastLoc F).x by A24,A29,GRFUNC_1:8
          .= (F ';' (G ';' H)).x by A25,FUNCT_4:12;
      end;
      suppose
A30:    k = card F - 1;
A31:    now
          assume x in dom
          Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A32:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + (card G -' 1) + (card F -' 1) = card F -' 1 by A30,A15,A32,A9,
PRE_CIRC:25;
          then card G -' 1 = 0;
          then card G - 1 = 0 by PRE_CIRC:25;
          hence contradiction by A4,Th26;
        end;
A33:    0 in dom IncAddr(G ';' H,card F -' 1) by AFINSQ_1:69;
A34:    0 in dom IncAddr(G,card F -' 1) by AFINSQ_1:69;
A35:    0 in dom G by AFINSQ_1:69;
A36:    0 in dom (G ';' H) by AFINSQ_1:69;
        k = (0 qua Nat) + (card F -' 1) by A30,PRE_CIRC:25;
        then
A37:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A9,A11,A33;
A38:    k = card F -' 1 by A30,PRE_CIRC:25;
A39:    x = (0 qua Nat)+k by A9;
        0 in dom IncAddr(G,card F -' 1) by AFINSQ_1:69;
        then
A40:    x in dom Shift(IncAddr(G,card F -' 1),card F -' 1) by A16,A38,A39;
then x in dom CutLastLoc F \/ dom Shift(IncAddr(G,card F -' 1),card F -' 1)
        by XBOOLE_0:def 3;
        then
A41:    x in dom (F ';' G) by FUNCT_4:def 1;
        now
A42:      dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))
          = {LastLoc (F ';' G)} by FUNCOP_1:19
            .= {card (F ';' G) -' 1} by AFINSQ_1:74;
assume x in dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ));
          then x = card (F ';' G) -' 1 by A42,TARSKI:def 1;
          then card G - 1 = 0 by A38,A9,A15,PRE_CIRC:25;
          hence contradiction by A4,Th26;
        end;
        then
A43:    x in dom (F ';' G) \
        dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))
        by A41,XBOOLE_0:def 5;
        1 <= card G by NAT_1:14;
        then card G > 1 by A4,Th26,XXREAL_0:1;
        then
A44:    card G - 1 > 1 - 1 by XREAL_1:11;
        then card G -' 1 > 1 - 1 by PRE_CIRC:25;
        then
A45:    not 0 in dom Shift(IncAddr(H,card G -' 1), card G -' 1) by VALUED_1:30;
        card CutLastLoc G <> {} by A44,VALUED_1:39;
        then
A46:    0 in dom CutLastLoc G by AFINSQ_1:69,CARD_1:47;
A47:    G/.0 = G.0 by A35,PARTFUN1:def 8
          .= (CutLastLoc G).0 by A46,GRFUNC_1:8
          .= (G ';' H).0 by A45,FUNCT_4:12
          .= (G ';' H)/.0 by A36,PARTFUN1:def 8;
        thus (F ';' G ';' H).x = ((F ';' G) \
        ( LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))).x by A31,
FUNCT_4:12
.= (CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1)).x by A43,
GRFUNC_1:93
          .= Shift(IncAddr(G,card F -' 1),card F -' 1).x by A40,FUNCT_4:14
          .= IncAddr(G,card F -' 1).0 by A34,A38,A39,VALUED_1:def 12
          .= IncAddr((G ';' H)/.0,card F -' 1) by A35,A47,Def15
          .= IncAddr(G ';' H,card F -' 1).0 by A36,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
        by A33,A38,A39,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A37,FUNCT_4:14;
      end;
      suppose that
A48:    card F <= k and
A49:    k <= card F + card G - 3;
A50:    now
          assume
          x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A51:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + ((card G -' 1) + (card F -' 1))
          <= - 1 + ((card G -' 1) + (card F -' 1)) by A9,A15,A17,A18,A49,A51;
          then m <= -1 by XREAL_1:8;
          hence contradiction by Lm1;
        end;
        card F -' 1 <= card F by NAT_D:35;
        then
A52:    x = k -' (card F -' 1) + (card F -' 1)
        by A9,A48,XREAL_1:237,XXREAL_0:2;
A53:    card F - card F <= k - card F by A48,XREAL_1:11;
        card F - 1 < card F - 0 by XREAL_1:17;
        then k - (card F - 1) >= 0 by A53,XREAL_1:17;
        then
A54:    k - (card F -' 1) >= 0 by PRE_CIRC:25;
A55:    card F + card G - 3 < card F + card G - 3 + 1 by XREAL_1:31;
        then
A56:    k < (card G - 1) + (card F - 1) by A49,XXREAL_0:2;
        k - (card F - 1) + (card F - 1) < (card G - 1) + (card F - 1)
        by A49,A55,XXREAL_0:2;
        then k - (card F - 1) < card G - 1 by XREAL_1:9;
        then k - (card F -' 1) < card G - 1 by PRE_CIRC:25;
        then k -' (card F -' 1) < card G - 1 by A54,XREAL_0:def 2;
        then k -' (card F -' 1) < card CutLastLoc G by VALUED_1:39;
        then
A57:    k -' (card F -' 1) in dom CutLastLoc G by AFINSQ_1:70;
        then k -' (card F -' 1) in
        dom CutLastLoc G \/ dom Shift(IncAddr(H,card G -' 1),card G -' 1)
        by XBOOLE_0:def 3;
        then
A58:    k -' (card F -' 1) in dom (G ';' H) by FUNCT_4:def 1;
        then
A59:    k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by Def15;
        then
A60:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A52;
        card G + card F - 2 < card F + card G - 1 by XREAL_1:17;
        then k < card F + card G - 1 by A56,XXREAL_0:2;
        then k < card (F ';' G) by Th52;
        then
A61:    x in dom (F ';' G) by A9,AFINSQ_1:70;
        now
          assume x in dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G));
          then x in {LastLoc (F ';' G)} by FUNCOP_1:19;
          then x = LastLoc (F ';' G) by TARSKI:def 1
            .= card (F ';' G) -' 1 by AFINSQ_1:74;
          then k = (card G - 1) + (card F - 1) by A9,A15,A18,PRE_CIRC:25;
          hence contradiction by A49,A55;
        end;
        then
A62:    x in dom (F ';' G) \
        dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G))
        by A61,XBOOLE_0:def 5;
A63:    dom CutLastLoc G c= dom G by GRFUNC_1:8;
        then k -' (card F -' 1) in dom G by A57;
        then
A64:    k -' (card F -' 1) in dom IncAddr(G,card F -' 1) by Def15;
        then
A65:    x in dom Shift(IncAddr(G,card F -' 1),card F -' 1) by A16,A52;
A66:    now
          assume k -' (card F -' 1) in
          dom Shift(IncAddr(H,card G -' 1),card G -' 1);
          then consider m being Element of NAT such that
A67:      k -' (card F -' 1) = m+(card G -' 1) and
          m in dom IncAddr(H,card G -' 1) by A13;
A68:      m = k -' (card F -' 1) - (card G -' 1) by A67
            .= k - (card F -' 1) - (card G -' 1) by A54,XREAL_0:def 2
            .= k - (card F - 1) - (card G -' 1) by PRE_CIRC:25
            .= k - (card F - 1) - (card G - 1) by PRE_CIRC:25
            .= k - (card F + card G - 2);
          k - (card F + card G - 2)
          <= card F + card G - 3 - (card F + card G - 2) by A49,XREAL_1:11;
          hence contradiction by A68,Lm1;
        end;
A69:    (G ';' H)/.(k -' (card F -' 1))
        = (CutLastLoc G +* Shift(IncAddr(H,card G -' 1),card G -' 1))
        .(k -' (card F -' 1)) by A58,PARTFUN1:def 8
          .= (CutLastLoc G).(k -' (card F -' 1)) by A66,FUNCT_4:12
          .= G.(k -' (card F -' 1)) by A57,GRFUNC_1:8;
        thus (F ';' G ';' H).x
        = ((F ';' G) \ (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G))).x
        by A50,FUNCT_4:12
.= (CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1)).x by A62,
GRFUNC_1:93
          .= Shift(IncAddr(G,card F -' 1),card F -' 1).x by A65,FUNCT_4:14
          .= IncAddr(G,card F -' 1).(k -' (card F -' 1))
           by A52,A64,VALUED_1:def 12
          .= IncAddr(G/.(k -' (card F -' 1)),card F -' 1)
        by A57,A63,Def15
          .= IncAddr((G ';' H)/.(k -' (card F -' 1)),card F -' 1)
        by A57,A63,A69,PARTFUN1:def 8
          .= IncAddr(G ';' H,card F -' 1).(k -' (card F -' 1))
        by A58,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A52,A59,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A60,FUNCT_4:14;
      end;
      suppose
A70:    k = card F + card G - 2;
        then
A71:    x = (k -' (card (F ';' G) -' 1) + (card (F ';' G) -' 1))
        by A9,A14,XREAL_1:237;
        k - (card (F ';' G) -' 1) = 0 by A14,A70;
        then
A72:    k -' (card (F ';' G) -' 1) = 0 by XREAL_0:def 2;
        then
A73:    k -' (card (F ';' G) -' 1) in dom IncAddr(H,card (F ';' G)
        -' 1) by AFINSQ_1:69;
        then
A74:    x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1)
        by A12,A71;
A75:    x = (card G -' 1) + (card F -' 1) by A9,A17,A18,A70;
        card G - 1 + (0 qua Nat) < card G - 1 + card H by XREAL_1:8;
        then card G -' 1 < card G + card H - 1 by PRE_CIRC:25;
        then card G -' 1 < card (G ';' H) by Th52;
        then
A76:    (card G -' 1) in dom (G ';' H) by AFINSQ_1:70;
        then
A77:    (card G -' 1) in dom IncAddr(G ';' H,card F -' 1) by Def15;
        then
A78:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A75;
A79:    0 in dom H by AFINSQ_1:69;
A80:    (G ';' H)/.(card G -' 1) = (G ';' H).(card G -' 1)
        by A76,PARTFUN1:def 8;
A81:    0 in dom IncAddr(H,card G -' 1) by AFINSQ_1:69;
        then
A82:    IncAddr(H,card G -' 1)/.0
        = IncAddr(H,card G -' 1).0 by PARTFUN1:def 8
          .= IncAddr(H/.0,(card G -' 1)) by A79,Def15;
        (G ';' H)/.(card G -' 1)
        = (G ';' H).LastLoc G by A80,AFINSQ_1:74
          .= IncAddr(H,card G -' 1).0 by Th55
          .= IncAddr(H,card G -' 1)/.0 by A81,PARTFUN1:def 8;
        then
A83:    IncAddr((G ';' H)/.(card G -' 1),card F -' 1)
        = IncAddr(H/.0,card (F ';' G) -' 1) by A15,A82,Th37;
        thus (F ';' G ';' H).x
        = Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1).x
        by A74,FUNCT_4:14
          .= IncAddr(H,card (F ';' G) -' 1).(k -' (card (F ';' G) -' 1))
        by A71,A73,VALUED_1:def 12
          .= IncAddr(H/.0,card (F ';' G) -' 1) by A72,A79,Def15
          .= IncAddr(G ';' H,card F -' 1).(card G -' 1) by A76,A83,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A75,A77,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A78,FUNCT_4:14;
      end;
      suppose
A84:    card F + card G - 2 < k;
        then
A85:    x = (k -' (card (F ';' G) -' 1) + (card (F ';' G) -' 1))
        by A9,A14,XREAL_1:237;
        k + (0 qua Nat) < card F + card G - (1 + 1) + card H by A10;
        then k - (card F + card G - (1 + 1)) < card H - 0 by XREAL_1:23;
        then k -' (card (F ';' G) -' 1) < card H by A14,XREAL_0:def 2;
        then
A86:    k -' (card (F ';' G) -' 1) in dom H by AFINSQ_1:70;
        then
A87:    k -' (card (F ';' G) -' 1) in dom IncAddr(H,card (F ';' G)
        -' 1) by Def15;
        then
A88:    x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1)
        by A12,A85;
A89:    card F -' 1 <= (card G -' 1) + (card F -' 1) by NAT_1:11;
        then
A90:    k >= card F -' 1 by A14,A15,A84,XXREAL_0:2;
A91:    x = k -' (card F -' 1) + (card F -' 1) by A9,A14,A15,A84,A89,
XREAL_1:237,XXREAL_0:2;
A92:    k - (card F -' 1) >= 0 by A90,XREAL_1:50;
A93:    k - (card F -' 1) < card F + card G + card H - 1 - 1 - (card F -' 1)
        by A10,XREAL_1:11;
        then
A94:    k -' (card F -' 1) < card F + card G + card H - card F - 1
        by A17,A92,XREAL_0:def 2;
        k -' (card F -' 1) < card F - card F + card G + card H - 1
        by A17,A92,A93,XREAL_0:def 2;
        then k -' (card F -' 1) < card (G ';' H) by Th52;
        then
A95:    k -' (card F -' 1) in dom (G ';' H) by AFINSQ_1:70;
        then k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by Def15;
        then
A96:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A91;
A97:    k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by A95,Def15;
A98:    k - (card F -' 1) >= card (F ';' G) -' 1 - (card F -' 1)
        by A14,A84,XREAL_1:11;
        then
A99:    k -' (card F -' 1) >= (card F -' 1) + (card G -' 1) - ( card F -' 1)
        by A14,A15,A84,A89,XREAL_1:235,XXREAL_0:2;
A100:   k -' (card F -' 1) >= card G -' 1 by A14,A15,A84,A89,A98,XREAL_1:235
,XXREAL_0:2;
A101:   k -' (card F -' 1) =
        k -' (card F -' 1) -' (card G -' 1) + (card G -' 1) by A99,XREAL_1:237;
        k -' (card F -' 1) - (card G -' 1) < card G + card H - 1 - (card G -
        1) by A18,A94,XREAL_1:11;
        then k -' (card F -' 1) -' (card G -' 1) <
        card H + (card G - 1) - (card G - 1) by A100,XREAL_1:235;
then k -' (card F -' 1) -' (card G -' 1) in dom H by AFINSQ_1:70;
        then
A102:   k -' (card F -' 1) -' (card G -' 1) in
        dom IncAddr(H,card G -' 1) by Def15;
        then
A103:   k -' (card F -' 1) in
        dom Shift(IncAddr(H,card G -' 1),card G -' 1) by A13,A101;
A104:   k -' (card F -' 1) -' (card G -' 1)
        = k -' (card F -' 1) - (card G -' 1) by A99,XREAL_1:235
       .= k - (card F -' 1) - (card G -' 1) by A14,A15,A84,A89,XREAL_1:235
,XXREAL_0:2
          .= k - ((card F -' 1) + (card G -' 1))
          .= k -' (card (F ';' G) -' 1) by A14,A15,A84,XREAL_1:235;
A105:   (G ';' H)/.(k -' (card F -' 1))
        = ((CutLastLoc G) +* Shift(IncAddr(H,card G -' 1),card G -' 1)).
        (k -' (card F -' 1)) by A95,PARTFUN1:def 8
.= Shift(IncAddr(H,card G -' 1),card G -' 1).(k -' (card F -' 1))
        by A103,FUNCT_4:14
.= IncAddr(H,card G -' 1).(k -' (card (F ';' G) -' 1)) by A101,A102,A104,
VALUED_1:def 12
          .= IncAddr(H/.(k -' (card (F ';' G) -' 1)),card G -' 1)
        by A86,Def15;
        thus (F ';' G ';' H).x
        = Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1).x
        by A88,FUNCT_4:14
          .= IncAddr(H,card (F ';' G) -' 1).(k -' (card (F ';' G) -' 1))
        by A85,A87,VALUED_1:def 12
.= IncAddr(H/.(k -' (card (F ';' G) -' 1)),card (F ';' G) -' 1)
        by A86,Def15
          .= IncAddr((G ';' H)/.(k -' (card F -' 1)),card F -' 1)
        by A15,A105,Th37
          .= IncAddr(G ';' H,card F -' 1).(k -' (card F -' 1))
        by A95,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A91,A97,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A96,FUNCT_4:14;
      end;
    end;
    hence thesis by A7,A8,FUNCT_1:9;
  end;
end;

theorem
  for S being regular homogeneous
  (standard-ins non empty stored-program AMI-Struct over N),
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x in (product" JumpParts InsCode I).x
proof
  let S be regular homogeneous
  (standard-ins non empty stored-program AMI-Struct over N),
  I be Instruction of S, x be set such that
A1: x in dom JumpPart I;
A2: JumpPart I in JumpParts InsCode I;
A3: dom product" JumpParts InsCode I = DOM JumpParts InsCode I
  by CARD_3:92
    .= dom JumpPart I by A2,CARD_3:def 12;
  (JumpPart I).x in pi(JumpParts InsCode I,x) by A2,CARD_3:def 6;
  hence thesis
  by A1,A3,CARD_3:93;
end;

theorem
  for I being Instruction of Trivial-AMI N holds JumpPart I = 0 by Lm3;

theorem
  for T being InsType of Trivial-AMI N holds JumpParts T = {0} by Lm4;

begin :: Addenda

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  N for with_non-empty_elements non empty set,
  S for standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  l for Element of NAT,
  f for FinPartState of S;

Lm7: for
a,b,c being set st a c= c & b c= c \ a holds c = a \/ (c \ (a\/b)) \/ b
proof
  let a,b,c be set such that
A1: a c= c and
A2: b c= c \ a;
  thus a \/ (c \ (a\/b)) \/ b = a \/ (c \ a \ b) \/ b by XBOOLE_1:41
    .= a \/ ((c \ a \ b) \/ b) by XBOOLE_1:4
    .= a \/ ((c \ a) \/ b) by XBOOLE_1:39
    .= a \/ (c \ a) by A2,XBOOLE_1:12
    .= a \/ c by XBOOLE_1:39
    .= c by A1,XBOOLE_1:12;
end;

Lm8: for S being IC-Ins-separated definite realistic
(non empty stored-program AMI-Struct over N) holds
NAT c= (the carrier of S) \ {IC S}
proof
  let S be IC-Ins-separated definite realistic
  (non empty stored-program AMI-Struct over N);
  let i be set;
A1: NAT c= the carrier of S by COMPOS_1:def 2;
  assume
A2: i in NAT;
  then i <> IC S by COMPOS_1:3;
  then not i in {IC S} by TARSKI:def 1;
  hence thesis by A1,A2,XBOOLE_0:def 5;
end;

canceled 2;

theorem
  for S being Exec-preserving IC-Ins-separated definite realistic
  steady-programmed (non empty stored-program AMI-Struct over N),
  s being State of S, i being Instruction of S,
  p being NAT-defined FinPartState of S
  holds Exec (i, s +* p) = Exec (i,s) +* p
proof
  let S be Exec-preserving IC-Ins-separated definite realistic
  steady-programmed (non empty stored-program AMI-Struct over N),
  s be State of S, i be Instruction of S, p be NAT-defined FinPartState of S;
  set C = the carrier of S;
  set I = NAT;
  set D = C \ ({IC S} \/ I);
A1: dom p c= I by RELAT_1:def 18;
A2: dom s = C by PARTFUN1:def 4;
A3: dom (s+*p) = C by PARTFUN1:def 4;
A4: dom Exec(i,s) = C by PARTFUN1:def 4;
A5: dom Exec(i,s+*p) = C by PARTFUN1:def 4;
  D = C \ I \ {IC S} by XBOOLE_1:41;
  then
A6: D \/ {IC S} = (C \ I) \/ {IC S} by XBOOLE_1:39;
A7: {IC S} c= C by ZFMISC_1:37;
  {IC S} c= C \ I
  proof
    let x be set;
    assume
A8: x in {IC S};
    then
A9: x = IC S by TARSKI:def 1;
    not x in I by A9,COMPOS_1:3;
    hence thesis by A7,A8,XBOOLE_0:def 5;
  end;
  then
A10: C \ I = D \/ {IC S} by A6,XBOOLE_1:12;
  I c= C \ {IC S} by Lm8;
  then
A11: C = {IC S} \/ D \/ I by A7,Lm7;
  D \/ {IC S} misses I
  proof
    assume not thesis;
    then consider o being set such that
A12: o in D \/ {IC S} and
A13: o in I by XBOOLE_0:3;
    reconsider l = o as Element of NAT by A13;
A14: o in D or o in {IC S} by A12,XBOOLE_0:def 3;
    per cases by A14,TARSKI:def 1;
    suppose o in D;
      then not o in {IC S} \/ I by XBOOLE_0:def 5;
      hence contradiction by A13,XBOOLE_0:def 3;
    end;
    suppose o = IC S;
      then l = IC S;
      hence contradiction by COMPOS_1:3;
    end;
  end;
  then
A15: D \/ {IC S} misses dom p by A1,XBOOLE_1:63;
  then s|(dom s \ I) = (s+*p)|(dom(s+*p) \ I) by A2,A3,A10,FUNCT_4:76;
  then s, s+*p equal_outside I by FUNCT_7:def 2;
  then
A16: Exec(i,s), Exec(i,s+*p) equal_outside I by Def19;
A17: (Exec(i,s) +* p) | (D \/ {IC S})
  = Exec(i,s) | (D \/ {IC S}) by A15,FUNCT_4:76
    .= Exec(i,s +* p) | (D \/ {IC S}) by A4,A5,A10,A16,FUNCT_7:def 2;
A18: ProgramPart Exec (i, s +* p) = ProgramPart (s +* p) by AMI_1:117
    .= ProgramPart s +* ProgramPart p by FUNCT_4:75
    .= ProgramPart Exec (i,s) +* ProgramPart p by AMI_1:117
    .= ProgramPart (Exec (i, s) +* p) by FUNCT_4:75;
  thus Exec (i, s +* p)
  = Exec (i, s +* p)| ({IC S} \/ D \/ I) by A5,A11,RELAT_1:98
    .= (Exec (i, s) +* p)| ({IC S} \/ D)
  +* (Exec (i, s) +* p)|I by A17,A18,FUNCT_4:83
    .= (Exec (i,s) +* p)| ({IC S} \/ D \/ I) by FUNCT_4:83
    .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by A11,PARTFUN1:def 4
    .= Exec (i,s) +* p by RELAT_1:98;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard (IC-Ins-separated definite
  halting realistic
  (standard-ins non empty stored-program AMI-Struct over N)),
  k be Element of NAT, p be FinPartState of S;
  func Relocated (p,k) -> FinPartState of S equals
   IncrIC(NPP p,k) +* Reloc(ProgramPart p,k);
:::  Start-At(IC p + k,S) +* Reloc(ProgramPart(p),k) +* DataPart p;
  coherence;
end;

reserve S for regular homogeneous J/A-independent standard (IC-Ins-separated
definite halting realistic
  (standard-ins non empty stored-program AMI-Struct over N)),
  g for FinPartState of S,
  il for Element of NAT;

theorem
 for k being Element of NAT holds
  DataPart(Relocated(g,k)) = DataPart(g)
proof
  let k be Element of NAT;
   dom Reloc(ProgramPart(g),k) c= NAT by RELAT_1:def 18;
   then dom Reloc(ProgramPart(g),k) misses Data-Locations S
        by COMPOS_1:51,XBOOLE_1:63;
  hence DataPart Relocated(g,k)
     = DataPart IncrIC(NPP g,k) by FUNCT_4:76
    .= DataPart NPP g by COMPOS_1:48
    .= DataPart g by COMPOS_1:73;
end;

theorem Th69:
  for k being Element of NAT holds
  ProgramPart(Relocated(g,k)) = Reloc(ProgramPart(g),k)
proof
  let k be Element of NAT;
  thus ProgramPart(Relocated(g,k)) =
     IncrIC(NPP g,k)|NAT +* Reloc(ProgramPart(g),k)|NAT by FUNCT_4:75
    .= {} +* Reloc(ProgramPart(g),k)|NAT by COMPOS_1:def 29
    .= Reloc(ProgramPart(g),k)|NAT by FUNCT_4:21
    .= Reloc(ProgramPart g,k) by RELAT_1:209;
end;

theorem Th70:
  for k being Element of NAT holds
  for p being finite NAT-defined (the Instructions of S)-valued Function
   holds dom Reloc(p,k) =
    { j+k where j is Element of NAT:j in dom p }
proof
  let k be Element of NAT;
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  thus dom Reloc(p,k) = dom Shift(p,k) by Def15
    .= { j+k where j is Element of NAT:j in dom p } by VALUED_1:def 12;
end;

theorem
  for k being Element of NAT holds
  il in dom g iff il + k in dom Relocated(g,k)
proof
  let k be Element of NAT;
  consider m being natural number such that
A2: il = m;
  A4: dom ProgramPart(Relocated(g,k)) = dom Reloc(ProgramPart g,k) by Th69
   .= { j+k where j is Element of NAT:
  j in dom ProgramPart(g) } by Th70;
  ProgramPart(Relocated(g,k)) c= Relocated(g,k) by RELAT_1:88;
  then
A5: dom ProgramPart(Relocated(g,k)) c= dom Relocated(g,k) by GRFUNC_1:8;
  hereby
    assume il in dom g;
    then m in dom ProgramPart g by A2,COMPOS_1:16;
    then il + k in dom ProgramPart(Relocated(g,k)) by A2,A4;
    hence il + k in dom Relocated(g,k) by A5;
  end;
  assume il + k in dom Relocated(g,k);
  then il + k in dom ProgramPart(Relocated(g,k)) by COMPOS_1:16;
  then consider j being Element of NAT such that
A7: il + k = j+k and
A8: j in dom ProgramPart g by A4;
  ProgramPart g c= g by RELAT_1:88;
  then dom ProgramPart g c= dom g by GRFUNC_1:8;
  hence thesis by A8,A7;
end;

theorem Th72:
  for k being Element of NAT holds
  IC S in dom Relocated (g,k)
proof
  let k be Element of NAT;
  Relocated (g,k) = IncrIC(NPP g,k) +* Reloc(ProgramPart(g),k) &
  IC S in dom IncrIC(NPP g,k) by COMPOS_1:53;
  hence thesis by FUNCT_4:13;
end;

theorem Th73:
  for k being Element of NAT st IC S in dom g
   holds IC Relocated (g,k) = IC g + k
proof
  let k be Element of NAT such that
A3: IC S in dom g;
    ProgramPart(Relocated(g,k)) = Reloc(ProgramPart g,k) by Th69;
  then
A1: not IC S in dom Reloc(ProgramPart g,k) by COMPOS_1:12;
  thus IC Relocated (g,k) = Relocated (g,k).IC S
    .= IC IncrIC(NPP g,k) by A1,FUNCT_4:12
    .= (IC NPP g) +k by COMPOS_1:54
    .= (IC g) +k by A3,COMPOS_1:72;
end;

canceled;

theorem Th75:
  for i,j being Element of NAT holds
  for p being NAT-defined (the Instructions of S)-valued FinPartState of S
  holds Shift(IncAddr(p,i),j) = IncAddr(Shift(p,j),i)
proof
  let i,j be Element of NAT;
  let p be NAT-defined (the Instructions of S)-valued FinPartState of S;
  set f = Shift(IncAddr(p,i),j);
  set g = IncAddr(Shift(p,j),i);
  dom(IncAddr(p,i)) = dom p by Def15;
  then dom(Shift(p,j)) = { m+j where m is Element of NAT:
  m in dom (IncAddr(p,i)) } by VALUED_1:def 12
    .= dom f by VALUED_1:def 12;
  then
A1: dom f = dom g by Def15;
  now
    let x be set;
A2: dom f c= NAT by RELAT_1:def 18;
    assume
A3: x in dom f;
    then reconsider x9=x as Element of NAT by A2;
    reconsider xx=x9 as Element of NAT;
    x in { m+j where m is Element of NAT:
    m in dom IncAddr(p,i) } by A3,VALUED_1:def 12;
    then consider m being Element of NAT such that
A4: x = m+j and
A5: m in dom IncAddr(p,i);
A7: m in dom p by A5,Def15;
    dom Shift(p,j) = { mm+j where mm is Element of NAT :
    mm in dom p} by VALUED_1:def 12;
    then
A8: x9 in dom Shift(p,j) by A4,A7;
    reconsider mm=m as Element of NAT;
A9: p/.mm = p.m by A7,PARTFUN1:def 8
      .= Shift(p,j).(m + j) by A7,VALUED_1:def 12
      .= Shift(p,j)/.xx by A4,A8,PARTFUN1:def 8;
    thus f.x = IncAddr(p,i).(m) by A5,A4,VALUED_1:def 12
      .= IncAddr(Shift(p,j)/.xx,i) by A7,A9,Def15
      .= g.x by A8,Def15;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for k being Element of NAT holds
  for I being Instruction of S holds
  il in dom ProgramPart g & I = g.il implies
  IncAddr(I, k) = (Relocated (g, k)).(il + k)
proof
  let k be Element of NAT;
  let I be Instruction of S;
  assume that
A2: il in dom ProgramPart g and
A3: I = g.il;
A4: ProgramPart g c= g by RELAT_1:88;
  consider i being natural number such that
A5: il = i;
  reconsider ii = il as Element of NAT;
  i+k in { j+k where j is Element of NAT:
  j in dom ProgramPart(g) } by A2,A5;
  then il + k in dom Reloc(ProgramPart g,k) by A5,Th70;
  then
A6: il + k in dom ProgramPart(Relocated(g,k)) by Th69;
A7: il in dom IncAddr(ProgramPart(g),k) by A2,Def15;
A8: I = (ProgramPart g).il by A2,A3,A4,GRFUNC_1:8;
  ProgramPart (Relocated(g, k)) c= (Relocated(g, k)) by RELAT_1:88;
  hence (Relocated(g, k)).(il + k)
  = (ProgramPart(Relocated(g, k))).(il + k) by A6,GRFUNC_1:8
    .= (IncAddr(Shift(ProgramPart(g),k),k)).(il + k) by Th69
    .= (Shift(IncAddr(ProgramPart(g),k),k)).(il + k) by Th75
    .= (IncAddr(ProgramPart(g),k)).il by A7,VALUED_1:def 12
    .= IncAddr((ProgramPart g)/.ii,k) by A2,Def15
    .= IncAddr(I,k) by A2,A8,PARTFUN1:def 8;
end;

theorem
  for k being Element of NAT st IC S in dom g
  holds Start-At (IC g + k,S) c= Relocated (g,k)
proof
  let k be Element of NAT such that
Z: IC S in dom g;
A1: Start-At(IC g +k,S) = {[IC S,IC g + k]} by FUNCT_4:87;
A2: IC Relocated(g,k) = IC g + k by Z,Th73;
A3: IC S in dom (Relocated(g,k)) by Th72;
A4: [IC S,IC g + k] in Relocated(g,k) by A3,A2,FUNCT_1:def 4;
  thus Start-At(IC g +k,S) c= Relocated(g,k)
  proof
    let x be set;
    assume x in Start-At(IC g +k,S);
    hence thesis by A1,A4,TARSKI:def 1;
  end;
end;

theorem
  for k being Element of NAT holds
  for q being data-only FinPartState of S
   holds Relocated((g +* q), k) = Relocated (g,k) +* q
proof
  let k be Element of NAT,
      s be data-only FinPartState of S;
A: NAT misses Data-Locations S by COMPOS_1:51;
  dom s c= Data-Locations S by COMPOS_1:31;
  then
Y:  dom s misses NAT by A,XBOOLE_1:63;
XX: dom Reloc(ProgramPart g,k) c= NAT by RELAT_1:def 18;
  thus Relocated((g +* s), k)
     = IncrIC(NPP(g +* s),k) +* Reloc(ProgramPart(g +* s),k)
    .= IncrIC(NPP(g +* s),k) +* Reloc(ProgramPart g,k) by COMPOS_1:66
    .= IncrIC(NPP g +* s,k) +* Reloc(ProgramPart g,k) by COMPOS_1:67
    .= IncrIC(NPP g,k) +* s +* Reloc(ProgramPart g,k) by COMPOS_1:60
    .= IncrIC(NPP g,k) +* (s +* Reloc(ProgramPart g,k)) by FUNCT_4:15
    .= IncrIC(NPP g,k) +* (Reloc(ProgramPart g,k) +* s)
     by XX,Y,FUNCT_4:36,XBOOLE_1:63
    .= IncrIC(NPP g,k) +* Reloc(ProgramPart g,k) +* s by FUNCT_4:15
    .= Relocated (g,k) +* s;
end;

