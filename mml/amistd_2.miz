:: On the Composition of Macro Instructions of Standard Computers
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5,
      AMISTD_1, UNIALG_1, FUNCT_1, CARD_3, CARD_5, FRECHET, RCOMP_1, STRUCT_0,
      VALUED_1, FSM_1, FUNCT_4, FUNCT_7, TURING_1, CIRCUIT2, AMISTD_2,
      PARTFUN1, CAT_1, SCMNORM, NAT_1, RELOC, PBOOLE, XXREAL_0, COMPOS_1,
      MSUALG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, MCART_1, SETFAM_1,
      MEMBERED, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE,
      CARD_1,
      NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1, NAT_D,
      FUNCT_7, VALUED_0, VALUED_1, AFINSQ_1, STRUCT_0,
      COMPOS_1, EXTPRO_1, AMISTD_1;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, RECDEF_2, VALUED_1, NAT_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1, EXTPRO_1,
      XCMPLX_0, REAL_1, PBOOLE;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions RELAT_1, FUNCT_1, WELLORD2, FUNCT_7, COMPOS_1, EXTPRO_1, YELLOW_8,
      AMISTD_1, XBOOLE_0, FUNCOP_1, CARD_3, NAT_1, AFINSQ_1, MCART_1, VALUED_1,
      TARSKI, STRUCT_0;
 theorems AMISTD_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRFUNC_1, MCART_1,
      RELAT_1, SETFAM_1, TARSKI, ZFMISC_1, CARD_3, XBOOLE_0, XBOOLE_1, FUNCT_7,
      PBOOLE, PARTFUN1, RECDEF_2, VALUED_1, COMPOS_1, EXTPRO_1, ORDINAL1,
      NAT_D, NAT_1,XXREAL_0;
 schemes NAT_1;

begin  :: Properties of AMI-Struct

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set,
  N for with_non-empty_elements non empty set;

canceled 16;

theorem Th17:
  for I being Instruction of STC N holds JumpPart I = 0
proof
  let I be Instruction of STC N;
  the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
  then I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
  hence thesis by RECDEF_2:def 2;
end;

definition
 canceled 5;
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite standard-ins
  (non empty stored-program AMI-Struct over N), I be Instruction of S;
  attr I is with_explicit_jumps means
:Def6: JUMP I = rng JumpPart I;
  canceled;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  attr S is with_explicit_jumps means
:Def8: for I being Instruction of S holds I is with_explicit_jumps;
  canceled;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard -> (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard standard-ins (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

theorem Th18:
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I being Instruction of S
  st for f being Element of NAT holds NIC(I,f)={succ f}
  holds JUMP I is empty
proof
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  assume
A1: for f being Element of NAT holds NIC(I,f)={succ f};
  set p=1, q=2;
  reconsider p,q as Element of NAT;
  set X = { NIC(I,f) where f is Element of NAT:
  not contradiction };
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
A3: NIC(I,p) = {succ p} by A1;
A4: NIC(I,q) = {succ q} by A1;
A5: {succ p} in X by A3;
A6: {succ q} in X by A4;
A7: x in {succ p} by A2,A5,SETFAM_1:def 1;
A8: x in {succ q} by A2,A6,SETFAM_1:def 1;
    x = succ p by A7,TARSKI:def 1;
  hence contradiction by A8,TARSKI:def 1;
end;

registration
  let N be with_non-empty_elements non empty set,
  I be Instruction of STC N;
  cluster JUMP I -> empty;
  coherence
  proof
    per cases by AMISTD_1:22;
    suppose InsCode I = 0;
      then for f being Element of NAT holds NIC(I,f)={f} by AMISTD_1:15,20;
      hence thesis by AMISTD_1:14;
    end;
    suppose InsCode I = 1;
      then for f being Element of NAT holds NIC(I,f)={succ f} by AMISTD_1:39;
      hence thesis by Th18;
    end;
  end;
end;

theorem Th19:
  for T being InsType of STC N holds JumpParts T = {0}
proof
  let T be InsType of STC N;
  set A = { JumpPart I where I is Instruction of STC N: InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
A2:   the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
      then
A3:   InsCodes STC N = {0,1} by MCART_1:96;
      per cases by A3,TARSKI:def 2;
      suppose
A4:     T = 0;
        reconsider I = [0,0,0] as Instruction of STC N by A2,TARSKI:def 2;
A5:     JumpPart I = 0 by Th17;
        InsCode I = 0 by RECDEF_2:def 1;
        hence a in A by A1,A4,A5;
      end;
      suppose
A6:     T = 1;
        reconsider I = [1,0,0] as Instruction of STC N by A2,TARSKI:def 2;
A7:     JumpPart I = 0 by Th17;
        InsCode I = 1 by RECDEF_2:def 1;
        hence a in A by A1,A6,A7;
      end;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of STC N st a = JumpPart I & InsCode I = T;
    then a = 0 by Th17;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

Lm1: for I being Instruction of Trivial-AMI N holds JumpPart I = 0
proof
  let I be Instruction of Trivial-AMI N;
  the Instructions of Trivial-AMI N = {[0,0,{}]} by EXTPRO_1:def 1;
  then I = [0,0,0] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 2;
end;

Lm2: for T being InsType of Trivial-AMI N holds JumpParts T = {0}
proof
  let T be InsType of Trivial-AMI N;
  set A = { JumpPart I
   where I is Instruction of Trivial-AMI N: InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
A2:   the Instructions of Trivial-AMI N = {[0,0,{}]} by EXTPRO_1:def 1;
      then InsCodes Trivial-AMI N = {0} by MCART_1:97;
      then
A3:   T = 0 by TARSKI:def 1;
      reconsider I = [0,0,0] as Instruction of Trivial-AMI N
      by A2,TARSKI:def 1;
A4:   JumpPart I = 0 by Lm1;
      InsCode I = 0 by RECDEF_2:def 1;
      hence a in A by A1,A3,A4;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of Trivial-AMI N
    st a = JumpPart I & InsCode I = T;
    then a = 0 by Lm1;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N ->
   with_explicit_jumps homogeneous regular J/A-independent;
  coherence
  proof
    thus STC N is with_explicit_jumps
    proof
      let I be Instruction of STC N;
      the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
      then I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
      hence JUMP I = rng JumpPart I by RECDEF_2:def 2,RELAT_1:60;
    end;
    thus STC N is homogeneous
     proof let I, J be Instruction of STC N;
       JumpPart I = {} & JumpPart J = {} by Th17;
      hence thesis;
     end;
    thus STC N is regular
     proof let I be Instruction of STC N;
       JumpPart I = {} by Th17;
      hence thesis;
     end;
    let T be InsType of STC N;
    let f1,f2 be Function, p be set;
    assume f1 in JumpParts T;
     then
A1:    f1 in {0} by Th19;
     assume
A2:    f2 in product product" JumpParts T;
     product" JumpParts T = {} by Th19,CARD_3:156;
     then f1 = 0 & f2 = 0 by A1,A2,CARD_3:19,TARSKI:def 1;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard regular J/A-independent homogeneous
   halting realistic with_explicit_jumps (IC-Ins-separated definite
   standard-ins
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> regular J/A-independent;
  coherence
  proof
   thus Trivial-AMI N is regular
    proof
    let I be Instruction of Trivial-AMI N;
     JumpPart I = {} by Lm1;
    hence thesis;
    end;
    let T be InsType of Trivial-AMI N;
    let f1,f2 be Function, p be set;
    assume f1 in JumpParts T;
     then
A1:    f1 in {0} by Lm2;
     assume
A2:    f2 in product product" JumpParts T;
     product" JumpParts T = {} by Lm2,CARD_3:156;
     then f1 = 0 & f2 = 0 by A1,A2,CARD_3:19,TARSKI:def 1;
    hence thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster regular J/A-independent (standard-ins AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set,
  I be Instruction of Trivial-AMI N;
  cluster JUMP I -> empty;
  coherence
  proof
    for f being Element of NAT holds NIC(I,f)={f} by AMISTD_1:15,56;
    hence thesis by AMISTD_1:14;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> with_explicit_jumps;
  coherence
  proof
    thus Trivial-AMI N is with_explicit_jumps
    proof
      let I be Instruction of Trivial-AMI N;
      the Instructions of Trivial-AMI N = {[0,0,{}]} by EXTPRO_1:def 1;
      then I = [0,0,0] by TARSKI:def 1;
      hence JUMP I = rng JumpPart I by RECDEF_2:def 2,RELAT_1:60;
    end;
  end;
end;

registration
  let N;
  cluster regular J/A-independent
    (non empty stored-program standard-ins AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster with_explicit_jumps halting realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be with_explicit_jumps (IC-Ins-separated
  definite (non empty stored-program standard-ins AMI-Struct over N));
  cluster -> with_explicit_jumps Instruction of S;
  coherence by Def8;
end;

canceled;

theorem Th21:
  for S being realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  I being Instruction of S st I is halting holds JUMP I is empty
proof

  let S be realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N), I be Instruction of S;
  assume I is halting;
  then for l being Element of NAT holds NIC(I,l)={l}
  by AMISTD_1:15;
  hence thesis by AMISTD_1:14;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be halting realistic
  (IC-Ins-separated definite (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S;
  cluster JUMP I -> empty;
  coherence by Th21;
end;

theorem
  for S being halting with_explicit_jumps
  realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds JUMP I is empty
proof
  let S be halting with_explicit_jumps realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N)),
  I be Instruction of S such that
A1: JumpPart I is empty;
A2: rng JumpPart I = {} by A1;
   JUMP I c= rng JumpPart I by Def6;
  hence thesis by A2,XBOOLE_1:3;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be with_explicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster halting -> ins-loc-free Instruction of S;
  coherence
proof
  let I be Instruction of S;
  assume I is halting;
   then
A1:  JUMP I is empty by Th21;
   rng JumpPart I = JUMP I by Def6;
  hence JumpPart I is empty by A1;
end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be with_explicit_jumps
   standard-ins (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N));
  cluster sequential -> ins-loc-free Instruction of S;
  coherence
proof
  let I be Instruction of S;
  assume I is sequential;
   then
A1: JUMP I is empty by AMISTD_1:43;
   rng JumpPart I = JUMP I by Def6;
  hence JumpPart I is empty by A1;
end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard realistic halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster Stop S -> closed;
  coherence by AMISTD_1:46;
end;

begin  :: On the composition of macro instructions

registration
  let N be with_non-empty_elements non empty set,
  S be halting with_explicit_jumps
  realistic regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S, k be natural number;
  cluster IncAddr(I,k) -> halting;
  coherence by COMPOS_1:92;
end;

canceled 13;

theorem
  for S being regular homogeneous J/A-independent standard halting
  with_explicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is sequential
  holds IncAddr(I,k) is sequential by COMPOS_1:92;

definition
 canceled 8;
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  attr I is IC-relocable means
  :Def18:
  for j,k being natural number, s being State of S
  holds IC Exec(IncAddr(I,j),s) + k = IC Exec(IncAddr(I,j+k),IncIC(s,k));
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  attr S is IC-relocable means
  :Def19:
  for I being Instruction of S holds I is IC-relocable;
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N, I be Instruction of S;
  attr I is Exec-preserving means
  :Def20:
  for s1, s2 being State of S st NPP s1 = NPP s2
   holds NPP Exec(I,s1) = NPP Exec(I,s2);
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N;
  attr S is Exec-preserving means
  :Def21:
  for I being Instruction of S holds I is Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster sequential -> IC-relocable Instruction of S;
  coherence
proof
  let I be Instruction of S such that
A1: I is sequential;
  let j,k be natural number, s1 be State of S;
  set s2 = IncIC(s1,k);
  dom (IC S .--> (IC s1 + k)) = {IC S} by FUNCOP_1:19;
  then IC S in dom (IC S .--> (IC s1 + k)) by TARSKI:def 1;
  then
A2: IC s2 = (IC S .--> (IC s1 + k)).IC S by FUNCT_4:14
    .= IC s1 + k by FUNCOP_1:87;
A3: IC Exec(I, s2) = succ IC s2 by A1,AMISTD_1:def 16
    .= IC s1 + 1 + k by A2;
A4: IncAddr(I,j) = I by A1,COMPOS_1:92;
  IC Exec(I,s1) = succ IC s1 by A1,AMISTD_1:def 16
    .= IC s1 + 1;
  hence IC Exec(IncAddr(I,j),s1) + k
      = IC Exec(IncAddr(IncAddr(I,j),k), s2) by A1,A3,COMPOS_1:92,A4
     .= IC Exec(IncAddr(I,j+k), s2) by COMPOS_1:97;
end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  realistic with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster halting -> IC-relocable Instruction of S;
  coherence
proof
  let I be Instruction of S such that
A1: I is halting;
  let j,k be natural number, s1 be State of S;
  set s2 = IncIC(s1,k);
  dom (IC S .--> (IC s1 + k)) = {IC S} by FUNCOP_1:19;
  then
A2: IC S in dom (IC S .--> (IC s1 + k)) by TARSKI:def 1;
  thus IC Exec(IncAddr(I,j),s1) + k = IC s1 + k by A1,EXTPRO_1:def 3
    .= (IC S .--> (IC s1 + k)).IC S by FUNCOP_1:87
    .= IC s2 by A2,FUNCT_4:14
    .= IC Exec(IncAddr(I,j+k), s2) by A1,EXTPRO_1:def 3;
end;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be stored-program AMI-Struct over N;
  cluster halting -> Exec-preserving Instruction of S;
  coherence
proof
  let I be Instruction of S such that
A1: for s being State of S holds Exec(I,s) = s;
  let s1, s2 be State of S such that
A2: NPP s1 = NPP s2;
  Exec(I,s1) = s1 by A1;
  hence thesis by A1,A2;
end;
end;

canceled 9;

theorem Th46:
  for S being stored-program AMI-Struct over N,
  I being Instruction of S st I is halting holds I is Exec-preserving;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> IC-relocable Exec-preserving;
  coherence
  proof
    thus STC N is IC-relocable
    proof
      let I be Instruction of STC N, j,k be natural number,
      s1 be State of STC N;
      set s2 = IncIC(s1,k);
      {IC STC N} = dom (IC STC N .--> (IC s1 + k)) by FUNCOP_1:19;
      then IC STC N in dom (IC STC N .--> (IC s1 + k)) by TARSKI:def 1;
      then
A1:   IC s2 = (IC STC N .--> (IC s1 + k)).IC STC N by FUNCT_4:14
        .= IC s1 + k by FUNCOP_1:87;
      per cases by AMISTD_1:22;
      suppose
A2:     InsCode I = 1;
        then
A3:     InsCode IncAddr(I,k) = 1 by COMPOS_1:def 38;
A4:      IncAddr(I,j) = I by COMPOS_1:92;
        IC Exec(I,s1) = succ IC s1 by A2,AMISTD_1:38
          .= IC s1 + 1;
        hence IC Exec(IncAddr(I,j),s1) + k = succ IC s2 by A1,A4
          .= IC Exec(IncAddr(IncAddr(I,j),k), s2) by A4,A3,AMISTD_1:38
          .= IC Exec(IncAddr(I,j+k), s2) by COMPOS_1:97;
      end;
      suppose InsCode I = 0;
        then
A5:     I is halting by AMISTD_1:20;
        hence IC Exec(IncAddr(I,j),s1) + k = IC s1 + k by EXTPRO_1:def 3
          .= IC Exec(IncAddr(IncAddr(I,j),k), s2) by A1,A5,EXTPRO_1:def 3
          .= IC Exec(IncAddr(I,j+k), s2) by COMPOS_1:97;
      end;
    end;
    let I be Instruction of STC N;
    per cases by AMISTD_1:22;
    suppose
A6:   InsCode I = 1;
      the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
      then
A7:   I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
      let s1, s2 be State of STC N such that
A8:   NPP s1 = NPP s2;
      consider f being Function of product the Object-Kind of STC N,
      product the Object-Kind of STC N such that
A9:   for s being Element of product the Object-Kind of STC N
      holds f.s = s+*(NAT .-->succ(s.NAT)) and
A10:  the Execution of STC N
      = ([1,0,0] .--> f) +* ([0,0,0] .--> id product the Object-Kind of STC N)
      by AMISTD_1:def 11;
A11:   for s being State of STC N
      holds f.s = s+*(NAT .-->succ(s.NAT))
       proof let s be State of STC N;
        reconsider s as Element of product the Object-Kind of STC N
         by PBOOLE:155;
        f.s = s+*(NAT .-->succ(s.NAT)) by A9;
       hence thesis;
       end;
      [0,0,0] <> [1,0,0] by MCART_1:28;
      then not I in {[0,0,0]} by A6,A7,RECDEF_2:def 1,TARSKI:def 1;
      then not I in dom ([0,0,0] .--> id product the Object-Kind of STC N)
      by FUNCOP_1:19;
      then
A12:  (the Execution of STC N).I = ([1,0,0] .--> f).I by A10,FUNCT_4:12;
A13:  I in {[1,0,0]} by A6,A7,RECDEF_2:def 1,TARSKI:def 1;
      then
A14:  Exec(I,s1) = f.s1 by A12,FUNCOP_1:13
        .= s1+*(NAT .-->succ(s1.NAT)) by A11;
A15:  Exec(I,s2) = f.s2 by A12,A13,FUNCOP_1:13
        .= s2+*(NAT .-->succ(s2.NAT)) by A11;
A16:  dom Exec(I,s1) = the carrier of STC N by PARTFUN1:def 4
           .= dom Exec(I,s2) by PARTFUN1:def 4;
      for x being set st x in dom Exec(I,s1) \ NAT
      holds Exec(I,s1).x = Exec(I,s2).x
      proof
        let x be set;
        assume
A17:    x in dom Exec(I,s1) \ NAT;
        then
A18:    not x in NAT by XBOOLE_0:def 5;
A19:    s1.NAT = IC s1 by AMISTD_1:def 11
          .= IC s2 by A8,COMPOS_1:230
          .= s2.NAT by AMISTD_1:def 11;
        x in dom Exec(I,s1) by A17;
        then x in the carrier of STC N by PARTFUN1:def 4;
        then x in NAT \/ {NAT} by AMISTD_1:def 11;
        then
A20:    x in {NAT} by A18,XBOOLE_0:def 3;
        then
A21:    x in dom (NAT .-->succ(s2.NAT)) by FUNCOP_1:19;
        x in dom (NAT .-->succ(s1.NAT)) by A20,FUNCOP_1:19;
        hence Exec(I,s1).x = (NAT .-->succ(s1.NAT)).x by A14,FUNCT_4:14
          .= Exec(I,s2).x by A15,A19,A21,FUNCT_4:14;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) =
         Exec(I,s2)|(dom Exec(I,s2) \ NAT) by A16,FUNCT_1:165;
     hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose InsCode I = 0;
      hence thesis by Th46,AMISTD_1:20;
    end;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster homogeneous realistic halting
    with_explicit_jumps Exec-preserving
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N)));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster IC-relocable (homogeneous realistic
    with_explicit_jumps Exec-preserving halting
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N))));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> Exec-preserving;
  coherence
  proof
    let I be Instruction of Trivial-AMI N;
    thus thesis by Th46,AMISTD_1:56;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-relocable (regular homogeneous J/A-independent
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N)));
  cluster -> IC-relocable Instruction of S;
  coherence by Def19;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be Exec-preserving (stored-program AMI-Struct over N);
  cluster -> Exec-preserving Instruction of S;
  coherence by Def21;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  realistic with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
 cluster IC-relocable Instruction of S;
 existence
  proof
   take the halting Instruction of S;
   thus thesis;
  end;
end;

theorem Th47:
  for S be regular homogeneous J/A-independent halting
  realistic with_explicit_jumps
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being IC-relocable Instruction of S
  for k being natural number, s being State of S
  holds IC Exec(I,s) + k = IC Exec(IncAddr(I,k),IncIC(s,k))
proof
  let S be regular homogeneous J/A-independent halting
  realistic with_explicit_jumps
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being IC-relocable Instruction of S;
  let k being natural number, s being State of S;
A1: k+(0 qua natural number)=k;
  thus IC Exec(I,s) + k
     = IC Exec(IncAddr(I,0),s) + k by COMPOS_1:91
    .= IC Exec(IncAddr(I,k),IncIC(s,k)) by Def18,A1
    .= IC Exec(IncAddr(I,k),IncIC(s,k));
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-relocable (homogeneous Exec-preserving
  (regular J/A-independent standard realistic with_explicit_jumps
  halting (standard-ins
  IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)))),
  F, G be closed initial non empty (NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> closed;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
    let f be Element of NAT such that
A1: f in dom P;
A2: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A3: dom CutLastLoc F c= dom F by GRFUNC_1:8;
A4: dom Shift(IncAddr(G,k),k) =
    {(m+k) where m is Element of NAT: m in dom IncAddr(G,k)}
    by VALUED_1:def 12;
    let x be set;
    assume x in NIC(P/.f,f);
    then consider s2 being Element of product the Object-Kind of S
    such that
A5: x = IC Exec(P/.f,s2) and
A6: IC s2 = f;
A7: P/.f = P.f by A1,PARTFUN1:def 8;
    per cases by A1,A2,XBOOLE_0:def 3;
    suppose
A8:    f in dom CutLastLoc F;
      then
A9:  NIC(F/.f,f) c= dom F by A3,AMISTD_1:def 17;
      dom CutLastLoc F = dom F \ {LastLoc F} by VALUED_1:37;
      then
A10:   f in dom F by A8,XBOOLE_0:def 5;
      dom CutLastLoc F misses dom Shift(IncAddr(G,card F -' 1),card F -' 1)
          by COMPOS_1:100;
      then
A11:    not f in dom Shift(IncAddr(G,card F -' 1),card F -' 1)
          by  A8,XBOOLE_0:3;
A12:    P/.f = P.f by A1,PARTFUN1:def 8
        .= (CutLastLoc F).f by A11,FUNCT_4:12
        .= F.f by A8,GRFUNC_1:8
        .= F/.f by A10,PARTFUN1:def 8;
      IC Exec(F/.f,s2) in NIC(F/.f,f) by A6;
      then
A13:  x in dom F by A5,A9,A12;
      dom F c= dom P by COMPOS_1:103;
      hence thesis by A13;
    end;
    suppose
A14:  f in dom Shift(IncAddr(G,k),k);
      then consider m being Element of NAT such that
A15:  f = m+k and
A16:  m in dom IncAddr(G,k) by A4;
A17:  m in dom G by A16,COMPOS_1:def 40;
      then
A18:  NIC(G/.m,m) c= dom G by AMISTD_1:def 17;
A19:  ObjectKind IC S = NAT by COMPOS_1:def 6;
      reconsider v = IC S .--> m as FinPartState of S
      by A19,COMPOS_1:5;
      set s1 = s2 +* v;
A20:  P/.f = Shift(IncAddr(G,k),k).f by A7,A14,FUNCT_4:14
        .= IncAddr(G,k).m by A15,A16,VALUED_1:def 12;
A21:  (IC S .--> m).IC S = m by FUNCOP_1:87;
A22:  IC S in {IC S} by TARSKI:def 1;
A23:  dom (IC S .--> m) = {IC S} by FUNCOP_1:19;
      reconsider w = IC S .--> (IC s1 + k) as FinPartState of S
      by A19,COMPOS_1:5;
A24:  dom (s1 +* (IC S .--> (IC s1 + k))) = the carrier of S by PARTFUN1:def 4;
A25:    dom s2 = the carrier of S by PARTFUN1:def 4;
      for a being set st a in dom s2 holds
      s2.a = (s1 +* (IC S .--> (IC s1 + k))).a
      proof
        let a be set such that a in dom s2;
A26:    dom (IC S .--> (IC s1 + k)) = {IC S} by FUNCOP_1:19;
        per cases;
        suppose
A27:      a = IC S;
          hence s2.a = IC s1 + k by A6,A15,A23,A21,A22,FUNCT_4:14
            .= (IC S .--> (IC s1 + k)).a by A27,FUNCOP_1:87
            .= (s1 +* (IC S .--> (IC s1 + k))).a by A22,A26,A27,FUNCT_4:14;
        end;
        suppose
A28:      a <> IC S;
          then
A29:      not a in dom (IC S .--> (IC s1 + k)) by A26,TARSKI:def 1;
          not a in dom (IC S .--> m) by A23,A28,TARSKI:def 1;
          then s1.a = s2.a by FUNCT_4:12;
          hence thesis by A29,FUNCT_4:12;
        end;
      end;
      then
A30:  s2 = IncIC(s1,k) by A24,A25,FUNCT_1:9;
      set s3 = s1 +* (m .--> G/.m);
A31:  dom (m .--> G/.m) = {m} by FUNCOP_1:19;
      now
        assume IC S in dom (m .--> G/.m);
        then reconsider l=IC S as Element of NAT
        by A31,TARSKI:def 1;
        l=IC S;
        hence contradiction by COMPOS_1:3;
      end;
      then
A32:  IC s3 = s1.IC S by FUNCT_4:12
        .= m by A21,A22,A23,FUNCT_4:14;
A33:  dom s1 = the carrier of S by PARTFUN1:def 4;
A34:  dom s3 = the carrier of S by PARTFUN1:def 4;
      for x being set st x in dom s1 \ NAT holds s1.x = s3.x
      proof
        let x be set;
A35:    dom (m .--> G/.m) c= NAT by RELAT_1:def 18;
        assume x in dom s1 \ NAT;
        then not x in dom (m .--> G/.m)
        by A35,XBOOLE_0:def 5;
        hence thesis by FUNCT_4:12;
      end;
      then s1|(dom s1 \ NAT) = s3|(dom s3 \ NAT) by A33,A34,FUNCT_1:165;
      then NPP s1 = NPP s3 by COMPOS_1:233;
      then
A36:  NPP Exec(G/.m,s1) = NPP Exec(G/.m,s3) by Def20;
      reconsider s3 as Element of product the Object-Kind of S by PBOOLE:155;
      reconsider k,m as Element of NAT;
A37:  x = IC Exec(IncAddr(G/.m,k),s2) by A5,A17,A20,COMPOS_1:def 40
        .= IC Exec(G/.m, s1) + k by A30,Th47
        .= IC Exec(G/.m, s3) + k by A36,COMPOS_1:230;
      IC Exec(G/.m, s3) in NIC(G/.m,m) by A32;
      then IC Exec(G/.m, s3) in dom G by A18;
      then IC Exec(G/.m, s3) in dom IncAddr(G,k) by COMPOS_1:def 40;
      then x in dom Shift(IncAddr(G,k),k) by A4,A37;
      hence thesis by A2,XBOOLE_0:def 3;
    end;
  end;
end;

canceled 15;

theorem
  for I being Instruction of Trivial-AMI N holds JumpPart I = 0 by Lm1;

theorem
  for T being InsType of Trivial-AMI N holds JumpParts T = {0} by Lm2;

theorem
  for S being Exec-preserving IC-Ins-separated definite realistic
   (stored-program non empty AMI-Struct over N)
  for s1,s2 being State of S
   st (s1 | (Data-Locations S \/ {IC S}))
    = (s2 | (Data-Locations S \/ {IC S}))
for l being Instruction of S holds
 Exec (l,s1) | (Data-Locations S \/ {IC S})
  = Exec (l,s2) | (Data-Locations S \/ {IC S})
proof
 let S be Exec-preserving IC-Ins-separated definite realistic
   (stored-program non empty AMI-Struct over N);
 let s1,s2 being State of S such that
A1: (s1 | (Data-Locations S \/ {IC S}))
    = (s2 | (Data-Locations S \/ {IC S}));
 let l be Instruction of S;
  NPP s1 = NPP s2 by A1,COMPOS_1:175;
  then NPP Exec (l,s1) = NPP Exec (l,s2) by Def20;
 hence Exec (l,s1) | (Data-Locations S \/ {IC S})
  = Exec (l,s2) | (Data-Locations S \/ {IC S}) by COMPOS_1:175;
end;

reserve n,m for Element of NAT;

theorem
 for S being Exec-preserving IC-Ins-separated definite realistic
  (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S, I being Program of S
 for P1,P2 being (the Instructions of S)-valued ManySortedSet of NAT
  st I c= P1 & I c= P2 & NPP s1 = NPP s2 &
   (for m st m < n holds IC Comput(P2,s2,m) in dom I)
 for m st m <= n holds
    NPP Comput(P1,s1,m) = NPP Comput(P2,s2,m)
proof
 let S be Exec-preserving IC-Ins-separated definite realistic
  (non empty stored-program AMI-Struct over N);
 let s1,s2 be State of S, I be Program of S;
 let P1,P2 be (the Instructions of S)-valued ManySortedSet of NAT
 such that
A1: I c= P1 & I c= P2;
  assume that
A2: NPP s1 = NPP s2 and
A3: for m st m < n holds IC Comput(P2,s2,m) in dom I;
  defpred X[Nat] means $1 <= n implies
   NPP Comput(P1,s1,$1) = NPP Comput(P2,s2,$1);
A4: for m st X[m] holds X[m+1]
  proof
    let m such that
A5: X[m];
A6: Comput(P2,s2,m+1) = Following(P2,Comput(P2,s2,m)) by EXTPRO_1:4
      .= Exec(CurInstr(P2,Comput(P2,s2,m)),Comput(P2,s2,m));
A7: Comput(P1,s1,m+1) = Following(P1,Comput(P1,s1,m)) by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,m)),Comput(P1,s1,m));
    assume
A8: m+1 <= n;
    then m < n by NAT_1:13;
    then
A9: IC Comput(P1,s1,m) = IC Comput(P2,s2,m) by A5,COMPOS_1:230;
    m < n by A8,NAT_1:13;
    then
A10: IC Comput(P2,s2,m) in dom I by A3;
    dom P2 = NAT by PARTFUN1:def 4;
    then
A11:  IC Comput(P2,s2,m) in dom P2;
    dom P1 = NAT by PARTFUN1:def 4;
    then IC Comput(P1,s1,m) in dom P1;
    then CurInstr(P1,Comput(P1,s1,m))
       = P1.IC( Comput(P1,s1,m)) by PARTFUN1:def 8
      .= I.IC( Comput(P1,s1,m)) by A10,A9,GRFUNC_1:8,A1
      .= P2.IC Comput(P2,s2,m) by A10,A9,GRFUNC_1:8,A1
      .= CurInstr(P2,Comput(P2,s2,m)) by A11,PARTFUN1:def 8;
    hence thesis by A5,A7,A6,A8,NAT_1:13,Def20;
  end;
  Comput(P1,s1,0) = s1 by EXTPRO_1:3;
  then
A12: X[0] by A2,EXTPRO_1:3;
  thus for m holds X[m] from NAT_1:sch 1(A12,A4);
end;

theorem ThX:
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT
 holds NPP Following(P,s1) = NPP Following(P,s2)
proof
 let S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N);
 let s1,s2 being State of S such that
Z: NPP s1 = NPP s2;
 let P being (the Instructions of S)-valued ManySortedSet of NAT;
A: CurInstr(P,s1) = CurInstr(P,s2) by Z,COMPOS_1:230;
 thus NPP Following(P,s1) = NPP Exec(CurInstr(P,s1),s1)
     .= NPP Exec(CurInstr(P,s2),s2) by A,Z,Def20
     .= NPP Following(P,s2);
end;


theorem ThY:
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT,
     k being Nat
 holds NPP Comput(P,s1,k) = NPP Comput(P,s2,k)
proof
 let S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N);
 let s1,s2 being State of S such that
Z: NPP s1 = NPP s2;
 let P being (the Instructions of S)-valued ManySortedSet of NAT;
  defpred P[Nat] means NPP Comput(P,s1,$1) = NPP Comput(P,s2,$1);
  Comput(P,s1,0) = s1 & Comput(P,s2,0) = s2 by EXTPRO_1:3;
  then
A: P[0] by Z;
B: now let k be Nat;
    assume
ZZ:  P[k];
     NPP Comput(P,s1,k+1)
        = NPP Following(P,Comput(P,s1,k)) by EXTPRO_1:4
       .= NPP Following(P,Comput(P,s2,k)) by ZZ,ThX
       .= NPP Comput(P,s2,k+1) by EXTPRO_1:4;
    hence P[k+1];
   end;
 thus for k being Nat holds P[k] from NAT_1:sch 2(A,B);
end;


theorem Th69:
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT
 holds P halts_on s1 implies P halts_on s2
 proof let S be Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N);
  let s1,s2 be State of S such that
Z: NPP s1 = NPP s2;
  let P be (the Instructions of S)-valued ManySortedSet of NAT;
  assume P halts_on s1;
  then consider k being Nat such that
 IC Comput(P,s1,k) in dom P and
W2: CurInstr(P,Comput(P,s1,k)) = halt S by EXTPRO_1:def 7;
  take k;
   dom P = NAT by PARTFUN1:def 4;
  hence IC Comput(P,s2,k) in dom P;
   NPP Comput(P,s1,k) = NPP Comput(P,s2,k) by Z,ThY;
   then IC Comput(P,s1,k) = IC Comput(P,s2,k) by COMPOS_1:230;
  hence CurInstr(P,Comput(P,s2,k)) = P/.IC Comput(P,s1,k)
    .= halt S by W2;
 end;

theorem
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N),
  P being (the Instructions of S)-valued ManySortedSet of NAT,
  s being State of S st NPP s = NPP Following(P,s)
  holds for n holds NPP Comput(P,s,n) = NPP s
proof
  let S be Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N),
  P be (the Instructions of S)-valued ManySortedSet of NAT,
  s be State of S;
  defpred X[Element of NAT] means NPP Comput(P,s,$1) = NPP s;
  assume
Z:  NPP s = NPP Following(P,s);
A1:
  now let n;
   assume
ZZ:  X[n];
    NPP Comput(P,s,n+1)
     = NPP Following(P,Comput(P,s,n)) by EXTPRO_1:4
    .= NPP s by Z,ThX,ZZ;
   hence X[n+1];
  end;
A2: X[ 0] by EXTPRO_1:3;
  thus for n holds X[n] from NAT_1:sch 1(A2, A1);
end;

theorem
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT
   st P halts_on s1
 holds NPP Result(P,s1) = NPP Result(P,s2)
proof
 let S be Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N);
 let s1,s2 be State of S such that
Z1: NPP s1 = NPP s2;
 let P be (the Instructions of S)-valued ManySortedSet of NAT such that
Z2: P halts_on s1;
  consider k1 being Nat such that
 IC Comput(P,s1,k1) in dom P and
W2: CurInstr(P,Comput(P,s1,k1)) = halt S by Z2,EXTPRO_1:def 7;
C: P halts_on s2 by Z1,Z2,Th69;
  then consider k2 being Nat such that
 IC Comput(P,s2,k2) in dom P and
W4: CurInstr(P,Comput(P,s2,k2)) = halt S by EXTPRO_1:def 7;
  reconsider k1,k2 as Element of NAT by ORDINAL1:def 13;
  reconsider k = max(k1,k2) as Element of NAT by ORDINAL1:def 13;
  k1 <= k by XXREAL_0:25;
  then
D: Comput(P,s1,k) = Comput(P,s1,k1) by W2,EXTPRO_1:6;
  k2 <= k by XXREAL_0:25;
  then
E: Comput(P,s2,k2) = Comput(P,s2,k) by W4,EXTPRO_1:6;
A: Result(P,s1) = Comput(P,s1,k) by Z2,W2,EXTPRO_1:def 8,D;
F: Result(P,s2) = Comput(P,s2,k) by C,W4,EXTPRO_1:def 8,E;
 NPP Comput(P,s1,k) = NPP Comput(P,s2,k) by Z1,ThY;
 hence NPP Result(P,s1) = NPP Result(P,s2) by A,F;
end;
