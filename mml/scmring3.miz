:: The Properties of Instructions of { \bf SCM } over Ring
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMFSA7B, FUNCSDOM, SUBSET_1, AMI_3, AMI_1, FSM_1,
      ORDINAL1, INT_3, FINSET_1, STRUCT_0, AMI_2, TARSKI, ZFMISC_1, RELAT_1,
      FUNCOP_1, XBOOLE_0, CAT_1, FUNCT_1, CARD_1, GRAPHSP,
      FINSEQ_1, AMISTD_2, CARD_3, AMISTD_1, CIRCUIT2, FUNCT_4, SETFAM_1,
      SUPINF_2, ARYTM_3, XXREAL_0, GOBOARD5, ARYTM_1, GROUP_1,PBOOLE,
      FRECHET, UNIALG_1, CARD_5, PARTFUN1, RECDEF_2, SCMNORM, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, ENUMSET1, ZFMISC_1, MCART_1,
      SETFAM_1, RELAT_1, FUNCT_1, XXREAL_0, RECDEF_2, VALUED_1,PBOOLE,
      STRUCT_0, ALGSTR_0, FUNCSDOM,
      ORDINAL1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, FUNCOP_1, FINSEQ_1, PARTFUN1, FUNCT_4,
      CARD_3, FUNCT_7, GROUP_1, COMPOS_1, EXTPRO_1, AMI_2,
      AMI_3, SCMRING1, SCMRING2, INT_3, NAT_D,
      AMISTD_1, AMISTD_2, FUNCT_2;
 constructors XXREAL_0, NAT_1, FINSEQ_4, VECTSP_2, REALSET2, INT_3, AMI_3,
      SCMRING2, AMISTD_2, BINOP_2, RELSET_1, RECDEF_2, VALUED_1,
      GCD_1, NAT_D, XCMPLX_0, REAL_1, AMISTD_1,PBOOLE, FUNCT_7,
      PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      XREAL_0, INT_1, FINSEQ_1, CARD_3, STRUCT_0, VECTSP_1, INT_3,
      AMI_3, SCMRING1, SCMRING2, AMISTD_2, NUMBERS, RELSET_1, ZFMISC_1, CARD_2,
      FUNCT_2, FUNCT_4, ALGSTR_0, ALGSTR_1, GCD_1, VALUED_1, VALUED_0,
      COMPOS_1, EXTPRO_1, XCMPLX_0, REAL_1, NAT_1, PBOOLE, FUNCT_7, PRE_POLY;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, FUNCT_1, FUNCT_7, SCMRING1, SCMRING2, AMISTD_1, AMISTD_2,
      XBOOLE_0, FUNCOP_1, STRUCT_0, COMPOS_1, EXTPRO_1,
      AMI_2, CARD_3, NAT_1,
      MCART_1, ZFMISC_1;
 theorems TARSKI, NAT_1, SCMRING2, AMI_3, FUNCT_4, FUNCT_1, ZFMISC_1,
      FUNCOP_1, SCMRING1, SETFAM_1, AMI_2, AMISTD_1, MCART_1, INT_1, INT_3,
      STRUCT_0, RLVECT_1, VECTSP_1, LMOD_6, FINSEQ_1, AMISTD_2, CARD_3,
      ORDINAL1, XBOOLE_0, XBOOLE_1, RELAT_1, ENUMSET1, NUMBERS, PARTFUN1,
      PBOOLE, RECDEF_2, VALUED_1, COMPOS_1, EXTPRO_1, FUNCT_7;

begin

reserve R for good Ring,
  r for Element of R,
  a, b, d1, d2 for Data-Location of R,
  il, i1, i2 for Element of NAT,
  I for Instruction of SCM R,
  s,s1, s2 for State of SCM R,
  T for InsType of SCM R,
  k for natural number;

registration
  cluster INT.Ring -> infinite good;
  coherence
  proof
    thus the carrier of INT.Ring is infinite by INT_3:def 3;
    thus the carrier of INT.Ring <> NAT by INT_3:def 3,NUMBERS:27;
    assume the carrier of INT.Ring = SCM-Instr INT.Ring;
    then
A1:   1 in SCM-Instr INT.Ring by INT_1:def 2,INT_3:def 3;
     SCM-Instr INT.Ring c= [:NAT,NAT*,proj2 SCM-Instr INT.Ring:]
        by SCMRING1:21;
    then ex a, b being set
     st a in [:NAT,NAT*:] & b in proj2 SCM-Instr INT.Ring & 1 = [a,b]
     by A1,ZFMISC_1:def 2;
    hence thesis;
  end;
end;

registration
  cluster strict infinite good Ring;
  existence
  proof
    take INT.Ring;
    thus thesis;
  end;
end;

theorem Th1:
  ObjectKind a = the carrier of R
proof
  a in Data-Locations SCM & the Object-Kind of SCM R = SCM-OK R
   by SCMRING2:1,def 1;
  hence thesis by AMI_3:72,SCMRING1:5;
end;

definition
  let R be good Ring;
  let la, lb be Data-Location of R;
  let a, b be Element of R;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCM R;
  coherence
  proof
    reconsider b9 = b as Element of ObjectKind lb by Th1;
    reconsider a9 = a as Element of ObjectKind la by Th1;
    (la,lb) --> (a9,b9) is FinPartState of SCM R;
    hence thesis;
  end;
end;

theorem Th2:
  not a in NAT
proof
  a in (the carrier of SCM R) \ (NAT \/ {NAT}) by SCMRING2:def 2;
  then not a in NAT \/ {NAT} by XBOOLE_0:def 5;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th3:
  a <> IC SCM R
proof
  a in (the carrier of SCM R) \ (NAT \/ {NAT}) by SCMRING2:def 2;
  then not a in NAT \/ {NAT} by XBOOLE_0:def 5;
  then not a in {NAT} by XBOOLE_0:def 3;
  then a <> NAT by TARSKI:def 1;
  hence thesis by SCMRING2:9;
end;

theorem
  Data-Locations SCM <> NAT by AMI_2:12,AMI_3:72;

theorem Th5:
  for o being Object of SCM R holds o = IC SCM R or o in NAT or o
  is Data-Location of R
proof
  let o be Object of SCM R;
  assume o <> IC SCM R;
  then not o in {IC SCM R} by TARSKI:def 1;
  then
A1: not o in {NAT} by SCMRING2:9;
  assume not o in NAT;
  then not o in NAT \/ {NAT} by A1,XBOOLE_0:def 3;
  hence o in (the carrier of SCM R) \ (NAT \/ {NAT}) by XBOOLE_0:def 5;
end;

canceled;

theorem Th7:
  NPP s1 = NPP s2 implies s1.a = s2.a
proof
  assume
A1: NPP s1 = NPP s2;
A2: not a in NAT by Th2;
  dom s2 = the carrier of SCM R by PARTFUN1:def 4;
  then a in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: a in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
X1: s1|(dom s1 \ NAT) = NPP s1 &
    s2|(dom s2 \ NAT) = NPP s2 by COMPOS_1:232;
  dom s1 = the carrier of SCM R by PARTFUN1:def 4;
  then a in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then a in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence s1.a = (s1|(dom s1 \ NAT)).a by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).a by A1,X1
    .= s2.a by A3,FUNCT_1:71;
end;

theorem Th8:
  InsCode halt SCM R = 0
proof
  thus InsCode halt SCM R = [0,{},{}]`1_3 by SCMRING2:30
   .= 0 by RECDEF_2:def 1;
end;

theorem
  InsCode (a:=b) = 1 by RECDEF_2:def 1;

theorem
  InsCode AddTo(a,b) = 2 by RECDEF_2:def 1;

theorem
  InsCode SubFrom(a,b) = 3 by RECDEF_2:def 1;

theorem
  InsCode MultBy(a,b) = 4 by RECDEF_2:def 1;

theorem
  InsCode (a:=r) = 5 by RECDEF_2:def 1;

theorem Th14:
  InsCode goto(i1,R) = 6 by RECDEF_2:def 1;

theorem Th15:
  InsCode (a=0_goto i1) = 7 by RECDEF_2:def 1;

theorem Th16:
  InsCode I = 0 implies I = halt SCM R
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or
 (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
  (ex i1 st I = goto(i1,R)) or
    (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 0;
  hence thesis by A1,RECDEF_2:def 1,SCMRING2:30;
end;

theorem Th17:
  InsCode I = 1 implies ex a, b st I = a:=b
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
   (ex i1 st I = goto(i1,R)) or
    (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 1;
  hence thesis by A1,RECDEF_2:def 1;
end;

theorem Th18:
  InsCode I = 2 implies ex a, b st I = AddTo(a,b)
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
   (ex i1 st I = goto(i1,R)) or
    (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 2;
  hence thesis by A1,RECDEF_2:def 1;
end;

theorem Th19:
  InsCode I = 3 implies ex a, b st I = SubFrom(a,b)
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
  (ex i1 st I = goto(i1,R)) or
   (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 3;
  hence thesis by A1,RECDEF_2:def 1;
end;

theorem Th20:
  InsCode I = 4 implies ex a, b st I = MultBy(a,b)
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
   (ex i1 st I = goto(i1,R)) or
    (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 4;
  hence thesis by A1,RECDEF_2:def 1;
end;

theorem Th21:
  InsCode I = 5 implies ex a, r st I = a:=r
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
  (ex i1 st I = goto(i1,R)) or
   (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 5;
  hence thesis by A1,RECDEF_2:def 1;
end;

theorem Th22:
  InsCode I = 6 implies ex i2 st I = goto(i2,R)
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
  (ex i1 st I = goto(i1,R)) or
   (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 6;
  hence thesis by A1,RECDEF_2:def 1;
end;

theorem Th23:
  InsCode I = 7 implies ex a, i1 st I = a=0_goto i1
proof
A1: I = [0,{},{}] or (ex a,b st I = a:=b) or (ex a,b st I = AddTo(a,b)) or (ex
  a,b st I = SubFrom(a,b)) or (ex a,b st I = MultBy(a,b)) or
   (ex i1 st I = goto(i1,R)) or
    (ex a,i1 st I = a=0_goto i1) or ex a,r st I = a:=r by SCMRING2:8;
  assume InsCode I = 7;
  hence thesis by A1,RECDEF_2:def 1;
end;

Lm1: for x, y being set st x in dom <*y*> holds x = 1
proof
  let x, y be set;
  assume x in dom <*y*>;
  then x in Seg 1 by FINSEQ_1:def 8;
  hence thesis by FINSEQ_1:4,TARSKI:def 1;
end;

Lm2: T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7
proof
  consider y being set such that
A1: [T,y] in proj1 the Instructions of SCM R by RELAT_1:def 4;
  consider x being set such that
A2: [[T,y],x] in the Instructions of SCM R by A1,RELAT_1:def 4;
  [T,y,x] in SCM-Instr R by A2,SCMRING2:def 1;

  then
  [T,y,x] in { [0,{},{}] }
   \/ { [I,{},<*a,b*>]
   where I is Element of Segm 8, a, b is Element of Data-Locations SCM:
     I in { 1,2,3,4 } }
   \/ { [6,<*i*>,{}] where i is Element of NAT: not contradiction }
   \/ { [7,<*i*>,<*a*>]
   where i is Element of NAT, a is Element of Data-Locations SCM:
   not contradiction}
    or [T,y,x] in { [5,{},<*a,r*>]
     where a is Element of Data-Locations SCM, r is Element of R:
     not contradiction}
by AMI_3:72,XBOOLE_0:def 3;

  then
  [T,y,x] in { [0,{},{}] } \/ { [I,{},<*a,b*>]
   where I is Element of Segm 8, a, b
  is Element of Data-Locations SCM: I in { 1,2,3,4 } } \/ { [6,<*i*>,{}]
  where i is
  Element of NAT: not contradiction } or [T,y,x] in { [7,<*i*>,<*a*>]
   where i is

Element of NAT, a is Element of Data-Locations SCM: not contradiction } or
 [T,y,x] in {
  [5,{},<*a,r*>] where a is Element of Data-Locations SCM, r is Element of R:
  not
  contradiction } by XBOOLE_0:def 3;

  then
A3: [T,y,x] in { [0,{},{}] }
    \/ { [I,{},<*a,b*>] where I is Element of Segm 8, a, b

is Element of Data-Locations SCM: I in { 1,2,3,4 } } or
    [T,y,x] in { [6,<*i*>,{}] where i
  is Element of NAT: not contradiction } or
   [T,y,x] in { [7,<*i*>,<*a*>] where i is

Element of NAT, a is Element of Data-Locations SCM: not contradiction } or
 [T,y,x] in {
  [5,{},<*a,r*>] where a is Element of Data-Locations SCM, r is Element of R:
  not
  contradiction } by XBOOLE_0:def 3;

  per cases by A3,XBOOLE_0:def 3;
  suppose
    [T,y,x] in { [0,{},{}] };
    then [T,y,x] = [0,{},{}] by TARSKI:def 1;
    hence thesis by MCART_1:28;
  end;
  suppose

    [T,y,x] in { [I,{},<*a,b*>] where I is Element of Segm 8, a, b is
    Element of Data-Locations SCM: I in { 1,2,3,4 } };

    then
    ex I being Element of Segm 8, a,b being Element of Data-Locations SCM
     st [T,y,x] = [I,{},<*a,b*>] & I in { 1,2,3,4 };

    then T in { 1,2,3,4 } by MCART_1:28;
    hence thesis by ENUMSET1:def 2;
  end;
  suppose

    [T,y,x] in { [6,<*i*>,{}] where i is Element of NAT: not contradiction
    };

    then ex i being Element of NAT st [T,y,x] = [6,<*i*>,{}];
    hence thesis by MCART_1:28;
  end;
  suppose

    [T,y,x] in { [7,<*i*>,<*a*>] where i is Element of NAT, a is Element of
    Data-Locations SCM: not contradiction };

    then
    ex i being Element of NAT, a being Element of Data-Locations SCM
     st [T,y,x] =
    [7,<*i*>,<*a*>];

    hence thesis by MCART_1:28;
  end;
  suppose

    [T,y,x] in { [5,{},<*a,r*>] where a is Element of Data-Locations SCM, r is
    Element of R: not contradiction };

    then
    ex a being Element of Data-Locations SCM, r being Element of R
     st [T,y,x] = [5,{},<*a,r*>];

    hence thesis by MCART_1:28;
  end;
end;

canceled 8;

theorem Th32:
  T = 0 implies JumpParts T = {0}
proof
  assume
A1: T = 0;
  hereby
    let a be set;
    assume a in JumpParts T;
    then consider I such that
A2: a = JumpPart I and
A3: InsCode I = T;
    I = halt SCM R by A1,A3,Th16;
    then a = {} by A2;
    hence a in {0} by TARSKI:def 1;
  end;
  let a be set;
  assume a in {0};
  then
A4: a = 0 by TARSKI:def 1;
  InsCode halt SCM R = 0 & JumpPart halt SCM R = 0 by Th8;
  hence thesis by A1,A4;
end;

theorem Th33:
  T = 1 implies JumpParts T = {{}}
proof
  assume
A1: T = 1;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM R such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = a:=b by A1,A3,Th17;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location of R;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart(a:= a) by RECDEF_2:def 2;
    InsCode(a:= a) = 1 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th34:
  T = 2 implies JumpParts T = {{}}
proof
  assume
A1: T = 2;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM R such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = AddTo(a,b) by A1,A3,Th18;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location of R;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart AddTo(a,a) by RECDEF_2:def 2;
    InsCode AddTo(a,a) = 2 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th35:
  T = 3 implies JumpParts T = {{}}
proof
  assume
A1: T = 3;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM R such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = SubFrom(a,b) by A1,A3,Th19;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location of R;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart SubFrom(a,a) by RECDEF_2:def 2;
    InsCode SubFrom(a,a) = 3 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th36:
  T = 4 implies JumpParts T = {{}}
proof
  assume
A1: T = 4;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM R such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = MultBy(a,b) by A1,A3,Th20;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location of R;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart MultBy(a,a) by RECDEF_2:def 2;
    InsCode MultBy(a,a) = 4 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th37:
  T = 5 implies JumpParts T = {{}}
proof
  assume
A1: T = 5;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM R such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,r such that
A4:   I = a:=r by A1,A3,Th21;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location of R, r = the Element of R;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart(a:=r) by RECDEF_2:def 2;
    InsCode(a:=r) = 5 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th38:
  T = 6 implies dom product" JumpParts T = {1}
proof
  set i1 =the  Element of NAT;
  assume
A1: T = 6;
A2: JumpPart goto(i1,R) = <*i1*> by RECDEF_2:def 2;
  hereby
    let x be set;
    InsCode goto(i1,R) = 6 by RECDEF_2:def 1;
    then
A3: JumpPart goto(i1,R) in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart goto(i1,R) by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,def 8;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM R such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1 such that
A7: I = goto(i1,R) by A1,A6,Th22;
    f = <*i1*> by A5,A7,RECDEF_2:def 2;
    hence thesis by A4,FINSEQ_1:4,def 8;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th39:
  T = 7 implies dom product" JumpParts T = {1}
proof
  set i1 =the  Element of NAT,a =the  Data-Location of R;
  assume
A1: T = 7;
A2: JumpPart (a =0_goto i1) = <*i1*> by RECDEF_2:def 2;
  hereby
    let x be set;
    InsCode (a =0_goto i1) = 7 by RECDEF_2:def 1;
    then
A3: JumpPart (a =0_goto i1) in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart (a =0_goto i1) by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,55;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM R such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider a, i1 such that
A7: I = a =0_goto i1 by A1,A6,Th23;
    f = <*i1*> by A5,A7,RECDEF_2:def 2;
    hence thesis by A4,FINSEQ_1:4,55;
  end;
  hence thesis by CARD_3:def 13;
end;

canceled 10;

theorem Th50:
  (product" JumpParts InsCode goto(i1,R)).1 = NAT
proof
  dom product" JumpParts InsCode goto(i1,R) = {1} by Th14,Th38;
  then
A1: 1 in dom product" JumpParts InsCode goto(i1,R) by TARSKI:def 1;
A2: InsCode goto(i1,R) = 6 by RECDEF_2:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode goto(i1,R)).1;
    then x in pi(JumpParts InsCode goto(i1,R),1) by A1,CARD_3:93;
    then consider g being Function such that
A3: g in JumpParts InsCode goto(i1,R) and
A4: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A5: g = JumpPart I and
A6: InsCode I = InsCode goto(i1,R) by A3;
    consider i2 such that
A7: I = goto(i2,R) by A2,A6,Th22;
    g = <*i2*> by A5,A7,RECDEF_2:def 2;
    then x = i2 by A4,FINSEQ_1:def 8;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
  JumpPart goto(x,R) = <*x*> & InsCode goto(i1,R) = InsCode goto(x,R) by A2,
RECDEF_2:def 1,def 2;
  then
A8: <*x*> in JumpParts InsCode goto(i1,R);
  <*x*>.1 = x by FINSEQ_1:def 8;
  then x in pi(JumpParts InsCode goto(i1,R),1) by A8,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th51:
  (product" JumpParts InsCode (a =0_goto i1)).1 = NAT
proof
  dom product" JumpParts InsCode (a =0_goto i1) = {1} by Th15,Th39;
  then
A1: 1 in dom product" JumpParts InsCode (a =0_goto i1) by TARSKI:def 1;
A2: InsCode (a =0_goto i1) = 7 by RECDEF_2:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode (a =0_goto i1)).1;
    then x in pi(JumpParts InsCode (a =0_goto i1),1) by A1,CARD_3:93;
    then consider g being Function such that
A3: g in JumpParts InsCode (a =0_goto i1) and
A4: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A5: g = JumpPart I and
A6: InsCode I = InsCode (a =0_goto i1) by A3;
    consider b, i2 such that
A7: I = b =0_goto i2 by A2,A6,Th23;
    g = <*i2*> by A5,A7,RECDEF_2:def 2;
    then x = i2 by A4,FINSEQ_1:57;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
  JumpPart (a =0_goto x) = <*x*> & InsCode (a =0_goto i1) = InsCode
  (a =0_goto x) by A2,RECDEF_2:def 1,def 2;
  then
A8: <*x*> in JumpParts InsCode (a =0_goto i1);
  <*x*>.1 = x by FINSEQ_1:57;
  then x in pi(JumpParts InsCode (a =0_goto i1),1) by A8,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

canceled;

Lm4: for i being Instruction of SCM R holds (for l being Element of NAT
 holds NIC(i,l)={succ l}) implies JUMP i is empty
proof
  set p=1, q=2;
  let i be Instruction of SCM R;
  assume
A1: for l being Element of NAT holds NIC(i,l)={succ l};

  set X = { NIC(i,f) where f is Element of NAT: not
  contradiction };

  reconsider p, q as Element of NAT;
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {succ p} by A1;
  then {succ p} in X;
  then x in {succ p} by A2,SETFAM_1:def 1;
  then
A3: x = succ p by TARSKI:def 1;
  NIC(i,q) = {succ q} by A1;
  then {succ q} in X;
  then x in {succ q} by A2,SETFAM_1:def 1;
  hence contradiction by A3,TARSKI:def 1;
end;

registration
  let R;
  cluster JUMP halt SCM R -> empty;
  coherence;
end;

registration
  let R, a, b;
  cluster a:=b -> sequential;
  coherence
  proof
    let s be State of SCM R;
    thus thesis by SCMRING2:13;
  end;
  cluster AddTo(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM R;
    thus thesis by SCMRING2:14;
  end;
  cluster SubFrom(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM R;
    thus thesis by SCMRING2:15;
  end;
  cluster MultBy(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM R;
    thus thesis by SCMRING2:16;
  end;
end;

registration
  let R, a, r;
  cluster a:=r -> sequential;
  coherence
  proof
    let s be State of SCM R;
    thus thesis by SCMRING2:19;
  end;
end;

registration
  let R, a, b;
  cluster JUMP (a := b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=b,l)={succ l}
    by AMISTD_1:41;
    hence thesis by Lm4;
  end;
end;

registration
  let R, a, b;
  cluster JUMP AddTo(a, b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(AddTo(a,b),l)={
    succ l} by AMISTD_1:41;
    hence thesis by Lm4;
  end;
end;

registration
  let R, a, b;
  cluster JUMP SubFrom(a, b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(SubFrom(a,b),l)={
    succ l } by AMISTD_1:41;
    hence thesis by Lm4;
  end;
end;

registration
  let R, a, b;
  cluster JUMP MultBy(a,b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(MultBy(a,b),l)={
    succ l } by AMISTD_1:41;
    hence thesis by Lm4;
  end;
end;

registration
  let R, a, r;
  cluster JUMP (a := r) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=r,l)={succ l}
    by AMISTD_1:41;
    hence thesis by Lm4;
  end;
end;

canceled 6;

theorem Th59:
  NIC(goto(i1,R), il) = {i1}
proof
  now
    let x be set;
A1: now
      reconsider il1 = il as Element of ObjectKind IC SCM R by COMPOS_1:def 6;
      reconsider I = goto(i1,R) as Element of (the Object-Kind of SCM R).il
       by COMPOS_1:def 8;
  set t = the State of SCM R,
      Q = the (the Instructions of SCM R)-valued ManySortedSet of NAT;
      assume
A2:   x = i1;
  reconsider u = t+*(IC SCM R,il1)
   as Element of product the Object-Kind of SCM R by PBOOLE:155;
  reconsider P = Q +* (il,I)
   as (the Instructions of SCM R)-valued ManySortedSet of NAT;
A3:   P/.il = P.il by PBOOLE:158;
    IC SCM R in dom t by COMPOS_1:9;
    then
A4: IC u = il by FUNCT_7:33;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
B4: P.il = I by FUNCT_7:33;
      then IC Following(P,u) = i1 by A4,A3,SCMRING2:17;
      hence x in {IC Exec(goto(i1,R),s)
       where s is Element of product the Object-Kind of SCM R
       : IC s = il} by A2,A3,A4,B4;
    end;
    now
      assume x in {IC Exec(goto(i1,R),s)
       where s is Element of product the Object-Kind of SCM R
       : IC s = il};
      then
      ex s being Element of product the Object-Kind of SCM R
       st x = IC Exec(goto(i1,R),s) & IC s = il;
      hence x = i1 by SCMRING2:17;
    end;
    hence
    x in {i1} iff x in {IC Exec(goto(i1,R),s)
       where s is Element of product the Object-Kind of SCM R
     : IC s = il } by A1,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th60:
  JUMP goto(i1,R) = {i1}
proof
  set X = { NIC(goto(i1,R), il) : not contradiction };
  now
    let x be set;
    hereby
      reconsider il1 = 1 as Element of NAT;
A1:   NIC(goto(i1,R), il1) in X;
      assume x in meet X;
      then x in NIC(goto(i1,R), il1) by A1,SETFAM_1:def 1;
      hence x in {i1} by Th59;
    end;
    assume x in {i1};
    then
A2: x = i1 by TARSKI:def 1;
A3: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A4:   Y = NIC(goto(i1,R), il);
      NIC(goto(i1,R), il) = {i1} by Th59;
      hence i1 in Y by A4,TARSKI:def 1;
    end;
    NIC(goto(i1,R), i1) in X;
    hence x in meet X by A2,A3,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let R, i1;
  cluster JUMP goto(i1,R) -> non empty trivial;
  coherence
  proof
    JUMP goto(i1,R) = {i1} by Th60;
    hence thesis;
  end;
end;

theorem Th61:
  i1 in NIC(a=0_goto i1, il) & NIC(a=0_goto i1, il) c= {i1, succ il}
proof
  set t = the State of SCM R,
      Q = the (the Instructions of SCM R)-valued ManySortedSet of NAT;
  reconsider I = a=0_goto i1 as Element of (the Object-Kind of SCM R).il
   by COMPOS_1:def 8;
  reconsider a9 = a as Element of Data-Locations SCM by SCMRING2:1;
  reconsider il1 = il as Element of ObjectKind IC SCM R by COMPOS_1:def 6;
  ObjectKind a = (SCM-OK R).a9 by SCMRING2:def 1
    .= the carrier of R by AMI_3:72,SCMRING1:5;
  then reconsider 0R = 0.R as Element of ObjectKind a;
  reconsider u = t+*(IC SCM R,il1)
   as Element of product the Object-Kind of SCM R by PBOOLE:155;
  reconsider P = Q +* (il,I)
   as (the Instructions of SCM R)-valued ManySortedSet of NAT;
  reconsider v = u+*(a .--> 0R)
   as Element of product the Object-Kind of SCM R by PBOOLE:155;
xx: IC SCM R in dom t by COMPOS_1:9;
A1: dom (a .--> 0R) = {a} by FUNCOP_1:19;
   IC SCM R <> a by Th3;
    then not IC SCM R in dom (a .--> 0R) by A1,TARSKI:def 1;
    then
A4: IC v = IC u by FUNCT_4:12
      .= il by FUNCT_7:33,xx;
B7:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
A7: P.il = I by FUNCT_7:33;
  a in dom (a .--> 0R) by A1,TARSKI:def 1;
  then v.a = (a .--> 0R).a by FUNCT_4:14
    .= 0.R by FUNCOP_1:87;
  then IC Following(P,v) = i1 by A4,A7,SCMRING2:18,B7;
  hence i1 in NIC(a=0_goto i1, il) by A4,A7,B7;
  let x be set;
  assume x in NIC(a=0_goto i1, il);
  then consider s being Element of product the Object-Kind of SCM R
  such that
A8: x = IC Exec(a=0_goto i1,s) & IC s = il;
  per cases;
  suppose
    s.a = 0.R;
    then x = i1 by A8,SCMRING2:18;
    hence thesis by TARSKI:def 2;
  end;
  suppose
    s.a <> 0.R;
    then x = succ il by A8,SCMRING2:18;
    hence thesis by TARSKI:def 2;
  end;
end;

theorem
  for R being non trivial good Ring, a being Data-Location of R, il, i1
being Element of NAT holds NIC(a=0_goto i1, il) = {i1, succ il}
proof
  let R be non trivial good Ring, a be Data-Location of R, il, i1 be
  Element of NAT;
  set t = the State of SCM R,
      Q = the (the Instructions of SCM R)-valued ManySortedSet of NAT;
  reconsider I = a=0_goto i1 as Element of (the Object-Kind of SCM R).il
   by COMPOS_1:def 8;
  reconsider a9 = a as Element of Data-Locations SCM by SCMRING2:1;
A1: ObjectKind a = (SCM-OK R).a9 by SCMRING2:def 1
    .= the carrier of R by AMI_3:72,SCMRING1:5;
  reconsider il1 = il as Element of ObjectKind IC SCM R by COMPOS_1:def 6;
  thus NIC(a=0_goto i1, il) c= {i1, succ il} by Th61;
  reconsider u = t+*(IC SCM R,il1)
   as Element of product the Object-Kind of SCM R by PBOOLE:155;
  reconsider P = Q +* (il,I)
   as (the Instructions of SCM R)-valued ManySortedSet of NAT;
  let x be set;
A3: IC SCM R <> a by Th3;
xx: IC SCM R in dom t by COMPOS_1:9;
  assume
A4: x in {i1, succ il};
  per cases by A4,TARSKI:def 2;
  suppose
A5: x = i1;
    reconsider 0R = 0.R as Element of ObjectKind a by A1;
    reconsider v = u+*(a .--> 0R)
     as Element of product the Object-Kind of SCM R by PBOOLE:155;
A9: dom (a .--> 0R) = {a} by FUNCOP_1:19;
    then not IC SCM R in dom (a .--> 0R) by A3,TARSKI:def 1;
    then
A10: IC v = IC u by FUNCT_4:12
      .= il by xx,FUNCT_7:33;
A12:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
B12: P.il = I by FUNCT_7:33;
    a in dom (a .--> 0R) by A9,TARSKI:def 1;
    then v.a = (a .--> 0R).a by FUNCT_4:14
      .= 0.R by FUNCOP_1:87;
    then IC Following(P,v) = i1 by A10,A12,SCMRING2:18,B12;
    hence thesis by A5,A10,A12,B12;
  end;
  suppose
A13: x = succ il;
    consider e being Element of R such that
A14: e <> 0.R by STRUCT_0:def 19;
    reconsider E = e as Element of ObjectKind a by A1;
    reconsider v = u+*(a .--> E)
     as Element of product the Object-Kind of SCM R by PBOOLE:155;
A18: dom (a .--> E) = {a} by FUNCOP_1:19;
    then not IC SCM R in dom (a .--> E) by A3,TARSKI:def 1;
    then
A19: IC v = IC u by FUNCT_4:12
      .= il by xx,FUNCT_7:33;
A21:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
B21: P.il = I by FUNCT_7:33;
    a in dom (a .--> E) by A18,TARSKI:def 1;
    then v.a = (a .--> E).a by FUNCT_4:14
      .= E by FUNCOP_1:87;
    then IC Following(P,v) = succ il by A14,A19,A21,SCMRING2:18,B21;
    hence thesis by A13,A19,A21,B21;
  end;
end;

theorem Th63:
  JUMP (a=0_goto i1) = {i1}
proof
  set X = { NIC(a=0_goto i1, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume Y in X;
      then ex il being Element of NAT st Y = NIC(a=0_goto i1,
      il);
      hence i1 in Y by Th61;
    end;
    hereby
      reconsider il1 = 1, il2 = 2 as Element of NAT;
      assume
A2:   x in meet X;
A3:   NIC(a=0_goto i1, il2) c= {i1, succ il2} by Th61;
      NIC(a=0_goto i1, il2) in X;
      then x in NIC(a=0_goto i1, il2) by A2,SETFAM_1:def 1;
      then
A4:   x = i1 or x = succ il2 by A3,TARSKI:def 2;
A5:   NIC(a=0_goto i1, il1) c= {i1, succ il1} by Th61;
      NIC(a=0_goto i1, il1) in X;
      then x in NIC(a=0_goto i1, il1) by A2,SETFAM_1:def 1;
      then x = i1 or x = succ il1 by A5,TARSKI:def 2;
      hence x in {i1} by A4,TARSKI:def 1;
    end;
    assume x in {i1};
    then
A6: x = i1 by TARSKI:def 1;
    NIC(a=0_goto i1, i1) in X;
    hence x in meet X by A6,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let R, a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a =0_goto i1) = {i1} by Th63;
    hence thesis;
  end;
end;

theorem Th64:
  SUCC(il,SCM R) = {il, succ il}
proof
  set X = { NIC(I, il) \ JUMP I where I is Element of the Instructions of SCM
R: not contradiction };
  set N = {il, succ il};
  now
    let x be set;
    hereby
      assume x in union X;
      then consider Y being set such that
A1:   x in Y and
A2:   Y in X by TARSKI:def 4;
      consider i being Element of the Instructions of SCM R such that
A3:   Y = NIC(i, il) \ JUMP i by A2;
      per cases by SCMRING2:8;
      suppose
        i = [0,{},{}];
        then i = halt SCM R by SCMRING2:30;
        then x in {il} \ JUMP halt SCM R by A1,A3,AMISTD_1:15;
        then x = il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = a:=b;
        then consider a, b such that
A4:     i = a:=b;
        x in {succ il} \ JUMP (a:=b) by A1,A3,A4,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = AddTo(a,b);
        then consider a, b such that
A5:     i = AddTo(a,b);
        x in {succ il} \ JUMP AddTo(a,b) by A1,A3,A5,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = SubFrom(a,b);
        then consider a, b such that
A6:     i = SubFrom(a,b);
        x in {succ il} \ JUMP SubFrom(a,b) by A1,A3,A6,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = MultBy(a,b);
        then consider a, b such that
A7:     i = MultBy(a,b);
        x in {succ il} \ JUMP MultBy(a,b) by A1,A3,A7,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex i1 st i = goto(i1,R);
        then consider i1 such that
A8:     i = goto(i1,R);
        x in {i1} \ JUMP i by A1,A3,A8,Th59;
        then x in {i1} \ {i1} by A8,Th60;
        hence x in N by XBOOLE_1:37;
      end;
      suppose
        ex a,i1 st i = a=0_goto i1;
        then consider a, i1 such that
A9:     i = a=0_goto i1;
A10:    NIC(i, il) c= {i1, succ il} by A9,Th61;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A11:    x = i1 or x = succ il by A10,TARSKI:def 2;
        x in NIC(i, il) \ {i1} by A1,A3,A9,Th63;
        then not x in {i1} by XBOOLE_0:def 5;
        hence x in N by A11,TARSKI:def 1,def 2;
      end;
      suppose
        ex a,r st i = a:=r;
        then consider a, r such that
A12:    i = a := r;
        x in {succ il} \ JUMP (a:=r) by A1,A3,A12,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
    end;
    assume
A13: x in {il, succ il};
    per cases by A13,TARSKI:def 2;
    suppose
A14:  x = il;
      set i = halt SCM R;
      NIC(i, il) \ JUMP i = {il} by AMISTD_1:15;
      then
A15:  {il} in X;
      x in {il} by A14,TARSKI:def 1;
      hence x in union X by A15,TARSKI:def 4;
    end;
    suppose
A16:  x = succ il;
      set a =the  Data-Location of R;
      set i = AddTo(a,a);
      NIC(i, il) \ JUMP i = {succ il} by AMISTD_1:41;
      then
A17:  {succ il} in X;
      x in {succ il} by A16,TARSKI:def 1;
      hence x in union X by A17,TARSKI:def 4;
    end;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th65:
for k being Element of NAT holds k+1 in SUCC(k,SCM R) &
 for j being Element of NAT st j in SUCC(k,SCM R) holds k <= j
proof
  let k be Element of NAT;
  reconsider fk = k as Element of NAT;
A1: SUCC(k,SCM R) = {k, succ (fk)} by Th64;
  hence k+1 in SUCC(k,SCM R) by TARSKI:def 2;
  let j be Element of NAT;
  assume
A2: j in SUCC(k,SCM R);
  reconsider fk = k as Element of NAT;
  per cases by A1,A2,TARSKI:def 2;
  suppose
    j = k;
    hence thesis;
  end;
  suppose
    j = succ (fk);
    hence thesis by NAT_1:11;
  end;
end;

registration
  let R;
  cluster SCM R -> standard;
  coherence
  proof
    deffunc U(Element of NAT) = $1;
    for k being Element of NAT
     holds k+1 in SUCC(k,SCM R) &
      for j being Element of NAT st j in SUCC(k,SCM R) holds k <= j by Th65;
    hence thesis by AMISTD_1:19;
  end;
end;

canceled 3;

definition
  let R be good Ring, k be Element of NAT;
  func dl.(R,k) -> Data-Location of R equals
  dl.k;
  coherence
  proof
    dl.k in Data-Locations SCM by AMI_3:72,def 2;
    hence thesis by SCMRING2:1;
  end;
end;

registration
  let R;
  cluster InsCode halt SCM R -> jump-only InsType of SCM R;
  coherence
  proof
    now
      let s be State of SCM R, o be Object of SCM R, I be Instruction of SCM R;
      assume that
A1:   InsCode I = InsCode halt SCM R and
      o in Data-Locations SCM R;
      I = halt SCM R by A1,Th8,Th16;
      hence Exec(I, s).o = s.o by EXTPRO_1:def 3;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let R;
  cluster halt SCM R -> jump-only;
  coherence
  proof
    thus InsCode halt SCM R is jump-only;
  end;
end;

registration
  let R, i1;
  cluster InsCode goto(i1,R) -> jump-only InsType of SCM R;
  coherence
  proof
    set S = SCM R;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode goto(i1,R) and
A2:   o in Data-Locations SCM R;
      InsCode goto(i1,R) = 6 by RECDEF_2:def 1;
      then
A3:   ex i2 st I = goto(i2,R) by A1,Th22;
        o in Data-Locations SCM by A2,SCMRING2:31;
        then o is Data-Location of R by SCMRING2:1;
        hence Exec(I, s).o = s.o by A3,SCMRING2:17;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let R, i1;
  cluster goto(i1,R) -> jump-only;
  coherence
  proof
    thus InsCode goto(i1,R) is jump-only;
  end;
end;

registration
  let R, a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM R;
  coherence
  proof
    set S = SCM R;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode (a =0_goto i1) and
A2:   o in Data-Locations SCM R;
      InsCode (a =0_goto i1) = 7 by RECDEF_2:def 1;
      then
A3:   ex b, i2 st I = (b =0_goto i2) by A1,Th23;
        o in Data-Locations SCM by A2,SCMRING2:31;
        then o is Data-Location of R by SCMRING2:1;
     hence Exec(I, s).o = s.o by A3,SCMRING2:18;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let R, a, i1;
  cluster a =0_goto i1 -> jump-only;
  coherence
  proof
    thus InsCode (a =0_goto i1) is jump-only;
  end;
end;

reserve S for non trivial good Ring,
  p, q for Data-Location of S,
  w for Element of S;

registration
  let S, p, q;
  cluster InsCode (p:=q) -> non jump-only InsType of SCM S;
  coherence
  proof
    set w =the  State of SCM S;
    consider e being Element of S such that
A1: e <> 0.S by STRUCT_0:def 19;
    reconsider e as Element of S;
    set t = w+*((dl.(S,0), dl.(S,1))-->(0.S,e));
A2: dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65;
    then
A3: dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by TARSKI:def 2;
A4: InsCode (p:=q) = 1 by RECDEF_2:def 1
      .= InsCode (dl.(S,0):=dl.(S,1)) by RECDEF_2:def 1;
    dl.(S,0) in Data-Locations SCM by SCMRING2:1;
    then
A5: dl.(S,0) in Data-Locations SCM S by SCMRING2:31;
    dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by A2,TARSKI:def 2;
    then
A6: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,0) by FUNCT_4:14
      .= 0.S by AMI_3:52,FUNCT_4:66;
    Exec((dl.(S,0):=dl.(S,1)), t).dl.(S,0) = t.dl.(S,1) by SCMRING2:13
      .= (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,1) by A3,FUNCT_4:14
      .= e by FUNCT_4:66;
    hence thesis by A1,A4,A6,AMISTD_1:def 3,A5;
  end;
end;

registration
  let S, p, q;
  cluster p:=q -> non jump-only;
  coherence
  proof
    thus InsCode (p:=q) is not jump-only;
  end;
end;

registration
  let S, p, q;
  cluster InsCode AddTo(p,q) -> non jump-only InsType of SCM S;
  coherence
  proof
    set w =the  State of SCM S;
    consider e being Element of S such that
A1: e <> 0.S by STRUCT_0:def 19;
    reconsider e as Element of S;
    set t = w+*((dl.(S,0), dl.(S,1))-->(0.S,e));
A2: dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65;
    then dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by TARSKI:def 2;
    then
A3: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,0) by FUNCT_4:14
      .= 0.S by AMI_3:52,FUNCT_4:66;
A4: InsCode AddTo(p,q) = 2 by RECDEF_2:def 1
      .= InsCode AddTo(dl.(S,0), dl.(S,1)) by RECDEF_2:def 1;
    dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by A2,TARSKI:def 2;
    then
A5: t.dl.(S,1) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,1) by FUNCT_4:14
      .= e by FUNCT_4:66;
    dl.(S,0) in Data-Locations SCM by SCMRING2:1;
    then
A6: dl.(S,0) in Data-Locations SCM S by SCMRING2:31;
    Exec(AddTo(dl.(S,0), dl.(S,1)), t).dl.(S,0) = t.dl.(S,0) + t.dl.(S,1)
    by SCMRING2:14
      .= e by A3,A5,RLVECT_1:10;
    hence thesis by A1,A4,A3,AMISTD_1:def 3,A6;
  end;
end;

registration
  let S, p, q;
  cluster AddTo(p, q) -> non jump-only;
  coherence
  proof
    thus InsCode AddTo(p, q) is not jump-only;
  end;
end;

registration
  let S, p, q;
  cluster InsCode SubFrom(p,q) -> non jump-only InsType of SCM S;
  coherence
  proof
    set w =the  State of SCM S;
    consider e being Element of S such that
A1: e <> 0.S by STRUCT_0:def 19;
    reconsider e as Element of S;
A2: now
      assume -e = 0.S;
      then e = -0.S by RLVECT_1:30;
      hence contradiction by A1,RLVECT_1:25;
    end;
    set t = w+*((dl.(S,0), dl.(S,1))-->(0.S,e));
A3: InsCode SubFrom(p,q) = 3 by RECDEF_2:def 1
      .= InsCode SubFrom(dl.(S,0), dl.(S,1)) by RECDEF_2:def 1;
A4: dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65;
    then dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by TARSKI:def 2;
    then
A5: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,0) by FUNCT_4:14
      .= 0.S by AMI_3:52,FUNCT_4:66;
    dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by A4,TARSKI:def 2;
    then
A6: t.dl.(S,1) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,1) by FUNCT_4:14
      .= e by FUNCT_4:66;
    dl.(S,0) in Data-Locations SCM by SCMRING2:1;
    then
A7: dl.(S,0) in Data-Locations SCM S by SCMRING2:31;
    Exec(SubFrom(dl.(S,0), dl.(S,1)), t).dl.(S,0) = t.dl.(S,0) - t.dl.(S,
    1) by SCMRING2:15
      .= -e by A5,A6,RLVECT_1:27;
    hence thesis by A3,A5,A2,AMISTD_1:def 3,A7;
  end;
end;

registration
  let S, p, q;
  cluster SubFrom(p, q) -> non jump-only;
  coherence
  proof
    thus InsCode SubFrom(p, q) is not jump-only;
  end;
end;

registration
  let S, p, q;
  cluster InsCode MultBy(p,q) -> non jump-only InsType of SCM S;
  coherence
  proof
    IC SCM S = IC SCM by AMI_3:4,SCMRING2:9;
    then
A1: 0.S <> 1_S & dl.(S,0) <> IC SCM S by AMI_3:57,LMOD_6:def 2;
    set w =the  State of SCM S;
    set t = w+*((dl.(S,0), dl.(S,1))-->(1_S,0.S));
A2: InsCode MultBy(p,q) = 4 by RECDEF_2:def 1
      .= InsCode MultBy(dl.(S,0), dl.(S,1)) by RECDEF_2:def 1;
A3: dom ((dl.(S,0), dl.(S,1))-->(1_S,0.S)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65
;
    then dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(1_S,0.S)) by TARSKI:def 2;
    then
A4: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(1_S,0.S).dl.(S,0) by FUNCT_4:14
      .= 1_S by AMI_3:52,FUNCT_4:66;
    dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(1_S,0.S)) by A3,TARSKI:def 2;
    then
A5: t.dl.(S,1) = (dl.(S,0), dl.(S,1))-->(1_S,0.S).dl.(S,1) by FUNCT_4:14
      .= 0.S by FUNCT_4:66;
    dl.(S,0) in Data-Locations SCM by SCMRING2:1;
    then
A6: dl.(S,0) in Data-Locations SCM S by SCMRING2:31;
    Exec(MultBy(dl.(S,0), dl.(S,1)), t).dl.(S,0) = t.dl.(S,0) * t.dl.(S,1)
    by SCMRING2:16
      .= 0.S by A5,VECTSP_1:36;
    hence thesis by A2,A1,A4,AMISTD_1:def 3,A6;
  end;
end;

registration
  let S, p, q;
  cluster MultBy(p, q) -> non jump-only;
  coherence
  proof
    thus InsCode MultBy(p, q) is not jump-only;
  end;
end;

registration
  let S, p, w;
  cluster InsCode (p:=w) -> non jump-only InsType of SCM S;
  coherence
  proof
    set j =the  State of SCM S;
A1: InsCode (p:=w) = 5 by RECDEF_2:def 1
      .= InsCode (dl.(S,0):=w) by RECDEF_2:def 1;
    the carrier of S <> {w};
    then consider e being set such that
A2: e in the carrier of S and
A3: e <> w by ZFMISC_1:41;
    reconsider e as Element of S by A2;
    ObjectKind dl.(S,0) = the carrier of S by Th1;
    then reconsider v = dl.(S,0) .--> e as FinPartState of SCM S by COMPOS_1:5;
    set t = j+*v;
    dom (dl.(S,0).-->e) = {dl.(S,0)} by FUNCOP_1:19;
    then dl.(S,0) in dom (dl.(S,0).-->e) by TARSKI:def 1;
    then
A4: t.dl.(S,0) = (dl.(S,0) .--> e).dl.(S,0) by FUNCT_4:14
      .= e by FUNCOP_1:87;
    dl.(S,0) in Data-Locations SCM by SCMRING2:1;
    then
A5: dl.(S,0) in Data-Locations SCM S by SCMRING2:31;
    Exec((dl.(S,0):=w), t).dl.(S,0) = w by SCMRING2:19;
    hence thesis by A3,A1,A4,AMISTD_1:def 3,A5;
  end;
end;

registration
  let S, p, w;
  cluster p:=w -> non jump-only;
  coherence
  proof
    thus InsCode (p:=w) is not jump-only;
  end;
end;

registration
  let R, i1;
  cluster goto(i1,R) -> non sequential;
  coherence
  proof
    JUMP goto(i1,R) <> {};
    hence thesis by AMISTD_1:43;
  end;
end;

registration
  let R, a, i1;
  cluster a =0_goto i1 -> non sequential;
  coherence
  proof
    JUMP (a =0_goto i1) <> {};
    hence thesis by AMISTD_1:43;
  end;
end;

registration
  let R, i1;
  cluster goto(i1,R) -> non ins-loc-free;
  coherence
  proof
    dom JumpPart goto(i1,R) = dom <*i1*> by RECDEF_2:def 2
      .= {1} by FINSEQ_1:4,def 8;
    hence JumpPart goto(i1,R) is not empty;
  end;
end;

registration
  let R, a, i1;
  cluster a =0_goto i1 -> non ins-loc-free;
  coherence
  proof
    dom JumpPart (a =0_goto i1) = dom <*i1*> by RECDEF_2:def 2
      .= {1} by FINSEQ_1:4,55;
    hence JumpPart(a =0_goto i1) is not empty;
  end;
end;

registration
  let R;
  cluster SCM R -> homogeneous with_explicit_jumps;
  coherence
  proof
    thus SCM R is homogeneous
    proof
      let I, J be Instruction of SCM R such that
A1:   InsCode I = InsCode J;
A2:   J = [0,{},{}] or (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or
(ex a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex i1 st J =
goto(i1,R)) or (ex a,i1 st J = a=0_goto i1) or ex a,r st J = a:=r
by SCMRING2:8;
      per cases by SCMRING2:8;
      suppose
A3:     I = [0,{},{}];
        then I = halt SCM R by SCMRING2:30;
        then InsCode I = 0 by Th8;
        hence thesis by A1,A2,A3,RECDEF_2:def 1;
      end;
      suppose
        ex a,b st I = a:=b;
        then consider a, b such that
A4:     I = a:=b;
A5:     InsCode I = 1 by A4,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A5,Th8;
          end;
          suppose
            ex a,b st J = a:=b;
            then consider d1, d2 such that
A6:         J = d1:=d2;
            thus dom JumpPart I = dom {} by A4,RECDEF_2:def 2
              .= dom JumpPart J by A6,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = AddTo(a,b)) or (ex a,b st J = SubFrom(a,b)
) or (ex a,b st J = MultBy(a,b)) or (ex i1 st J = goto(i1,R)) or
(ex a,i1 st J = a
            =0_goto i1) or ex a,r st J = a:=r;
            hence thesis by A1,A5,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        then consider a, b such that
A7:     I = AddTo(a,b);
A8:     InsCode I = 2 by A7,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A8,Th8;
          end;
          suppose
            ex a,b st J = AddTo(a,b);
            then consider d1, d2 such that
A9:         J = AddTo(d1,d2);
            thus dom JumpPart I = dom {} by A7,RECDEF_2:def 2
              .= dom JumpPart J by A9,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = SubFrom(a,b)) or (
ex a,b st J = MultBy(a,b)) or (ex i1 st J = goto(i1,R)) or (ex a,i1 st J = a
            =0_goto i1) or ex a,r st J = a:=r;
            hence thesis by A1,A8,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        then consider a, b such that
A10:    I = SubFrom(a,b);
A11:    InsCode I = 3 by A10,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A11,Th8;
          end;
          suppose
            ex a,b st J = SubFrom(a,b);
            then consider d1, d2 such that
A12:        J = SubFrom(d1,d2);
            thus dom JumpPart I = dom {} by A10,RECDEF_2:def 2
              .= dom JumpPart J by A12,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = MultBy(a,b)) or (ex i1 st J = goto(i1,R)) or
(ex a,i1 st J = a=0_goto
            i1) or ex a,r st J = a:=r;
            hence thesis by A1,A11,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        then consider a, b such that
A13:    I = MultBy(a,b);
A14:    InsCode I = 4 by A13,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A14,Th8;
          end;
          suppose
            ex a,b st J = MultBy(a,b);
            then consider d1, d2 such that
A15:        J = MultBy(d1,d2);
            thus dom JumpPart I = dom {} by A13,RECDEF_2:def 2
              .= dom JumpPart J by A15,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex i1 st J = goto(i1,R)) or
(ex a,i1 st J = a=0_goto
            i1) or ex a,r st J = a:=r;
            hence thesis by A1,A14,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1 st I = goto(i1,R);
        then consider i1 such that
A16:    I = goto(i1,R);
A17:    InsCode I = 6 by A16,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A17,Th8;
          end;
          suppose
            ex i2 st J = goto(i2,R);
            then consider i2 such that
A18:        J = goto(i2,R);
            thus dom JumpPart I = dom <*i1*> by A16,RECDEF_2:def 2
              .= Seg 1 by FINSEQ_1:def 8
              .= dom <*i2*> by FINSEQ_1:def 8
              .= dom JumpPart J by A18,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,i1 st J = a
            =0_goto i1) or ex a,r st J = a:=r;
            hence thesis by A1,A17,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,i1 st I = a=0_goto i1;
        then consider a, i1 such that
A19:    I = a=0_goto i1;
A20:    InsCode I = 7 by A19,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A20,Th8;
          end;
          suppose
            ex d1,i2 st J = d1 =0_goto i2;
            then consider d1, i2 such that
A21:        J = d1 =0_goto i2;
            thus dom JumpPart I = dom <*i1*> by A19,RECDEF_2:def 2
              .= Seg 1 by FINSEQ_1:55
              .= dom <*i2*> by FINSEQ_1:55
              .= dom JumpPart J by A21,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or
 (ex i1 st J = goto(i1,R)) or ex a,r st J = a:=r;
            hence thesis by A1,A20,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,r st I = a:=r;
        then consider a, r such that
A22:    I = a:=r;
A23:    InsCode I = 5 by A22,RECDEF_2:def 1;
        now
          per cases by SCMRING2:8;
          suppose
            J = [0,{},{}];
            then J = halt SCM R by SCMRING2:30;
            hence thesis by A1,A23,Th8;
          end;
          suppose
            ex a,r st J = a:=r;
            then consider
            b being Data-Location of R, r1 being Element of R such
            that
A24:        J = b:=r1;
            thus dom JumpPart I = dom {} by A22,RECDEF_2:def 2
              .= dom JumpPart J by A24,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or
 (ex i1 st J = goto(i1,R)) or ex a,i1 st J = a =0_goto i1;
            hence thesis by A1,A23,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
    end;
    thus SCM R is with_explicit_jumps
    proof
      let I be Instruction of SCM R;
      thus JUMP I c= rng JumpPart I
      proof
      let f be set such that
A25:  f in JUMP I;
      per cases by SCMRING2:8;
      suppose
A26:    I = [0,{},{}];
        JUMP halt SCM R is empty;
        hence thesis by A25,A26,SCMRING2:30;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis by A25;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis by A25;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis by A25;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis by A25;
      end;
      suppose
A27:    ex i1 st I = goto(i1,R);
        consider i1 such that
A28:    I = goto(i1,R) by A27;
A29:    JumpPart goto(i1,R) = <*i1*> by RECDEF_2:def 2;
        rng<*i1*> = {i1} by FINSEQ_1:56;
        hence f in rng JumpPart I by A25,A28,A29,Th60;
      end;
      suppose
A31:    ex a,i1 st I = a=0_goto i1;
        consider a, i1 such that
A32:    I = a=0_goto i1 by A31;
A33:    JumpPart (a=0_goto i1) = <*i1*> by RECDEF_2:def 2;
        rng<*i1*> = {i1} by FINSEQ_1:56;
        hence thesis by A25,A32,A33,Th63;
      end;
      suppose
        ex a,r st I = a:=r;
        hence thesis by A25;
      end;
    end;
    let f being set;
    assume f in rng JumpPart I;
    then consider k being set such that
A35: k in dom JumpPart I and
A36: f = (JumpPart I).k by FUNCT_1:def 5;
    per cases by SCMRING2:8;
    suppose
      I = [0,{},{}];
      then I = halt SCM R by SCMRING2:30;
      hence thesis by A35;
    end;
    suppose
      ex a,b st I = a:=b;
      then consider a, b such that
A37:  I = a:=b;
      k in dom {} by A35,A37,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = AddTo(a,b);
      then consider a, b such that
A38:  I = AddTo(a,b);
      k in dom {} by A35,A38,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A39:  I = SubFrom(a,b);
      k in dom {} by A35,A39,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = MultBy(a,b);
      then consider a, b such that
A40:  I = MultBy(a,b);
      k in dom {} by A35,A40,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex i1 st I = goto(i1,R);
      then consider i1 such that
A41:  I = goto(i1,R);
A42:  JumpPart I = <*i1*> by A41,RECDEF_2:def 2;
      then k = 1 by A35,Lm1;
      then
A43:  f = i1 by A42,A36,FINSEQ_1:def 8;
      JUMP I = {i1} by A41,Th60;
      hence thesis by A43,TARSKI:def 1;
    end;
    suppose
      ex a,i1 st I = a=0_goto i1;
      then consider a, i1 such that
A44:  I = a=0_goto i1;
A45:  JumpPart I = <*i1*> by A44,RECDEF_2:def 2;
      then k = 1 by A35,Lm1;
      then
A46:  f = i1 by A45,A36,FINSEQ_1:57;
      JUMP I = {i1} by A44,Th63;
      hence thesis by A46,TARSKI:def 1;
    end;
    suppose
      ex a,r st I = a:=r;
      then consider a, r such that
A47:  I = a:=r;
      k in dom {} by A35,A47,RECDEF_2:def 2;
      hence thesis;
    end;
  end;
  end;
end;

registration
  let R;
  cluster SCM R -> regular;
  coherence
  proof
    let I be Instruction of SCM R;
     set T = InsCode I;
A1:   JumpPart I in JumpParts T;
    per cases by Lm2;
    suppose T = 0;
      then I = halt SCM R by Th16;
     hence thesis;
    end;
    suppose T = 1;
      then JumpParts T = {{}} by Th33;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 2;
     then JumpParts T = {{}} by Th34;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 3;
     then JumpParts T = {{}} by Th35;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 4;
     then JumpParts T = {{}} by Th36;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 5;
     then JumpParts T = {{}} by Th37;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose
A2: T = 6;
     then consider i2 such that
A3:    I = goto(i2,R) by Th22;
     let k be set;
     assume
A4:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM R such that
A5:       f = JumpPart J and
A6:       InsCode J = T;
        thus k in dom f by A4,A5,A6,COMPOS_1:def 33;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A2,Th38;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by A3,Th50;
    end;
    suppose
A7: T = 7;
     then consider a,i1 such that
A8:    I = a=0_goto i1 by Th23;
     let k be set;
     assume
A9:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM R such that
A10:       f = JumpPart J and
A11:       InsCode J = T;
        thus k in dom f by A9,A10,A11,COMPOS_1:def 33;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A7,Th39;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by A8,Th51;
    end;
  end;
end;

registration
  let R;
  cluster SCM R -> J/A-independent;
  coherence
  proof
   let T be InsType of SCM R, f1,f2 be Function, p be set such that
A1: f1 in JumpParts T and
A2: f2 in product product" JumpParts T and
A3: [T,f1,p] in the Instructions of SCM R;
    per cases by Lm2;
    suppose T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5;
     then
A4:   JumpParts T = {0} by Th32,Th33,Th34,Th35,Th36,Th37;
     then
A5:    product product" JumpParts T = {0} by CARD_3:19,156;
     f1 = 0 by A4,A1,TARSKI:def 1 .= f2 by A2,A5,TARSKI:def 1;
    hence [T,f2,p] in the Instructions of SCM R by A3;
    end;
    suppose
A6:    T = 6;
    reconsider J = [T,f1,p] as Instruction of SCM R by A3;
A7: InsCode J = 6 by A6,RECDEF_2:def 1;
    then consider i1 being Element of NAT such that
A8:  J = goto(i1,R) by Th22;
A9:   p = {} by A8,MCART_1:28;
A10: dom f2 = dom product" JumpParts T  by A2,CARD_3:18;
A12: dom f2 = {1} by A6,A10,Th38;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by A10,A2,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by A8,A6,A7,Th50;
    set I = [T,f2,{}];
    I = goto(l,R) by A6,A12,FINSEQ_1:4,def 8;
    then  reconsider I as Instruction of SCM R;
    f2 = JumpPart I by RECDEF_2:def 2;
    hence [T,f2,p] in the Instructions of SCM R by A9;
    end;
    suppose
A13:    T = 7;
    reconsider J = [T,f1,p] as Instruction of SCM R by A3;
A14: InsCode J = T by RECDEF_2:def 1;
    then consider a,i1 such that
A15:  J = a=0_goto i1 by Th23,A13;
A16:   p = <*a*> by A15,MCART_1:28;
A17: dom f2 = dom product" JumpParts T  by A2,CARD_3:18;
A19: dom f2 = {1} by A13,A17,Th39;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by A17,A2,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by A15,A14,Th51;
    set I = [T,f2,p];
    I = a=0_goto l by A16,A13,A19,FINSEQ_1:4,def 8;
    then  reconsider I as Instruction of SCM R;
A20: f2 = JumpPart I by RECDEF_2:def 2;

    thus [T,f2,p] in the Instructions of SCM R by A20;
    end;
  end;
end;

theorem Th69:
  IncAddr(goto(i1,R),k) = goto(i1 + k,R)
proof
A1:  JumpPart IncAddr(goto(i1,R),k) = k + JumpPart goto(i1,R)
by COMPOS_1:def 38;
 then
A2: dom JumpPart IncAddr(goto(i1,R),k) = dom JumpPart goto(i1,R) by
VALUED_1:def 2;
A3: dom JumpPart goto(i1 + k,R)
 = dom <*i1 + k*> by RECDEF_2:def 2
    .= Seg 1 by FINSEQ_1:def 8
    .= dom <*i1*> by FINSEQ_1:def 8
    .= dom JumpPart goto(i1,R) by RECDEF_2:def 2;
A4: for x being set st x in dom JumpPart goto(i1,R) holds (JumpPart
  IncAddr(goto(i1,R),k)).x = (JumpPart
   goto(i1 + k,R)).x
  proof
    let x be set;
    assume
A5: x in dom JumpPart goto(i1,R);
    then x in dom <*i1*> by RECDEF_2:def 2;
    then
A6: x = 1 by Lm1;
    reconsider f = (JumpPart goto(i1,R)).x as Element of NAT
                   by ORDINAL1:def 13;
A7: (JumpPart IncAddr(goto(i1,R),k)).x = k + f by A5,A1,A2,VALUED_1:def 2;
    f = <*i1*>.x by RECDEF_2:def 2
      .= i1 by A6,FINSEQ_1:def 8;
    hence (JumpPart IncAddr(goto(i1,R),k)).x
     = <*i1 + k*>.x
    by A6,A7,FINSEQ_1:def 8
      .= (JumpPart goto(i1 + k,R)).x
       by RECDEF_2:def 2;
  end;
A8: InsCode IncAddr(goto(i1,R),k) = InsCode goto(i1,R) by COMPOS_1:def 38
    .= 6 by RECDEF_2:def 1
    .= InsCode goto(i1 + k,R) by RECDEF_2:def 1;
A9: AddressPart IncAddr(goto(i1,R),k)
     = AddressPart goto(i1,R) by COMPOS_1:def 38
    .= {} by RECDEF_2:def 3
    .= AddressPart goto(i1 + k,R) by RECDEF_2:def 3;
  JumpPart IncAddr(goto(i1,R),k) = JumpPart goto(i1 + k,R)
       by A2,A3,A4,FUNCT_1:9;
  hence thesis by A8,A9,COMPOS_1:7;
end;

theorem Th70:
  IncAddr(a=0_goto i1,k) = a=0_goto (i1 + k)
proof
A1: JumpPart IncAddr(a=0_goto i1,k) = k + JumpPart (a=0_goto i1)
  by COMPOS_1:def 38;
  then
A2: dom JumpPart IncAddr(a=0_goto i1,k) = dom JumpPart (a=0_goto i1)
  by VALUED_1:def 2;
A3: dom JumpPart (a=0_goto (i1 + k))
 = dom <*i1 + k*> by RECDEF_2:def 2
    .= Seg 1 by FINSEQ_1:55
    .= dom <*i1*> by FINSEQ_1:55
    .= dom JumpPart (a=0_goto i1) by RECDEF_2:def 2;
A4: for x being set st x in dom JumpPart (a=0_goto i1) holds (JumpPart
   IncAddr(a=0_goto i1,k)).x = (JumpPart (a=0_goto (i1 + k))).x
  proof
    let x be set;
    assume
A5: x in dom JumpPart (a=0_goto i1);
    then x in dom <*i1*> by RECDEF_2:def 2;
    then
A6:   x = 1 by FINSEQ_1:111;
    reconsider f = (JumpPart (a=0_goto i1)).x as Element of NAT
                   by ORDINAL1:def 13;
A7:   (JumpPart IncAddr(a=0_goto i1,k)).x = k + f by A5,A1,A2,VALUED_1:def 2;
      f = <*i1*>.x by RECDEF_2:def 2
        .= i1 by A6,FINSEQ_1:57;
      hence (JumpPart IncAddr(a=0_goto i1,k)).x
         = <*i1 + k*>.x by A6,A7,FINSEQ_1:57
        .= (JumpPart (a=0_goto (i1 + k))).x by RECDEF_2:def 2;
  end;
A8: InsCode IncAddr(a=0_goto i1,k) = InsCode (a=0_goto i1) by COMPOS_1:def 38
    .= 7 by RECDEF_2:def 1
    .= InsCode (a=0_goto ( i1 + k)) by RECDEF_2:def 1;
A9: AddressPart IncAddr(a=0_goto i1,k)
     = AddressPart (a=0_goto i1) by COMPOS_1:def 38
    .= <*a*> by RECDEF_2:def 3
    .= AddressPart (a=0_goto ( i1 + k)) by RECDEF_2:def 3;
  JumpPart IncAddr(a=0_goto i1,k) = JumpPart (a=0_goto ( i1 + k))
       by A2,A3,A4,FUNCT_1:9;
  hence thesis by A8,A9,COMPOS_1:7;
end;

registration
  let R;
  cluster SCM R -> IC-relocable Exec-preserving;
  coherence
  proof
    thus SCM R is IC-relocable
    proof
      let I be Instruction of SCM R;
      per cases by SCMRING2:8;
      suppose
        I = [0,{},{}];
        then I = halt SCM R by SCMRING2:30;
        hence thesis;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis;
      end;
      suppose
A1:     ex i1 st I = goto(i1,R);
        let j,k be natural number, s1 be State of SCM R;
        set s2 = IncIC(s1,k);
        consider i1 such that
A2:     I = goto(i1,R) by A1;
        thus IC Exec(IncAddr(I,j),s1) + k
         = IC Exec(goto(j+i1,R),s1) + k by A2,Th69
        .= j+i1+k by SCMRING2:17
        .= IC Exec(goto(j+i1+k,R),s2) by SCMRING2:17
        .= IC Exec(goto(j+k+i1,R),s2)
        .= IC Exec(IncAddr(I,j+k), s2) by A2,Th69;
      end;
      suppose
        ex a,i1 st I = a=0_goto i1;
        then consider a, i1 such that
A3:     I = a=0_goto i1;
        let j,k be natural number, s1 be State of SCM R;
        set s2 = IncIC(s1,k);
        a <> IC SCM R & dom (IC SCM R .--> (IC s1 + k)) = {IC SCM R}
        by Th3,FUNCOP_1:19;
        then not a in dom (IC SCM R .--> (IC s1 + k)) by TARSKI:def 1;
        then
A4:     s1.a = s2.a by FUNCT_4:12;
          per cases;
          suppose
A5:         s1.a = 0.R;
            thus IC Exec(IncAddr(I,j),s1) + k
         = IC Exec(a=0_goto(j+i1),s1) + k by A3,Th70
        .= j+i1+k by A5,SCMRING2:18
        .= IC Exec(a=0_goto(j+i1+k),s2) by A4,A5,SCMRING2:18
        .= IC Exec(a=0_goto(j+k+i1),s2)
            .= IC Exec(IncAddr(I,j+k), s2) by A3,Th70;
          end;
          suppose
A6:         s1.a <> 0.R;
A7:         IncAddr(I,j) = a=0_goto(i1+j) by A3,Th70;
A8:         IncAddr(I,j+k) = a=0_goto(i1+(j+k)) by A3,Th70;
            dom (IC SCM R .--> (IC s1 + k)) = {IC SCM R} by FUNCOP_1:19;
            then IC SCM R in dom (IC SCM R .--> (IC s1 + k)) by TARSKI:def 1;
            then
A9:         IC s2 = (IC SCM R .--> (IC s1 + k)).IC SCM R by FUNCT_4:14
              .= (IC s1 + k) by FUNCOP_1:87;
            thus IC Exec(IncAddr(I,j),s1) + k
              = succ IC s1 + k by A7,A6,SCMRING2:18
             .= IC s1 + 1 + k
             .= succ IC s2 by A9
             .= IC Exec(IncAddr(I,j+k), s2) by A8,A6,A4,SCMRING2:18;
          end;
      end;
      suppose
        ex a,r st I = a:=r;
        hence thesis;
      end;
    end;
    let I be Instruction of SCM R;
    let s1, s2 be State of SCM R such that
A10: NPP s1 = NPP s2;
A11: IC s1 = IC s2 by A10,COMPOS_1:230;
A12: dom Exec(I,s1) = the carrier of SCM R by PARTFUN1:def 4;
    then
A13: dom Exec(I,s1) = dom Exec(I,s2) by PARTFUN1:def 4;
X1: Exec(I,s1)|(dom Exec(I,s1) \ NAT) = NPP Exec(I,s1) &
    Exec(I,s2)|(dom Exec(I,s2) \ NAT) = NPP Exec(I,s2) by COMPOS_1:232;
    per cases by SCMRING2:8;
    suppose I = [0,{},{}];
      then I = halt SCM R by SCMRING2:30;
      hence thesis by A10,AMISTD_2:def 20;
    end;
    suppose
      ex a,b st I = a:=b;
      then consider a, b such that
A14:  I = a:=b;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A15:    x in dom Exec(I,s1) \ NAT;
        then
A16:    not x in NAT by XBOOLE_0:def 5;
        per cases by A12,A15,A16,Th5;
        suppose
A17:      x = IC SCM R;
          hence Exec(I,s1).x = succ IC s1 by A14,SCMRING2:13
            .= Exec(I,s2).x by A11,A14,A17,SCMRING2:13;
        end;
        suppose
A18:      x = a;
          hence Exec(I,s1).x = s1.b by A14,SCMRING2:13
            .= s2.b by A10,Th7
            .= Exec(I,s2).x by A14,A18,SCMRING2:13;
        end;
        suppose that
A19:      x is Data-Location of R and
A20:      x <> a;
          thus Exec(I,s1).x = s1.x by A14,A19,A20,SCMRING2:13
            .= s2.x by A10,A19,Th7
            .= Exec(I,s2).x by A14,A19,A20,SCMRING2:13;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
    suppose
      ex a,b st I = AddTo(a,b);
      then consider a, b such that
A21:  I = AddTo(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A22:    x in dom Exec(I,s1) \ NAT;
        then
A23:    not x in NAT by XBOOLE_0:def 5;
        per cases by A12,A22,A23,Th5;
        suppose
A24:      x = IC SCM R;
          hence Exec(I,s1).x = succ IC s1 by A21,SCMRING2:14
            .= Exec(I,s2).x by A11,A21,A24,SCMRING2:14;
        end;
        suppose
A25:      x = a;
          hence Exec(I,s1).x = s1.a + s1.b by A21,SCMRING2:14
            .= s1.a + s2.b by A10,Th7
            .= s2.a + s2.b by A10,Th7
            .= Exec(I,s2).x by A21,A25,SCMRING2:14;
        end;
        suppose that
A26:      x is Data-Location of R and
A27:      x <> a;
          thus Exec(I,s1).x = s1.x by A21,A26,A27,SCMRING2:14
            .= s2.x by A10,A26,Th7
            .= Exec(I,s2).x by A21,A26,A27,SCMRING2:14;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
    suppose
      ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A28:  I = SubFrom(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A29:    x in dom Exec(I,s1) \ NAT;
        then
A30:    not x in NAT by XBOOLE_0:def 5;
        per cases by A12,A29,A30,Th5;
        suppose
A31:      x = IC SCM R;
          hence Exec(I,s1).x = succ IC s1 by A28,SCMRING2:15
            .= Exec(I,s2).x by A11,A28,A31,SCMRING2:15;
        end;
        suppose
A32:      x = a;
          hence Exec(I,s1).x = s1.a - s1.b by A28,SCMRING2:15
            .= s1.a - s2.b by A10,Th7
            .= s2.a - s2.b by A10,Th7
            .= Exec(I,s2).x by A28,A32,SCMRING2:15;
        end;
        suppose that
A33:      x is Data-Location of R and
A34:      x <> a;
          thus Exec(I,s1).x = s1.x by A28,A33,A34,SCMRING2:15
            .= s2.x by A10,A33,Th7
            .= Exec(I,s2).x by A28,A33,A34,SCMRING2:15;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
    suppose
      ex a,b st I = MultBy(a,b);
      then consider a, b such that
A35:  I = MultBy(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A36:    x in dom Exec(I,s1) \ NAT;
        then
A37:    not x in NAT by XBOOLE_0:def 5;
        per cases by A12,A36,A37,Th5;
        suppose
A38:      x = IC SCM R;
          hence Exec(I,s1).x = succ IC s1 by A35,SCMRING2:16
            .= Exec(I,s2).x by A11,A35,A38,SCMRING2:16;
        end;
        suppose
A39:      x = a;
          hence Exec(I,s1).x = s1.a * s1.b by A35,SCMRING2:16
            .= s1.a * s2.b by A10,Th7
            .= s2.a * s2.b by A10,Th7
            .= Exec(I,s2).x by A35,A39,SCMRING2:16;
        end;
        suppose that
A40:      x is Data-Location of R and
A41:      x <> a;
          thus Exec(I,s1).x = s1.x by A35,A40,A41,SCMRING2:16
            .= s2.x by A10,A40,Th7
            .= Exec(I,s2).x by A35,A40,A41,SCMRING2:16;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
    suppose
      ex i1 st I = goto(i1,R);
      then consider i1 such that
A42:  I = goto(i1,R);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A43:    x in dom Exec(I,s1) \ NAT;
        then
A44:    not x in NAT by XBOOLE_0:def 5;
        per cases by A12,A43,A44,Th5;
        suppose
A45:      x = IC SCM R;
          hence Exec(I,s1).x = i1 by A42,SCMRING2:17
            .= Exec(I,s2).x by A42,A45,SCMRING2:17;
        end;
        suppose
A46:      x is Data-Location of R;
          hence Exec(I,s1).x = s1.x by A42,SCMRING2:17
            .= s2.x by A10,A46,Th7
            .= Exec(I,s2).x by A42,A46,SCMRING2:17;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
    suppose
      ex a,i1 st I = a=0_goto i1;
      then consider a, i1 such that
A47:  I = a=0_goto i1;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A48:    x in dom Exec(I,s1) \ NAT;
        then
A49:    not x in NAT by XBOOLE_0:def 5;
A50:    s1.a = s2.a by A10,Th7;
        per cases by A12,A48,A49,Th5;
        suppose that
A51:      x = IC SCM R & s1.a = 0.R;
          thus Exec(I,s1).x = i1 by A47,A51,SCMRING2:18
            .= Exec(I,s2).x by A47,A50,A51,SCMRING2:18;
        end;
        suppose that
A52:      x = IC SCM R & s1.a <> 0.R;
          thus Exec(I,s1).x = succ IC s1 by A47,A52,SCMRING2:18
            .= Exec(I,s2).x by A11,A47,A50,A52,SCMRING2:18;
        end;
        suppose
A53:      x is Data-Location of R;
          hence Exec(I,s1).x = s1.x by A47,SCMRING2:18
            .= s2.x by A10,A53,Th7
            .= Exec(I,s2).x by A47,A53,SCMRING2:18;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
    suppose
      ex a,r st I = a:=r;
      then consider a, r such that
A54:  I = a:=r;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A55:    x in dom Exec(I,s1) \ NAT;
        then
A56:    not x in NAT by XBOOLE_0:def 5;
        per cases by A12,A55,A56,Th5;
        suppose
A57:      x = IC SCM R;
          hence Exec(I,s1).x = succ IC s1 by A54,SCMRING2:19
            .= Exec(I,s2).x by A11,A54,A57,SCMRING2:19;
        end;
        suppose
A58:      x = a;
          hence Exec(I,s1).x = r by A54,SCMRING2:19
            .= Exec(I,s2).x by A54,A58,SCMRING2:19;
        end;
        suppose that
A59:      x is Data-Location of R and
A60:      x <> a;
          thus Exec(I,s1).x = s1.x by A54,A59,A60,SCMRING2:19
            .= s2.x by A10,A59,Th7
            .= Exec(I,s2).x by A54,A59,A60,SCMRING2:19;
        end;
      end;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by X1,A13,FUNCT_1:165;
    end;
  end;
end;

theorem
  InsCode I <= 7
proof
  set T = InsCode I;
  T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7 by Lm2;
  hence thesis;
end;

