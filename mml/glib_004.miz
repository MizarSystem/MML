:: Proof of Dijkstra's Shortest Path Algorithm & Prim's Minimum Spanning 
:: Tree Algorithm
::  by Gilbert Lee and Piotr Rudnicki
:: 
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies ALGSEQ_1, AMI_1, ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSEQ_2, FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003, GLIB_004, GRAPH_1, MATRIX_2, MSAFREE2,
      NEWTON, PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, QUANTAL1, REALSET1,
      RELAT_1, RELAT_2, RLVECT_1, SQUARE_1, TARSKI, TREES_1, UPROOTS;
 notations TARSKI, XBOOLE_0, ZFMISC_1, ENUMSET1, NUMBERS, SUBSET_1, XCMPLX_0,
      XREAL_0, DOMAIN_1, REAL_1, RELAT_1, PARTFUN1, FUNCT_1, FINSEQ_1,
      FINSEQ_2, SEQ_1, CARD_1, PBOOLE, CARD_FIL, FUNCT_2, RVSUM_1, ORDINAL1,
      SQUARE_1, POLYNOM1, UPROOTS, FINSET_1, NAT_1, CQC_LANG, FUNCT_4,
      GLIB_000, GLIB_001, GLIB_002, ABIAN, GLIB_003;
 constructors SQUARE_1, DOMAIN_1, CARD_FIL, REAL_1, AMISTD_2, PSCOMP_1,
      UPROOTS, BINOP_2, GLIB_002, GLIB_003;
 registrations SUBSET_1, RELSET_1, FINSET_1, XREAL_0, CARD_1, INT_1, ABIAN,
      FUNCT_1, XBOOLE_0, RELAT_1, MEMBERED, ORDINAL2, POLYNOM1, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI;
 theorems AXIOMS, BAGORDER, CARD_1, CARD_2, CQC_LANG, ENUMSET1, FINSEQ_1,
      FINSEQ_2, FINSEQ_3, FINSET_1, FRAENKEL, FUNCOP_1, FUNCT_1, FUNCT_2,
      FUNCT_4, GLIB_000, GLIB_001, GLIB_002, GLIB_003, HEYTING3, INT_1,
      JORDAN12, NAT_1, PARTFUN1, PBOOLE, POLYNOM1, REAL_1, RELAT_1, RLSUB_2,
      RVSUM_1, SCMPDS_9, SEQ_1, SQUARE_1, TARSKI, TREES_1, UPROOTS, XBOOLE_0,
      XBOOLE_1, XCMPLX_1, XREAL_0, YELLOW14, ZFMISC_1;
 schemes NAT_1, SUBSET_1, RECDEF_1, GRAPH_5, CQC_SIM1;

begin :: Preliminaries on Sum of RBag

theorem tSUPPORT01: ::tSUPPORT01
  for f, g being Function holds
    support (f +* g) c= support f \/ support g
proof
    let f, g be Function;
    let a be set;
    assume a in support (f +* g); then
A1: (f +* g).a <> 0 by POLYNOM1:def 7;
    assume not a in support f \/ support g; then
    not a in support f & not a in support g by XBOOLE_0:def 2; then
A2: f.a = 0 & g.a = 0 by POLYNOM1:def 7;
    a in dom g or not a in dom g;
    hence contradiction by A1, A2, FUNCT_4:12,14;
end;
   
theorem tSUPPORT02: ::tSUPPORT02
  for f being Function, x, y being set holds
    support (f +* (x.-->y)) c= support f \/ {x}
proof
    let f be Function, x, y be set;
    let a be set;
    assume a in support (f +* (x.-->y)); then
A1: (f +* (x.-->y)).a <> 0 by POLYNOM1:def 7;
    per cases;
    suppose a = x; then a in {x} by TARSKI:def 1;
        hence a in support f \/ {x} by XBOOLE_0:def 2; end;
    suppose a <> x; then
        (f +* (x.-->y)).a  = f.a by SCMPDS_9:6; then
        a in support f by A1, POLYNOM1:def 7;
        hence a in support f \/ {x} by XBOOLE_0:def 2; end;
end;
   
theorem tRBAGSUM01: ::tRBAGSUM01
  for A,B being set, b being Rbag of A,
      b1 being Rbag of B, b2 being Rbag of A\B
   st b = b1 +* b2 holds Sum b = Sum b1 + Sum b2
proof
   let A, B be set, b be Rbag of A,
          b1 be Rbag of B, b2 be Rbag of A\B such that
A: b = b1 +* b2;
   set B1 = (EmptyBag A) +* b1;
   set B2 = (EmptyBag A) +* b2;
C1: rng B1 c= rng (EmptyBag A) \/ rng b1 by FUNCT_4:18;
C2: rng b1 c= REAL by SEQ_1:def 1;
C3: rng (EmptyBag A) c= REAL by SEQ_1:def 1;
    rng (EmptyBag A) \/ rng b1 c= REAL by C2, C3, XBOOLE_1:8; then
C0: rng B1 c= REAL by C1, XBOOLE_1:1;
D1: support B1 c= (support EmptyBag A) \/ support b1 by tSUPPORT01;
D0: support B1 is finite by D1, FINSET_1:13;
   dom b = dom b1 \/ dom b2 by A, FUNCT_4:def 1; then
   dom b1 c= dom b by XBOOLE_1:7; then
   B c= dom b by PBOOLE:def 3; then
E: B c= A by PBOOLE:def 3;
   dom B1 = (dom EmptyBag A) \/ dom b1 by FUNCT_4:def 1
        .= A \/ dom b1 by PBOOLE:def 3
        .= A \/ B by PBOOLE:def 3
        .= A by E, XBOOLE_1:12; then
   reconsider B1 as Rbag of A by C0,SEQ_1:def 1,D0,POLYNOM1:def 8,PBOOLE:def 3;
C1: rng B2 c= rng (EmptyBag A) \/ rng b2 by FUNCT_4:18;
C2: rng b2 c= REAL by SEQ_1:def 1;
C3: rng (EmptyBag A) c= REAL by SEQ_1:def 1;
    rng (EmptyBag A) \/ rng b2 c= REAL by C2, C3, XBOOLE_1:8; then
C0: rng B2 c= REAL by C1, XBOOLE_1:1;
D1: support B2 c= (support EmptyBag A) \/ support b2 by tSUPPORT01;
D0: support B2 is finite by D1, FINSET_1:13;
   dom B2 = (dom EmptyBag A) \/ dom b2 by FUNCT_4:def 1
        .= A \/ dom b2 by PBOOLE:def 3
        .= A \/ (A\B) by PBOOLE:def 3
        .= A by XBOOLE_1:12; then
   reconsider B2 as Rbag of A by C0,D0,SEQ_1:def 1,PBOOLE:def 3,POLYNOM1:def 8;
   consider f1 being FinSequence of REAL such that
B: Sum b1 = Sum f1 and
C: f1 = b1*canFS(support b1) by UPROOTS:def 3;
   consider F1 being FinSequence of REAL such that
D: Sum B1 = Sum F1 and
E: F1 = B1*canFS(support B1) by UPROOTS:def 3;
G: rng canFS(support b1) = support b1 by UPROOTS:5;
Ga: support b1 c= dom b1 by POLYNOM1:41; then
H: dom f1 = dom canFS(support b1) by C, G, RELAT_1:46;
I: rng canFS(support B1) = support B1 by UPROOTS:5;
   support B1 c= dom B1 by POLYNOM1:41; then
J: dom F1 = dom canFS(support B1) by E, I, RELAT_1:46;
L: now let x be set;
     hereby assume
     A1: x in support b1; then
     B1: b1.x <> 0 by POLYNOM1:def 7;
         support b1 c= dom b1 by POLYNOM1:41; then
         B1.x = b1.x by FUNCT_4:14,A1;
      hence x in support B1 by B1, POLYNOM1:def 7;
     end;
     assume B0: x in support B1; then
     B1: B1.x <> 0 by POLYNOM1:def 7;
         per cases;
         suppose not x in dom b1; then
            B1.x = (EmptyBag A).x by FUNCT_4:12 .= 0 by POLYNOM1:56;
           hence x in support b1 by B0,POLYNOM1:def 7;
         end;
         suppose x in dom b1; then
            B1.x = b1.x by FUNCT_4:14;
           hence x in support b1 by B1, POLYNOM1:def 7;
         end;
   end; then
K: support b1 = support B1 by TARSKI:2; 
F: dom f1 = dom F1 by H, J,L,TARSKI:2;
   now let k be Nat such that
   A1: k in dom f1;
   B0: (canFS(support b1)).k in rng canFS(support b1) by A1, H, FUNCT_1:12;
    thus f1.k = b1.((canFS(support b1)).k) by C, A1, H, FUNCT_1:23
             .= B1.((canFS(support b1)).k) by B0,Ga,G,FUNCT_4:14
             .= F1.k by A1,H,K,E,FUNCT_1:23;
   end; then
SB1: Sum B1 = Sum b1 by B, D, F,FINSEQ_1:17;
   consider f2 being FinSequence of REAL such that
B: Sum b2 = Sum f2 and
C: f2 = b2*canFS(support b2) by UPROOTS:def 3;
   consider F2 being FinSequence of REAL such that
D: Sum B2 = Sum F2 and
E: F2 = B2*canFS(support B2) by UPROOTS:def 3;
G: rng canFS(support b2) = support b2 by UPROOTS:5;
Ga: support b2 c= dom b2 by POLYNOM1:41; then
H: dom f2 = dom canFS(support b2) by C, G, RELAT_1:46;
I: rng canFS(support B2) = support B2 by UPROOTS:5;
   support B2 c= dom B2 by POLYNOM1:41; then
J: dom F2 = dom canFS(support B2) by E, I, RELAT_1:46;
   now let x be set;
     hereby assume
     A1: x in support b2; then
     B1: b2.x <> 0 by POLYNOM1:def 7;
         support b2 c= dom b2 by POLYNOM1:41; then
         B2.x = b2.x by FUNCT_4:14,A1;
      hence x in support B2 by B1, POLYNOM1:def 7;
     end;
     assume
     B0: x in support B2; then
     B1: B2.x <> 0 by POLYNOM1:def 7;
         per cases;
         suppose not x in dom b2; then
            B2.x = (EmptyBag A).x by FUNCT_4:12 .= 0 by POLYNOM1:56;
           hence x in support b2 by B0,POLYNOM1:def 7;
         end;
         suppose x in dom b2; then
            B2.x = b2.x by FUNCT_4:14;
           hence x in support b2 by B1, POLYNOM1:def 7;
         end;
   end; then
K: support b2 = support B2 by TARSKI:2;
   now let k be Nat such that
   A1: k in dom f2;
   B0: (canFS(support b2)).k in rng canFS(support b2) by A1, H, FUNCT_1:12;
    thus f2.k = b2.((canFS(support b2)).k) by C, A1, H, FUNCT_1:23
             .= B2.((canFS(support b2)).k) by B0,Ga,G,FUNCT_4:14
             .= F2.k by A1,H,K,E,FUNCT_1:23;
   end; then
SB2: Sum B2 = Sum b2 by B, D,K,H,J,FINSEQ_1:17;
   now let x be set; assume
   A1: x in A;
   B2: dom b1 = B by PBOOLE:def 3;
   F2: dom b2 = A\B by PBOOLE:def 3; 
    per cases;
    suppose S1: x in B;
    A2: not x in dom b2 by F2, S1, XBOOLE_0:def 4;
    D2: B1.x = b1.x by S1, B2, FUNCT_4:14;
    E2: B2.x = (EmptyBag A).x by A2, FUNCT_4:12 .= 0 by POLYNOM1:56;
     thus b.x =  B1.x + B2.x by E2, D2, A, A2, FUNCT_4:12
             .= (B1 + B2).x by POLYNOM1:def 5;
    end;
    suppose S1: not x in B;
    C2: B1.x = (EmptyBag A).x by S1, B2, FUNCT_4:12 .= 0 by POLYNOM1:56;
    E2: x in dom b2 by F2, A1, S1, XBOOLE_0:def 4; then
    D2: B2.x = b2.x by FUNCT_4:14;
    thus b.x = B1.x + B2.x by D2, C2, A, E2, FUNCT_4:14
             .= (B1 + B2).x by POLYNOM1:def 5;
    end;
   end; then
   b = B1 + B2 by PBOOLE:3;
   hence Sum b = Sum b1 + Sum b2 by SB1, SB2, UPROOTS:17;
end;

theorem tRBAGSUM02: ::tRBAGSUM02
  for X,x being set, b being Rbag of X
   st dom b = {x} holds Sum b = b.x
proof
    let X,x be set, b be Rbag of X; assume
A0: dom b = {x};
A1: support b c= {x} by A0, POLYNOM1:41;
    {x} c= X by A0,PBOOLE:def 3; then
    consider f being FinSequence of REAL such that
A2: f = b*canFS({x}) & Sum b = Sum f by A1,UPROOTS:16;
A3: f = b*<*x*> by A2, UPROOTS:6;
    x in dom b by A0,TARSKI:def 1; then
    f = <*b.x*> by A3, BAGORDER:3;
    hence Sum b = b.x by A2,RVSUM_1:103;
end;

theorem tRBAGSUM03: ::tRBAGSUM03
  for A being set, b1,b2 being Rbag of A
   st (for x being set st x in A holds b1.x <= b2.x) holds
   Sum b1 <= Sum b2
proof
   let A be set, b1,b2 be Rbag of A such that
A: for x being set st x in A holds b1.x <= b2.x;
   set S = support b1 \/ support b2;
Aa: dom b1 = A & dom b2 = A by PBOOLE:def 3; then
   support b1 c= A & support b2 c= A by POLYNOM1:41; then
   reconsider S as finite Subset of A by XBOOLE_1:8;
   support b1 c= S by XBOOLE_1:7; then
   consider f1 being FinSequence of REAL such that
B: f1 = b1*canFS(S) and
C: Sum b1 = Sum f1 by UPROOTS:16;   
   support b2 c= S by XBOOLE_1:7; then
   consider f2 being FinSequence of REAL such that
D: f2 = b2*canFS(S) and
E: Sum b2 = Sum f2 by UPROOTS:16;
Fb: rng canFS(S) = S by UPROOTS:5; then
Fa: dom f1 = dom canFS(S) & dom f2 = dom canFS(S) by Aa, B, D, RELAT_1:46; then
F: len f1 = len f2 by FINSEQ_3:31;
G: f1 is Element of (len f1)-tuples_on REAL by FINSEQ_2:110;
H: f2 is Element of (len f2)-tuples_on REAL by FINSEQ_2:110;
   now let j be Nat; assume j in Seg len f1; then
   B1: j in dom f1 by FINSEQ_1:def 3; then
   C1: f1.j = b1.((canFS(S)).j) & f2.j = b2.((canFS(S)).j)
               by B,D,Fa,FUNCT_1:23;
       (canFS(S)).j in S by Fb, Fa, B1, FUNCT_1:12; 
     hence f1.j <= f2.j by A, C1;
   end; 
   hence Sum b1 <= Sum b2 by C, E,F, G, H, RVSUM_1:112;
end; 

theorem ::tRBAGSUM04
  for A being set, b1,b2 being Rbag of A
   st (for x being set st x in A holds b1.x = b2.x)
   holds Sum b1 = Sum b2
proof
   let A be set, b1,b2 be Rbag of A; assume
A1: for x being set st x in A holds b1.x = b2.x; then
    for x being set st x in A holds b1.x <= b2.x; then
A2: Sum b1 <= Sum b2 by tRBAGSUM03;
    for x being set st x in A holds b2.x <= b1.x by A1; then
    Sum b2 <= Sum b1 by tRBAGSUM03;
    hence thesis by A2,AXIOMS:21;
end;

theorem ::tRBAGSUM05
  for A1,A2 being set, b1 being Rbag of A1, b2 being Rbag of A2
   st b1 = b2 holds Sum b1 = Sum b2
proof
    let A1,A2 be set, b1 be Rbag of A1, b2 be Rbag of A2; assume
A1: b1 = b2;
    consider f1 being FinSequence of REAL such that
A2: Sum b1 = Sum f1 & f1 = b2*canFS(support b2) by A1,UPROOTS:def 3;
    consider f2 being FinSequence of REAL such that
A3: Sum b2 = Sum f2 & f2 = b2*canFS(support b2) by UPROOTS:def 3;
    thus Sum b1 = Sum b2 by A2,A3;
end;

theorem tRBAGSUM06: ::tRBAGSUM06
  for X, x being set, b being Rbag of X, y being real number
   st b = (EmptyBag X) +* (x.-->y) holds Sum b = y
proof
   let X, x be set, b be Rbag of X, y be real number such that
B: b = (EmptyBag X) +* (x.-->y);
Ac: dom (x.-->y) = {x} by CQC_LANG:5;
    dom b = dom EmptyBag X \/ dom (x.-->y) by B, FUNCT_4:def 1; then
Aa: {x} c= dom b by Ac, XBOOLE_1:7; then
    {x} c= X by PBOOLE:def 3; then
A: x in X by ZFMISC_1:37;
   reconsider S = {x} as finite Subset of X by Aa,PBOOLE:def 3;
C: support b c= S proof let a be set; assume a in support b; then
   A1: b.a <> 0 by POLYNOM1:def 7;
    assume not a in S; then a <> x by TARSKI:def 1; then
      b.a = (EmptyBag X).a by B, SCMPDS_9:6;
    hence contradiction by A1, POLYNOM1:56;
   end;
   consider f being FinSequence of REAL such that
D: f = b*canFS(S) and
E: Sum b = Sum f by C, UPROOTS:16;
F: canFS(S) = <*x*> by UPROOTS:6;
   x in dom b by A, PBOOLE:def 3; then
   f = <*b.x*> by D, F, BAGORDER:3;
 hence Sum b = b.x by E, RVSUM_1:103
            .= y by B, YELLOW14:3;
end;

theorem ::tRBAGSUM07
  for X, x being set, b1, b2 being Rbag of X, y being real number
   st b2 = b1 +* (x.-->y) holds Sum b2 = Sum b1 + y - b1.x
proof
   let X, x be set, b1, b2 be Rbag of X, y be real number such that
B: b2 = b1 +* (x.-->y);
Ac: dom (x.-->y) = {x} by CQC_LANG:5;
    dom b2 = dom b1 \/ dom (x.-->y) by B, FUNCT_4:def 1; then
    {x} c= dom b2 by Ac, XBOOLE_1:7; then
    {x} c= X by PBOOLE:def 3; then
A: x in X by ZFMISC_1:37; 
   set a = b1 +* (x.-->0);
C1: rng a c= rng b1 \/ rng (x.-->0) by FUNCT_4:18;
C2: rng (x.-->0) = {0} by CQC_LANG:5;
C3: rng b1 c= REAL by SEQ_1:def 1;
    {0} c= REAL by ZFMISC_1:37; then
    rng b1 \/ rng (x.-->0) c= REAL by C2, C3, XBOOLE_1:8; then
C0: rng a c= REAL by C1, XBOOLE_1:1;
D1: support a c= support b1 \/ {x} by tSUPPORT02;
D0: support a is finite by D1, FINSET_1:13;
   dom a = dom b1 \/ dom (x.-->0) by FUNCT_4:def 1
        .= X \/ dom (x.-->0) by PBOOLE:def 3
        .= X \/ {x} by CQC_LANG:5
        .= X by A, ZFMISC_1:46; then
   reconsider a as Rbag of X by SEQ_1:def 1,C0,D0,POLYNOM1:def 8,PBOOLE:def 3;
    set b = (EmptyBag X) +* (x .--> b1.x);
C1: rng b c= rng (EmptyBag X) \/ rng (x.-->b1.x) by FUNCT_4:18;
C2: rng (x.-->b1.x) = {b1.x} by CQC_LANG:5;
C3: rng (EmptyBag X) c= REAL by SEQ_1:def 1;
    rng (EmptyBag X) \/ rng (x.-->b1.x) c= REAL by C2, C3, XBOOLE_1:8; then
C0: rng b c= REAL by C1, XBOOLE_1:1;
D1: support b c= (support EmptyBag X) \/ {x} by tSUPPORT02;
D0: support b is finite by D1, FINSET_1:13;
   dom b = (dom EmptyBag X) \/ dom (x.-->b1.x) by FUNCT_4:def 1
        .= X \/ dom (x.-->b1.x) by PBOOLE:def 3
        .= X \/ {x} by CQC_LANG:5
        .= X by A, ZFMISC_1:46; then
   reconsider b as Rbag of X by C0,SEQ_1:def 1,D0,POLYNOM1:def 8,PBOOLE:def 3;
   set c = (EmptyBag X) +* (x.-->y);
C1: rng c c= rng (EmptyBag X) \/ rng (x.-->y) by FUNCT_4:18;
C2: rng (x.-->y) = {y} by CQC_LANG:5;
C3: rng (EmptyBag X) c= REAL by SEQ_1:def 1;
    y in REAL by XREAL_0:def 1; then
   {y} c= REAL by ZFMISC_1:37; then
    rng (EmptyBag X) \/ rng (x.-->y) c= REAL by C2, C3, XBOOLE_1:8; then
C0: rng c c= REAL by C1, XBOOLE_1:1;
D1: support c c= (support EmptyBag X) \/ {x} by tSUPPORT02;
D0: support c is finite by D1, FINSET_1:13;
   dom c = (dom EmptyBag X) \/ dom (x.-->y) by FUNCT_4:def 1
        .= X \/ dom (x.-->y) by PBOOLE:def 3
        .= X \/ {x} by CQC_LANG:5
        .= X by A, ZFMISC_1:46; then
   reconsider c as Rbag of X by SEQ_1:def 1,C0,D0,POLYNOM1:def 8,PBOOLE:def 3;
   now let i be set; assume i in X;
   B1: (EmptyBag X).i = 0 by POLYNOM1:56;   
    per cases;
    suppose S1: i = x;
     thus (a+b).i = a.i + b.i by POLYNOM1:def 5
                 .= 0 + b.i by S1, YELLOW14:3 .= b1.i by S1, YELLOW14:3;
    end;
    suppose S1: i <> x;
     thus (a+b).i = a.i + b.i by POLYNOM1:def 5 .= b1.i + b.i by S1, SCMPDS_9:6
       .= b1.i + 0 by S1, B1, SCMPDS_9:6        .= b1.i;
    end;
   end; then
   b1 = a+b by PBOOLE:3; then 
Y: Sum b1 - Sum b = Sum a + Sum b - Sum b by UPROOTS:17;
Z: Sum c = y by tRBAGSUM06;
X: Sum b = b1.x by tRBAGSUM06;
   now let i be set; assume i in X;
   B1: (EmptyBag X).i = 0 by POLYNOM1:56;
    per cases;
     suppose S1: i = x;
      thus b2.i = y by B, S1, YELLOW14:3      .= 0 + c.i by S1, YELLOW14:3
               .= a.i + c.i by S1, YELLOW14:3 .= (a+c).i by POLYNOM1:def 5;
     end;
     suppose S1: i <> x;
     A2: c.i = 0 by S1, B1, SCMPDS_9:6;
      thus b2.i = b1.i by B, S1, SCMPDS_9:6
               .= a.i + c.i by A2, S1, SCMPDS_9:6
               .= (a+c).i by POLYNOM1:def 5;
     end;
   end; then
   b2 = a+c by PBOOLE:3;
 hence Sum b2 = Sum b1 - Sum b + Sum c by Y, UPROOTS:17
             .= Sum b1 + y - b1.x by Z, X;
end;

begin :: Definitions for Dijkstra's Shortest Path Algorithm

definition let G1 be real-weighted WGraph, G2 be WSubgraph of G1, v be set;
  pred G2 is_mincost_DTree_rooted_at v means :dGMINCOSTDTREE:
    G2 is Tree-like &
    for x being Vertex of G2 holds
      ex W2 being DPath of G2 st W2 is_Walk_from v,x &
      for W1 being DPath of G1 st W1 is_Walk_from v,x holds
        W2.cost() <= W1.cost();
end;

definition let G be real-weighted WGraph, W be DPath of G, x,y be set;
  pred W is_mincost_DPath_from x,y means :dWMINCOSTD: ::dWMINCOSTD
     W is_Walk_from x,y & for W2 being DPath of G st
    W2 is_Walk_from x,y holds W.cost() <= W2.cost();
end;

definition let G be finite real-weighted WGraph, x,y be set;
  func G.min_DPath_cost(x,y) -> Real means :dWGMINDCOST: ::dWGMINDCOST
    ex W being DPath of G st W is_mincost_DPath_from x,y & it = W.cost() if
    ex W being DWalk of G st W is_Walk_from x,y otherwise it = 0;
  existence
  proof
    set X = {W where W is DPath of G: W is_Walk_from x,y};
    now let e be set; assume e in X; then consider
        W being DPath of G such that
    B1: e = W & W is_Walk_from x,y;
        e in {w where w is DPath of G: not contradiction} by B1;
        hence e in G.allDPaths() by GLIB_001:def 38;
    end; then reconsider X as finite Subset of G.allDPaths()
      by TARSKI:def 3,FINSET_1:13;
    hereby assume ex W being DWalk of G st W is_Walk_from x,y; then
        consider W being DWalk of G such that
    B1: W is_Walk_from x,y;
        consider P being DPath of W;
        P is_Walk_from x,y by B1, GLIB_001:161; then
        P in X; then reconsider X as non empty finite Subset of G.allDPaths();
        deffunc F(Element of X) = $1.cost();
        consider W1 being Element of X such that
    B3: for W2 being Element of X holds F(W1) <= F(W2) from GRAPH_5:sch 2;
        W1 in X; then consider WA being DPath of G such that
    B4: WA = W1 & WA is_Walk_from x,y;
    B5: now let WB be DPath of G; assume WB is_Walk_from x,y; then
            WB in X; then reconsider WB' = WB as Element of X;
            F(W1) <= F(WB') by B3;
            hence WA.cost() <= WB.cost() by B4;
        end;
        reconsider WA as DPath of G;
        set IT = WA.cost();
        take IT, WA;
        thus WA is_mincost_DPath_from x,y by B5,B4,dWMINCOSTD;
        thus IT = WA.cost();
    end;
    thus thesis;  
  end;
  uniqueness proof
    let IT1,IT2 be Real;
    hereby assume ex W being DWalk of G st W is_Walk_from x,y;
        given W1 being DPath of G such that
    B1: W1 is_mincost_DPath_from x,y & IT1 = W1.cost();
        given W2 being DPath of G such that
    B2: W2 is_mincost_DPath_from x,y & IT2 = W2.cost();
    B3: W1 is_Walk_from x,y & for W2 being DPath of G st
          W2 is_Walk_from x,y holds W1.cost() <= W2.cost() by B1,dWMINCOSTD;
    B4: W2 is_Walk_from x,y & for W1 being DPath of G st
          W1 is_Walk_from x,y holds W2.cost() <= W1.cost() by B2,dWMINCOSTD;
    B5: IT2 <= IT1 by B1,B2,B3,dWMINCOSTD;
        IT1 <= IT2 by B1,B2,dWMINCOSTD,B4;
        hence IT1 = IT2 by B5, AXIOMS:21; 
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be real-WEV WEVGraph; 
  func DIJK:NextBestEdges(G) -> Subset of the_Edges_of G means :dDIJKNEXT:
  for e1 being set holds e1 in it iff
    e1 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
    for e2 being set st
    e2 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G holds
        (the_VLabel_of G).((the_Source_of G).e1) + (the_Weight_of G).e1 <=
        (the_VLabel_of G).((the_Source_of G).e2) + (the_Weight_of G).e2;
  existence proof
    defpred P[set] means
    $1 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
    for e2 being set
     st e2 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
     holds (the_VLabel_of G).((the_Source_of G).$1)+(the_Weight_of G).$1 <=
           (the_VLabel_of G).((the_Source_of G).e2)+(the_Weight_of G).e2;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
      from SUBSET_1:sch 1;
    take IT;
    now let e1 be set;
        thus e1 in IT implies P[e1] by A1;
        assume
    B1: P[e1]; then
        e1 in the_Edges_of G by GLIB_000:def 18;
        hence e1 in IT by A1,B1;
    end;
    hence thesis;
  end;
  uniqueness proof
    defpred P[set] means
    $1 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
    for e2 being set
     st e2 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
     holds (the_VLabel_of G).((the_Source_of G).$1)+(the_Weight_of G).$1 <=
           (the_VLabel_of G).((the_Source_of G).e2)+(the_Weight_of G).e2;
    let IT1,IT2 be Subset of the_Edges_of G such that
A1: for y being set holds y in IT1 iff P[y] and
A2: for y being set holds y in IT2 iff P[y];
    now let x be set;
        hereby assume x in IT1; then
            P[x] by A1;
            hence x in IT2 by A2;
        end;
        assume x in IT2; then
        P[x] by A2;
        hence x in IT1 by A1;
    end;
    hence IT1 = IT2 by TARSKI:2;  
  end;
end;

definition let G be real-WEV WEVGraph;
  set e = choose DIJK:NextBestEdges(G);  
  func DIJK:Step(G) -> real-WEV WEVGraph equals :dDIJKSTEP: ::dDIJKSTEP
    G if DIJK:NextBestEdges(G) = {} otherwise
    G.labelEdge(e,1).labelVertex((the_Target_of G).e,
        (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e);
  coherence;
  consistency;
end;

registration let G be finite real-WEV WEVGraph;
  cluster DIJK:Step(G) -> finite;
  coherence proof
    set e = choose DIJK:NextBestEdges(G);  
    now per cases;
    suppose DIJK:NextBestEdges(G) = {};
        hence DIJK:Step(G) is finite by dDIJKSTEP; end;
    suppose DIJK:NextBestEdges(G) <> {}; then
        DIJK:Step(G) = G.labelEdge(e,1).labelVertex((the_Target_of G).e,
        (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e)
          by dDIJKSTEP;
        hence DIJK:Step(G) is finite; end;
    end;
    hence thesis;
  end;
end;

registration let G be nonnegative-weighted real-WEV WEVGraph;
  cluster DIJK:Step(G) -> nonnegative-weighted;
  coherence proof
    set e = choose DIJK:NextBestEdges(G);  
    now per cases;
    suppose DIJK:NextBestEdges(G) = {};
        hence thesis by dDIJKSTEP; end;
    suppose DIJK:NextBestEdges(G) <> {}; then
        DIJK:Step(G) = G.labelEdge(e,1).labelVertex((the_Target_of G).e,
        (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e)
          by dDIJKSTEP;
        hence thesis; end;
    end;
    hence thesis;
  end;
end;  

definition let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:Init(G, src) -> real-WEV WEVGraph equals :dDIJKINIT: ::dDIJKINIT:
    G.set(ELabelSelector,{}).set(VLabelSelector,src.-->0);
   coherence proof
    set G2 = G.set(ELabelSelector, {});
    G2 == G by GLIB_003:8; then
    reconsider src'=src as Vertex of G2 by GLIB_000:def 36;
    G2.set(VLabelSelector,(src'.-->0)) is real-WEV WEVGraph;
    hence thesis;
   end;
end;

definition let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:CompSeq(G,src) -> real-WEV WEVGraphSeq means :dDIJKCS: ::dDIJKCS
    it.->0 = DIJK:Init(G,src) &
    for n being Nat holds it.->(n+1) = DIJK:Step(it.->n);
  existence proof
    defpred P[set,set,set] means
      ($2 is real-WEV WEVGraph &
          ex Gn,Gn1 being real-WEV WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = DIJK:Step(Gn)) or
      (not $2 is real-WEV WEVGraph & $2 = $3);
    now let n,x be set;
        now per cases;
        suppose x is real-WEV WEVGraph;  then
            reconsider Gn=x as real-WEV WEVGraph;
            P[n,x,DIJK:Step(Gn)];
            hence ex y being set st P[n,x,y]; end;
        suppose not x is real-WEV WEVGraph;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A1: for n being Nat for x being set ex y being set st P[n,x,y];
A2: for n being Nat for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT &
    IT.0 = DIJK:Init(G,src) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3, PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is real-WEV WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat; assume P2[n]; then
        consider Gn,Gn1 being real-WEV WEVGraph such that
    B2: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = DIJK:Step(Gn) by A3;
        thus P2[n+1] by B2;
    end;
A6: for n being Nat holds P2[n] from NAT_1:sch 1(A4,A5); then
    for n being Nat holds IT.n is _Graph; then
    reconsider IT as GraphSeq by GLIB_000:def 55;
A7: now let n be Nat;
        IT.->n = IT.n by GLIB_000:def 59;
        hence IT.->n is real-WEV WEVGraph by A6;
    end; then
    for n being Nat holds
      IT.->n is [Weighted] & IT.->n is [ELabeled] & IT.->n is [VLabeled]; then
    reconsider IT as WEVGraphSeq
      by GLIB_003:def 24, GLIB_003:def 25, GLIB_003:def 26;
    for n being Nat holds IT.->n is real-WEV by A7; then
    reconsider IT as real-WEV WEVGraphSeq by GLIB_003:def 31;
    take IT;
    thus IT.->0 = DIJK:Init(G,src) by A3,GLIB_000:def 59;
    let n be Nat;
    IT.n is real-WEV WEVGraph by A6; then
    consider Gn,Gn1 being real-WEV WEVGraph such that
A8: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = DIJK:Step(Gn) by A3;
    Gn = IT.->n & Gn1 = IT.->(n+1) by A8, GLIB_000:def 59;
    hence IT.->(n+1) = DIJK:Step(IT.->n) by A8;
  end;
  uniqueness proof
    let IT1,IT2 be real-WEV WEVGraphSeq such that
A1: IT1.->0 = DIJK:Init(G,src) &
    for n being Nat holds IT1.->(n+1) = DIJK:Step(IT1.->n) and
A2: IT2.->0 = DIJK:Init(G,src) &
    for n being Nat holds IT2.->(n+1) = DIJK:Step(IT2.->n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
    IT1.0 = IT2.->0 by A1,A2,GLIB_000:def 59; then
A3: P[0] by GLIB_000:def 59;
    now let n be Nat; assume P[n]; then
        IT1.n = IT2.->n by GLIB_000:def 59; then
    B2: IT1.->n = IT2.-> n by GLIB_000:def 59;
        IT1.->(n+1) = DIJK:Step(IT2.->n) by B2, A1
                   .= IT2.->(n+1) by A2; then
        IT1.(n+1) = IT2.->(n+1) by GLIB_000:def 59;
        hence P[n+1] by GLIB_000:def 59;
    end; then
A4: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A3,A4); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(G,src) -> finite;
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Nat] means DCS.->$1 is finite;
    DCS.->0 = DIJK:Init(G,src) by dDIJKCS
           .= G.set(ELabelSelector,{})
               .set(VLabelSelector,((src.-->0))) by dDIJKINIT;then
A1: P[0];           
A2: now let n be Nat; assume P[n]; then
        reconsider Gn = DCS.->n as finite real-WEV WEVGraph;
        DCS.->(n+1) = DIJK:Step(Gn) by dDIJKCS;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by GLIB_000:def 60;
  end;
end;

registration let G be nonnegative-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(G,src) -> nonnegative-weighted;
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Nat] means DCS.->$1 is nonnegative-weighted;
    DCS.->0 = DIJK:Init(G,src) by dDIJKCS
           .= G.set(ELabelSelector,{})
               .set(VLabelSelector,(src.-->0)) by dDIJKINIT;then
A1: P[0];           
A2: now let n be Nat; assume P[n]; then
        reconsider Gn = DCS.->n as nonnegative-weighted real-WEV WEVGraph;
        DCS.->(n+1) = DIJK:Step(Gn) by dDIJKCS;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by GLIB_003:def 28;
  end;
end;

definition let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:SSSP(G,src) -> real-WEV WEVGraph equals :dDIJKSSSP: ::dDIJKSSSP
    DIJK:CompSeq(G,src).Result();
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    DCS.Result() = DCS.(DCS.Lifespan()) by GLIB_000:def 58
                .= DCS.->(DCS.Lifespan()) by GLIB_000:def 59;
    hence thesis;
  end;
end;

registration let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:SSSP(G,src) -> finite;
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    DIJK:SSSP(G,src) = DCS.Result() by dDIJKSSSP
                    .= DCS.(DCS.Lifespan()) by GLIB_000:def 58
                    .= DCS.->(DCS.Lifespan()) by GLIB_000:def 59;
    hence thesis;              
  end;
end;

begin  :: Dijkstra's Algorithm Theorems

theorem tWGMINDCOST01: ::tWGMINDCOST01
  for G being finite nonnegative-weighted WGraph, W being DPath of G,
    x,y being set, m,n being Nat st W is_mincost_DPath_from x,y holds
   W.cut(m,n) is_mincost_DPath_from W.cut(m,n).first(),W.cut(m,n).last()
proof
    let G be finite nonnegative-weighted WGraph, W be DPath of G,
    x,y be set, m,n be Nat;
    assume
A1: W is_mincost_DPath_from x,y; then
A2: W is_Walk_from x,y & for W2 being DPath of G st W2 is_Walk_from x,y holds
      W.cost() <= W2.cost() by dWMINCOSTD;
    set WC = W.cut(m,n);
A3: WC is_Walk_from WC.first(),WC.last() by GLIB_001:def 23;
A4: W.1 = x & W.(len W) = y by A2, GLIB_001:18;
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W;
        set W1 = W.cut(1,m), W3 = W.cut(n,len W);
    B2: 1 is odd & 1 <= m & 1 <= n by B1, HEYTING3:1, JORDAN12:3; then
    B3: W1.append(WC) = W.cut(1,n) by B1, GLIB_001:39;
    B4: W.cut(1,n).append(W3) = W.cut(1,len W) by B1, B2, GLIB_001:39
                             .= W by GLIB_001:40;
        W.cut(1,n).last() = W.n by B1, B2, GLIB_001:38
                         .= W3.first() by B1, GLIB_001:38; then
    B6: W.cost() = W.cut(1,n).cost() + W3.cost() by B4, GLIB_003:31;
    B7: m <= len W by B1, AXIOMS:22; then
        W1.last() = W.m by B1,B2,GLIB_001:38
                 .= WC.first() by B1,GLIB_001:38; then
        W.cut(1,n).cost() = W1.cost() + WC.cost() by B3, GLIB_003:31; then
    B9: W.cost() = WC.cost() + (W1.cost() + W3.cost()) by B6;
    BA: W1 is_Walk_from W.1, W.m by B1, B2, B7, GLIB_001:38;
    BB: W3 is_Walk_from W.n, W.(len W) by B1, GLIB_001:38;
        now assume not WC is_mincost_DPath_from WC.first(),WC.last(); then
            consider W2 being DPath of G such that
        C1: W2 is_Walk_from WC.first(), WC.last() & W2.cost() < WC.cost()
              by A3, dWMINCOSTD;
        C2: WC.first() = W.m & WC.last() = W.n by B1,GLIB_001:38; then
        C4: W2.first() = W.m & W2.last() = W.n by C1,GLIB_001:def 23;
            set WA = W1.append(W2), WB = WA.append(W3);
            WA is_Walk_from W.1, W.n by BA,C1,C2,GLIB_001:32; then
        C5: WB is_Walk_from x,y by A4,BB,GLIB_001:32;
        C6: W1.last() = W2.first() by B1,B2,B7,C4,GLIB_001:38; then
        C7: WA.cost() = W1.cost() + W2.cost() by GLIB_003:31;
            W3.first() = W2.last() by C4, B1,GLIB_001:38
                      .= WA.last() by C6, GLIB_001:31; then
            WB.cost() = W1.cost() + W2.cost() + W3.cost() by C7, GLIB_003:31
                     .= W2.cost() + (W1.cost() + W3.cost()); then
        C9: WB.cost() < W.cost() by B9, C1, REAL_1:67;
            consider WB2 being DPath of WB;
            WB2.cost() <= WB.cost() by GLIB_003:37; then
        CA: WB2.cost() < W.cost() by C9, AXIOMS:22;
            WB2 is_Walk_from x,y by C5,GLIB_001:161;
            hence contradiction by A1,dWMINCOSTD,CA;
        end;
        hence thesis; end;
    suppose
    B1: not (m is odd & n is odd & m <= n & n <= len W); then
        WC = W by GLIB_001:def 11; then
        WC.first() = x & WC.last() = y by A2, GLIB_001:def 23;
        hence thesis by A1, B1,GLIB_001:def 11; end;
    end;
    hence thesis;
end;    

theorem tWGMINDCOST02: ::tWGMINDCOST02
  for G being finite real-weighted WGraph, W1,W2 being DPath of G,
      x,y being set st
    W1 is_mincost_DPath_from x,y & W2 is_mincost_DPath_from x,y holds
    W1.cost() = W2.cost()
proof
    let G be finite real-weighted WGraph, W1,W2 be DPath of G,
        x,y be set; assume
A1: W1 is_mincost_DPath_from x,y & W2 is_mincost_DPath_from x,y; then
A2: W1 is_Walk_from x,y & for W2 being DPath of G st W2 is_Walk_from x,y
      holds W1.cost() <= W2.cost() by dWMINCOSTD;
    W2 is_Walk_from x,y & for W1 being DPath of G st W1 is_Walk_from x,y
      holds W2.cost() <= W1.cost() by A1, dWMINCOSTD; then
    W1.cost() <= W2.cost() & W2.cost() <= W1.cost() by A2;
    hence thesis by AXIOMS:21;
end;    

theorem tWGMINDCOST03: ::tWGMINDCOST03
  for G being finite real-weighted WGraph, W being DPath of G, x,y being set st
    W is_mincost_DPath_from x,y holds G.min_DPath_cost(x,y) = W.cost()
proof
    let G be finite real-weighted WGraph, W be DPath of G, x,y be set; assume
A1: W is_mincost_DPath_from x,y; then
    W is_Walk_from x,y by dWMINCOSTD; then
    consider W2 being DPath of G such that
A2: W2 is_mincost_DPath_from x,y & G.min_DPath_cost(x,y) = W2.cost()
      by dWGMINDCOST;
    thus thesis by A1,A2,tWGMINDCOST02;
end;

theorem tDSTEP01: ::tDSTEP01
  for G being finite real-WEV WEVGraph holds
    (card DIJK:Step(G).labeledV() = card G.labeledV()
        iff DIJK:NextBestEdges(G) = {}) &
    (card DIJK:Step(G).labeledV() = card G.labeledV() + 1
        iff DIJK:NextBestEdges(G) <> {})
proof
    let G be finite real-WEV WEVGraph;
    set BestEdges = DIJK:NextBestEdges(G), e = choose BestEdges;
    set nextEG = G.labelEdge(e,1), nextG = DIJK:Step(G);
    set VG = the_VLabel_of G, VNextEG = the_VLabel_of nextEG;
    set VNextG = the_VLabel_of nextG;
    set cardG = card VG, cardNextEG = card VNextEG, cardNextG = card VNextG;
    set src = (the_Source_of G).e, target = (the_Target_of G).e;
    set val = (the_VLabel_of G).src + (the_Weight_of G).e;
    hereby assume
    B1: card nextG.labeledV() = card G.labeledV();
        now assume
        C1: BestEdges <> {}; then
        C3: e in BestEdges; 
            G == nextEG by GLIB_003:41; then
            the_Vertices_of G = the_Vertices_of nextEG by GLIB_000:def 36;then
            reconsider target as Vertex of nextEG by C3, FUNCT_2:7;
        C5: G.labeledV() = nextEG.labeledV() by GLIB_003:63;
            e DSJoins G.labeledV(),the_Vertices_of G \ G.labeledV(), G
              by C1,dDIJKNEXT; then
            target in the_Vertices_of G \ G.labeledV() by GLIB_000:def 18; then
        C7: not target in nextEG.labeledV() by C5,XBOOLE_0:def 4;
        C8: card nextEG.labelVertex(target,val).labeledV() =
              card nextEG.labeledV() + 1 by C7, GLIB_003:61;
        CA: card G.labeledV() = card nextEG.labeledV() + 1
              by B1,C1,C8,dDIJKSTEP;
            the_VLabel_of G = the_VLabel_of nextEG by GLIB_003:43; then
            G.labeledV() = dom the_VLabel_of nextEG by GLIB_003:def 23;then
            0+card G.labeledV() = card G.labeledV() + 1 by CA,GLIB_003:def 23;
            hence contradiction by XCMPLX_1:2;
        end;
        hence BestEdges = {};
    end;
    thus BestEdges = {} implies card nextG.labeledV() = card G.labeledV()
      by dDIJKSTEP;
    hereby assume
    B1: card nextG.labeledV() = card G.labeledV() + 1;
        now assume BestEdges = {}; then
            0 + card G.labeledV() = card G.labeledV() + 1 by B1, dDIJKSTEP;
            hence contradiction by XCMPLX_1:2;
        end;
        hence BestEdges <> {};
    end;
    assume
A1: BestEdges <> {};
A3: e in BestEdges by A1;
    G == nextEG by GLIB_003:41; then
    the_Vertices_of nextEG = the_Vertices_of G by GLIB_000:def 36; then
    reconsider target as Vertex of nextEG by A3, FUNCT_2:7;
    the_VLabel_of nextG = the_VLabel_of
      nextEG.labelVertex(target,val) by A1, dDIJKSTEP; then
A5: nextEG.labelVertex(target,val).labeledV()
      = dom the_VLabel_of nextG by GLIB_003:def 23
     .= nextG.labeledV() by GLIB_003:def 23;
     the_VLabel_of G = the_VLabel_of nextEG by GLIB_003:43; then
A7: G.labeledV() = dom the_VLabel_of nextEG by GLIB_003:def 23
                 .= nextEG.labeledV() by GLIB_003:def 23;
    e DSJoins G.labeledV(),the_Vertices_of G \ G.labeledV(), G
      by A1,dDIJKNEXT; then
    target in the_Vertices_of G \ G.labeledV() by GLIB_000:def 18; then
     not target in nextEG.labeledV() by A7, XBOOLE_0:def 4;
    hence thesis by A5, A7, GLIB_003:61;
end;

theorem tDSTEP02: ::tDSTEP02
  for G being real-WEV WEVGraph holds
    G == DIJK:Step(G) &
    the_Weight_of  G = the_Weight_of  DIJK:Step(G) &
    G.labeledE() c= DIJK:Step(G).labeledE() &
    G.labeledV() c= DIJK:Step(G).labeledV()
proof
   let G be real-WEV WEVGraph;
    set NextG = DIJK:Step(G);
    set VG = the_VLabel_of G, VNextG = the_VLabel_of NextG;
    set BestEdges = DIJK:NextBestEdges(G), e = choose BestEdges;
    set NextEG = G.labelEdge(e,1), target = (the_Target_of G).e;
    set val = (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e;
    now per cases;
    suppose BestEdges = {};
        hence G == DIJK:Step(G) &
              the_Weight_of G  = the_Weight_of DIJK:Step(G) &
              G.labeledE() c= NextG.labeledE() &
              G.labeledV() c= NextG.labeledV() by dDIJKSTEP; end;
    suppose
    B1: BestEdges <> {}; then
    B2: NextG = NextEG.labelVertex(target,val) by dDIJKSTEP;
    B3: e in BestEdges by B1;
        G == NextEG by GLIB_003:41; then
    B4: the_Vertices_of G = the_Vertices_of NextEG &
        the_VLabel_of G = the_VLabel_of NextEG
          by GLIB_003:43,GLIB_000:def 36; then
        reconsider target as Vertex of NextEG by B3, FUNCT_2:7;
        set LV = NextEG.labelVertex(target, val);
        G == NextEG & NextEG == NextG by B2,GLIB_003:41,GLIB_003:47;
        hence G == NextG by GLIB_000:88;
        thus the_Weight_of G  = the_Weight_of NextEG by GLIB_003:42
                             .= the_Weight_of NextG by B2,GLIB_003:48;
        now let x be set; assume
        C1: x in G.labeledE();
            G.labeledE() c= G.labelEdge(e,1).labeledE()
              by B3, GLIB_003:53; then
        C2: x in G.labelEdge(e,1).labeledE() by C1;
        C3: the_ELabel_of NextEG = the_ELabel_of NextG by B2, GLIB_003:49;
            x in dom (the_ELabel_of NextEG) by C2, GLIB_003:def 20;
            hence x in NextG.labeledE() by C3,GLIB_003:def 20;
        end;
        hence G.labeledE() c= NextG.labeledE() by TARSKI:def 3;
        now let x be set; assume
            x in G.labeledV(); then
            x in dom (the_VLabel_of G) by GLIB_003:def 23; then
        C2: x in NextEG.labeledV() by B4, GLIB_003:def 23;
            NextEG.labeledV() c= NextEG.labelVertex(target,val).labeledV()
              by GLIB_003:60;
            hence x in NextG.labeledV() by C2,B2;
        end;
        hence G.labeledV() c= NextG.labeledV() by TARSKI:def 3; end;
  end;
  hence thesis;   
end;    

theorem tDIJKINIT01: ::tDIJKINIT01
  for G being real-weighted WGraph, src be Vertex of G
   holds DIJK:Init(G,src).labeledV() = {src}
proof
    let G be real-weighted WGraph, src be Vertex of G;
    set G2 = DIJK:Init(G,src);
A1: G2 = G.set(ELabelSelector,{}).set(VLabelSelector,src.-->0) by dDIJKINIT;
    the_VLabel_of G2 = G2.VLabelSelector by GLIB_003:def 9
                    .= src .--> 0 by A1, GLIB_000:11; then
    dom the_VLabel_of G2 = {src} by CQC_LANG:5;
    hence thesis by GLIB_003:def 23;
end;
  
theorem tDCS01: ::tDCS01
  for G being real-weighted WGraph, src being Vertex of G, i,j being Nat
   st i <= j holds
   (DIJK:CompSeq(G,src).->i).labeledV() c=
     (DIJK:CompSeq(G,src).->j).labeledV() &
   (DIJK:CompSeq(G,src).->i).labeledE() c=
     (DIJK:CompSeq(G,src).->j).labeledE()
proof
    let G be real-weighted WGraph, src be Vertex of G, i,j be Nat;
    set DCS = DIJK:CompSeq(G,src);
    set dDCS = (DCS.->i).labeledV();
    set eDCS = (DCS.->i).labeledE(); assume i <= j; then
    consider x being Nat such that
A2: j = i + x by NAT_1:28;
    defpred P[Nat] means dDCS c= (DCS.->(i+$1)).labeledV() &
                         eDCS c= (DCS.->(i+$1)).labeledE();
A3: P[0];
    now let k be Nat; assume
    B1: dDCS c= (DCS.->(i+k)).labeledV() &
        eDCS c= (DCS.->(i+k)).labeledE();
        DCS.->(i+k+1) = DIJK:Step(DCS.->(i+k)) by dDIJKCS; then
        (DCS.->(i+k)).labeledV() c= (DCS.->(i+k+1)).labeledV() &
        (DCS.->(i+k)).labeledE() c= (DCS.->(i+k+1)).labeledE()
          by tDSTEP02;
        hence dDCS c= (DCS.->(i+(k+1))).labeledV() &
              eDCS c= (DCS.->(i+(k+1))).labeledE() by B1, XBOOLE_1:1;
    end; then
A4: for k being Nat st P[k] holds P[k+1];
    for k being Nat holds P[k] from NAT_1:sch 1(A3,A4);
    hence dDCS c= (DCS.->j).labeledV() & eDCS c= (DCS.->j).labeledE() by A2;
end;

theorem tDCS02: ::tDCS02
  for G being real-weighted WGraph, src being Vertex of G, n being Nat holds
    G == DIJK:CompSeq(G,src).->n &
    the_Weight_of G = the_Weight_of (DIJK:CompSeq(G,src).->n)
proof
    let G be real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Nat] means
      G == DIJK:CompSeq(G,src).->$1 &
      the_Weight_of G  = the_Weight_of (DIJK:CompSeq(G,src).->$1);
    DCS.->0 = DIJK:Init(G,src) by dDIJKCS; then
A1: DCS.->0=G.set(ELabelSelector,{})
             .set(VLabelSelector,src.-->0) by dDIJKINIT; then
A2: DCS.->0 == G.set(ELabelSelector,{}) by GLIB_003:8;
A3: G == G.set(ELabelSelector, {}) by GLIB_003:8;
    the_Weight_of G = the_Weight_of G.set(ELabelSelector,{}) by GLIB_003:11
                   .= the_Weight_of (DCS.->0) by A1,GLIB_003:13; then
A5: P[0] by A2,A3,GLIB_000:88;
    now let k be Nat; assume
    B1: G == DCS.->k & the_Weight_of G = the_Weight_of (DCS.->k);
    B2: DCS.->(k+1) = DIJK:Step(DCS.->k) by dDIJKCS; then
        DCS.->k == DCS.->(k+1) by tDSTEP02;
        hence G == DCS.->(k+1) by B1, GLIB_000:88;
        thus the_Weight_of G = the_Weight_of (DCS.->(k+1)) by B1,B2,tDSTEP02;
    end; then
A6: for k being Nat st P[k] holds P[k+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A5,A6);
    hence thesis;
end;

theorem tDCS03: ::tDCS03
  for G being finite real-weighted WGraph, src being Vertex of G,
      n being Nat holds
    (DIJK:CompSeq(G,src).->n).labeledV() c= G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Nat] means (DCS.->$1).labeledV() c= G.reachableDFrom(src);
    DCS.->0 = DIJK:Init(G, src) by dDIJKCS; then
A1: (DCS.->0).labeledV() = {src} by tDIJKINIT01;
    src in G.reachableDFrom(src) by GLIB_002:18; then
A2: P[0] by A1, ZFMISC_1:37;
    now let k be Nat such that
    B1: (DCS.->k).labeledV() c= G.reachableDFrom(src);
        set Gk = DCS.->k, NextG = DCS.->(k+1);
        set VGk = (the_VLabel_of Gk), VNextG = (the_VLabel_of NextG);
        set BestEdges = DIJK:NextBestEdges(Gk), e = choose BestEdges;
        set NextEG = Gk.labelEdge(e,1);
        set v1 = (the_Source_of Gk).e, target = (the_Target_of Gk).e;
        set pc = (the_VLabel_of Gk).v1, ec = (the_Weight_of Gk).e;
    B2: NextG = DIJK:Step(Gk) by dDIJKCS;
        now let x be set; assume
        C1: x in (DCS.->(k+1)).labeledV();
            now per cases;
            suppose BestEdges = {}; then
                Gk = NextG by B2, dDIJKSTEP;
                hence x in G.reachableDFrom(src) by B1, C1; end;
            suppose
            D1: BestEdges <> {}; then
            D2: NextG = NextEG.labelVertex(target, pc+ec) by B2, dDIJKSTEP;
                set xx = x, GE = NextEG.labelVertex(target,pc+ec);
                G == DCS.->(k+1) by tDCS02; then
                reconsider xx as Vertex of G by C1,GLIB_000:def 36;
                e DSJoins Gk.labeledV(),the_Vertices_of Gk \ Gk.labeledV(),Gk
                  by D1, dDIJKNEXT; then
            D3: v1 in Gk.labeledV() by GLIB_000:def 18; then
                v1 in G.reachableDFrom(src) by B1; then
                reconsider v1' = v1 as Vertex of G;
                now per cases;
                suppose xx in Gk.labeledV();
                    hence xx in G.reachableDFrom(src) by B1; end;
                suppose not xx in Gk.labeledV(); then
                E1: not xx in dom (the_VLabel_of Gk) by GLIB_003:def 23;
                    the_VLabel_of Gk = the_VLabel_of NextEG
                      by GLIB_003:43; then
                E2: not xx in NextEG.labeledV() by E1, GLIB_003:def 23;
                    now
                    F0: e in BestEdges by D1;
                    F1: G == Gk by tDCS02; then
                        the_Edges_of Gk = the_Edges_of G &
                        the_Source_of Gk = the_Source_of G &
                        the_Target_of Gk = the_Target_of G by GLIB_000:def 36;                    
                        hence e in the_Edges_of G by F0;
                        thus (the_Source_of G).e = v1 by F1,GLIB_000:def 36;
                        target = xx by C1,D2,E2,GLIB_003:62;
                        hence (the_Target_of G).e = xx by F1,GLIB_000:def 36;
                    end; then e DJoins v1',xx,G by GLIB_000:def 16;
                    hence xx in G.reachableDFrom(src)
                      by B1,D3,GLIB_002:19; end;
                end;
                hence x in G.reachableDFrom(src); end;
            end;
            hence x in G.reachableDFrom(src);
        end;
        hence (DCS.->(k+1)).labeledV() c= G.reachableDFrom(src)
          by TARSKI:def 3;
    end; then
A3: for k being Nat st P[k] holds P[k+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

theorem tDCS05: ::tDCS05
  for G being finite real-weighted WGraph, src being Vertex of G, n being Nat
    holds DIJK:NextBestEdges(DIJK:CompSeq(G,src).->n) = {} iff
   (DIJK:CompSeq(G,src).->n).labeledV() = G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G, n be Nat;
    set DCS = DIJK:CompSeq(G,src), RFS = G.reachableDFrom(src);
    set Gn = DCS.->n, Gn_1 = DCS.->(n+1), VGn = the_VLabel_of Gn;
    set BestEdges = DIJK:NextBestEdges(Gn), e = choose BestEdges;
    set SG = the_Source_of G, SGn = the_Source_of Gn;
    set TG = the_Target_of G, TGn = the_Target_of Gn;
A1: Gn_1 = DIJK:Step(Gn) by dDIJKCS;
    hereby assume
    B1: BestEdges = {};
        now assume
        C1: Gn.labeledV() <> RFS;
            Gn.labeledV() c= RFS by tDCS03; then
        C2: Gn.labeledV() c< RFS by C1, XBOOLE_0:def 8;
            defpred P[set] means SGn.$1 in Gn.labeledV() &
                             not TGn.$1 in Gn.labeledV();
            consider BE1 being Subset of the_Edges_of Gn such that
        C3: for x being set holds x in BE1 iff x in the_Edges_of Gn & P[x]
              from SUBSET_1:sch 1;
            now assume
            D1: BE1 = {};
                consider v being set such that
            D2: v in RFS & not v in Gn.labeledV() by C2, RLSUB_2:77;
                reconsider v as Vertex of G by D2;
                consider W being directed Walk of G such that
            D3: W is_Walk_from src, v by D2, GLIB_002:def 6;
                DCS.->0 = DIJK:Init(G, src) by dDIJKCS; then
                (DCS.->0).labeledV() = {src} by tDIJKINIT01; then
            D4: src in (DCS.->0).labeledV() by TARSKI:def 1;
                0 <= n by NAT_1:18; then
            D5: (DCS.->0).labeledV() c= Gn.labeledV() by tDCS01;
                defpred P[Nat] means $1 is odd & $1 <= len W &
                  not (W.$1 in Gn.labeledV());
                W.(len W) = W.last() by GLIB_001:def 7
                         .= v by D3, GLIB_001:def 23; then
            D6: ex k being Nat st P[k] by D2;
                consider k being Nat such that
            D7: P[k] & for m being Nat st P[m] holds k <= m
                  from NAT_1:sch 5(D6);
                now per cases;
                suppose k = 1; then
                    W.k = W.first() by GLIB_001:def 6
                       .= src by D3, GLIB_001:def 23;
                    hence contradiction by D4,D5, D7; end;
                suppose
                E1: k <> 1; reconsider k'=k as odd Nat by D7;
                    1 <= k by D7, HEYTING3:1; then
                    1 < k by E1, REAL_1:def 5; then
                    1+1 < k+1 by REAL_1:67; then
                    2*1 <= k by NAT_1:38; then
                    reconsider k_2 = k'-2*1 as odd Nat by INT_1:18;
                E2: k - 2 < len W - 0 by D7, REAL_1:92;
                    k_2 < k - 0 by REAL_1:92; then
                E3: W.(k_2) in Gn.labeledV() by E2, D7;
                    set e = W.(k_2+1);
                    e DJoins W.k_2, W.(k_2+2), G by E2, GLIB_001:123; then
                E4: e in the_Edges_of G & (the_Source_of G).e = W.k_2
                      & (the_Target_of G).e = W.(k_2+2) by GLIB_000:def 16;
                    G == Gn by tDCS02; then
                E5: e in the_Edges_of Gn & SGn.e = W.k_2 & TGn.e = W.(k_2+2)
                      by E4, GLIB_000:def 36;
                    thus contradiction by D1, C3, E5, E3, D7; end;
                end;
                hence contradiction;
            end; then
            reconsider BE1 as non empty finite set;
            deffunc F(Element of BE1) =
               (the_VLabel_of Gn).((the_Source_of Gn).$1) +
               (the_Weight_of Gn).($1);
            consider e1 being Element of BE1 such that
        C4: for e2 being Element of BE1 holds F(e1) <= F(e2)
              from GRAPH_5:sch 2;
        C5: e1 in the_Edges_of Gn & (SGn).e1 in Gn.labeledV() &
              not (TGn).e1 in Gn.labeledV() by C3; then
            (TGn).e1 in the_Vertices_of Gn by GLIB_000:6; then
            (TGn).e1 in the_Vertices_of Gn \ Gn.labeledV()
              by C5,XBOOLE_0:def 4; then
        C6: e1 DSJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(),Gn
              by C5,GLIB_000:def 18;
            now let y be set; assume
            D1: y DSJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(),Gn;
            D2: y in the_Edges_of Gn & (SGn).y in Gn.labeledV() &
                  (TGn).y in the_Vertices_of Gn \ Gn.labeledV()
                  by D1, GLIB_000:def 18; then
                not (TGn).y in Gn.labeledV() by XBOOLE_0:def 4; then
                y in BE1 by C3,D2;
                hence (the_VLabel_of Gn).((the_Source_of Gn).e1) +
                  (the_Weight_of Gn).e1 <=
                  (the_VLabel_of Gn).((the_Source_of Gn).y) +
                  (the_Weight_of Gn).y by C4;
            end;
            hence contradiction by B1, C6, dDIJKNEXT;
        end;
        hence (DCS.->n).labeledV() = RFS;
    end;
    assume
A2: (DCS.->n).labeledV() = RFS;
    now assume BestEdges <> {}; then
    B1: card Gn_1.labeledV() = card RFS + 1 by A1, A2, tDSTEP01;
        Gn_1.labeledV() c= RFS by tDCS03;  then
        card Gn_1.labeledV() <=` card RFS by CARD_1:27; then
        card RFS + 1 <= card RFS + 0 by B1, CARD_2:57; 
        hence contradiction by REAL_1:53;
    end;
    hence BestEdges = {};
end;

theorem tDCS06: ::tDCS06
  for G being finite real-weighted WGraph, src being Vertex of G, n being Nat
    holds Card (DIJK:CompSeq(G,src).->n).labeledV() =
      min(n+1, card(G.reachableDFrom(src)))
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
     set DCS = DIJK:CompSeq(G, src), VL0 = (DCS.->0).labeledV();
     set RFS = G.reachableDFrom(src);
     defpred P[Nat] means Card (DCS.->$1).labeledV() =
       min($1+1, card(G.reachableDFrom(src)));
     DCS.->0 = DIJK:Init(G,src) by dDIJKCS; then
A1:  Card VL0 = Card {src} by tDIJKINIT01
             .= 1 by CARD_1:79;
     src in RFS by GLIB_002:18; then
     {src} c= RFS by ZFMISC_1:37; then
     card {src} <= card RFS by CARD_1:80; then
     0+1 <= card RFS by CARD_1:79; then
A2:  P[0] by A1, SQUARE_1:def 1;
     now let k be Nat such that
     B1: Card (DCS.->k).labeledV() = min(k+1, card RFS);
     B2: DCS.->(k+1) = DIJK:Step(DCS.->k) by dDIJKCS;
         set Gk = DCS.->k, Gk_1 = DCS.->(k+1);
         set VGk = the_VLabel_of Gk, VGk_1 = the_VLabel_of Gk_1;
         set BestEdges = DIJK:NextBestEdges(Gk), e = choose BestEdges;
         now per cases;
         suppose
         C1: BestEdges = {}; then
         C2: card Gk_1.labeledV() = card Gk.labeledV() by B2, tDSTEP01;
         C4: card Gk.labeledV() = card RFS by C1, tDCS05;
         C5: card Gk_1.labeledV() = card RFS by C1, C2, tDCS05;
             card RFS <= k+1 by B1, C4, SQUARE_1:def 1; then
             card RFS <= k+1+1 by NAT_1:37; 
             hence Card Gk_1.labeledV() = min((k+1)+1, card RFS)
               by C5, SQUARE_1:def 1; end;
         suppose
         C1: BestEdges <> {}; then
         C2: card Gk_1.labeledV() = card Gk.labeledV() + 1
               by B2, tDSTEP01;
         C3: Gk.labeledV() <> RFS by C1, tDCS05;
         C4: now assume
             D1: card Gk.labeledV() = card RFS;
                 Gk.labeledV() c= RFS by tDCS03; then
                 Gk.labeledV() c< RFS by C3, XBOOLE_0:def 8; 
                 hence contradiction by D1, CARD_2:67;
             end; then
         C6: card Gk_1.labeledV() = (k+1)+1 by B1, C2, SQUARE_1:38;
         C7: k+1 <= card RFS & (k+1) <> card RFS
               by B1, C4, SQUARE_1:def 1; then
         C8: k+1+1 <= card RFS + 1 by AXIOMS:24;
             k+1+1 <> card RFS + 1 by C7, XCMPLX_1:2; then 
             k+1+1 < card RFS + 1 by C8, REAL_1:def 5; then
             (k+1+1) <= card RFS by NAT_1:38;
             hence Card Gk_1.labeledV() = min((k+1)+1, card RFS)
               by C6, SQUARE_1:def 1; end;
         end;
         hence Card (DCS.->(k+1)).labeledV() = min((k+1)+1, card RFS);
     end; then
A3: for k being Nat st P[k] holds P[k+1];     
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

theorem tDCS07: ::tDCS07 
  for G being finite real-weighted WGraph, src being Vertex of G, n being Nat
    holds (DIJK:CompSeq(G,src).->n).labeledE() c= (DIJK:CompSeq(G,src).->n)
      .edgesBetween((DIJK:CompSeq(G,src).->n).labeledV())
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src), D0 = DCS.->0;
    defpred P[Nat] means (DCS.->$1).labeledE() c=
      (DCS.->$1).edgesBetween((DCS.->$1).labeledV());
    D0=DIJK:Init(G, src) by dDIJKCS; then
    D0=G.set(ELabelSelector,{}).set(VLabelSelector,src.-->0) by dDIJKINIT; then
A1: the_ELabel_of D0 = the_ELabel_of G.set(ELabelSelector,{}) by GLIB_003:14
                    .= G.set(ELabelSelector,{}).ELabelSelector by GLIB_003:4
                    .= {} by GLIB_000:11;
    for x being set st x in D0.labeledE()
      holds x in D0.edgesBetween(D0.labeledV())
      by A1,RELAT_1:60,GLIB_003:def 20; then
A4: P[0] by TARSKI:def 3;
    now let n be Nat; set Dn = DCS.->n, Dn1 = DCS.->(n+1);
        set BE = DIJK:NextBestEdges(Dn), e = choose BE;
        set target = (the_Target_of Dn).e;
        set val=(the_VLabel_of Dn).((the_Source_of Dn).e)+(the_Weight_of Dn).e;
        set DnE = Dn.labelEdge(e,1); assume
    B1: Dn.labeledE() c= Dn.edgesBetween(Dn.labeledV());
    B2: Dn1 = DIJK:Step(Dn) by dDIJKCS;
        G == Dn & G == Dn1 by tDCS02; then
        Dn == Dn1 by GLIB_000:88; then
    B3: the_Vertices_of Dn = the_Vertices_of Dn1 &
        the_Edges_of Dn = the_Edges_of Dn1 &
        the_Source_of Dn = the_Source_of Dn1 &
        the_Target_of Dn = the_Target_of Dn1 by GLIB_000:def 36;
        now let x be set; assume
        C1: x in Dn1.labeledE();
            n <= n+1 by NAT_1:37; then
        C2: Dn.labeledV() c= Dn1.labeledV() &
              Dn.labeledE() c= Dn1.labeledE() by tDCS01;
            now per cases;
            suppose BE = {}; then
                Dn1 = Dn by B2, dDIJKSTEP;
                hence x in Dn1.edgesBetween(Dn1.labeledV())
                  by B1, C1; end;
            suppose
            D1: BE <> {}; then
            D2: Dn1 = DnE.labelVertex(target,val) by B2, dDIJKSTEP;
            D3: e in BE by D1;
                Dn == DnE by GLIB_003:41; then
                the_Vertices_of Dn = the_Vertices_of DnE
                  by GLIB_000:def 36; then
            DZ: target in the_Vertices_of DnE by D3, GLIB_000:6;
            D4: DnE.labeledE() = Dn.labeledE() \/ {e} by D3,GLIB_003:52;
                the_ELabel_of DnE = the_ELabel_of Dn1 by D2,GLIB_003:49; then
            D5: Dn1.labeledE() = Dn.labeledE() \/ {e} by D4,GLIB_003:51;
            D6: Dn1.labeledV() = DnE.labeledV()\/{target} by D2,DZ,GLIB_003:59;
                now per cases by C1, D5, XBOOLE_0:def 2;
                suppose x in Dn.labeledE(); then
                    x in the_Edges_of Dn &
                      (the_Source_of Dn).x in Dn.labeledV() &
                      (the_Target_of Dn).x in Dn.labeledV()
                      by B1, GLIB_000:34;
                    hence x in Dn1.edgesBetween(Dn1.labeledV())
                      by B3, C2, GLIB_000:34; end;
                suppose x in {e}; then
                E1: x = e by TARSKI:def 1; then
                    (the_Target_of Dn1).x in {target}
                      by B3, TARSKI:def 1; then
                E3: (the_Target_of Dn1).x in Dn1.labeledV()
                      by D6, XBOOLE_0:def 2;
                     e DSJoins Dn.labeledV(),the_Vertices_of Dn \
                       Dn.labeledV(),Dn by D1, dDIJKNEXT; then
                    (the_Source_of Dn1).x in Dn.labeledV()
                      by B3, E1, GLIB_000:def 18;
                    hence x in Dn1.edgesBetween(Dn1.labeledV())
                      by C2, E1,B3,D3, E3, GLIB_000:34; end;
                end;
                hence x in Dn1.edgesBetween(Dn1.labeledV()); end;
            end;
            hence x in Dn1.edgesBetween(Dn1.labeledV());
        end;
        hence Dn1.labeledE() c= Dn1.edgesBetween(Dn1.labeledV())
          by TARSKI:def 3;
    end; then
A5: for k being Nat st P[k] holds P[k+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A4,A5);
    hence thesis;
end;

theorem tDCS08: ::tDCS08
  for G being finite nonnegative-weighted WGraph, src being Vertex of G,
    n being Nat, G2 being inducedWSubgraph of
    G,(DIJK:CompSeq(G,src).->n).labeledV(),
      (DIJK:CompSeq(G,src).->n).labeledE()
  holds G2 is_mincost_DTree_rooted_at src &
  for v being Vertex of G st v in (DIJK:CompSeq(G,src).->n).labeledV()
    holds G.min_DPath_cost(src,v) =
          (the_VLabel_of (DIJK:CompSeq(G,src).->n)).v
proof
    let G be finite nonnegative-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src), D0 = DCS.->0;
    defpred P[Nat] means
     for G2 being inducedWSubgraph of
          G,(DCS.->$1).labeledV(),(DCS.->$1).labeledE() holds
       G2 is_mincost_DTree_rooted_at src &
       for v being Vertex of G st v in (DCS.->$1).labeledV()
         holds G.min_DPath_cost(src,v) = (the_VLabel_of (DCS.->$1)).v;
    reconsider EL = {} as PartFunc of the_Edges_of G, REAL by  PARTFUN1:56;
A1: D0 = DIJK:Init(G,src) by dDIJKCS
      .= G.set(ELabelSelector,EL)
          .set(VLabelSelector,src.-->0) by dDIJKINIT; then
AZ: the_VLabel_of D0 = G.set(ELabelSelector,EL)
                        .set(VLabelSelector,src.-->0)
                        .VLabelSelector by GLIB_003:4
                    .= src .--> 0 by GLIB_000:11; then
    dom (the_VLabel_of D0) = {src} by CQC_LANG:5; then
A2: D0.labeledV() = {src} by GLIB_003:def 23;
    the_ELabel_of D0 = the_ELabel_of G.set(ELabelSelector,EL) by A1,GLIB_003:14
                    .= G.set(ELabelSelector,EL).ELabelSelector by GLIB_003:4
                    .= {} by GLIB_000:11; then
A3: D0.labeledE() = {} by RELAT_1:60, GLIB_003:def 20;
    now let D0W be inducedWSubgraph of G,D0.labeledV(),D0.labeledE();
        {} c= G.edgesBetween(D0.labeledV()) by XBOOLE_1:2; then
    B1: the_Vertices_of D0W = {src} & the_Edges_of D0W = {}
          by A2,A3,GLIB_000:def 39; then
    B2: card (the_Vertices_of D0W) = 1 & card (the_Edges_of D0W) = 0
          by CARD_1:78,CARD_1:79; then
        D0W.order() = 1 & D0W.size() = 0
          by GLIB_000:def 26,GLIB_000:def 27; then
    B4: D0W.order() = D0W.size() + 1;
        D0W is trivial by B2, GLIB_000:def 21, CARD_2:20; then
        D0W is connected by GLIB_002:7; then
    B5: D0W is Tree-like by B4, GLIB_002:47;
        now let x be Vertex of D0W;
        C1: x = src by B1, TARSKI:def 1;
            set W2 = D0W.walkOf(x);
            take W2;
            thus W2 is_Walk_from src,x by C1, GLIB_001:14;
            let W1 be DPath of G; assume W1 is_Walk_from src,x;
        C2: 0 <= W1.cost() by GLIB_003:36;
            thus W2.cost() <= W1.cost() by C2, GLIB_003:28;
        end;
        hence D0W is_mincost_DTree_rooted_at src by B5, dGMINCOSTDTREE;
        let v be Vertex of G; assume
    B6: v in D0.labeledV(); then
    B7: v = src by A2,TARSKI:def 1;
    B8: (the_VLabel_of D0).src = 0 by AZ,CQC_LANG:6;
        now set W1 = G.walkOf(v);
        C1: W1 is_Walk_from src,v by B7,GLIB_001:14; then
            consider W being DPath of G such that
        C2: W is_mincost_DPath_from src,v & G.min_DPath_cost(src,v) = W.cost()
              by dWGMINDCOST;
            W1.cost() = 0 by GLIB_003:28; then
            W.cost() <= 0 by C1, C2, dWMINCOSTD;
            hence G.min_DPath_cost(src,v) = 0 by C2, GLIB_003:36;
        end;
        hence G.min_DPath_cost(src,v) = (the_VLabel_of D0).v
          by B6,A2,TARSKI:def 1,B8;
    end; then
A4: P[0];
    now let n be Nat; set Dn = DCS.->n, Dn1 = DCS.->(n+1);
        set BE = DIJK:NextBestEdges(Dn), e = choose BE;
        set source = (the_Source_of Dn).e, target = (the_Target_of Dn).e;
        set DnE = Dn.labelEdge(e,1);
        set pc = (the_VLabel_of Dn).source;
        set ec = (the_Weight_of Dn).e;
        consider DnW being inducedWSubgraph of G,Dn.labeledV(),Dn.labeledE();
        assume
    B1: P[n];
        let Dn1W be inducedWSubgraph of G,Dn1.labeledV(), Dn1.labeledE();
    B2: Dn1 = DIJK:Step(Dn) by dDIJKCS; then
    B3: Dn == Dn1 &
        the_Weight_of  Dn = the_Weight_of  Dn1 &
        Dn.labeledE() c= Dn1.labeledE() &
        Dn.labeledV() c= Dn1.labeledV() by tDSTEP02;
    BY: G == Dn & the_Weight_of G = the_Weight_of Dn by tDCS02;
    BW: G == Dn1 & the_Weight_of G = the_Weight_of Dn1 by tDCS02;
    B4: src in D0.labeledV() by A2, TARSKI:def 1;
    BZ: the_Vertices_of G = the_Vertices_of Dn by BY, GLIB_000:def 36;
        0 <= n by NAT_1:18; then
    B5: D0.labeledV() c= Dn.labeledV() by tDCS01; then
    BU: Dn.labeledV() is non empty Subset of the_Vertices_of G
          by B4,BY,GLIB_000:def 36;
    B6: Dn.labeledE() c= Dn.edgesBetween(Dn.labeledV()) by tDCS07; then
    Bz: Dn.labeledE() c= G.edgesBetween(Dn.labeledV())
          by BY,GLIB_000:93; then
    B7: the_Vertices_of DnW = Dn.labeledV() &
          the_Edges_of DnW = Dn.labeledE() by BU,GLIB_000:def 39; then
    B8: card Dn.labeledV() = DnW.order() &
          card Dn.labeledE() = DnW.size() by GLIB_000:def 26, GLIB_000:def 27;
    BT: DnW is_mincost_DTree_rooted_at src by B1; then
    B0: DnW is Tree-like by dGMINCOSTDTREE; then
    BA: DnW is connected & DnW.order() = DnW.size() + 1 by GLIB_002:47;
        now per cases;
        suppose BE = {}; then
            Dn1 = Dn by B2, dDIJKSTEP;
            hence Dn1W is_mincost_DTree_rooted_at src &
              for v being Vertex of G st v in Dn1.labeledV()
              holds G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v by B1; end;
        suppose
        C0: BE <> {}; then
        C1: e in BE & Dn1 = DnE.labelVertex(target,pc+ec) by B2,dDIJKSTEP;
            Dn == DnE by GLIB_003:41; then
        C2: the_Vertices_of DnE = the_Vertices_of Dn &
            the_Edges_of DnE = the_Edges_of Dn &
            the_Source_of DnE = the_Source_of Dn &
            the_Target_of DnE = the_Target_of Dn by GLIB_000:def 36;
        CZ: target in the_Vertices_of DnE by C1,C2,GLIB_000:6;
            the_ELabel_of Dn1 = the_ELabel_of DnE by C1,GLIB_003:49; then
        ZX: Dn1.labeledE() = DnE.labeledE() &
            Dn1.labeledV() = DnE.labeledV() \/ {target}
              by C1,CZ,GLIB_003:51,GLIB_003:59;
        CT: the_VLabel_of Dn = the_VLabel_of DnE by GLIB_003:43; then
        C3: Dn1.labeledE() = Dn.labeledE() \/ {e} &
            Dn1.labeledV() = Dn.labeledV() \/ {target}
              by C1,ZX,GLIB_003:58,GLIB_003:52;
            now let v be set; assume
            D0: v in Dn1.labeledV();
                now per cases by D0,C3,XBOOLE_0:def 2;
                suppose v in Dn.labeledV();
                    hence v in the_Vertices_of G by BU; end;
                suppose v in {target}; then
                    v = target by TARSKI:def 1; then
                    v in the_Vertices_of Dn by C1,GLIB_000:6;
                    hence v in the_Vertices_of G by BY, GLIB_000:def 36; end;
                end;
                hence v in the_Vertices_of G;
            end; then
        ZZ: Dn1.labeledV() is non empty Subset of the_Vertices_of G
              by ZX,TARSKI:def 3;
        ZY: Dn1.labeledE() c= Dn1.edgesBetween(Dn1.labeledV())
              by tDCS07;
            Dn1.labeledE() c= G.edgesBetween(Dn1.labeledV())
              by BW,ZY,GLIB_000:93; then
        C4: the_Vertices_of Dn1W = Dn.labeledV() \/ {target} &
            the_Edges_of Dn1W =(Dn.labeledE() \/ {e}) by C3,ZZ,GLIB_000:def 39;
        TT: e DSJoins Dn.labeledV(), the_Vertices_of Dn \ Dn.labeledV(), Dn
              by C0, dDIJKNEXT; then
        TU: target in the_Vertices_of Dn\Dn.labeledV() by GLIB_000:def 18; then
        C5: not target in Dn.labeledV() by XBOOLE_0:def 4; then
            card (Dn.labeledV() \/ {target}) = card Dn.labeledV() + 1
              by CARD_2:54; then
        C6: Dn1W.order() = DnW.order() + 1 by B8, C4, GLIB_000:def 26;
        ZW: not e in Dn.labeledE() by B6, C5, GLIB_000:34; then
            card (Dn.labeledE() \/ {e}) = card Dn.labeledE() + 1
              by CARD_2:54; then
        C7: Dn1W.size() = DnW.size() + 1 by B8, C4, GLIB_000:def 27;
        C8: Dn1W.order() = Dn1W.size() + 1 by B0, C6, C7, GLIB_002:47;
        C9: DnW is Subgraph of Dn & Dn1W is Subgraph of Dn1
              by BY,BW,GLIB_000:94;
        CQ: now thus the_Vertices_of DnW c= the_Vertices_of Dn1W &
                  the_Edges_of DnW c= the_Edges_of Dn1W 
                  by B7, C4, XBOOLE_1:7;
                let e be set; assume
            D1: e in the_Edges_of DnW; then
            D2: e in the_Edges_of Dn1W by B7, C4, XBOOLE_0:def 2;
            D3: (the_Source_of DnW).e = (the_Source_of Dn).e &
                (the_Target_of DnW).e = (the_Target_of Dn).e 
                  by C9, D1, GLIB_000:def 34;
                the_Source_of Dn = the_Source_of Dn1 &
                the_Target_of Dn =the_Target_of Dn1 by B3,GLIB_000:def 36;hence
               (the_Source_of DnW).e = (the_Source_of Dn1W).e &
                (the_Target_of DnW).e = (the_Target_of Dn1W).e
                  by C9, D2, D3, GLIB_000:def 34;
            end; then
        CA: DnW is Subgraph of Dn1W by GLIB_000:def 34;
            reconsider DnW' = DnW as [Weighted] Subgraph of Dn1W
              by CQ, GLIB_000:def 34;
        YS: the_Weight_of DnW' = (the_Weight_of G)| the_Edges_of DnW
              by GLIB_003:def 10;
        YT: the_Weight_of Dn1W = (the_Weight_of G)| the_Edges_of Dn1W
              by GLIB_003:def 10;
        YW: dom the_Weight_of Dn1W = the_Edges_of Dn1W by GLIB_003:5;
            dom (the_Weight_of Dn1W)/\the_Edges_of DnW = the_Edges_of DnW
              by CQ,YW, XBOOLE_1:28; then
        YY: dom the_Weight_of DnW'=dom (the_Weight_of Dn1W)/\the_Edges_of DnW 
              by GLIB_003:5;
            now let y be set; assume y in dom the_Weight_of DnW'; then
            D1: y in the_Edges_of DnW by GLIB_003:5;
                hence (the_Weight_of DnW').y = (the_Weight_of G).y
                                                by YS,FUNCT_1:72
                                          .= (the_Weight_of Dn1W).y
                                                by YT,D1,CQ,FUNCT_1:72;
            end; then
            the_Weight_of DnW' = (the_Weight_of Dn1W) | the_Edges_of DnW
              by YY, FUNCT_1:68; then
        CB: DnW is WSubgraph of Dn1W by GLIB_003:def 10;
        CC: source in Dn.labeledV() by TT, GLIB_000:def 18;
            e in {e} by TARSKI:def 1; then
        CD: e in the_Edges_of Dn1W by C4, XBOOLE_0:def 2;
            e DJoins source, target, Dn by C1, GLIB_000:def 16; then
            e DJoins source, target, Dn1 by B3, GLIB_000:91; then
        CH: e DJoins source, target, Dn1W by CD, C9, GLIB_000:76; then
        CI: e Joins source, target, Dn1W by GLIB_000:19;
            now let u,v be Vertex of Dn1W;
            D1: now let u,v be set; assume
                    u in Dn.labeledV() & v in Dn.labeledV(); then
                    reconsider u'=u, v'=v as Vertex of DnW
                      by Bz,BU,GLIB_000:def 39; 
                    consider W1 being Walk of DnW such that
                E1: W1 is_Walk_from u',v' by BA, GLIB_002:def 1;
                    reconsider W2=W1 as Walk of Dn1W by CA, GLIB_001:168;
                    W2 is_Walk_from u,v by E1, GLIB_001:20;
                    hence ex W being Walk of Dn1W st W is_Walk_from u,v;
                end;
                now per cases by C4, XBOOLE_0:def 2;
                suppose u in Dn.labeledV() & v in Dn.labeledV();
                  hence ex W being Walk of Dn1W st W is_Walk_from u,v
                    by D1; end;
                suppose
                E1: u in Dn.labeledV() & v in {target}; then
                    consider W being Walk of Dn1W such that
                E2: W is_Walk_from u,source by CC, D1;
                E3: W.addEdge(e) is_Walk_from u,target by E2, CI,GLIB_001:67;
                    v = target by E1, TARSKI:def 1;
                    hence ex W being Walk of Dn1W st W is_Walk_from u,v
                      by E3; end;
                suppose
                E1: u in {target} & v in Dn.labeledV(); then
                    consider W being Walk of Dn1W such that
                E2: W is_Walk_from v,source by CC, D1;
                E3: W.addEdge(e) is_Walk_from v,target by E2, CI,GLIB_001:67;
                    W.addEdge(e) is_Walk_from v,u by E1, E3, TARSKI:def 1; then
                    W.addEdge(e).reverse() is_Walk_from u,v by GLIB_001:24;
                    hence ex W being Walk of Dn1W st W is_Walk_from u,v; end;
                suppose u in {target} & v in {target}; then
                E1: u = target & v = target by TARSKI:def 1;
                    take W = Dn1W.walkOf(u);
                    thus W is_Walk_from u,v by E1, GLIB_001:14; end;
                end;
                hence ex W being Walk of Dn1W st W is_Walk_from u,v;
            end; then
            Dn1W is connected by GLIB_002:def 1; then
        CJ: Dn1W is Tree-like by C8, GLIB_002:47;
            now consider WT being DPath of DnW such that
            D1: WT is_Walk_from src,source &
                for W1 being DPath of G st W1 is_Walk_from src,source
                  holds WT.cost() <= W1.cost() by B7,CC,BT,dGMINCOSTDTREE;
                reconsider WT'=WT as DPath of Dn1W by CA, GLIB_001:176;
                set W2 = WT'.addEdge(e);
            D2: WT' is_Walk_from src,source by D1, GLIB_001:20; then
                reconsider W2 as DWalk of Dn1W by CH, GLIB_001:124;
                now target in {target} by TARSKI:def 1;
                    hence target is Vertex of Dn1W by C4, XBOOLE_0:def 2;
                    thus e Joins WT'.last(),target,Dn1W
                      by CI,D2,GLIB_001:def 23;
                E1: not e in the_Edges_of DnW by ZW,Bz,BU,GLIB_000:def 39; 
                    WT.edges() = WT'.edges() by GLIB_001:111;
                    hence not e in WT'.edges() by E1;
                    now assume
                    F1: WT' is non trivial;
                        now assume WT' is closed; then
                        G1: WT' is Cycle-like by F1, GLIB_001:def 31;
                            Dn1W is acyclic by CJ, GLIB_002:def 3;
                            hence contradiction by G1, GLIB_002:def 2;
                        end;
                        hence WT' is open;
                    end;
                    hence WT' is trivial or WT' is open;
                    WT'.vertices() = WT.vertices() by GLIB_001:99; then
                E3: not target in WT'.vertices() by TU,XBOOLE_0:def 4,B7;
                    let n be odd Nat; assume 1 < n & n <= len WT';
                    hence WT'.n <> target by E3, GLIB_001:88;
                end; then reconsider W2 as DPath of Dn1W by GLIB_001:151;
                take W2;
                thus W2 is_Walk_from src,target by CI, D2, GLIB_001:67;
                reconsider W2G = W2 as DWalk of G by GLIB_001:176;
                now
                E1: WT'.last() = source by D2, GLIB_001:def 23;
                E2: e in the_Edges_of Dn1W &
                      (the_Source_of Dn1W).e = source by CH, GLIB_000:def 16;
                    hence e in WT'.last().edgesInOut() by E1,GLIB_000:64;
                    (the_Weight_of Dn1W).e =
                      ((the_Weight_of G) | the_Edges_of Dn1W).e
                        by GLIB_003:def 10;
                    hence ec = (the_Weight_of Dn1W).e by BY,E2,FUNCT_1:72;
                E3: pc = G.min_DPath_cost(src,source) by B1,CC,BZ;
                    reconsider WTG = WT as DPath of G by GLIB_001:176;
                E6: WTG is_Walk_from src,source by D1, GLIB_001:20; then
                    consider WX being DPath of G such that
                E7: WX is_mincost_DPath_from src,source & pc = WX.cost()
                      by E3, dWGMINDCOST;
                    WX is_Walk_from src,source & for WY being DPath of G
                      st WY is_Walk_from src,source holds
                      pc <= WY.cost() by E7, dWMINCOSTD; then
                    WT.cost() <= pc by D1,E7; then
                EB: WT'.cost() <= pc by CB, GLIB_003:34;
                    pc <= WTG.cost() by E6, E7, dWMINCOSTD; then
                    pc <= WT'.cost() by GLIB_003:34;
                    hence WT'.cost() = pc by EB, AXIOMS:21;
                end;
                hence W2.cost() = pc + ec by GLIB_003:32;
            end; then consider W2 being DPath of Dn1W such that
        CK: W2 is_Walk_from src,target & W2.cost() = pc+ec;
            reconsider W2G = W2 as DPath of G by GLIB_001:176;
        CM: W2G is_Walk_from src, target by CK, GLIB_001:20;
        CN: W2G.cost() = pc+ec by CK, GLIB_003:34;
        CO: src <> target by B4, B5,TU,XBOOLE_0:def 4;
            set mc = G.min_DPath_cost(src,target);            
            now consider WB being DPath of G such that
            D1: WB is_mincost_DPath_from src,target & mc = WB.cost()
                  by CM, dWGMINDCOST;
            D2: WB is_Walk_from src,target & for WA being DPath of G
                  st WA is_Walk_from src,target holds WB.cost() <= WA.cost()
                  by D1, dWMINCOSTD;                  
                thus mc <= pc+ec by D1, CM, CN, dWMINCOSTD;
                WB.first() = src & WB.last() = target
                  by D2, GLIB_001:def 23; then
                WB is non trivial by CO, GLIB_001:128; then
                consider lenWB_2 being odd Nat such that
            D3: lenWB_2 = len WB - 2 &
                  WB.cut(1,lenWB_2).addEdge(WB.(lenWB_2+1)) = WB
                  by GLIB_001:134;
                set WA = WB.cut(1,lenWB_2);
                set sa = WB.lenWB_2, ea = WB.(lenWB_2+1);
            D4: 1 <= lenWB_2 & 1 is odd by HEYTING3:1, JORDAN12:3;
            D5: lenWB_2 < len WB - 0 by D3, REAL_1:92;
            D6: WB.1 = WB.first() by GLIB_001:def 6
                    .= src by D2, GLIB_001:def 23; then
                WA is_Walk_from src,sa by D4, D5, GLIB_001:38; then
                reconsider sa as Vertex of G by GLIB_001:19;
                reconsider target'=target as Vertex of G by D2,GLIB_001:19;
            D7: ea DJoins sa, WB.(lenWB_2+2), G by D5, GLIB_001:123; then
                ea DJoins sa, WB.last(), G by D3,GLIB_001:def 7; then
            D8: ea DJoins sa, target, G by D2, GLIB_001:def 23; then
                ea Joins sa,target',G by GLIB_000:19; then
                ea in sa.edgesInOut() by GLIB_000:65; then
            D9: ea in WA.last().edgesInOut() by D4,D5,GLIB_001:38; then
            DA: mc = WA.cost() + (the_Weight_of G).ea by D1, D3, GLIB_003:32;
            DB: WA.first() = src & WA.last() = sa by D6,D4,D5,GLIB_001:38; then
            DC: WA is_mincost_DPath_from src,sa by D1, tWGMINDCOST01; then
            DD: WA.cost() = G.min_DPath_cost(src,sa) by tWGMINDCOST03;
            DE: ea DJoins sa, target, Dn by BY, D8, GLIB_000:91;
                now assume
                E1: mc < pc+ec;
                    defpred P[Nat] means $1 is odd & $1 <= len WA &
                      not WA.$1 in Dn.labeledV();
                E2: now assume
                    F1: not sa in Dn.labeledV(); 
                        sa = WA.last() by D4,D5,GLIB_001:38
                          .= WA.(len WA) by GLIB_001:def 7; then
                    F2: ex k being Nat st P[k] by F1;
                        consider k being Nat such that
                    F3: P[k] & for m being Nat st P[m] holds k <= m
                          from NAT_1:sch 5(F2);
                        reconsider k as odd Nat by F3;
                        WA.1 = WA.first() by GLIB_001:def 6
                            .= src by D6, D4, D5, GLIB_001:38; then
                    F4: k <> 1 by B4, B5, F3;
                        1 <= k by HEYTING3:1; then
                        1 < k by F4, REAL_1:def 5; then
                        1+1 < k+1 by REAL_1:67; then
                        2 <= k by NAT_1:38; then
                        reconsider k_2 = k-2*1 as odd Nat by INT_1:18;
                        set sk = WA.k_2, ek = WA.(k_2+1), tk = WA.k;
                    F5: 1 is odd & 1 <= k_2 & k_2 < len WA - 0
                          by F3, REAL_1:92, HEYTING3:1, JORDAN12:3;
                        k_2 < k - 0 by REAL_1:92; then
                    F6: sk in Dn.labeledV() by F3, F5; then
                        reconsider sk as Vertex of G by BY,GLIB_000:def 36;
                        reconsider tk as Vertex of G by F3, GLIB_001:8;
                        set WK1 = WA.cut(1,k_2), WK2 = WA.cut(k_2,len WA);
                        set WKA = WA.cut(1,k), WKB = WA.cut(k,len WA);
                        tk = WA.(k_2+2); then
                    F7: ek DJoins sk,tk,G by F5, GLIB_001:123; then
                        ek DJoins sk,tk,Dn by BY, GLIB_000:91; then
                    F8: ek in the_Edges_of Dn & (the_Source_of Dn).ek = sk &
                        (the_Target_of Dn).ek = tk by GLIB_000:def 16;
                    F9: WK1.first() = WA.1 & WK1.last() = sk by F5,GLIB_001:38;
                        WK1 is_mincost_DPath_from WA.1, sk
                          by DC, F9, tWGMINDCOST01; then
                        WK1 is_mincost_DPath_from WA.first(),sk
                          by GLIB_001:def 6; then
                        G.min_DPath_cost(src,sk) = WK1.cost()
                          by DB, tWGMINDCOST03; then
                    FZ: (the_VLabel_of Dn).sk = WK1.cost() by B1, F6;
                        tk in the_Vertices_of Dn by F8, GLIB_000:6; then
                        tk in the_Vertices_of Dn \ Dn.labeledV()
                          by F3, XBOOLE_0:def 4; then
                        ek DSJoins Dn.labeledV(),the_Vertices_of Dn \
                          Dn.labeledV(),Dn by F8,F6,GLIB_000:def 18; then
                    FA: pc+ec <= WK1.cost() + (the_Weight_of G).ek
                          by BY,FZ,C0,dDIJKNEXT,F8;
                        k_2 + 2 = k; then
                    FB: WK1.addEdge(ek) = WKA by F5, GLIB_001:42;
                        ek in the_Edges_of G & (the_Source_of G).ek = sk &
                          (the_Target_of G).ek = tk by F7,GLIB_000:def 16; then
                        ek in sk.edgesInOut() by GLIB_000:64; then
                    FC: pc+ec <= WKA.cost() by F9, FA, FB, GLIB_003:32;
                    FD: 1 <= k & k <= len WA by HEYTING3:1, F3; then
                    FE: WKA.append(WKB) = WA.cut(1,len WA)
                                          by JORDAN12:3,GLIB_001:39
                                       .= WA by GLIB_001:40;
                        WKB.first() = WA.k by F3, GLIB_001:38
                                   .= WKA.last()
                        by FD,JORDAN12:3, GLIB_001:38; then
                    FF: WA.cost() = WKA.cost() + WKB.cost() by FE,GLIB_003:31;
                        0 <= WKB.cost() by GLIB_003:36; then
                        0 + WKA.cost() <= WA.cost() by FF, REAL_1:55; then
                    FG: pc+ec <= WA.cost() by FC, AXIOMS:22;
                        ea in the_Edges_of G by D7, GLIB_000:def 16; then
                        0 <= (the_Weight_of G).ea by GLIB_003:38; then
                        pc+ec+0 <= WA.cost()+(the_Weight_of G).ea
                          by FG, REAL_1:55;
                        hence contradiction by D9,D1,D3,GLIB_003:32,E1;
                    end;
                E3: WA.cost() = (the_VLabel_of Dn).sa by E2, DD, B1;
                E4: ea in the_Edges_of Dn & (the_Source_of Dn).ea = sa &
                      (the_Target_of Dn).ea=target by DE,GLIB_000:def 16; then
                    ea DSJoins Dn.labeledV(), the_Vertices_of Dn \
                      Dn.labeledV(),Dn by E2,TU,GLIB_000:def 18;
                    hence contradiction by DA, E1,E3,BY,C0,dDIJKNEXT, E4;
                end;
                hence mc >= pc+ec;
            end; then
        CX: G.min_DPath_cost(src,target) = pc+ec by AXIOMS:21;
            now let x be Vertex of Dn1W; 
                now per cases by C4, XBOOLE_0:def 2;
                suppose x in Dn.labeledV(); then
                    reconsider x'=x as Vertex of DnW by Bz,BU,GLIB_000:def 39;
                    DnW is_mincost_DTree_rooted_at src by B1; then
                    consider W2 being DPath of DnW such that
                E1: W2 is_Walk_from src,x' &
                    for W1 being DPath of G st W1 is_Walk_from src,x'
                      holds W2.cost() <= W1.cost() by dGMINCOSTDTREE;
                    reconsider W2'=W2 as DPath of Dn1W by CA, GLIB_001:176;
                    take W2';
                    thus W2' is_Walk_from src,x by E1, GLIB_001:20;
                    let W1 be DPath of G; assume
                    W1 is_Walk_from src,x; then
                    W2.cost() <= W1.cost() by E1;
                    hence W2'.cost() <= W1.cost() by CB,GLIB_003:34; end;
                suppose
                E1: x in {target}; then
                E2: x = target by TARSKI:def 1;
                    take W2;
                    thus W2 is_Walk_from src,x by CK, E1, TARSKI:def 1;
                    let W1 be DPath of G; assume
                E3: W1 is_Walk_from src,x;
                    consider WX being DPath of G such that
                E4: WX is_mincost_DPath_from src, target & WX.cost()=W2.cost()
                       by CM, CK, CX, dWGMINDCOST;
                    thus W2.cost() <= W1.cost() by E2,E3,E4,dWMINCOSTD; end;
                end;
                hence ex W2 being DPath of Dn1W st W2 is_Walk_from src,x &
                  for W1 being DPath of G st W1 is_Walk_from src,x
                  holds W2.cost() <= W1.cost();
            end;
            hence Dn1W is_mincost_DTree_rooted_at src by CJ, dGMINCOSTDTREE;
            let v be Vertex of G; assume
        CK: v in Dn1.labeledV();
            now per cases by C3, CK, XBOOLE_0:def 2;
            suppose
            D1: v in Dn.labeledV(); then
            D2: G.min_DPath_cost(src,v) = (the_VLabel_of DnE).v by CT, B1;
            D3: the_VLabel_of Dn1 = (the_VLabel_of DnE)+*(target .-->(pc+ec))
                  by C1, CZ, GLIB_003:45;
            D4: dom (target .--> (pc+ec)) = {target} by CQC_LANG:5; then
            D5: not v in dom (target .-->(pc+ec)) by C5, D1, TARSKI:def 1; then
                v in DnE.labeledV() by D4,CK, ZX, XBOOLE_0:def 2; then
                v in dom (the_VLabel_of DnE) by GLIB_003:def 23; then
                v in dom (the_VLabel_of DnE)\/{target} by XBOOLE_0:def 2;
                hence G.min_DPath_cost(src,v)=(the_VLabel_of Dn1).v
                  by D2,D3, D4, D5, FUNCT_4:def 1; end;
            suppose
            D1: v in {target}; then
            D2: v = target by TARSKI:def 1;
            D3: the_VLabel_of Dn1 = (the_VLabel_of DnE)+*(target .-->(pc+ec))
                  by C1, CZ, GLIB_003:45;
            D4: dom (target .--> (pc+ec)) = {target} by CQC_LANG:5; then
                v in dom (the_VLabel_of DnE) \/ dom (target .--> (pc+ec))
                  by D1, XBOOLE_0:def 2; then
                (the_VLabel_of Dn1).v = (target .--> (pc+ec)).v
                  by D1, D3, D4, FUNCT_4:def 1;
                hence G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v
                  by CX,D2,CQC_LANG:6; end;
            end;
            hence G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v; end;
         end;
         hence Dn1W is_mincost_DTree_rooted_at src &
         for v being Vertex of G st v in Dn1.labeledV()
           holds G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v;
    end; then
A5: for k being Nat st P[k] holds P[k+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A4,A5);
    hence thesis;          
end;
      
theorem tDIJK01: ::tDIJK01
  for G being finite real-weighted WGraph, src being Vertex of G
    holds DIJK:CompSeq(G,src) is halting
proof
    let G be finite real-weighted WGraph, src be Vertex of G;    
    set DCS = DIJK:CompSeq(G, src);
    now take n = card G.reachableDFrom(src);
        set Gn = DCS.->n, Gn_1 = DCS.->(n+1), VGn = the_VLabel_of Gn;
        set BestEdges = DIJK:NextBestEdges(Gn), e = choose BestEdges;
        set NextEG = Gn.labelEdge(e, 1), target = (the_Target_of Gn).e;
        set RSize = card G.reachableDFrom(src);
        set pc = (the_VLabel_of Gn).((the_Source_of Gn).e);
        set ec = (the_Weight_of Gn).e;
    B1: Gn_1 = DIJK:Step(Gn) by dDIJKCS;
        now per cases;
        suppose BestEdges = {};
            hence DCS.->n = DCS.->(n+1) by B1, dDIJKSTEP; end;
        suppose
        C1: BestEdges <> {};
        C2: Card (DCS.->n).labeledV() = min(n+1, RSize) by tDCS06;
            RSize <= RSize + 1 by NAT_1:29; then
        C3: card Gn.labeledV() = RSize by C2, SQUARE_1:def 1;
        C4: card (DIJK:Step(Gn)).labeledV() = 
              card Gn.labeledV() + 1 by C1, tDSTEP01;
        C5: RSize + 1 <= RSize + 1 + 1 by NAT_1:29;
            RSize <= (RSize+1) by NAT_1:29; then
        C6: RSize <= (n + 1) + 1 by C5, AXIOMS:22;
            card Gn_1.labeledV() = min((n+1)+1, RSize) by tDCS06
                                 .= RSize by C6, SQUARE_1:def 1;
            hence DCS.->n = DCS.->(n+1) by C3, C4, dDIJKCS; end;
        end;
        hence DCS.->n = DCS.->(n+1);
    end;
    hence thesis by GLIB_000:def 68;
end;

registration let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(G,src) -> halting;
  coherence by tDIJK01;
end;  

theorem tDIJK02: ::tDIJK02
  for G being finite real-weighted WGraph, src being Vertex of G holds
    DIJK:CompSeq(G,src).Lifespan() + 1 = card G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src), RFS = G.reachableDFrom(src);
    src in RFS by GLIB_002:18; then
    {src} c= RFS by ZFMISC_1:37; then
    card {src} <= card RFS by CARD_1:80; then
    card RFS <> 0 by CARD_1:79; then
    consider k being Nat such that
A2: card RFS = k + 1 by NAT_1:22;
    set Gk = DCS.->k, Gk1 = DCS.->(k+1);
A3: Gk1 = DIJK:Step(Gk) by dDIJKCS;
A4: card Gk1.labeledV() = min(card RFS+1, card RFS) by A2, tDCS06;
A5: card RFS <= card RFS + 1 by NAT_1:29;
    card Gk.labeledV() = min(card RFS, card RFS) by A2, tDCS06; then
    card Gk1.labeledV() = card Gk.labeledV() by A4, A5, SQUARE_1:def 1; then
    DIJK:NextBestEdges(Gk) = {} by A3, tDSTEP01; then
A6: DCS.->k = DCS.->(k+1) by A3, dDIJKSTEP;
A7: DCS.k = DCS.->(k+1) by A6, GLIB_000:def 59
         .= DCS.(k+1) by GLIB_000:def 59;
    now let n be Nat; assume
    B1: DCS.n = DCS.(n+1); set Gn = DCS.->n, Gn1 = DCS.->(n+1);
    B2: DCS.->n = DCS.(n+1) by B1, GLIB_000:def 59
               .= DCS.->(n+1) by GLIB_000:def 59;
        now assume n < k; then
        C1: n + 1 < card RFS by A2, REAL_1:67;
            card Gn.labeledV() = min(n+1, card RFS) by tDCS06; then
        C2: card Gn.labeledV() = n+1 by C1, SQUARE_1:def 1;
        C3: card Gn1.labeledV() = min(n+1+1, card RFS) by tDCS06;
            n + 1 + 1 <= card RFS by C1, NAT_1:38; then
            0+(n+1) = 1+(n+1) by B2, C2, C3, SQUARE_1:def 1;
            hence contradiction by XCMPLX_1:2;
        end;
        hence k <= n;
    end; 
    hence DIJK:CompSeq(G,src).Lifespan() + 1 = card RFS
      by A2, A7, GLIB_000:def 57;
end;

theorem tDIJK03: ::tDIJK03
  for G being finite real-weighted WGraph, src being Vertex of G
    holds DIJK:SSSP(G,src).labeledV() = G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set Gn = DIJK:SSSP(G, src), RFS = G.reachableDFrom(src);
    set DCS = DIJK:CompSeq(G,src), n = DCS.Lifespan();
    Gn = DCS.Result() by dDIJKSSSP; then
    Gn = DCS.n by GLIB_000:def 58; then
A1: Gn = DCS.->n by GLIB_000:def 59; then
A2: card Gn.labeledV() = min(n+1, card RFS) by tDCS06
                             .= min(card RFS, card RFS) by tDIJK02
                             .= card RFS;
    now assume
    B1: Gn.labeledV() <> RFS;
        Gn.labeledV() c= RFS by A1, tDCS03; then
        Gn.labeledV() c< RFS by B1, XBOOLE_0:def 8;
        hence contradiction by A2, TREES_1:24;
    end; 
    hence thesis;
end;

theorem ::tDIJK04
  for G being finite nonnegative-weighted WGraph, src being Vertex of G,
     G2 being inducedWSubgraph of G, DIJK:SSSP(G,src).labeledV(),
                                     DIJK:SSSP(G,src).labeledE() holds
     G2 is_mincost_DTree_rooted_at src &
     for v being Vertex of G st v in G.reachableDFrom(src) holds
       v in the_Vertices_of G2 &
       G.min_DPath_cost(src,v) = (the_VLabel_of DIJK:SSSP(G,src)).v
proof
    let G be finite nonnegative-weighted WGraph, src be Vertex of G,
        G2 be inducedWSubgraph of G, DIJK:SSSP(G,src).labeledV(),
                                     DIJK:SSSP(G,src).labeledE();
    set Res = DIJK:SSSP(G,src), DCS = DIJK:CompSeq(G,src);
A1: Res = DCS.Result() by dDIJKSSSP
       .= DCS.(DCS.Lifespan()) by GLIB_000:def 58
       .= DCS.->(DCS.Lifespan()) by GLIB_000:def 59;
    hence G2 is_mincost_DTree_rooted_at src by tDCS08;                     
    let v being Vertex of G; assume
A2: v in G.reachableDFrom(src); then
A3: v in Res.labeledV() by tDIJK03;
A4: G == Res by A1, tDCS02;
A5: Res.labeledV() is non empty Subset of the_Vertices_of G
      by A2,tDIJK03;
    G.edgesBetween(Res.labeledV()) =
      Res.edgesBetween(Res.labeledV()) by A4,GLIB_000:93; then
    Res.labeledE() c= G.edgesBetween(Res.labeledV()) 
      by A1, tDCS07;
    hence v in the_Vertices_of G2 by A3,A5,GLIB_000:def 39;
    thus thesis by A1,A3,tDCS08;
end;       

begin :: Prim's Algorithm preliminaries

definition
  func WGraphSelectors -> non empty finite Subset of NAT equals :dWGRAPHSEL: ::dWGRAPHSEL
    {VertexSelector, EdgeSelector, SourceSelector, TargetSelector,
     WeightSelector};
  coherence by ENUMSET1:def 3;
end;

lWGRAPHSEL02:
  for G being WGraph holds
    WGraphSelectors c= dom G
proof
    let G be WGraph;
    now let x be set; assume x in WGraphSelectors; then
        x = VertexSelector or x = EdgeSelector or
        x = SourceSelector or x = TargetSelector or
        x = WeightSelector by dWGRAPHSEL, ENUMSET1:def 3;
        hence x in dom G by GLIB_000:def 11, GLIB_003:def 4;
    end;
    hence thesis by TARSKI:def 3;
end;    

registration let G be WGraph;
  cluster G.strict(WGraphSelectors) -> [Graph-like] [Weighted];
  coherence
  proof
    set G2 = G.strict(WGraphSelectors);
A1: G2 = G | WGraphSelectors by GLIB_000:def 14;
A2: WGraphSelectors c= dom G by lWGRAPHSEL02;
A3: dom G2 = dom G /\ WGraphSelectors by A1,RELAT_1:90
          .= WGraphSelectors by A2, XBOOLE_1:28;
A4: VertexSelector in WGraphSelectors &
    EdgeSelector   in WGraphSelectors &
    SourceSelector in WGraphSelectors &
    TargetSelector in WGraphSelectors &
    WeightSelector in WGraphSelectors by dWGRAPHSEL, ENUMSET1:def 3;
A5: the_Vertices_of G2 = G2.VertexSelector by GLIB_000:4
                      .= G.VertexSelector by A1,A4,FUNCT_1:72
                      .= the_Vertices_of G by GLIB_000:4;
A6: the_Edges_of G2 = G2.EdgeSelector by GLIB_000:4
                   .= G.EdgeSelector by A1,A4,FUNCT_1:72
                   .= the_Edges_of G by GLIB_000:4;
A7: the_Source_of G2 = G2.SourceSelector by GLIB_000:4
                    .= G.SourceSelector by A1,A4,FUNCT_1:72
                    .= the_Source_of G by GLIB_000:4;
A8: the_Target_of G2 = G2.TargetSelector by GLIB_000:4
                    .= G.TargetSelector by A1,A4,FUNCT_1:72
                    .= the_Target_of G by GLIB_000:4;
    for x being set st x in _GraphSelectors holds x in dom G2
      by GLIB_000:2,A3,A4; then
    _GraphSelectors c= dom G2 by TARSKI:def 3;
    hence G2 is [Graph-like] by A5,A6,A7,A8,GLIB_000:7;
    G2.WeightSelector = G.WeightSelector by A1,A4,FUNCT_1:72; then
    G2.WeightSelector is ManySortedSet of the_Edges_of G2
      by A6, GLIB_003:def 4;
    hence G2 is [Weighted] by A3,A4,GLIB_003:def 4;
  end;
end;

lWSSEL01:
  for G being WGraph holds
    G == (G.strict(WGraphSelectors)) &
    the_Weight_of G = the_Weight_of (G.strict(WGraphSelectors))
proof
    let G be WGraph; set G2 = G.strict(WGraphSelectors);
A1: G2 = G | WGraphSelectors by GLIB_000:def 14;
A2: VertexSelector in WGraphSelectors &
    EdgeSelector   in WGraphSelectors &
    SourceSelector in WGraphSelectors &
    TargetSelector in WGraphSelectors &
    WeightSelector in WGraphSelectors by dWGRAPHSEL, ENUMSET1:def 3;
A3: the_Vertices_of G2 = G2.VertexSelector by GLIB_000:4
                      .= G.VertexSelector by A1,A2,FUNCT_1:72
                      .= the_Vertices_of G by GLIB_000:4;
A4: the_Edges_of G2 = G2.EdgeSelector by GLIB_000:4
                      .= G.EdgeSelector by A1,A2,FUNCT_1:72
                      .= the_Edges_of G by GLIB_000:4;
A5: the_Source_of G2 = G2.SourceSelector by GLIB_000:4
                      .= G.SourceSelector by A1,A2,FUNCT_1:72
                      .= the_Source_of G by GLIB_000:4;
    the_Target_of G2 = G2.TargetSelector by GLIB_000:4
                      .= G.TargetSelector by A1,A2,FUNCT_1:72
                      .= the_Target_of G by GLIB_000:4;
    hence G == G2 by A3,A4,A5,GLIB_000:def 36;
    thus the_Weight_of G2 = G2.WeightSelector by GLIB_003:def 7
                          .= G.WeightSelector by A1,A2,FUNCT_1:72
                          .= the_Weight_of G by GLIB_003:def 7;
end;

lWSSEL02:
  for G being WGraph holds
    dom (G.strict(WGraphSelectors)) = WGraphSelectors
proof
    let G be WGraph; set G2 = G.strict(WGraphSelectors);
A1: G2 = G | WGraphSelectors by GLIB_000:def 14;
    WGraphSelectors c= dom G by lWGRAPHSEL02;
    hence thesis by A1, RELAT_1:91;
end;    

definition let G be WGraph;
  func G.allWSubgraphs() -> non empty set means :dGALLWSUBG: ::dGALLWSUBG
    for x being set holds x in it iff
      ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors;
  existence
  proof
    set Z = {bool the_Vertices_of G, bool the_Edges_of G,
             bool the_Source_of G, bool the_Target_of G,
             bool the_Weight_of G};
    set Y = union Z;
    set X = Funcs(WGraphSelectors, Y);
    defpred P[set] means $1 is WSubgraph of G;
    consider IT being Subset of X such that
A1: for x being set holds x in IT iff x in X & P[x] from SUBSET_1:sch 1;
    set G' = G.strict(WGraphSelectors);
A2: G == G' & the_Weight_of G = the_Weight_of G' by lWSSEL01; then
    reconsider G' as [Weighted] Subgraph of G by GLIB_000:90;
    dom the_Weight_of G = the_Edges_of G'
      by A2,GLIB_003:5; then
    the_Weight_of G' = (the_Weight_of G) | the_Edges_of G'
      by A2,RELAT_1:98; then
    reconsider G' as WSubgraph of G by GLIB_003:def 10;
A3: dom G' = WGraphSelectors by lWSSEL02;
A4: now let G2 be WSubgraph of G; assume
    B1: dom G2 = WGraphSelectors;
        now let y be set; assume y in rng G2; then
            consider x being set such that
        C2: x in WGraphSelectors & G2.x = y by B1,FUNCT_1:def 5;
            now per cases by C2, dWGRAPHSEL, ENUMSET1:def 3;
            suppose x = VertexSelector; then
            D2: y = the_Vertices_of G2 by C2,GLIB_000:4;
                bool the_Vertices_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            suppose x = EdgeSelector; then
            D2: y = the_Edges_of G2 by C2,GLIB_000:4;
                bool the_Edges_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            suppose x = SourceSelector; then
                y = the_Source_of G2 by C2,GLIB_000:4; then
                y = (the_Source_of G) | the_Edges_of G2 by GLIB_000:48; then
            D2: y c= the_Source_of G by RELAT_1:88;
                bool the_Source_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            suppose x = TargetSelector; then
                y = the_Target_of G2 by C2,GLIB_000:4; then
                y = (the_Target_of G) | the_Edges_of G2 by GLIB_000:48; then
            D2: y c= the_Target_of G by RELAT_1:88;
                bool the_Target_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            suppose x = WeightSelector; then
                y = the_Weight_of G2 by C2,GLIB_003:def 7; then
                y = (the_Weight_of G) | the_Edges_of G2 by GLIB_003:def 10;then
            D2: y c= the_Weight_of G by RELAT_1:88;
                bool the_Weight_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            end;
            hence y in Y;
        end;
        hence rng G2 c= Y by TARSKI:def 3;
    end; then
    rng G' c= Y by A3; then
    G' in X by A3, FUNCT_2:def 2; then
    reconsider IT as non empty set by A1;
    take IT;
    let x be set;
    hereby assume
    B1: x in IT; then
        reconsider x' = x as WSubgraph of G by A1;
        take x';
        thus x' = x;
        consider f being Function such that
    B2: f = x & dom f = WGraphSelectors & rng f c= Y by B1,FUNCT_2:def 2;
        thus dom x' = WGraphSelectors by B2;
    end;
    given G2 being WSubgraph of G such that
A5: G2 = x & dom G2 = WGraphSelectors;
    rng G2 c= Y by A4,A5; then
    x in X by A5, FUNCT_2:def 2;
    hence x in IT by A1,A5;
  end;
  uniqueness proof
    let IT1,IT2 be non empty set such that
A1: for x being set holds x in IT1 iff
      ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors and
A2: for x being set holds x in IT2 iff
      ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors;
    now let x be set;
        x in IT1 iff ex G2 being WSubgraph of G
          st x = G2 & dom G2 = WGraphSelectors by A1;
        hence x in IT1 iff x in IT2 by A2;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;
       
registration let G be finite WGraph;
  cluster G.allWSubgraphs() -> finite;
  coherence proof
    set Z = {bool the_Vertices_of G, bool the_Edges_of G,
             bool the_Source_of G, bool the_Target_of G,
             bool the_Weight_of G}, Y = union Z;
    for x being set st x in Z holds x is finite by ENUMSET1:def 3; then
    reconsider Y as finite set by FINSET_1:25;
    set X = Funcs(WGraphSelectors, Y);
A1: X is finite by FRAENKEL:16;
    now let x be set; assume x in G.allWSubgraphs(); then
        consider G2 being WSubgraph of G such that
    B1: x = G2 & dom G2 = WGraphSelectors by dGALLWSUBG;
        now let y be set; assume y in rng G2; then
            consider x being set such that
        C2: x in WGraphSelectors & G2.x = y by B1,FUNCT_1:def 5;
            now per cases by C2, dWGRAPHSEL, ENUMSET1:def 3;
            suppose x = VertexSelector; then
            D2: y = the_Vertices_of G2 by C2,GLIB_000:4;
                bool the_Vertices_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            suppose x = EdgeSelector; then
            D2: y = the_Edges_of G2 by C2,GLIB_000:4;
                bool the_Edges_of G in Z by ENUMSET1:def 3;
                hence y in Y by D2, TARSKI:def 4;
                end;
            suppose x = SourceSelector; then
                y = the_Source_of G2 by C2,GLIB_000:4; then
                y = (the_Source_of G) | the_Edges_of G2 by GLIB_000:48; then
            D1: y c= the_Source_of G by RELAT_1:88;
                bool the_Source_of G in Z by ENUMSET1:def 3;
                hence y in Y by D1, TARSKI:def 4;
                end;
            suppose x = TargetSelector; then
                y = the_Target_of G2 by C2,GLIB_000:4; then
                y = (the_Target_of G) | the_Edges_of G2 by GLIB_000:48; then
            D1: y c= the_Target_of G by RELAT_1:88;
                bool the_Target_of G in Z by ENUMSET1:def 3;
                hence y in Y by D1, TARSKI:def 4;
                end;
            suppose x = WeightSelector; then
                y = the_Weight_of G2 by C2,GLIB_003:def 7; then
                y = (the_Weight_of G) | the_Edges_of G2 by GLIB_003:def 10;then
            D1: y c= the_Weight_of G by RELAT_1:88;
                bool the_Weight_of G in Z by ENUMSET1:def 3;
                hence y in Y by D1,TARSKI:def 4;
                end;
            end;
            hence y in Y;
        end; then
        rng G2 c= Y by TARSKI:def 3;
        hence x in X by B1,FUNCT_2:def 2;
    end; then
    G.allWSubgraphs() c= X by TARSKI:def 3;
    hence thesis by A1, FINSET_1:13;
  end;
end;

definition let G be WGraph, X be non empty Subset of G.allWSubgraphs();
  redefine mode Element of X -> WSubgraph of G;
  coherence
  proof
    let x be Element of X;
    consider G2 being WSubgraph of G such that
A1: G2 = x & dom G2 = WGraphSelectors by dGALLWSUBG;
    thus thesis by A1;    
  end;
end;  

definition let G be finite real-weighted WGraph;
  func G.cost() -> Real equals :dWGCOST: ::dWGCOST
    Sum the_Weight_of G;
  coherence by XREAL_0:def 1;
end;

theorem ::tWGRAPHSEL01
  for x being set holds x in WGraphSelectors iff
  (x = VertexSelector or x = EdgeSelector or
   x = SourceSelector or x = TargetSelector or
   x = WeightSelector) by dWGRAPHSEL, ENUMSET1:def 3;

theorem ::tWGRAPHSEL02
  for G being WGraph holds
    WGraphSelectors c= dom G by lWGRAPHSEL02;

theorem ::tWSSEL01
  for G being WGraph holds
    G == (G.strict(WGraphSelectors)) &
    the_Weight_of G = the_Weight_of (G.strict(WGraphSelectors)) by lWSSEL01;

theorem ::tWSEL02
  for G being WGraph holds
    dom (G.strict(WGraphSelectors)) = WGraphSelectors by lWSSEL02;

theorem ::tGCOST01
  for G being finite real-weighted WGraph st the_Edges_of G = {} holds
    G.cost() = 0
proof
    let G be finite real-weighted WGraph; assume the_Edges_of G = {}; then
    dom (the_Edges_of G --> 0) = {} &
    dom the_Weight_of G = {} by GLIB_003:5, FUNCOP_1:16; then
    the_Weight_of G = the_Edges_of G --> 0 by FUNCOP_1:4; then
    the_Weight_of G = EmptyBag the_Edges_of G by POLYNOM1:def 15; then
    Sum the_Weight_of G = 0 by UPROOTS:13;
    hence thesis by dWGCOST;
end;

theorem tGCOST02: ::tGCOST02
  for G1,G2 being finite real-weighted WGraph
   st the_Edges_of G1 = the_Edges_of G2 & the_Weight_of G1 = the_Weight_of G2
   holds G1.cost() = G2.cost()
proof
    let G1,G2 be finite real-weighted WGraph; assume
    the_Edges_of G1 = the_Edges_of G2 & the_Weight_of G1 = the_Weight_of G2;
    hence G1.cost() = Sum the_Weight_of G2 by dWGCOST
                   .= G2.cost() by dWGCOST;
end;

theorem tGCOST03: ::tGCOST03
  for G1 being finite real-weighted WGraph, e being set,
      G2 being weight-inheriting ([Weighted] removeEdge of G1,e)
   st e in the_Edges_of G1 holds
      G1.cost() = G2.cost() + (the_Weight_of G1).e
proof
    let G1 be finite real-weighted WGraph, e be set,
        G2 be weight-inheriting ([Weighted] removeEdge of G1,e);
    set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2; assume
A1: e in EG1;
A2: G1.cost() = Sum the_Weight_of G1 by dWGCOST;
A3: G2.cost() = Sum the_Weight_of G2 by dWGCOST;
A4: EG2 = EG1 \ {e} by GLIB_000:54;
A5: the_Weight_of G2 = (the_Weight_of G1) | (EG2)
      by GLIB_003:def 10;
    set b2 = (e .--> (the_Weight_of G1).e);
A6: dom b2 = {e} & rng b2 = {(the_Weight_of G1).e} by CQC_LANG:5;
    EG1 \ EG2 = EG1 /\ {e} by A4, XBOOLE_1:48
             .= {e} by A1, ZFMISC_1:52; then
    reconsider b2 as ManySortedSet of EG1 \ EG2 by A6, PBOOLE:def 3;
    reconsider b2 as Rbag of EG1 \ EG2 by SEQ_1:def 1,A6;
A8: dom (the_Weight_of G2 +* b2) = dom the_Weight_of G2 \/ {e}
                                     by A6, FUNCT_4:def 1
                                .= (EG1 \ {e}) \/ {e} by A4,GLIB_003:5
                                .= EG1 \/ {e} by XBOOLE_1:39
                                .= EG1 by A1, ZFMISC_1:46;
A9: dom the_Weight_of G1 = EG1 by GLIB_003:5;
    now let x be set; assume x in dom the_Weight_of G1; then
    B1: x in EG1 by GLIB_003:5;
        now per cases;
        suppose
        C1: x in {e}; then
        C2: x = e by TARSKI:def 1; 
            hence (the_Weight_of G2 +* b2).x = b2.e by C1,A6,FUNCT_4:14
                                           .= (the_Weight_of G1).x
                                                 by C2,CQC_LANG:6;
            end;
        suppose
        C1: not x in {e}; then
        C2: (the_Weight_of G2 +* b2).x = (the_Weight_of G2).x
              by FUNCT_4:12,A6;
            x in EG1 \ {e} by B1,C1, XBOOLE_0:def 4;
            hence (the_Weight_of G2 +* b2).x = (the_Weight_of G1).x
              by A4,A5,C2,FUNCT_1:72;
            end;
        end;
        hence (the_Weight_of G1).x = (the_Weight_of G2 +* b2).x;
    end; then
    the_Weight_of G1 = the_Weight_of G2 +* b2 by A8,A9,FUNCT_1:9;
    hence G1.cost() = G2.cost() + Sum b2 by A2,A3,tRBAGSUM01
                   .= G2.cost() + b2.e by A6,tRBAGSUM02
                   .= G2.cost() + (the_Weight_of G1).e by CQC_LANG:6;
end;

theorem tGCOST04: ::tGCOST04
  for G being finite real-weighted WGraph,
      V1 being non empty Subset of the_Vertices_of G,
      E1 being Subset of G.edgesBetween(V1),
      G1 being inducedWSubgraph of G,V1,E1, e being set,
      G2 being inducedWSubgraph of G,V1,E1 \/ {e}
   st not e in E1 & e in G.edgesBetween(V1)
   holds G1.cost() + (the_Weight_of G).e = G2.cost()
proof
    let G be finite real-weighted WGraph,
       V1 be non empty Subset of the_Vertices_of G,
       E1 be Subset of G.edgesBetween(V1),
       G1 be inducedWSubgraph of G,V1,E1, e being set,
       G2 be inducedWSubgraph of G,V1,E1 \/ {e}; assume
A1: not e in E1 & e in G.edgesBetween(V1);
A2: the_Vertices_of G1 = V1 & the_Edges_of G1 = E1 by GLIB_000:def 39;
    {e} c= G.edgesBetween(V1) by A1, ZFMISC_1:37; then
    (E1 \/ {e}) c= G.edgesBetween(V1) by XBOOLE_1:8; then
A3: the_Vertices_of G2 = V1 & the_Edges_of G2 = E1 \/ {e} by GLIB_000:def 39;
A4: G1.cost() = Sum the_Weight_of G1 & G2.cost() = Sum the_Weight_of G2
      by dWGCOST;
    set W2 = (e .--> (the_Weight_of G).e);
A5: the_Edges_of G2 \ the_Edges_of G1 = {e} \ E1 by A2,A3,XBOOLE_1:40
                                     .= {e} by A1,ZFMISC_1:67;
A6: dom W2 = {e} by CQC_LANG:5; then
    reconsider W2 as ManySortedSet of (the_Edges_of G2 \ the_Edges_of G1)
      by A5,PBOOLE:def 3;
    now let y be set; assume y in rng W2; then
        y in {(the_Weight_of G).e} by CQC_LANG:5;
        hence y in REAL;
    end; then
    rng W2 c= REAL by TARSKI:def 3; then
    reconsider W2 as Rbag of (the_Edges_of G2 \ the_Edges_of G1)
      by SEQ_1:def 1;
A7: dom the_Weight_of G2 = E1 \/ {e} by A3, GLIB_003:5;
A8: dom ((the_Weight_of G1) +* W2) = dom the_Weight_of G1 \/ dom W2
                                     by FUNCT_4:def 1
                                .= E1 \/ {e} by A2, A6,GLIB_003:5;
A9: the_Weight_of G1 = (the_Weight_of G) | E1 by A2, GLIB_003:def 10;
    now let x be set; assume x in dom the_Weight_of G2; then
    B1: x in E1 \/ {e} by A3,GLIB_003:5;
        the_Weight_of G2 = (the_Weight_of G) | (E1 \/ {e})
          by A3, GLIB_003:def 10; then
    B2: (the_Weight_of G2).x = (the_Weight_of G).x by B1, FUNCT_1:72;
        now per cases;
        suppose
        C1: not x in dom W2; then
        C2: ((the_Weight_of G1)+*W2).x = (the_Weight_of G1).x by FUNCT_4:12;
            x in E1 by A6, B1, C1, XBOOLE_0:def 2;
            hence ((the_Weight_of G1)+*W2).x = (the_Weight_of G2).x
              by A9,B2,C2,FUNCT_1:72; end;
        suppose
        C1: x in dom W2; then
        C2: x = e by A6,TARSKI:def 1;
            ((the_Weight_of G1)+*W2).x = W2.x by C1,FUNCT_4:14
                                      .= (the_Weight_of G).e by C2,CQC_LANG:6;
            hence ((the_Weight_of G1)+*W2).x = (the_Weight_of G2).x
              by B2,C1,A6,TARSKI:def 1;
            end;
        end;
        hence (the_Weight_of G2).x = ((the_Weight_of G1) +* W2).x;
    end; then
AA: the_Weight_of G2 = the_Weight_of G1 +* W2 by A7,A8,FUNCT_1:9;
    dom W2 = {e} by CQC_LANG:5; then
    Sum W2 = W2.e by tRBAGSUM02
          .= (the_Weight_of G).e by CQC_LANG:6;
    hence G1.cost() + (the_Weight_of G).e = G2.cost() by AA,A4,tRBAGSUM01;
end;

begin :: PRIM's Algorithm definitions

definition let G be real-weighted WVGraph;
  func PRIM:NextBestEdges(G) -> Subset of the_Edges_of G means :dPRIMNEXT: ::dPRIMNEXT
    for e1 being set holds e1 in it iff
      e1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).e1 <= (the_Weight_of G).e2;
  existence
  proof
   defpred P[set] means
      $1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).$1 <= (the_Weight_of G).e2;
    consider IT being Subset of the_Edges_of G such that
A1: for e1 being set holds e1 in IT iff e1 in the_Edges_of G & P[e1]
      from SUBSET_1:sch 1;
    take IT;
    let e1 be set;
    thus e1 in IT implies P[e1] by A1;
    assume
A2: P[e1]; then
    e1 in the_Edges_of G by GLIB_000:def 17;
    hence e1 in IT by A1,A2;
  end;
  uniqueness proof 
    let IT1, IT2 be Subset of the_Edges_of G such that
A1: for e1 being set holds e1 in IT1 iff
      e1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).e1 <= (the_Weight_of G).e2 and
A2: for e1 being set holds e1 in IT2 iff
      e1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).e1 <= (the_Weight_of G).e2;
    defpred P[set] means
      $1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
        st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
        holds (the_Weight_of G).$1 <= (the_Weight_of G).e2;
    now let e1 be set;
        hereby assume e1 in IT1; then
           P[e1] by A1;
           hence e1 in IT2 by A2;
        end;
        assume e1 in IT2; then
        P[e1] by A2;
        hence e1 in IT1 by A1;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end; 
end;

definition let G be real-weighted WGraph;
  func PRIM:Init(G) -> real-WEV WEVGraph equals :dPRIMINIT: ::dPRIMINIT
    G.set(VLabelSelector,(choose the_Vertices_of G).-->1)
     .set(ELabelSelector,{});
  coherence;
end;

definition let G be real-WEV WEVGraph;
  set e = choose PRIM:NextBestEdges(G);
  func PRIM:Step(G) -> real-WEV WEVGraph equals :dPRIMSTEP: ::dPRIMSTEP
    G if PRIM:NextBestEdges(G) = {},
    G.labelEdge(e,1).labelVertex((the_Target_of G).e,1)
      if PRIM:NextBestEdges(G) <> {} &
         (the_Source_of G).e in G.labeledV() otherwise
    G.labelEdge(e,1).labelVertex((the_Source_of G).e,1);
  coherence;
  consistency;
end;

definition let G be real-weighted WGraph;
  func PRIM:CompSeq(G) ->  real-WEV WEVGraphSeq means :dPRIMCS: ::dPRIMCS
    it.->0 = PRIM:Init(G) &
    for n being Nat holds it.->(n+1) = PRIM:Step(it.->n);
  existence
  proof
    defpred P[set,set,set] means
      ($2 is real-WEV WEVGraph &
          ex Gn,Gn1 being real-WEV WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = PRIM:Step(Gn)) or
      (not $2 is real-WEV WEVGraph & $2 = $3);
    now let n,x be set;
        now per cases;
        suppose x is real-WEV WEVGraph;
            then reconsider Gn=x as real-WEV WEVGraph;
            P[n,x,PRIM:Step(Gn)];
            hence ex y being set st P[n,x,y]; end;
        suppose not x is real-WEV WEVGraph; 
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A1: for n being Nat for x being set ex y being set st P[n,x,y];
A2: for n being Nat for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT &
    IT.0 = PRIM:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3, PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is real-WEV WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat; assume P2[n]; then
        consider Gn,Gn1 being real-WEV WEVGraph such that
    B2: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = PRIM:Step(Gn) by A3;
        thus P2[n+1] by B2;
    end;
A6: for n being Nat holds P2[n] from NAT_1:sch 1(A4,A5); then
    for n being Nat holds IT.n is _Graph; then
    reconsider IT as GraphSeq by GLIB_000:def 55;
A7: now let n be Nat;
        IT.->n = IT.n by GLIB_000:def 59;
        hence IT.->n is real-WEV WEVGraph by A6;
    end; then
    for n being Nat holds
      IT.->n is [Weighted] & IT.->n is [ELabeled] & IT.->n is [VLabeled]; then
    reconsider IT as WEVGraphSeq
      by GLIB_003:def 24, GLIB_003:def 25, GLIB_003:def 26;
    for n being Nat holds IT.->n is real-WEV by A7; then
    reconsider IT as real-WEV WEVGraphSeq by GLIB_003:def 31;
    take IT;
    thus IT.->0 = PRIM:Init(G) by A3,GLIB_000:def 59;
    let n be Nat;
    IT.n is real-WEV WEVGraph by A6; then
    consider Gn,Gn1 being real-WEV WEVGraph such that
A8: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = PRIM:Step(Gn) by A3;
    Gn = IT.->n & Gn1 = IT.->(n+1) by A8, GLIB_000:def 59;
    hence IT.->(n+1) = PRIM:Step(IT.->n) by A8;
  end; 
  uniqueness proof
    let IT1,IT2 be real-WEV WEVGraphSeq such that
A1: IT1.->0 = PRIM:Init(G) &
    for n being Nat holds IT1.->(n+1) = PRIM:Step(IT1.->n) and
A2: IT2.->0 = PRIM:Init(G) &
    for n being Nat holds IT2.->(n+1) = PRIM:Step(IT2.->n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
    IT1.0 = IT2.->0 by A1,A2,GLIB_000:def 59; then
A3: P[0] by GLIB_000:def 59;
    now let n be Nat; assume P[n]; then
        IT1.n = IT2.->n by GLIB_000:def 59; then
    B2: IT1.->n = IT2.-> n by GLIB_000:def 59;
        IT1.->(n+1) = PRIM:Step(IT2.->n) by B2, A1
                   .= IT2.->(n+1) by A2; then
        IT1.(n+1) = IT2.->(n+1) by GLIB_000:def 59;
        hence P[n+1] by GLIB_000:def 59;
    end; then
A4: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A3,A4); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite real-weighted WGraph;
  cluster PRIM:CompSeq(G) -> finite;
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
    defpred P[Nat] means PCS.->$1 is finite;
    (PCS.->0) = PRIM:Init(G) by dPRIMCS
             .= G.set(VLabelSelector,(choose the_Vertices_of G).-->1)
                 .set(ELabelSelector,{}) by dPRIMINIT; then
A1: P[0];
A2: now let n be Nat; assume P[n]; then
        reconsider Gn = (PCS.->n) as finite real-WEV WEVGraph;
        set Gn1 = PCS.->(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    B1: Gn1 = PRIM:Step(Gn) by dPRIMCS;
        now per cases;
        suppose Next = {};
            hence P[n+1] by B1,dPRIMSTEP;
            end;
        suppose Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
            Gn1 = Gn.labelEdge(e,1).labelVertex((the_Target_of Gn).e,1)
              by B1,dPRIMSTEP;
            hence P[n+1];
            end;
        suppose Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
            Gn1 = Gn.labelEdge(e,1).labelVertex((the_Source_of Gn).e,1)
              by B1,dPRIMSTEP;
            hence P[n+1];
            end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by GLIB_000:def 60;
  end; 
end;  

definition let G be real-weighted WGraph;
  func PRIM:MST(G) -> real-WEV WEVGraph equals :dPRIMMST: ::dPRIMMST
    PRIM:CompSeq(G).Result();    
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
    PCS.Result() = PCS.(PCS.Lifespan()) by GLIB_000:def 58
                .= PCS.->(PCS.Lifespan()) by GLIB_000:def 59;
    hence thesis;                
  end;
end;  

registration let G be finite real-weighted WGraph;
  cluster PRIM:MST(G) -> finite;
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
    PRIM:MST(G) = PCS.Result() by dPRIMMST
               .= PCS.(PCS.Lifespan()) by GLIB_000:def 58
               .= PCS.->(PCS.Lifespan()) by GLIB_000:def 59;
    hence thesis;               
  end;
end;  

lPRIMINIT01:
  for G being real-weighted WGraph holds
    G == PRIM:Init(G) &
    the_Weight_of G = the_Weight_of PRIM:Init(G) &
    the_ELabel_of PRIM:Init(G) = {} &
    the_VLabel_of PRIM:Init(G) = (choose the_Vertices_of G).-->1
proof
    let G be real-weighted WGraph; set G2 = PRIM:Init(G);
    set X = (choose the_Vertices_of G).-->1;
A1: G2 = G.set(VLabelSelector,X).set(ELabelSelector,{}) by dPRIMINIT;
A2: G == G.set(VLabelSelector,X) by GLIB_003:8;
    G.set(VLabelSelector,X) == G2 by A1,GLIB_003:8;
    hence G == G2 by A2, GLIB_000:88;
    thus the_Weight_of G2 = the_Weight_of G.set(VLabelSelector,X)
                              by A1,GLIB_003:11
                         .= the_Weight_of G by GLIB_003:13;
    thus the_ELabel_of G2 = G2.ELabelSelector
                              by GLIB_003:4
                         .= {} by A1,GLIB_000:11;
    the_VLabel_of G2 = the_VLabel_of G.set(VLabelSelector,X)
                         by A1,GLIB_003:12
                    .= G.set(VLabelSelector,X).VLabelSelector by GLIB_003:4
                    .= X by GLIB_000:11;
    hence thesis;
end;

lPRIMINIT02:
  for G being real-weighted WGraph holds
    PRIM:Init(G).labeledV() = {choose the_Vertices_of G} &
    PRIM:Init(G).labeledE() = {}
proof
    let G be real-weighted WGraph;
    thus PRIM:Init(G).labeledV() = dom the_VLabel_of PRIM:Init(G)
                                   by GLIB_003:def 23
                                .= dom ((choose the_Vertices_of G).-->1)
                                   by lPRIMINIT01
                                .= {choose the_Vertices_of G}
                                   by CQC_LANG:5;
    thus PRIM:Init(G).labeledE() = dom the_ELabel_of PRIM:Init(G)
                                   by GLIB_003:def 20
                                .= dom {} by lPRIMINIT01
                                .= {};
end;    

lPRIMSTEP02:
  for G being real-WEV WEVGraph st PRIM:NextBestEdges(G) <> {} holds
     ex v being Vertex of G st not v in G.labeledV() &
     PRIM:Step(G) = G.labelEdge(choose PRIM:NextBestEdges(G),1)
                     .labelVertex(v,1)
proof
    let G be real-WEV WEVGraph; set G2 = PRIM:Step(G); assume
A1: PRIM:NextBestEdges(G) <> {};
    set e = choose PRIM:NextBestEdges(G);
    set src = (the_Source_of G).e, tar = (the_Target_of G).e;
AZ: e in PRIM:NextBestEdges(G) by A1; 
A3: e SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
      by A1,dPRIMNEXT;
    reconsider src,tar as Vertex of G by GLIB_000:6,AZ;
    now per cases;
    suppose
    B1: src in G.labeledV();
        take tar;
        not src in the_Vertices_of G \ G.labeledV() by B1,XBOOLE_0:def 4; then
        tar in the_Vertices_of G \ G.labeledV() by A3,GLIB_000:def 17;
        hence not tar in G.labeledV() by XBOOLE_0:def 4;
        thus G2 = G.labelEdge(e,1).labelVertex(tar,1) by B1,A1,dPRIMSTEP; end;
    suppose
    B1: not src in G.labeledV();
        take src;
        thus not src in G.labeledV() by B1;
        thus G2 = G.labelEdge(e,1).labelVertex(src,1) by B1,A1,dPRIMSTEP; end;
    end;
    hence thesis;
end;

lPRIMSTEP01:
  for G being real-WEV WEVGraph holds
    G == PRIM:Step(G) & the_Weight_of G  = the_Weight_of PRIM:Step(G) &
    G.labeledE() c= PRIM:Step(G).labeledE() &
    G.labeledV() c= PRIM:Step(G).labeledV()
proof
    let G be real-WEV WEVGraph; set G2 = PRIM:Step(G);
    set Next = PRIM:NextBestEdges(G), e = choose Next, GE = G.labelEdge(e,1);
    set src = (the_Source_of G).e, tar = (the_Target_of G).e;
    now per cases;
    suppose Next = {};
        hence thesis by dPRIMSTEP; end;
    suppose
    B0: Next <> {}; then
        consider v being Vertex of G such that
    B1: not v in G.labeledV() &
          G2 = GE.labelVertex(v,1) by lPRIMSTEP02;
    B2: G == GE by GLIB_003:41;
        GE == G2 by B1, GLIB_003:47;
        hence G == G2 by B2, GLIB_000:88;
        e SJoins G.labeledV(),the_Vertices_of G \ G.labeledV(),G
          by B0, dPRIMNEXT; then
    B3: e in the_Edges_of G by GLIB_000:def 17;
        thus the_Weight_of G  = the_Weight_of GE by GLIB_003:42
                             .= the_Weight_of G2 by B1,GLIB_003:48;
        G.labeledE() c= GE.labeledE() by B3,GLIB_003:53;
        hence G.labeledE() c= G2.labeledE() by B1, GLIB_003:56; 
        the_Vertices_of G = the_Vertices_of GE by B2,GLIB_000:def 36; then
        GE.labeledV() c= G2.labeledV() by B1,GLIB_003:60;
        hence G.labeledV() c= G2.labeledV() by GLIB_003:63; end;
    end;
    hence thesis;
end;    

lPRIMCS03:
  for G being finite real-weighted WGraph, n being Nat holds
     G == PRIM:CompSeq(G).->n &
     the_Weight_of (PRIM:CompSeq(G).->n) = the_Weight_of G
proof
   let G be finite real-weighted WGraph; set PCS = PRIM:CompSeq(G);
    defpred P[Nat] means
    G == PCS.->$1 & the_Weight_of (PCS.->$1) = the_Weight_of G;
    PCS.->0 = PRIM:Init(G) by dPRIMCS; then
A2: P[0] by lPRIMINIT01;
A3: now let n be Nat; set Gn = PCS.->n, Gn1 = PCS.->(n+1);assume
    B1: P[n];
        Gn1 = PRIM:Step(Gn) by dPRIMCS; then
        Gn1 == Gn & the_Weight_of Gn1 = the_Weight_of Gn
          by lPRIMSTEP01;
        hence P[n+1] by B1,GLIB_000:88;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

lPRIMCS05:
  for G being finite real-weighted WGraph, n being Nat holds
   (PRIM:CompSeq(G).->n).labeledV() is non empty Subset of the_Vertices_of G &
   (PRIM:CompSeq(G).->n).labeledE() c=
     G.edgesBetween((PRIM:CompSeq(G).->n).labeledV())
proof
    let G be finite real-weighted WGraph;
    set PCS = PRIM:CompSeq(G);
    defpred P[Nat] means
      (PCS.->$1).labeledV() is non empty Subset of the_Vertices_of G &
      (PCS.->$1).labeledE() c= G.edgesBetween((PCS.->$1).labeledV());
    now (PCS.->0).labeledV() = PRIM:Init(G).labeledV() by dPRIMCS
                            .= {choose the_Vertices_of G} by lPRIMINIT02;
        hence (PCS.->0).labeledV() is non empty Subset of the_Vertices_of G;
        (PCS.->0).labeledE() = PRIM:Init(G).labeledE() by dPRIMCS
                            .= {} by lPRIMINIT02;
        hence (PCS.->0).labeledE() c=
          G.edgesBetween((PRIM:CompSeq(G).->0).labeledV()) by XBOOLE_1:2;
    end; then                         
A1: P[0];
    now let n be Nat; assume
    B1: P[n];
        set Gn = PCS.->n, Gn1 = PCS.->(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    B2: Gn1 = PRIM:Step(Gn) by dPRIMCS;
        now per cases;
        suppose Next = {}; then
            Gn1 = Gn by B2, dPRIMSTEP;
            hence P[n+1] by B1; end;
        suppose
        C1: Next <> {};
            set src = (the_Source_of Gn).e, tar = (the_Target_of Gn).e;
        C2: e in Next by C1;
            Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
        C3: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36; then
        C4: src in the_Vertices_of Gn.labelEdge(e,1) &
            tar in the_Vertices_of Gn.labelEdge(e,1) by C2,GLIB_000:6;
            Gn == G by lPRIMCS03; then
        C5: the_Vertices_of Gn = the_Vertices_of G &
            the_Edges_of Gn = the_Edges_of G &
            the_Source_of Gn = the_Source_of G &
            the_Target_of Gn = the_Target_of G by GLIB_000:def 36;
        CZ: e SJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(), Gn
              by C1, dPRIMNEXT;
            now per cases;
            suppose
            D1:(the_Source_of Gn).e in Gn.labeledV(); then
            D2: Gn1 = Gn.labelEdge(e,1).labelVertex((the_Target_of Gn).e,1)
                  by B2,C1,dPRIMSTEP;
                Gn.labeledV() = Gn.labelEdge(e,1).labeledV()
                  by GLIB_003:63; then
            D3: Gn1.labeledV() = Gn.labeledV() \/ {tar} by C4,D2,GLIB_003:59;
            D4: Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by D2,GLIB_003:56
                              .= Gn.labeledE() \/ {e} by C2,GLIB_003:52;
                now let x be set; assume
                E1: x in Gn1.labeledV();
                    now per cases by E1, D3, XBOOLE_0:def 2;
                    suppose x in Gn.labeledV();
                        hence x in the_Vertices_of G by B1; end;
                    suppose x in {tar};
                        hence x in the_Vertices_of G by TARSKI:def 1,C3,C4,C5;
                        end;
                    end;
                    hence x in the_Vertices_of G;
                end;
                hence Gn1.labeledV() is non empty Subset of the_Vertices_of G
                  by D3, TARSKI:def 3;
            D5: Gn.labeledV() c= Gn1.labeledV() by D3, XBOOLE_1:7; then
            D6: G.edgesBetween(Gn.labeledV()) c=
                  G.edgesBetween(Gn1.labeledV()) by GLIB_000:39;
                now let x be set; assume
                E1: x in Gn1.labeledE();
                    now per cases by D4, E1, XBOOLE_0:def 2;
                    suppose x in Gn.labeledE(); then
                        x in G.edgesBetween(Gn.labeledV()) by B1;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by D6; end;
                    suppose x in {e}; then
                    F1: x = e by TARSKI:def 1; then
                        (the_Target_of G).x in {tar} by C5,TARSKI:def 1;then
                        (the_Target_of G).x in Gn1.labeledV()
                          by D3,XBOOLE_0:def 2;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by C2,C5,F1,D1,D5,GLIB_000:34; end;
                    end;
                    hence x in G.edgesBetween(Gn1.labeledV());
                end;
                hence Gn1.labeledE() c= G.edgesBetween(Gn1.labeledV())
                  by TARSKI:def 3; end;
            suppose
            D1: not (the_Source_of Gn).e in Gn.labeledV(); then
            D2: Gn1 = Gn.labelEdge(e,1).labelVertex((the_Source_of Gn).e,1)
                  by B2,C1,dPRIMSTEP;
                Gn.labeledV() = Gn.labelEdge(e,1).labeledV()
                  by GLIB_003:63; then
            D3: Gn1.labeledV() = Gn.labeledV() \/ {src} by C4,D2,GLIB_003:59;
            D4: Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by D2,GLIB_003:56
                              .= Gn.labeledE() \/ {e} by C2,GLIB_003:52;
                now let x be set; assume
                E1: x in Gn1.labeledV();
                    now per cases by E1, D3, XBOOLE_0:def 2;
                    suppose x in Gn.labeledV();
                        hence x in the_Vertices_of G by B1;
                        end;
                    suppose x in {src};
                        hence x in the_Vertices_of G by C3,C4,C5,TARSKI:def 1;
                        end;
                    end;
                    hence x in the_Vertices_of G;
                end;
                hence Gn1.labeledV() is non empty Subset of the_Vertices_of G
                  by D3,TARSKI:def 3;
            D5: Gn.labeledV() c= Gn1.labeledV() by D3, XBOOLE_1:7; then
            D6: G.edgesBetween(Gn.labeledV()) c=
                  G.edgesBetween(Gn1.labeledV()) by GLIB_000:39;
            D7: tar in Gn.labeledV() by D1,CZ,GLIB_000:def 17;
                now let x be set; assume
                E1: x in Gn1.labeledE();
                    now per cases by D4, E1, XBOOLE_0:def 2;
                    suppose x in Gn.labeledE(); then
                        x in G.edgesBetween(Gn.labeledV()) by B1;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by D6; end;
                          suppose x in {e}; then
                    F1: x = e by TARSKI:def 1; then
                        (the_Source_of G).x in {src}
                          by C5,TARSKI:def 1; then
                        (the_Source_of G).x in Gn1.labeledV()
                          by D3,XBOOLE_0:def 2;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by C2,C5,F1,D5,D7,GLIB_000:34; end;
                        end;
                    hence x in G.edgesBetween(Gn1.labeledV());
                end;
                hence Gn1.labeledE() c= G.edgesBetween(Gn1.labeledV())
                  by TARSKI:def 3; end;
            end;
            hence P[n+1]; end;
        end;
        hence P[n+1];
        
    end; then
A2: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

lPRIMCS02:
  for G1 being finite real-weighted WGraph, n being Nat,
      G2 being inducedSubgraph of G1,(PRIM:CompSeq(G1).->n).labeledV(),
                                     (PRIM:CompSeq(G1).->n).labeledE()
  holds G2 is connected
proof
    let G1 be finite real-weighted WGraph;
    defpred P[Nat] means
    for G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).->$1).labeledV(),
      (PRIM:CompSeq(G1).->$1).labeledE() holds G2 is connected;
    set G0 = PRIM:CompSeq(G1).->0, v = choose the_Vertices_of G1;
    now let G be inducedSubgraph of G1, G0.labeledV(), G0.labeledE();
      G0 = PRIM:Init(G1) by dPRIMCS; then
      G0.labeledV() = {v} & G0.labeledE() = {} by lPRIMINIT02; then
        reconsider G' = G as inducedSubgraph of G1,{v},{};
        G' is connected;
        hence G is connected;
    end; then
A1: P[0];
    now let n be Nat; assume
    B1: P[n];
        set Gn = PRIM:CompSeq(G1).->n, Gn1 = PRIM:CompSeq(G1).->(n+1);
        set e = choose PRIM:NextBestEdges(Gn);
        set v1 = (the_Target_of Gn).e, v2 = (the_Source_of Gn).e;
    B2: Gn1 = PRIM:Step(Gn) by dPRIMCS;
        now let Gn1s be inducedSubgraph of G1, Gn1.labeledV(), Gn1.labeledE();
            Gn1.labeledV() is non empty Subset of the_Vertices_of G1 &
            Gn1.labeledE()c=G1.edgesBetween(Gn1.labeledV()) by lPRIMCS05; then
        C1: the_Vertices_of Gn1s = Gn1.labeledV() &
            the_Edges_of Gn1s = Gn1.labeledE() by GLIB_000:def 39;
            now per cases;
            suppose PRIM:NextBestEdges(Gn) = {}; then
                 Gn1 = Gn by B2, dPRIMSTEP;
                 hence Gn1s is connected by B1; end;
            suppose
            D0: PRIM:NextBestEdges(Gn) <> {} & v2 in Gn.labeledV(); then
            D1: Gn1 = Gn.labelEdge(e,1).labelVertex(v1,1) by B2, dPRIMSTEP;
            DZ: e in PRIM:NextBestEdges(Gn) by D0; then
                reconsider v1 as Vertex of Gn by GLIB_000:6;
                Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
                the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
                  by GLIB_000:def 36; then
                Gn1.labeledV() = Gn.labelEdge(e,1).labeledV() \/ {v1}
                  by D1,GLIB_003:59; then
            D3: Gn1.labeledV() = Gn.labeledV() \/ {v1} by GLIB_003:63;
                the_ELabel_of Gn.labelEdge(e,1) = the_ELabel_of Gn1
                  by D1,GLIB_003:49; then
            D4: Gn1.labeledE() = Gn.labelEdge(e,1).labeledE()
                  by GLIB_003:51;
            D5: Gn1.labeledE() = Gn.labeledE() \/ {e} by D4,DZ,GLIB_003:52;
                consider Gns being inducedSubgraph of
                  G1,Gn.labeledV(),Gn.labeledE();
            D6: Gns is connected by B1;
            DB: Gn.labeledV() is non empty Subset of the_Vertices_of G1 &
                  Gn.labeledE() c= G1.edgesBetween(Gn.labeledV())
                  by lPRIMCS05; then
            D7: the_Vertices_of Gns = Gn.labeledV() &
                the_Edges_of Gns = Gn.labeledE() by GLIB_000:def 39; then
                the_Vertices_of Gns c= the_Vertices_of Gn1s &
                the_Edges_of Gns c= the_Edges_of Gn1s
                  by C1,D3,D5,XBOOLE_1:7; then
                reconsider Gns as Subgraph of Gn1s by GLIB_000:47;
                consider src being Vertex of Gns;
                reconsider src' = src as Vertex of Gn1s by GLIB_000:45;
            D8: Gn == G1 by lPRIMCS03;
                e Joins v2,v1,Gn by DZ, GLIB_000:def 15; then
            D9: e Joins v2,v1,G1 by D8,GLIB_000:91;
                e in {e} by TARSKI:def 1; then
                e in the_Edges_of Gn1s by C1,D5,XBOOLE_0:def 2; then
            DA: e Joins v2,v1,Gn1s by D9, GLIB_000:76;
                now let x be Vertex of Gn1s;
                    now per cases;
                    suppose
                    F1: x = v1;
                        reconsider v2'=v2 as Vertex of Gns
                          by D0,DB,GLIB_000:def 39;
                        consider W being Walk of Gns such that
                    F2: W is_Walk_from src,v2' by D6, GLIB_002:def 1;
                        reconsider W as Walk of Gn1s by GLIB_001:168;
                        W is_Walk_from src',v2 by F2,GLIB_001:20; then
                        W.addEdge(e) is_Walk_from src',x by DA,F1,GLIB_001:67;
                        hence ex W being Walk of Gn1s st
                          W is_Walk_from src',x; end;
                    suppose x <> v1; then
                        not x in {v1} by TARSKI:def 1; then
                        reconsider x'=x as Vertex of Gns
                          by D7,C1,D3,XBOOLE_0:def 2;
                        consider W being Walk of Gns such that
                    F1: W is_Walk_from src,x' by D6,GLIB_002:def 1;
                        reconsider W'=W as Walk of Gn1s by GLIB_001:168;
                        W' is_Walk_from src',x by F1,GLIB_001:20;
                        hence ex W being Walk of Gn1s st
                          W is_Walk_from src',x; end;
                    end;
                    hence ex W being Walk of Gn1s st W is_Walk_from src',x;
                end;
                hence Gn1s is connected by GLIB_002:6; end;
          suppose
          D0: PRIM:NextBestEdges(Gn) <> {} & not v2 in Gn.labeledV(); then
          D1: Gn1 = Gn.labelEdge(e,1).labelVertex(v2,1) by B2, dPRIMSTEP;
              e SJoins Gn.labeledV(),the_Vertices_of Gn\Gn.labeledV(),Gn
                by D0, dPRIMNEXT; then
          DZ: e in the_Edges_of Gn & v1 in Gn.labeledV()
                by D0, GLIB_000:def 17; then
              reconsider v2 as Vertex of Gn by GLIB_000:6;
              Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
              the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
                by GLIB_000:def 36; then
              Gn1.labeledV() = Gn.labelEdge(e,1).labeledV() \/ {v2}
                by D1,GLIB_003:59; then
          D3: Gn1.labeledV() = Gn.labeledV() \/ {v2} by GLIB_003:63;
              the_ELabel_of Gn.labelEdge(e,1) = the_ELabel_of Gn1
                by D1,GLIB_003:49; then
          D4: Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by GLIB_003:51;
          D5: Gn1.labeledE() = Gn.labeledE() \/ {e} by D4,DZ,GLIB_003:52;
               consider Gns being inducedSubgraph of
                 G1,Gn.labeledV(),Gn.labeledE();
          D6: Gns is connected by B1;
          DX: Gn.labeledV() is non empty Subset of the_Vertices_of G1 &
                Gn.labeledE()c= G1.edgesBetween(Gn.labeledV())
                by lPRIMCS05; then
          D7: the_Vertices_of Gns = Gn.labeledV() &
                the_Edges_of Gns = Gn.labeledE() by GLIB_000:def 39; then
              the_Vertices_of Gns c= the_Vertices_of Gn1s &
                the_Edges_of Gns c= the_Edges_of Gn1s
                by C1,D3,D5,XBOOLE_1:7; then
              reconsider Gns as Subgraph of Gn1s by GLIB_000:47;
              consider src being Vertex of Gns;
              reconsider src' = src as Vertex of Gn1s by GLIB_000:45;
          D8: Gn == G1 by lPRIMCS03;
              e Joins v1,v2,Gn by DZ, GLIB_000:def 15; then
          D9: e Joins v1,v2,G1 by D8,GLIB_000:91;
              e in {e} by TARSKI:def 1; then
              e in the_Edges_of Gn1s by D5,XBOOLE_0:def 2,C1; then
          DA: e Joins v1,v2,Gn1s by D9, GLIB_000:76;
              now let x be Vertex of Gn1s;
                  now per cases;
                  suppose
                  F1: x = v2;
                      reconsider v1'=v1 as Vertex of Gns
                        by DZ,DX,GLIB_000:def 39;
                      consider W being Walk of Gns such that
                  F2: W is_Walk_from src,v1' by D6, GLIB_002:def 1;
                      reconsider W as Walk of Gn1s by GLIB_001:168;
                      W is_Walk_from src',v1 by F2,GLIB_001:20; then
                      W.addEdge(e) is_Walk_from src',x by DA,F1,GLIB_001:67;
                      hence ex W being Walk of Gn1s st
                        W is_Walk_from src',x; end;
                  suppose x <> v2; then
                      not x in {v2} by TARSKI:def 1; then
                      reconsider x'=x as Vertex of Gns
                        by D7,C1,D3,XBOOLE_0:def 2;
                      consider W being Walk of Gns such that
                  F1: W is_Walk_from src,x' by D6,GLIB_002:def 1;
                      reconsider W'=W as Walk of Gn1s by GLIB_001:168;
                      W' is_Walk_from src',x by F1,GLIB_001:20;
                      hence ex W being Walk of Gn1s st
                        W is_Walk_from src',x; end;
                  end;
                  hence ex W being Walk of Gn1s st W is_Walk_from src',x;
              end;
              hence Gn1s is connected by GLIB_002:6; end;
          end;
          hence Gn1s is connected;
        end;
        hence P[n+1];
    end; then
A2: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

lPRIMCS04:
  for G1 being finite real-weighted WGraph, n being Nat,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).->n).labeledV()
    holds G2 is connected
proof
    let G1 be finite real-weighted WGraph, n be Nat;
    set V = (PRIM:CompSeq(G1).->n).labeledV();
    set E = (PRIM:CompSeq(G1).->n).labeledE();
    let G2 be inducedSubgraph of G1, V;
    reconsider V as non empty Subset of the_Vertices_of G1 by lPRIMCS05;
    reconsider E as Subset of G1.edgesBetween(V) by lPRIMCS05;
    consider G3 being inducedSubgraph of G1,V,E;
A1: the_Vertices_of G3 = V & the_Edges_of G3 = E by GLIB_000:def 39;
A2: the_Vertices_of G2 = V & the_Edges_of G2 = G1.edgesBetween(V)
      by GLIB_000:def 39; then
    reconsider G3 as Subgraph of G2 by A1, GLIB_000:47;
A3: G3 is connected by lPRIMCS02;
    G3 is spanning by A1,A2,GLIB_000:def 35;
    hence G2 is connected by A3,GLIB_002:23;
end;

registration let G1 be finite real-weighted WGraph, n being Nat;
  cluster
  -> connected inducedSubgraph of G1,(PRIM:CompSeq(G1).->n).labeledV();
  coherence by lPRIMCS04;
end;  

registration let G1 be finite real-weighted WGraph, n being Nat;
  cluster
  -> connected inducedSubgraph of G1, (PRIM:CompSeq(G1).->n).labeledV(),
                                      (PRIM:CompSeq(G1).->n).labeledE();
  coherence by lPRIMCS02;
end;

lPRIMCS08:
  for G being finite real-weighted WGraph, n being Nat holds
    (PRIM:CompSeq(G).->n).labeledV() c=
      G.reachableFrom(choose the_Vertices_of G)
proof
    let G be finite real-weighted WGraph;
    set src = choose the_Vertices_of G;
    defpred P[Nat] means
    (PRIM:CompSeq(G).->$1).labeledV() c=
      G.reachableFrom(choose the_Vertices_of G);
    set G0 = PRIM:CompSeq(G).->0;
    G0 = PRIM:Init(G) by dPRIMCS; then
    the_VLabel_of G0 = src.-->1 by lPRIMINIT01; then
    dom the_VLabel_of G0 = {src} by CQC_LANG:5; then
A1: G0.labeledV() = {src} by GLIB_003:def 23;
    src in G.reachableFrom(src) by GLIB_002:9; then
A2: P[0] by A1, ZFMISC_1:37;
A3: now let n be Nat; assume
    B1: P[n];
        set Gn = PRIM:CompSeq(G).->n, Gn1 = PRIM:CompSeq(G).->(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
        set sc = (the_Source_of Gn).e, tar = (the_Target_of Gn).e;
    B2: Gn1 = PRIM:Step(Gn) by dPRIMCS;
        now per cases;
        suppose Next = {};
            hence P[n+1] by B1,B2,dPRIMSTEP; end;
        suppose
        C1: Next <> {} & sc in Gn.labeledV(); then
        C2: Gn1 = Gn.labelEdge(e,1).labelVertex(tar,1) by B2,dPRIMSTEP;
        C4: e in Next by C1; then
        C5: tar in the_Vertices_of Gn by GLIB_000:6;
            Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
        C6: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36;
            Gn.labeledV() = Gn.labelEdge(e,1).labeledV() by GLIB_003:63; then
        C8: Gn1.labeledV() = Gn.labeledV() \/ {tar} by C2,C5,C6,GLIB_003:59;
            now let v be set; assume
            D1: v in Gn1.labeledV();
                now per cases by C8, D1, XBOOLE_0:def 2;
                suppose v in Gn.labeledV();
                    hence v in G.reachableFrom(src) by B1; end;
                suppose v in {tar}; then
                    v = tar by TARSKI:def 1; then
                E1: e Joins sc,v,Gn by C4, GLIB_000:def 15;
                    G == Gn by lPRIMCS03; then
                    e Joins sc,v,G by E1, GLIB_000:91; 
                    hence v in G.reachableFrom(src) by B1,C1,GLIB_002:10; end;
                end;
                hence v in G.reachableFrom(src);
            end;
            hence P[n+1] by TARSKI:def 3; end;
        suppose
        C1: Next <> {} & not sc in Gn.labeledV(); then
        C2: Gn1 = Gn.labelEdge(e,1).labelVertex(sc,1) by B2,dPRIMSTEP;
        CZ: e SJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(), Gn
              by C1, dPRIMNEXT; then
        C3: tar in Gn.labeledV() by C1,GLIB_000:def 17;
        C4: e in the_Edges_of Gn by CZ, GLIB_000:def 17; then
        C5: sc in the_Vertices_of Gn by GLIB_000:6;
            Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
        C6: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36;
            Gn.labeledV() = Gn.labelEdge(e,1).labeledV() by GLIB_003:63; then
        C8: Gn1.labeledV() = Gn.labeledV() \/ {sc} by C2,C5,C6,GLIB_003:59;
            now let v be set; assume
            D1: v in Gn1.labeledV();
                now per cases by C8, D1, XBOOLE_0:def 2;
                suppose v in Gn.labeledV();
                    hence v in G.reachableFrom(src) by B1; end;
                suppose v in {sc}; then
                    v = sc by TARSKI:def 1; then
                E1: e Joins tar,v,Gn by C4, GLIB_000:def 15;
                    G == Gn by lPRIMCS03; then
                    e Joins tar,v,G by E1, GLIB_000:91; 
                    hence v in G.reachableFrom(src) by B1,C3,GLIB_002:10; end;
                end;
                hence v in G.reachableFrom(src);
            end;        
            hence P[n+1] by TARSKI:def 3; end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

lPRIMCS13:
  for G being finite real-weighted WGraph, i,j being Nat st i <= j holds
    (PRIM:CompSeq(G).->i).labeledV() c=
    (PRIM:CompSeq(G).->j).labeledV() &
    (PRIM:CompSeq(G).->i).labeledE() c=
    (PRIM:CompSeq(G).->j).labeledE()
proof
    let G be finite real-weighted WGraph, i,j be Nat;
    set PCS = PRIM:CompSeq(G);
    set vPCS = (PCS.->i).labeledV(), ePCS = (PCS.->i).labeledE();
    assume i <= j; then
    consider x being Nat such that
A1: j = i + x by NAT_1:28;
    defpred P[Nat] means vPCS c= (PCS.->(i+$1)).labeledV() &
                         ePCS c= (PCS.->(i+$1)).labeledE();
A2: P[0];
    now let k be Nat; assume
    B1: vPCS c= (PCS.->(i+k)).labeledV() &
        ePCS c= (PCS.->(i+k)).labeledE();
        PCS.->(i+k+1) = PRIM:Step(PCS.->(i+k)) by dPRIMCS; then
        (PCS.->(i+k)).labeledV() c= (PCS.->(i+k+1)).labeledV() &
        (PCS.->(i+k)).labeledE() c= (PCS.->(i+k+1)).labeledE()
          by lPRIMSTEP01;
        hence vPCS c= (PCS.->(i+(k+1))).labeledV() &
              ePCS c= (PCS.->(i+(k+1))).labeledE() by B1, XBOOLE_1:1;
    end; then
A3: for k being Nat st P[k] holds P[k+1];
    for k being Nat holds P[k] from NAT_1:sch 1(A2,A3);
    hence vPCS c= (PCS.->j).labeledV() & ePCS c= (PCS.->j).labeledE() by A1;     
end;

lPRIMCS07:
    for G being finite real-weighted WGraph, n being Nat holds
      PRIM:NextBestEdges(PRIM:CompSeq(G).->n) = {} iff
   (PRIM:CompSeq(G).->n).labeledV() =
     G.reachableFrom(choose the_Vertices_of G)
proof
    let G be finite real-weighted WGraph, n be Nat;
    set src = choose the_Vertices_of G;
    set PCS = PRIM:CompSeq(G), RFS = G.reachableFrom(src);
    set Gn = PCS.->n, Gn1 = PCS.->(n+1);
    set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    set GnV = Gn.labeledV(), _GnV = the_Vertices_of Gn \ GnV;
    hereby assume
    B1: Next = {};
        now assume
        C1: GnV <> RFS;
            GnV c= RFS by lPRIMCS08; then
        C2: GnV c< RFS by C1, XBOOLE_0:def 8;
            defpred P1[set] means $1 SJoins GnV, _GnV, Gn;
            consider BE1 being Subset of the_Edges_of Gn such that
        C3: for x being set holds x in BE1 iff x in the_Edges_of Gn & P1[x]
              from SUBSET_1:sch 1;
            now assume
            D1: BE1 = {};
                consider v being set such that
            D2: v in RFS & not v in Gn.labeledV() by C2, RLSUB_2:77;
                reconsider v as Vertex of G by D2;
                consider W being Walk of G such that
            D3: W is_Walk_from src, v by D2, GLIB_002:def 5;
                src in {src} by TARSKI:def 1; then
                src in PRIM:Init(G).labeledV() by lPRIMINIT02; then
            D4: src in (PCS.->0).labeledV() by dPRIMCS;
                0 <= n by NAT_1:18; then
            D5: (PCS.->0).labeledV() c= Gn.labeledV() by lPRIMCS13;
                defpred P2[Nat] means
                  $1 is odd & $1 <= len W & not W.$1 in GnV;
                W.(len W) = W.last() by GLIB_001:def 7
                         .= v by D3, GLIB_001:def 23; then
            D6: ex k being Nat st P2[k] by D2;
                consider k being Nat such that
            D7: P2[k] & for m being Nat st P2[m] holds k <= m
                  from NAT_1:sch 5(D6);
                now per cases;
                    suppose k = 1; then
                    W.k = W.first() by GLIB_001:def 6
                       .= src by D3, GLIB_001:def 23;
                    hence contradiction by D4,D5,D7;
                    end;
                    suppose
                E1: k <> 1; reconsider k'=k as odd Nat by D7;
                    1 <= k by D7, HEYTING3:1; then
                    1 < k by E1, REAL_1:def 5; then
                    1+1 <= k by NAT_1:38; then
                    reconsider k_2 = k'-2*1 as odd Nat by INT_1:18;
                E2: k - 2 < len W - 0 by D7, REAL_1:92;
                    k_2 < k - 0 by REAL_1:92; then
                E3: W.k_2 in GnV by E2, D7;
                    set e = W.(k_2+1);
                EZ: e Joins W.k_2, W.(k_2+2),G by E2, GLIB_001:def 3; then
                E5: W.k in the_Vertices_of G by GLIB_000:16; 
                E6: G == Gn by lPRIMCS03; then
                E7: the_Vertices_of G = the_Vertices_of Gn &
                    the_Edges_of G = the_Edges_of Gn by GLIB_000:def 36; then
                    W.k in _GnV by D7,E5,XBOOLE_0:def 4; then
                    e SJoins GnV, _GnV, G by E3,EZ,GLIB_000:20; then
                E8: P1[e] by E6,GLIB_000:91;
                    e in the_Edges_of Gn by EZ, E7, GLIB_000:def 15;
                    hence contradiction by C3,D1,E8;
                    end;
                end;
                hence contradiction;
            end; then reconsider BE1 as non empty finite set;
            deffunc F(Element of BE1) = (the_Weight_of Gn).$1;
            consider e1 being Element of BE1 such that
        C4: for e2 being Element of BE1 holds F(e1)<=F(e2) from GRAPH_5:sch 2;
        C5: e1 SJoins GnV, _GnV, Gn by C3;
            now let e2 be set; assume
            D1: e2 SJoins GnV, _GnV, Gn; then
                e2 in the_Edges_of Gn by GLIB_000:def 17; then
                reconsider e2' = e2 as Element of BE1 by C3,D1;
                (the_Weight_of Gn).e1 <= (the_Weight_of Gn).e2' by C4;
                hence (the_Weight_of Gn).e1 <= (the_Weight_of Gn).e2;
            end; 
            hence contradiction by B1, C5, dPRIMNEXT;
         end;
         hence GnV = RFS;
    end;
    assume
A2: GnV = RFS; set e = choose Next;
    now assume Next <> {}; then 
    B2: e SJoins GnV, _GnV, Gn by dPRIMNEXT; then
    B4: e in the_Edges_of Gn by GLIB_000:def 17;
    B5: Gn == G by lPRIMCS03;
        now per cases by B2,GLIB_000:def 17;
            suppose
        C1: (the_Source_of Gn).e in GnV & (the_Target_of Gn).e in _GnV; then
        C2: not (the_Target_of Gn).e in GnV by XBOOLE_0:def 4;
            e Joins (the_Source_of Gn).e, (the_Target_of Gn).e, Gn
              by B4, GLIB_000:def 15; then
            e Joins (the_Source_of Gn).e, (the_Target_of Gn).e, G
              by B5, GLIB_000:91;
            hence contradiction by C2,A2,C1,GLIB_002:10;
            end;
            suppose
        C1: (the_Source_of Gn).e in _GnV & (the_Target_of Gn).e in GnV; then
        C2: not (the_Source_of Gn).e in GnV by XBOOLE_0:def 4;
            e Joins (the_Target_of Gn).e, (the_Source_of Gn).e, Gn
              by B4, GLIB_000:def 15; then
            e Joins (the_Target_of Gn).e, (the_Source_of Gn).e, G
              by B5, GLIB_000:91;
            hence contradiction by C2,A2,C1,GLIB_002:10;
            end;
        end;
        hence contradiction;  
    end;
    hence Next = {};
end;

lPRIMCS06:
  for G being finite real-weighted WGraph, n being Nat holds
    card (PRIM:CompSeq(G).->n).labeledV() = 
      min(n+1, card(G.reachableFrom(choose the_Vertices_of G)))
proof
    let G be finite real-weighted WGraph;
    set CS = PRIM:CompSeq(G), src = choose the_Vertices_of G;
    defpred P[Nat] means
    card (PRIM:CompSeq(G).->$1).labeledV() =
      min($1+1, card(G.reachableFrom(src)));
    set G0 = CS.->0;
    G0 = PRIM:Init(G) by dPRIMCS; then
    the_VLabel_of G0 = src.-->1 by lPRIMINIT01; then
    {src} = dom the_VLabel_of G0 by CQC_LANG:5
         .= G0.labeledV() by GLIB_003:def 23; then
A2: card G0.labeledV() = 1 by CARD_1:79;
    src in G.reachableFrom(src) by GLIB_002:9; then
    {src} c= G.reachableFrom(src) by ZFMISC_1:37; then
    card {src} <= card G.reachableFrom(src) by CARD_1:80; then
    0+1 <= card G.reachableFrom(src) by CARD_1:79; then
A3: P[0] by A2, SQUARE_1:def 1;
A4: now let n be Nat; assume
    B1: P[n];
        set Gn = PRIM:CompSeq(G).->n, Gn1 = PRIM:CompSeq(G).->(n+1);
        set e = choose PRIM:NextBestEdges(Gn);
    B2: Gn1 = PRIM:Step(Gn) by dPRIMCS;
        now per cases;
        suppose
        C1: PRIM:NextBestEdges(Gn) = {}; then
        C2: card Gn1.labeledV() = min(n+1, card (G.reachableFrom(src)))
              by B1,B2,dPRIMSTEP;
        C3: card Gn.labeledV() = card G.reachableFrom(src) by C1,lPRIMCS07;then
            card G.reachableFrom(src) <= n+1 by B1,SQUARE_1:def 1; then
            card G.reachableFrom(src) <= n+1+1 by NAT_1:37;
            hence P[n+1] by C2,C3,B1,SQUARE_1:def 1; end;
        suppose
        C1: PRIM:NextBestEdges(Gn) <> {}; then
            consider v being Vertex of Gn such that
        C2: not v in Gn.labeledV() &
              Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by B2, lPRIMSTEP02;
        C3: Gn.labeledV() = Gn.labelEdge(e,1).labeledV() by GLIB_003:63;
            Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
            the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36; then
        C6: card Gn1.labeledV() = card Gn.labeledV() + 1
              by C2,C3,GLIB_003:61;
        C7: Gn.labeledV() <> G.reachableFrom(src) by C1,lPRIMCS07;
        C8: Gn.labeledV() c= G.reachableFrom(src) by lPRIMCS08; then
        C9: card Gn.labeledV() <= card G.reachableFrom(src) by CARD_1:80;
        CA: now assume
            D1: card Gn.labeledV() = card G.reachableFrom(src);
                Gn.labeledV() c< G.reachableFrom(src) by C7,C8,XBOOLE_0:def 8;
                hence contradiction by D1, CARD_2:67;
            end; then
        CB: card Gn.labeledV() = n+1 by B1,SQUARE_1:38; then
            n+1 < card G.reachableFrom(src) by C9,CA,REAL_1:def 5; then
            n+1+1 <= card G.reachableFrom(src) by NAT_1:38;
            hence P[n+1] by C6,CB,SQUARE_1:def 1; end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A3,A4);
    hence thesis;
end;

lPRIMCS09:
  for G being finite real-weighted WGraph holds
    PRIM:CompSeq(G) is halting & PRIM:CompSeq(G).Lifespan() + 1 =
      card G.reachableFrom(choose the_Vertices_of G)
proof
    let G be finite real-weighted WGraph;
    set PCS = PRIM:CompSeq(G);
    set src = choose the_Vertices_of G, RFS = G.reachableFrom(src);
    card RFS <> 0 by CARD_2:59; then
    consider n being Nat such that
A1: n + 1 = card RFS by NAT_1:22;
    set Gn = PCS.->n, Gn1 = PCS.->(n+1);
A2: card RFS <= card RFS + 1 by NAT_1:29;    
A3: card Gn.labeledV() = min(card RFS, card RFS) by A1,lPRIMCS06
                      .= card RFS;
A4: card Gn1.labeledV() = min(card RFS + 1, card RFS) by A1,lPRIMCS06                          
                       .= card RFS by SQUARE_1:def 1, A2;
A5: Gn1 = PRIM:Step(Gn) by dPRIMCS; then
A6: Gn.labeledV() c= Gn1.labeledV() by lPRIMSTEP01;
A7: now assume Gn.labeledV() <> Gn1.labeledV(); then
        Gn.labeledV() c< Gn1.labeledV() by A6, XBOOLE_0:def 8;
        hence contradiction by A3,A4,CARD_2:67;
    end;
    set e = choose PRIM:NextBestEdges(Gn);
    now assume PRIM:NextBestEdges(Gn) <> {}; then
        consider v being Vertex of Gn such that
    B2: not v in Gn.labeledV() &
          Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by A5, lPRIMSTEP02;
        Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
        the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
            by GLIB_000:def 36; then
    B4: Gn1.labeledV() = Gn.labelEdge(e,1).labeledV() \/ {v}
          by B2,GLIB_003:59;
        v in {v} by TARSKI:def 1;
        hence contradiction by A7,B2,B4, XBOOLE_0:def 2;
    end; then
A8: Gn1 = Gn by A5, dPRIMSTEP;
A9: Gn = PRIM:CompSeq(G).n & Gn1 = PRIM:CompSeq(G).(n+1) by GLIB_000:def 59;
    hence
AA: PRIM:CompSeq(G) is halting by A8, GLIB_000:def 56;
    now let m be Nat; assume
    B1: PCS.m = PCS.(m+1);
        set Gm = PCS.->m, Gm1 = PCS.->(m+1);
    B2: Gm = PCS.(m+1) by B1, GLIB_000:def 59
          .= Gm1 by GLIB_000:def 59;
        now assume m < n; then
        C2: m+1 <= n by NAT_1:38;
            n+0 < card RFS by A1, REAL_1:67; then
        C3: m+1 < card RFS by C2, AXIOMS:22;
        C4: card Gm.labeledV() = min(m+1, card RFS) by lPRIMCS06
                              .= m+1 by C3, SQUARE_1:def 1;
        C5: m+1+1 <= card RFS by C3, NAT_1:38;
            card Gm.labeledV() = min(m+1+1,card RFS) by B2,lPRIMCS06
                              .= m+1+1 by C5, SQUARE_1:def 1; then
            m+1+0 = m+1+1 by C4;
            hence contradiction by XCMPLX_1:2;
        end;
        hence n <= m;
    end;
    hence PCS.Lifespan() + 1 = card RFS by A1,AA,A8,A9,GLIB_000:def 57;
end;

lPRIMCS11:
  for G1 being finite real-weighted WGraph, n being Nat,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).->n).labeledV(),
                                      (PRIM:CompSeq(G1).->n).labeledE()
  holds G2 is Tree-like
proof
    let G1 be finite real-weighted WGraph;
    set PCS = PRIM:CompSeq(G1);
    defpred P[Nat] means
       for G2 being inducedSubgraph of G1,(PCS.->$1).labeledV(),
                                           (PCS.->$1).labeledE()
         holds G2 is Tree-like;
    set G0 = PCS.->0, src = choose the_Vertices_of G1;
    G0 = PRIM:Init(G1) by dPRIMCS; then
A1: G0.labeledV() = {src} & G0.labeledE() = {} by lPRIMINIT02;
    now let G2 be inducedSubgraph of G1,G0.labeledV(),G0.labeledE();
        reconsider G2'=G2 as inducedSubgraph of G1,{src},{} by A1;
        G2' is Tree-like;
        hence G2 is Tree-like;
    end; then
A2: P[0];
    now let n be Nat; assume
    B1: P[n];
        set Gn = PCS.->n, Gn1 = PCS.->(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    B2: Gn1 = PRIM:Step(Gn) by dPRIMCS;
        consider G3 being inducedSubgraph of G1,Gn.labeledV(),Gn.labeledE();
    B3: G3 is Tree-like by B1;
    BZ: Gn.labeledV() is non empty Subset of the_Vertices_of G1 &
        Gn.labeledE() c= G1.edgesBetween(Gn.labeledV()) by lPRIMCS05; then
    B4: the_Vertices_of G3 = Gn.labeledV() &
        the_Edges_of G3 = Gn.labeledE() by GLIB_000:def 39;
        Gn == G1 by lPRIMCS03; then
    B6: the_Source_of Gn = the_Source_of G1 &
        the_Target_of Gn = the_Target_of G1 by GLIB_000:def 36;
        now let G2 be inducedSubgraph of G1,Gn1.labeledV(),Gn1.labeledE();
            Gn1.labeledV() is non empty Subset of the_Vertices_of G1 &
            Gn1.labeledE()c=G1.edgesBetween(Gn1.labeledV()) by lPRIMCS05; then
        C1: the_Vertices_of G2 = Gn1.labeledV() &
            the_Edges_of G2 = Gn1.labeledE() by GLIB_000:def 39; then
            the_Vertices_of G3 c= the_Vertices_of G2 &
            the_Edges_of G3 c= the_Edges_of G2 by B2,B4,lPRIMSTEP01; then
            reconsider G3'=G3 as Subgraph of G2 by GLIB_000:47;
            G3.order() = G3.size() + 1 by B3, GLIB_002:46; then
        C2: card Gn.labeledV() = G3.size() + 1 by B4,GLIB_000:def 26
                              .= card Gn.labeledE() + 1 by B4,GLIB_000:def 27;
            now per cases;
            suppose Next = {}; then
                Gn = Gn1 by B2, dPRIMSTEP;
                hence G2 is Tree-like by B1;
                end;
            suppose
            D1: Next <> {}; then
                consider v being Vertex of Gn such that
            D2: not v in Gn.labeledV() &
                Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by B2, lPRIMSTEP02;
                set GnV = Gn.labeledV(), _GnV = the_Vertices_of Gn \ GnV;
            D3: e SJoins GnV, _GnV, Gn by D1, dPRIMNEXT; then
            D4: e in the_Edges_of Gn by GLIB_000:def 17;
                now assume e in Gn.labeledE(); then
                    (the_Source_of Gn).e in GnV &
                      (the_Target_of Gn).e in GnV by BZ,B6,GLIB_000:34; then
                    not (the_Source_of Gn).e in _GnV &
                    not (the_Target_of Gn).e in _GnV by XBOOLE_0:def 4;
                    hence contradiction by D3, GLIB_000:def 17;
                end;
                then card Gn.labelEdge(e,1).labeledE() =
                card Gn.labeledE() + 1 by D4, GLIB_003:54; then
            D7: card Gn1.labeledE() = card Gn.labeledE() + 1 by D2,GLIB_003:56;
                Gn == Gn.labelEdge(e,1) by GLIB_003:41; then
            D8: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
                  by GLIB_000:def 36;
                Gn.labeledV() = Gn.labelEdge(e,1).labeledV()
                  by GLIB_003:63; then
                card Gn1.labeledV() = card Gn.labeledV() + 1
                  by D2,D8,GLIB_003:61; then
                G2.order() = card Gn1.labeledE() + 1 
                  by C1,C2,D7,GLIB_000:def 26; then
            DA: G2.order() = G2.size() + 1 by C1, GLIB_000:def 27;
                thus G2 is Tree-like by DA, GLIB_002:47;
                end;
            end;
            hence G2 is Tree-like;
        end;
        hence P[n+1];
    end; then
A3: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;  

lPRIMMST02:
  for G being finite connected real-weighted WGraph
    holds PRIM:MST(G).labeledV() = the_Vertices_of G
proof
    let G be finite connected real-weighted WGraph;
    set M = PRIM:MST(G), PCS = PRIM:CompSeq(G), V = M.labeledV();
    set src = choose the_Vertices_of G, RFS = G.reachableFrom(src);
A1: M = PCS.Result() by dPRIMMST
     .= PCS.(PCS.Lifespan()) by GLIB_000:def 58
     .= PCS.->(PCS.Lifespan()) by GLIB_000:def 59; 

    PCS.Lifespan() + 1 = card RFS by lPRIMCS09; then
A3: card V = min(card RFS,card RFS) by A1,lPRIMCS06;
A4: V c= RFS by A1, lPRIMCS08;
    now assume V <> RFS; then
        V c< RFS by A4, XBOOLE_0:def 8;
        hence contradiction by A3, CARD_2:67;
    end;
    hence thesis by GLIB_002:16;
end;

registration let G be finite connected real-weighted WGraph;
  cluster spanning Tree-like WSubgraph of G;
  existence
  proof
    set PCS = PRIM:CompSeq(G), n = PCS.Lifespan();
    consider IT being inducedWSubgraph of G,(PCS.->n).labeledV(),
                                            (PCS.->n).labeledE();
    take IT;
    (PCS.->n).labeledV() is non empty Subset of the_Vertices_of G &
    (PCS.->n).labeledE() c= G.edgesBetween((PCS.->n).labeledV())
      by lPRIMCS05; then
A1: the_Vertices_of IT = (PCS.->n).labeledV() by GLIB_000:def 39;
    PRIM:MST(G) = PCS.Result() by dPRIMMST
               .= PCS.n by GLIB_000:def 58
               .= PCS.->n by GLIB_000:def 59; then
    (PCS.->n).labeledV() = the_Vertices_of G by lPRIMMST02;
    hence IT is spanning by A1, GLIB_000:def 35;
    thus IT is Tree-like by lPRIMCS11;
  end;
end;

definition let G1 be finite connected real-weighted WGraph,
               G2 be spanning Tree-like WSubgraph of G1;
  attr G2 is min-cost means :dWGMINCOST: ::dWGMINCOST
    for G3 being spanning Tree-like WSubgraph of G1 holds
       G2.cost() <= G3.cost();
end;

registration let G1 be finite connected real-weighted WGraph;
  cluster min-cost (spanning Tree-like WSubgraph of G1);
  existence
  proof
    set X = {G2 where G2 is Element of G1.allWSubgraphs() :
             G2 is spanning Tree-like WSubgraph of G1};
    now let x be set; assume x in X;
      then consider G2 being Element of G1.allWSubgraphs() such that
    B2: x = G2 & G2 is spanning Tree-like WSubgraph of G1;
        thus x in G1.allWSubgraphs() by B2;
    end; then
    reconsider X as finite Subset of G1.allWSubgraphs()
      by TARSKI:def 3,FINSET_1:13;
    consider GT being spanning Tree-like WSubgraph of G1;
    set G3 = GT.strict(WGraphSelectors);
A1: G3 == GT & the_Weight_of G3 = the_Weight_of GT by lWSSEL01; then
    reconsider G3 as WSubgraph of G1 by GLIB_003:15;
    the_Vertices_of G3 = the_Vertices_of GT by A1, GLIB_000:def 36
                      .= the_Vertices_of G1 by GLIB_000:def 35; then
    reconsider G3 as spanning Tree-like WSubgraph of G1
      by A1, GLIB_000:def 35, GLIB_002:48;
    dom G3 = WGraphSelectors by lWSSEL02; then
    G3 in G1.allWSubgraphs() by dGALLWSUBG; then
    G3 in X; then
    reconsider X as finite non empty Subset of G1.allWSubgraphs();
    deffunc F(finite real-weighted WGraph) = $1.cost();
    consider x being Element of X such that
A1: for y being Element of X holds F(x) <= F(y) from GRAPH_5:sch 2;
    x in X; then
    consider G2 being Element of G1.allWSubgraphs() such that
A2: x = G2 & G2 is spanning Tree-like WSubgraph of G1;    
    reconsider x as spanning Tree-like WSubgraph of G1 by A2;
    take x;
    now let GT be spanning Tree-like WSubgraph of G1;
        set G3 = GT.strict(WGraphSelectors);
    B1: G3 == GT & the_Weight_of G3 = the_Weight_of GT by lWSSEL01; then
        reconsider G3 as WSubgraph of G1 by GLIB_003:15;
        the_Vertices_of G3 = the_Vertices_of GT by B1, GLIB_000:def 36
                          .= the_Vertices_of G1 by GLIB_000:def 35; then
        reconsider G3 as spanning Tree-like WSubgraph of G1
          by B1, GLIB_000:def 35, GLIB_002:48;
        dom G3 = WGraphSelectors by lWSSEL02; then
        G3 in G1.allWSubgraphs() by dGALLWSUBG; then
        G3 in X; then
    B2: x.cost() <= G3.cost() by A1;
        the_Edges_of G3 = the_Edges_of GT by B1, GLIB_000:def 36;
        hence x.cost() <= GT.cost() by B1,B2,tGCOST02;
    end;
    hence x is min-cost by dWGMINCOST; 
  end;
end;

definition let G be finite connected real-weighted WGraph;
  mode minimumSpanningTree of G is
       min-cost (spanning Tree-like WSubgraph of G);
end;

begin :: Prim's Algorithm Theorems

theorem ::tMST01
  for G1,G2 being finite connected real-weighted WGraph,
      G3 being WSubgraph of G1
   st G3 is minimumSpanningTree of G1 &
      G1 == G2 & the_Weight_of G1 = the_Weight_of G2
holds G3 is minimumSpanningTree of G2
proof
    let G1,G2 be finite connected real-weighted WGraph, G3 be WSubgraph of G1;
    assume
A1: G3 is minimumSpanningTree of G1 &
    G1 == G2 & the_Weight_of G1 = the_Weight_of G2;
    set G3' = G3;
    reconsider G3' as Tree-like WSubgraph of G2 by A1, GLIB_003:17;
    the_Vertices_of G3 = the_Vertices_of G1 by A1, GLIB_000:def 35
                      .= the_Vertices_of G2 by A1, GLIB_000:def 36; then
    reconsider G3' as spanning Tree-like WSubgraph of G2 by GLIB_000:def 35;
    now let G be spanning Tree-like WSubgraph of G2;
        reconsider G'=G as Tree-like WSubgraph of G1 by A1,GLIB_003:17;
        the_Vertices_of G = the_Vertices_of G2 by GLIB_000:def 35
                         .= the_Vertices_of G1 by A1, GLIB_000:def 36; then
        G' is spanning by GLIB_000:def 35;
        hence G3.cost() <= G.cost() by A1,dWGMINCOST;
    end; then
    G3' is min-cost by dWGMINCOST;
    hence thesis;
end;

theorem tMST02: ::tMST02
  for G being finite connected real-weighted WGraph,
    G1 being minimumSpanningTree of G, G2 being WGraph
   st G1 == G2 & the_Weight_of G1 = the_Weight_of G2 holds
   G2 is minimumSpanningTree of G
proof
    let G be finite connected real-weighted WGraph,
       G1 be minimumSpanningTree of G, G2 be WGraph; assume
A1: G1 == G2 & the_Weight_of G1 = the_Weight_of G2; then
    reconsider G2'=G2 as WSubgraph of G by GLIB_003:15;
    the_Vertices_of G2 = the_Vertices_of G1 by A1, GLIB_000:def 36
                      .= the_Vertices_of G by GLIB_000:def 35; then
    reconsider G2' as spanning Tree-like WSubgraph of G
      by A1,GLIB_002:48,GLIB_000:def 35;
    now let G3 be spanning Tree-like WSubgraph of G;
    B1: G1.cost() <= G3.cost() by dWGMINCOST;
        the_Edges_of G1 = the_Edges_of G2 by A1, GLIB_000:def 36;
        hence G2'.cost() <= G3.cost() by B1,A1,tGCOST02;
    end;
    hence thesis by dWGMINCOST;
end;
   
theorem ::tPRIMINIT01
  for G being real-weighted WGraph holds
    G == PRIM:Init(G) &
    the_Weight_of G = the_Weight_of PRIM:Init(G) &
    the_ELabel_of PRIM:Init(G) = {} &
    the_VLabel_of PRIM:Init(G) = (choose the_Vertices_of G).-->1
      by lPRIMINIT01;

theorem ::tPRIMINIT02
  for G being real-weighted WGraph holds
    PRIM:Init(G).labeledV() = {choose the_Vertices_of G} &
    PRIM:Init(G).labeledE() = {} by lPRIMINIT02;

theorem ::lPRIMSTEP02
  for G being real-WEV WEVGraph st PRIM:NextBestEdges(G) <> {} holds
     ex v being Vertex of G st not v in G.labeledV() &
     PRIM:Step(G) = G.labelEdge(choose PRIM:NextBestEdges(G),1)
                     .labelVertex(v,1) by lPRIMSTEP02;

theorem ::tPRIMSTEP01
  for G being real-WEV WEVGraph holds
    G == PRIM:Step(G) & the_Weight_of G  = the_Weight_of PRIM:Step(G) &
    G.labeledE() c= PRIM:Step(G).labeledE() &
    G.labeledV() c= PRIM:Step(G).labeledV() by lPRIMSTEP01;

theorem ::tPRIMCS03
  for G being finite real-weighted WGraph, n being Nat holds
     G == PRIM:CompSeq(G).->n &
     the_Weight_of (PRIM:CompSeq(G).->n) = the_Weight_of G by lPRIMCS03;

theorem ::tPRIMCS05
  for G being finite real-weighted WGraph, n being Nat holds
   (PRIM:CompSeq(G).->n).labeledV() is non empty Subset of the_Vertices_of G &
   (PRIM:CompSeq(G).->n).labeledE() c=
     G.edgesBetween((PRIM:CompSeq(G).->n).labeledV()) by lPRIMCS05;

theorem ::tPRIMCS02
  for G1 being finite real-weighted WGraph, n being Nat,
      G2 being inducedSubgraph of G1,(PRIM:CompSeq(G1).->n).labeledV(),
                                     (PRIM:CompSeq(G1).->n).labeledE()
  holds G2 is connected;

theorem ::tPRIMCS04
  for G1 being finite real-weighted WGraph, n being Nat,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).->n).labeledV()
    holds G2 is connected;

theorem ::tPRIMCS08
  for G being finite real-weighted WGraph, n being Nat holds
    (PRIM:CompSeq(G).->n).labeledV() c=
      G.reachableFrom(choose the_Vertices_of G) by lPRIMCS08;

theorem ::tPRIMCS13
  for G being finite real-weighted WGraph, i,j being Nat st i <= j holds
    (PRIM:CompSeq(G).->i).labeledV() c=
    (PRIM:CompSeq(G).->j).labeledV() &
    (PRIM:CompSeq(G).->i).labeledE() c=
    (PRIM:CompSeq(G).->j).labeledE() by lPRIMCS13;

theorem ::tPRIMCS07
    for G being finite real-weighted WGraph, n being Nat holds
      PRIM:NextBestEdges(PRIM:CompSeq(G).->n) = {} iff
   (PRIM:CompSeq(G).->n).labeledV() =
     G.reachableFrom(choose the_Vertices_of G) by lPRIMCS07;

theorem ::tPRIMCS06
  for G being finite real-weighted WGraph, n being Nat holds
    card (PRIM:CompSeq(G).->n).labeledV() =
      min(n+1, card(G.reachableFrom(choose the_Vertices_of G))) by lPRIMCS06;

theorem ::tPRIMCS09
  for G being finite real-weighted WGraph holds
    PRIM:CompSeq(G) is halting & PRIM:CompSeq(G).Lifespan() + 1 =
      card G.reachableFrom(choose the_Vertices_of G) by lPRIMCS09;

theorem ::tPRIMCS11
  for G1 being finite real-weighted WGraph, n being Nat,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).->n).labeledV(),
                                      (PRIM:CompSeq(G1).->n).labeledE()
  holds G2 is Tree-like by lPRIMCS11;

theorem ::tPRIMMST02
  for G being finite connected real-weighted WGraph
    holds PRIM:MST(G).labeledV() = the_Vertices_of G by lPRIMMST02;

theorem tPRIMMST03: ::tPRIMMST03
  for G being finite connected real-weighted WGraph, n being Nat holds
   (PRIM:CompSeq(G).->n).labeledE() c= PRIM:MST(G).labeledE()
proof
    let G be finite connected real-weighted WGraph, n be Nat;
    set PCS = PRIM:CompSeq(G), PMST = PRIM:MST(G);
A1: PMST = PCS.Result() by dPRIMMST
        .= PCS.(PCS.Lifespan()) by GLIB_000:def 58
        .= PCS.->(PCS.Lifespan()) by GLIB_000:def 59;
    defpred P[Nat] means
      (PCS.->(PCS.Lifespan()+$1)) = PRIM:MST(G);
A2: P[0] by A1;
A3: now let n be Nat; assume
    B1: P[n];
        set off = PCS.Lifespan();
        set Gn = PCS.->(off+n), Gn1 = PCS.->(off+n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    B2: Gn1 = PRIM:Step(Gn) by dPRIMCS;
    B3: Gn.labeledV() = the_Vertices_of G by B1,lPRIMMST02;
        now assume Next <> {}; then
            consider v being Vertex of Gn such that
        C1: not v in Gn.labeledV() &
            Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by B2,lPRIMSTEP02;
            Gn == G by lPRIMCS03; then
            the_Vertices_of G = the_Vertices_of Gn by GLIB_000:def 36;
            hence contradiction by C1,B3;
        end; 
        hence P[n+1] by B1,B2,dPRIMSTEP;
    end;  
A4: for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    now per cases;
    suppose n <= PCS.Lifespan();
        hence thesis by A1,lPRIMCS13;
        end;
    suppose PCS.Lifespan() < n; then
        consider k being Nat such that
    B1: n = PCS.Lifespan() + k by NAT_1:28;
        thus thesis by B1,A4;
        end;
    end;
    hence thesis;
end;

theorem ::tPRIMMST04
  for G1 being finite connected real-weighted WGraph,
      G2 being inducedWSubgraph of G1, PRIM:MST(G1).labeledV(),
                                       PRIM:MST(G1).labeledE() holds
      G2 is minimumSpanningTree of G1
proof
    let G1 be finite connected real-weighted WGraph; set PMST = PRIM:MST(G1);
    let G2 be inducedWSubgraph of G1, PMST.labeledV(), PMST.labeledE();
    set PCS = PRIM:CompSeq(G1);
A1: PMST = PCS.Result() by dPRIMMST
        .= PCS.(PCS.Lifespan()) by GLIB_000:def 58
        .= PCS.->(PCS.Lifespan()) by GLIB_000:def 59; then
    PMST == G1 & the_Weight_of G1 = the_Weight_of PMST by lPRIMCS03; then
A3: the_Edges_of G1 = the_Edges_of PMST by GLIB_000:def 36; 
A4: PMST.labeledV() = the_Vertices_of G1 by lPRIMMST02;
    PMST.labeledE() c= the_Edges_of G1 by A3; then
A5: PMST.labeledE() c= G1.edgesBetween(PMST.labeledV())
      by A4, GLIB_000:37;
    PMST.labeledV() c= the_Vertices_of G1 by lPRIMMST02; then
A6: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 = PMST.labeledE() by A4,A5,GLIB_000:def 39; then
A7: G2 is Tree-like & G2 is spanning by A1,lPRIMCS11, GLIB_000:def 35;
    reconsider G2'=G2 as Tree-like _Graph by A1,lPRIMCS11;
    now assume
    B1: not G2 is minimumSpanningTree of G1;
        set X = {x where x is Element of G1.allWSubgraphs() :
                 x is minimumSpanningTree of G1};
        now let x be set; assume x in X; then
            consider G2 being Element of G1.allWSubgraphs() such that
        C1: x = G2 & G2 is minimumSpanningTree of G1;
            thus x in G1.allWSubgraphs() by C1;
        end; then
        reconsider X as finite Subset of G1.allWSubgraphs()
          by TARSKI:def 3,FINSET_1:13;
        now consider M being minimumSpanningTree of G1;
            set M' = M.strict(WGraphSelectors);
            M' == M & the_Weight_of M' = the_Weight_of M by lWSSEL01; then
            reconsider M' as minimumSpanningTree of G1 by tMST02;
            dom M' = WGraphSelectors by lWSSEL02; then
            M' in G1.allWSubgraphs() by dGALLWSUBG; then
            M' in X;
            hence X <> {};
        end; then
        reconsider X as non empty finite Subset of G1.allWSubgraphs();
        defpred Z[finite _Graph, Nat] means
          not (PCS.->($2+1)).labeledE() c= the_Edges_of $1 &        
          for n being Nat st n <= $2 holds
            (PCS.->n).labeledE() c= the_Edges_of $1;
        defpred P[finite _Graph, finite _Graph] means
           card (the_Edges_of $1 /\ the_Edges_of G2) >
           card (the_Edges_of $2 /\ the_Edges_of G2) or
          (card (the_Edges_of $1 /\ the_Edges_of G2) =
           card (the_Edges_of $2 /\ the_Edges_of G2) &
           for k1,k2 being Nat st Z[$1,k1] & Z[$2,k2] holds k1 >= k2);
    X4: now let G be Element of X;
            G in X; then
            consider G' being Element of G1.allWSubgraphs() such that
        C1: G = G' & G' is minimumSpanningTree of G1;
            reconsider G' = G as minimumSpanningTree of G1 by C1;
        C2: the_Vertices_of G2 = the_Vertices_of G' by A6,GLIB_000:def 35;
        C3: now assume
            D1: the_Edges_of G2 = the_Edges_of G';
            D2: G2 == G' by D1, C2,GLIB_000:89;
                the_Weight_of G2 = (the_Weight_of G1) | the_Edges_of G2
                                   by GLIB_003:def 10
                                .= the_Weight_of G' by D1,GLIB_003:def 10;
                hence contradiction by B1,D2,tMST02;
            end;
            defpred P4[Nat] means not (PCS.->$1).labeledE()c= the_Edges_of G';
            now assume the_Edges_of G2 c= the_Edges_of G'; then
                the_Edges_of G2 c< the_Edges_of G' by C3,XBOOLE_0:def 8; then
                card the_Edges_of G2 < card the_Edges_of G' by CARD_2:67; then
                G2.size() < card the_Edges_of G' by GLIB_000:def 27; then
                G2.size() < G'.size() by GLIB_000:def 27; then
                G2.size() + 1 < G'.size() + 1 by REAL_1:67; then
            C1: G2.order() < G'.size() + 1 by A7,GLIB_002:46;
                G2.order() = card the_Vertices_of G' by C2, GLIB_000:def 26
                          .= G'.order() by GLIB_000:def 26;
                hence contradiction by C1,GLIB_002:46;
            end; then
        CT: ex n being Nat st P4[n] by A1,A6;
            consider k3 being Nat such that
        CS: P4[k3] & for n being Nat st P4[n] holds k3 <= n
              from NAT_1:sch 5(CT);
            now assume k3 = 0; then
            C1: not PRIM:Init(G1).labeledE() c= the_Edges_of G' by CS,dPRIMCS;
                the_ELabel_of PRIM:Init(G1) = {} by lPRIMINIT01; then
                PRIM:Init(G1).labeledE() = {} by RELAT_1:60,GLIB_003:def 20;
                hence contradiction by C1, XBOOLE_1:2;
            end; then consider k2 being Nat such that
        CR: k2 + 1 = k3 by NAT_1:22;
            k2 + 1 - 1 < k3 - 0 by CR, REAL_1:92; then
        CQ: (PCS.->k2).labeledE() c= the_Edges_of G' by CS;
            now let n be Nat; assume n <= k2; then
             (PCS.->n).labeledE() c= (PCS.->k2).labeledE() by lPRIMCS13;
                hence (PCS.->n).labeledE() c= the_Edges_of G'
                  by CQ, XBOOLE_1:1;
            end;
            hence ex k1 being Nat st Z[G,k1] by CS,CR;
        end;
    X5: now let G be Element of X, k1,k2 be Nat;
            G in X; then
           consider G' being Element of G1.allWSubgraphs() such that
        C1: G = G' & G' is minimumSpanningTree of G1;
            reconsider G' = G as minimumSpanningTree of G1 by C1; assume
            Z[G,k1] & Z[G,k2]; then
            k1+1 > k2 & k2+1 > k1; then
            k1 >= k2 & k2 >= k1 by NAT_1:38;
            hence k1 = k2 by AXIOMS:21;
        end;
    X1: X is finite & X <> {} & X c= X;
        now let x,y be Element of X;
            x in X; then
            consider x' being WSubgraph of G1 such that
        C1: x' = x & dom x' = WGraphSelectors by dGALLWSUBG;
            y in X; then
            consider y' being WSubgraph of G1 such that
        C2: y' = y & dom y' = WGraphSelectors by dGALLWSUBG;
            set CX = card (the_Edges_of x' /\ the_Edges_of G2);
            set CY = card (the_Edges_of y' /\ the_Edges_of G2);
            now per cases by REAL_1:def 5;
            suppose CX < CY;
                hence P[x,y] or P[y,x] by C1,C2; end;
            suppose
            D1: CY = CX;
                consider k1 being Nat such that
            D2: Z[x,k1] by X4;
                consider k2 being Nat such that
            D3: Z[y,k2] by X4;
                now per cases;
                suppose
                E1: k1 >= k2;
                    now let z1,z2 be Nat; assume Z[x,z1] & Z[y,z2]; then
                        z1 = k1 & z2 = k2 by D2,D3,X5;
                        hence z1 >= z2 by E1;
                    end;
                    hence P[x,y] or P[y,x] by D1,C1,C2; end;
                suppose
                E1: k1 < k2;
                    now let z1,z2 be Nat; assume Z[x,z1] & Z[y,z2]; then
                        z1 = k1 & z2 = k2 by D2,D3,X5;
                        hence z1 <= z2 by E1;
                    end;
                    hence P[x,y] or P[y,x] by D1,C1,C2; end;
                end;
                hence P[x,y] or P[y,x]; end;
            suppose CX > CY;
                hence P[x,y] or P[y,x] by C1,C2; end;                
            end;
            hence P[x,y] or P[y,x];
        end; then
    X2: for x,y being Element of X holds P[x,y] or P[y,x];
        now let x,y,z be Element of X; assume
        C1: P[x,y] & P[y,z];
            x in X; then
            consider x' being WSubgraph of G1 such that
        C2: x' = x & dom x' = WGraphSelectors by dGALLWSUBG;
            y in X; then
            consider y' being WSubgraph of G1 such that
        C3: y' = y & dom y' = WGraphSelectors by dGALLWSUBG;
            z in X; then
            consider z' being WSubgraph of G1 such that
        C4: z' = z & dom z' = WGraphSelectors by dGALLWSUBG;
            set CX = card (the_Edges_of x' /\ the_Edges_of G2);
            set CY = card (the_Edges_of y' /\ the_Edges_of G2);
            set CZ = card (the_Edges_of z' /\ the_Edges_of G2);
            now per cases by C1, C2, C3;
            suppose
            D1: CX > CY;
                now per cases by C1, C3, C4;
                suppose CY > CZ;
                    hence P[x,z] by C2,C4,D1,AXIOMS:22; end;
                suppose CY = CZ &
                    for ky,kz being Nat st Z[y',ky] & Z[z',kz] holds ky >= kz;
                    hence P[x,z] by D1, C2,C4; end;
                end;
                hence P[x,z]; end;
            suppose
            D1: CX = CY &
                for kx,ky being Nat st Z[x',kx] & Z[y',ky] holds kx >= ky;
                now per cases by C1, C3, C4;
                suppose CY > CZ;
                    hence P[x,z] by C2,C4,D1; end;
                suppose
                E1: CY = CZ &
                    for ky,kz being Nat st Z[y',ky] & Z[z',kz] holds ky >= kz;
                    consider zx being Nat;
                    consider zy being Nat such that
                E3: Z[y,zy] by X4;
                    consider zz being Nat;
                    now let kx,kz be Nat; assume
                        Z[x',kx] & Z[z',kz]; then
                        kx >= zy & zy >= kz by C3,D1, E1, E3;
                        hence kx >= kz by AXIOMS:22;
                    end;
                    hence P[x,z] by D1,E1,C2,C4; end;
                end;
                hence P[x,z]; end;
            end;
            hence P[x,z];
        end; then
    X3: for x,y,z being Element of X st P[x,y] & P[y,z]
          holds P[x,z];
        consider M being Element of X such that
    B5: M in X & for y being Element of X
          st y in X holds P[M,y] from CQC_SIM1:sch 4(X1,X2,X3);
        consider x being Element of G1.allWSubgraphs() such that
    B6: M = x & x is minimumSpanningTree of G1 by B5; 
        reconsider M as minimumSpanningTree of G1 by B6;
    B7: the_Vertices_of G2 = the_Vertices_of M by A6,GLIB_000:def 35;
    B8: now assume
        C1: the_Edges_of G2 = the_Edges_of M; then
        C2: G2 == M by B7, GLIB_000:89;
            the_Weight_of G2 = (the_Weight_of G1) | the_Edges_of G2
                                 by GLIB_003:def 10
                            .= the_Weight_of M by C1,GLIB_003:def 10;
            hence contradiction by B1,C2,tMST02;
        end;
        defpred P2[Nat] means not (PCS.->$1).labeledE() c= the_Edges_of M;
        now assume the_Edges_of G2 c= the_Edges_of M; then
            the_Edges_of G2 c< the_Edges_of M by B8,XBOOLE_0:def 8; then
            card the_Edges_of G2 < card the_Edges_of M by CARD_2:67; then
            G2.size() < card the_Edges_of M by GLIB_000:def 27; then
            G2.size() < M.size() by GLIB_000:def 27; then
            G2.size() + 1 < M.size() + 1 by REAL_1:67; then
        C1: G2.order() < M.size() + 1 by A7,GLIB_002:46;
            G2.order() = card the_Vertices_of M by B7, GLIB_000:def 26
                      .= M.order() by GLIB_000:def 26;
            hence contradiction by C1,GLIB_002:46;
        end; then
    B9: ex k being Nat st P2[k] by A1,A6;
        consider k being Nat such that
    BA: P2[k] & for n being Nat st P2[n] holds k <= n from NAT_1:sch 5(B9);
        now assume k = 0; then
        C1: not PRIM:Init(G1).labeledE() c= the_Edges_of M by BA,dPRIMCS;
            the_ELabel_of PRIM:Init(G1) = {} by lPRIMINIT01; then
            PRIM:Init(G1).labeledE() = {} by RELAT_1:60,GLIB_003:def 20;
            hence contradiction by C1, XBOOLE_1:2;
        end; then
        consider k_1 being Nat such that
    BB: k = k_1 + 1 by NAT_1:22;
        set Gk_1 = PCS.->k_1, Gk = PCS.->k;
    BC: Gk = PRIM:Step(Gk_1) by BB, dPRIMCS;
        k_1 + 1 - 1 < k - 0 by BB, REAL_1:92; then
    BD: Gk_1.labeledE() c= the_Edges_of M by BA;        
        set Next = PRIM:NextBestEdges(Gk_1), ep = choose Next;
    BE: Next <> {} by BC,dPRIMSTEP,BD,BA; then
    BF: ep in Next;
        consider v being Vertex of Gk_1 such that
    BG: not v in Gk_1.labeledV() &
        Gk = Gk_1.labelEdge(ep,1).labelVertex(v,1) by BC,BE,lPRIMSTEP02;
    XZ: Gk.labeledE() = Gk_1.labelEdge(ep,1).labeledE() by BG,GLIB_003:56
                     .= Gk_1.labeledE() \/ {ep} by BF, GLIB_003:52; then
    XY: not {ep} c= the_Edges_of M by BA,BD,XBOOLE_1:8; then
    BH: not ep in the_Edges_of M by ZFMISC_1:37;
        set V = Gk_1.labeledV();
    BI: Gk_1 == G1 by lPRIMCS03; then
    BJ: the_Vertices_of Gk_1 = the_Vertices_of G1 by GLIB_000:def 36
                            .= the_Vertices_of M by GLIB_000:def 35; then
        reconsider V as non empty Subset of the_Vertices_of M by lPRIMCS05;
        consider Mep being inducedWSubgraph of G1,the_Vertices_of G1,
                                                 the_Edges_of M \/ {ep};
        set v1 = (the_Source_of Mep).ep, v2 = (the_Target_of Mep).ep;
        ep in the_Edges_of Gk_1 by BF; then
        ep in the_Edges_of G1 by BI, GLIB_000:def 36; then
        {ep} c= the_Edges_of G1 & the_Edges_of M c= the_Edges_of G1
          by ZFMISC_1:37; then
        the_Edges_of M \/ {ep} c= the_Edges_of G1 by XBOOLE_1:8; then
        the_Vertices_of G1 c= the_Vertices_of G1 &
        the_Edges_of M \/ {ep} c= G1.edgesBetween(the_Vertices_of G1)
          by GLIB_000:37; then
    BL: the_Vertices_of Mep = the_Vertices_of G1 &
        the_Edges_of Mep = the_Edges_of M \/ {ep} by GLIB_000:def 39;
        the_Vertices_of M c= the_Vertices_of Mep &
          the_Edges_of M c= the_Edges_of Mep by BL,XBOOLE_1:7; then
        reconsider M'=M as connected Subgraph of Mep by GLIB_000:47;        
        ep in {ep} by TARSKI:def 1; then
    BM: ep in the_Edges_of Mep by BL, XBOOLE_0:def 2;
        the_Vertices_of Mep = the_Vertices_of M by BL,GLIB_000:def 35; then
        reconsider v1,v2 as Vertex of M by BM,GLIB_000:6;
        consider W being Walk of M' such that
    BN: W is_Walk_from v2,v1 by GLIB_002:def 1;
        consider PW being Path of W;
    BO: PW is_Walk_from v2,v1 by BN, GLIB_001:161;
    BP: PW.edges() c= the_Edges_of M;
        reconsider P=PW as Path of Mep by GLIB_001:176;
    BQ: P.edges() c= the_Edges_of M by BP,GLIB_001:111;
    BR: P is_Walk_from v2,v1 by BO, GLIB_001:20;
        ep in {ep} by TARSKI:def 1; then
    BS: ep in Gk.labeledE() by XZ, XBOOLE_0:def 2;
    BT: Gk.labeledE() c= PMST.labeledE() by tPRIMMST03; then
    BU: {ep} /\ the_Edges_of G2 = {ep} by BS,A6,ZFMISC_1:52;
    BV: ep Joins v1,v2,Mep by BM, GLIB_000:def 15; then
        ep Joins v1,v2,G1 by GLIB_000:75; then
    BW: ep Joins v1,v2,G2' by BS,BT,A6,GLIB_000:76; then
        ((the_Source_of G2).ep = v1 & (the_Target_of G2).ep = v2) or
        ((the_Target_of G2).ep = v1 & (the_Source_of G2).ep = v2)
          by GLIB_000:def 15; then
        v1 <> v2 by A6,BS,BT,BW,GLIB_000:def 20; then
        v1 <> P.first() by BR,GLIB_001:def 23; then
        P.last() <> P.first() by BR,GLIB_001:def 23; then
    BX: P is open by GLIB_001:def 24;
    BY: ep Joins P.last(),v2,Mep by BR,BV,GLIB_001:def 23;
    BZ: not ep in P.edges() by BQ,XY,ZFMISC_1:37;
        now let n be odd Nat; assume
        C1: 1 < n & n <= len P & P.n = v2;
            v2 = P.first() by BR,GLIB_001:def 23
              .= P.(2*0+1) by GLIB_001:def 6; then
            n = len P by C1,GLIB_001:def 28; then
            P.last() = v2 by C1, GLIB_001:def 7
                    .= P.first() by BR,GLIB_001:def 23; then
        C3: P is closed by GLIB_001:def 24;
            reconsider PM = P as Walk of M;
            PM is Path-like & PM is closed & PM is non trivial
              by C3,C1,GLIB_001:127,GLIB_001:177; then
            PM is Cycle-like by GLIB_001:def 31;
            hence contradiction by GLIB_002:def 2;
        end; then
    Ba: P.addEdge(ep) is Path-like by BX,BY,BZ,GLIB_001:151;
        set C = P.addEdge(ep);
    Bb: P.addEdge(ep) is non trivial by BY, GLIB_001:133;
        P.addEdge(ep) is_Walk_from v2,v2 by BR,BV,GLIB_001:67; then
        P.addEdge(ep) is closed by GLIB_001:120; then
    Bd: C is Cycle-like by Ba,Bb,GLIB_001:def 31;
    By: ep SJoins Gk_1.labeledV(), the_Vertices_of Gk_1 \ Gk_1.labeledV(),Gk_1
          by BE,dPRIMNEXT;
        Gk_1 == G1 by lPRIMCS03; then
        (the_Source_of Gk_1).ep=(the_Source_of G1).ep &
        (the_Target_of Gk_1).ep=(the_Target_of G1).ep by GLIB_000:def 36; then
    Bx: (the_Source_of Gk_1).ep = v1 & (the_Target_of Gk_1).ep = v2
          by BM, GLIB_000:def 34;
    Bw: v1 = P.(len P) & v2 = P.1 by BO,GLIB_001:18;
        now per cases by By, Bx, GLIB_000:def 17;
        suppose
        C1: v1 in Gk_1.labeledV() & v2 in the_Vertices_of Gk_1\Gk_1.labeledV();
            defpred P3[Nat] means
              $1 is odd & $1 <= len P & P.$1 in Gk_1.labeledV();
        C2: ex n being Nat st P3[n] by Bw, C1;
            consider m being Nat such that
        C3: P3[m] & for n being Nat st P3[n] holds m <= n from NAT_1:sch 5(C2);
            reconsider m as odd Nat by C3;
        C4: 1 <= m & m <= len P by C3, HEYTING3:1;
            m <> 1 by C3,XBOOLE_0:def 4,Bw,C1; then
            1 < m by C4, REAL_1:def 5; then
            1+1 <= m by NAT_1:38; then
            reconsider m_2 = m-2*1 as odd Nat by INT_1:18;
        C5: m_2 < m - 0 by REAL_1:92; then
        C6: m_2 < len P by C3,AXIOMS:22; then
        C7: not P.m_2 in Gk_1.labeledV() by C3, C5;
        C8: m_2+2 = m;
            set em = P.(m_2+1); take em;
        C9: em in P.edges() by C6,GLIB_001:101;
            C.edges() = P.edges() \/ {ep} by BY, GLIB_001:112;
            hence em in C.edges() by C9, XBOOLE_0:def 2;
            consider i being even Nat such that
        CC: 1 <= i & i <= len P & P.i = em by C9, GLIB_001:100;
            i in dom P by CC, FINSEQ_3:27; then
        CD: C.i = em by BY, CC, GLIB_001:66;
        CE: len C = len P + 2 by BY, GLIB_001:65;
        CF: C.(len P + 1) = ep by BY, GLIB_001:66;
            len P + 0 < len P + 1 by REAL_1:67; then
        CG: i < len P + 1 by CC, AXIOMS:22;
        CH: len P + 1 <= len P + 2 by REAL_1:55;
            C is Trail-like by Ba, GLIB_001:def 28;
            hence em <> ep by CC, CE, CD, CF, CG, CH, GLIB_001:139;
        CI: em Joins PW.m_2, PW.m, M by C6,C8,GLIB_001:def 3; then
            PW.m_2 in the_Vertices_of M by GLIB_000:16; then
            PW.m_2 in the_Vertices_of M\Gk_1.labeledV() by C7,XBOOLE_0:def 4;
            hence em SJoins V, the_Vertices_of M \ V, M
              by C3,CI,GLIB_000:20; end;
        suppose
        C1: v2 in Gk_1.labeledV() & v1 in the_Vertices_of Gk_1\Gk_1.labeledV();
            defpred P3[Nat] means
              $1 is odd & $1 <= len P &
              P.$1 in the_Vertices_of Gk_1\Gk_1.labeledV();
        C2: ex n being Nat st P3[n] by Bw, C1;
            consider m being Nat such that
        C3: P3[m] & for n being Nat st P3[n] holds m <= n from NAT_1:sch 5(C2);
            reconsider m as odd Nat by C3;
        C4: 1 <= m & m <= len P by C3, HEYTING3:1;
            m <> 1 by Bw,C1,C3,XBOOLE_0:def 4; then
            1 < m by C4, REAL_1:def 5; then
            1+1 <= m by NAT_1:38; then
            reconsider m_2 = m-2*1 as odd Nat by INT_1:18;
        C5: m_2 < m - 0 by REAL_1:92; then
        C6: m_2 < len P by C3,AXIOMS:22;
        C7: now assume
            D1: not P.m_2 in Gk_1.labeledV();
                P.m_2 in the_Vertices_of Gk_1 by C6, BJ, GLIB_001:8; then
                P.m_2 in the_Vertices_of Gk_1\Gk_1.labeledV()
                  by D1,XBOOLE_0:def 4;
                hence contradiction by C3,C5,C6;
            end;
        C8: m_2+2 = m;
            set em = P.(m_2+1); take em;
        C9: em in P.edges() by C6,GLIB_001:101;
            C.edges() = P.edges() \/ {ep} by BY, GLIB_001:112;
            hence em in C.edges() by C9, XBOOLE_0:def 2;
            consider i being even Nat such that
        CC: 1 <= i & i <= len P & P.i = em by C9, GLIB_001:100;
            i in dom P by CC, FINSEQ_3:27; then
        CD: C.i = em by BY, CC, GLIB_001:66;
        CE: len C = len P + 2 by BY, GLIB_001:65;
        CF: C.(len P + 1) = ep by BY, GLIB_001:66;
            len P + 0 < len P + 1 by REAL_1:67; then
        CG: i < len P + 1 by CC, AXIOMS:22;
        CH: len P + 1 <= len P + 2 by REAL_1:55;
            C is Trail-like by Ba, GLIB_001:def 28;
            hence em <> ep by CC, CE, CD, CF, CG, CH, GLIB_001:139;
            em Joins PW.m_2, PW.m, M by C6,C8,GLIB_001:def 3;
            hence em SJoins V, the_Vertices_of M \ V, M
              by C3,BJ,C7,GLIB_000:20; end;            
        end; then
        consider em being set such that
    Be: em in C.edges() & em <> ep & em SJoins V, the_Vertices_of M \ V, M;
    Xz: em SJoins V, the_Vertices_of Gk_1 \ V, G1 by GLIB_000:75,Be,BJ; then
        em SJoins V, the_Vertices_of Gk_1 \ V, Gk_1 by BI, GLIB_000:91; then
        (the_Weight_of Gk_1).ep <= (the_Weight_of Gk_1).em by BE,dPRIMNEXT;then
        (the_Weight_of G1).ep <= (the_Weight_of Gk_1).em by lPRIMCS03; then
    Bf: (the_Weight_of G1).ep <= (the_Weight_of G1).em by lPRIMCS03;
        consider M2 being weight-inheriting ([Weighted] removeEdge of Mep,em);
        reconsider M2 as WSubgraph of G1 by GLIB_003:16;
        the_Vertices_of M c= the_Vertices_of Mep &
          the_Edges_of M c= the_Edges_of Mep by BL,XBOOLE_1:7; then
        reconsider M'=M as connected Subgraph of Mep by GLIB_000:47;
        the_Vertices_of M' = the_Vertices_of Mep by BL, GLIB_000:def 35; then
        M' is spanning by GLIB_000:def 35; then
        Mep is connected by GLIB_002:23; then
    Bg: M2 is connected by Bd, Be, GLIB_002:5;
    Bh: the_Edges_of M2 = the_Edges_of M \/ {ep} \{em} by BL,GLIB_000:54;
        now 
        C1: {em} c= the_Edges_of M \/ {ep} by Be,BL,ZFMISC_1:37;
        C2: M2.size() = card the_Edges_of M2 by GLIB_000:def 27
                      .= card (the_Edges_of M \/{ep})-card {em}
                         by C1,Bh,CARD_2:63
                      .= card (the_Edges_of M \/ {ep}) - 1 by CARD_1:79
                      .= card the_Edges_of M + 1 - 1 by BH,CARD_2:54
                      .= M.size() by GLIB_000:def 27;
            M2.order() = card the_Vertices_of M2 by GLIB_000:def 26
                       .= card the_Vertices_of G1 by BL, GLIB_000:56
                       .= card the_Vertices_of M by GLIB_000:def 35
                       .= M.order() by GLIB_000:def 26;
            hence M2.order() = M2.size() + 1 by C2,GLIB_002:46;
        end; then
    Bi: M2 is Tree-like by Bg, GLIB_002:47;
        set M2' = M2.strict(WGraphSelectors);
    Bj: M2' == M2 & the_Weight_of M2' = the_Weight_of M2 by lWSSEL01; then
    Bk: the_Edges_of M2' = the_Edges_of M \/ {ep} \ {em} by Bh,GLIB_000:def 36;
        reconsider M2' as WSubgraph of G1 by Bj,GLIB_003:15;
        now thus M2' is Tree-like by Bi, Bj, GLIB_002:48;
            the_Vertices_of M2' = the_Vertices_of M2 by Bj,GLIB_000:def 36
                               .= the_Vertices_of G1 by BL, GLIB_000:56;
            hence M2' is spanning by GLIB_000:def 35;
        end; then
        reconsider M2' as spanning Tree-like WSubgraph of G1;
        now
        C0: G1.edgesBetween(the_Vertices_of G1) = the_Edges_of G1
              by GLIB_000:37; then
        C1: the_Edges_of M c= G1.edgesBetween(the_Vertices_of G1) &
            the_Vertices_of G1 c= the_Vertices_of G1;
        CZ: the_Edges_of G1 = the_Edges_of Gk_1 by BI, GLIB_000:def 36;
            the_Vertices_of G1 = the_Vertices_of M by GLIB_000:def 35; then
            M is inducedWSubgraph of G1,the_Vertices_of G1, the_Edges_of M
              by C0,GLIB_000:def 39; then            
        C2: Mep.cost() = M.cost() + (the_Weight_of G1).ep
              by CZ,BF,C0,C1,BH,tGCOST04;
            M2.cost() + (the_Weight_of Mep).em = Mep.cost() by Be,tGCOST03;then
        C4: M2.cost() = Mep.cost() - (the_Weight_of Mep).em by XCMPLX_1:26;
            the_Weight_of Mep = (the_Weight_of G1) | the_Edges_of Mep
              by GLIB_003:def 10; then
        C5: M2.cost() = M.cost()+(the_Weight_of G1).ep
              - (the_Weight_of G1).em by C2,Be,C4,FUNCT_1:72;
            the_Edges_of M2 = the_Edges_of M2' by Bj, GLIB_000:def 36;
            hence M2'.cost() = M.cost()+(the_Weight_of G1).ep
              - (the_Weight_of G1).em by Bj,C5,tGCOST02;
        end; then
    XA: M2'.cost() + (the_Weight_of G1).em - (the_Weight_of G1).em <=
          M.cost() + (the_Weight_of G1).ep - (the_Weight_of G1).ep
          by Bf,REAL_1:92;
        now let G3 being spanning Tree-like WSubgraph of G1;
            M.cost() <= G3.cost() by dWGMINCOST;
            hence M2'.cost() <= G3.cost() by XA, AXIOMS:22;
        end; then
        reconsider M2' as minimumSpanningTree of G1 by dWGMINCOST;
        set MG2' = the_Edges_of M2' /\ the_Edges_of G2;
        set MG2 = the_Edges_of M /\ the_Edges_of G2;
    Bl: MG2' = ((the_Edges_of M \/ {ep}) /\ the_Edges_of G2) \
          {em} /\ the_Edges_of G2 by Bk, XBOOLE_1:50;
        now assume MG2 /\ {ep} <> {}; then
            consider x being set such that
        C1: x in MG2 /\ {ep} by XBOOLE_0:def 1;
            x in MG2 & x in {ep} by C1,XBOOLE_0:def 3; then
            x in the_Edges_of M & x = ep by XBOOLE_0:def 3, TARSKI:def 1;
            hence contradiction by XY,ZFMISC_1:37;
        end; then
    Bz: MG2 misses {ep} by XBOOLE_0:def 7;
        dom M2' = WGraphSelectors by lWSSEL02; then
        M2' in G1.allWSubgraphs() by dGALLWSUBG; then
    Bq: M2' in X;
    Br: now thus not (PCS.->(k_1+1)).labeledE() c= the_Edges_of M by BA,BB;
            let n be Nat; assume n <= k_1; then
            (PCS.->n).labeledE() c= Gk_1.labeledE() by lPRIMCS13;
            hence (PCS.->n).labeledE() c= the_Edges_of M by BD, XBOOLE_1:1;
        end;
    Bx: now assume
        C1: em in the_Edges_of G2; then
        C2: MG2'=((the_Edges_of M \/ {ep}) /\ the_Edges_of G2)\{em}
              by ZFMISC_1:52,Bl;
            now let x be set; assume x in {em}; then
                x = em by TARSKI:def 1;
                hence x in (the_Edges_of M \/ {ep}) /\ the_Edges_of G2
                  by BL,Be,C1,XBOOLE_0:def 3;
            end; then
            {em}c=(the_Edges_of M\/{ep})/\the_Edges_of G2 by TARSKI:def 3; then
        C8: card MG2' = card (the_Edges_of Mep /\ the_Edges_of G2) -
                        card {em} by BL, C2,CARD_2:63
                     .= card (the_Edges_of Mep /\ the_Edges_of G2) - 1
                          by CARD_1:79
                     .= card (MG2 \/ {ep}) - 1 by BU, BL, XBOOLE_1:23
                     .= card MG2 + card {ep} - 1 by Bz, CARD_2:53
                     .= card MG2 + 1 - 1 by CARD_1:79
                     .= card MG2;
            consider k2 being Nat such that 
        C4: Z[M2',k2] by Bq, X4;
        CY: now set _V = the_Vertices_of Gk_1 \ V; assume
            D1: em in Gk_1.labeledE();
                Gk_1.labeledE() c= G1.edgesBetween(Gk_1.labeledV())
                  by lPRIMCS05; then
                (the_Source_of G1).em in Gk_1.labeledV() &
                (the_Target_of G1).em in Gk_1.labeledV() by D1,GLIB_000:34;then
                not (the_Source_of G1).em in _V &
                  not (the_Target_of G1).em in _V by XBOOLE_0:def 4;
                hence contradiction by Xz,GLIB_000:def 17;
            end;
            now let x be set; assume
            D1: x in Gk.labeledE();
                now per cases by D1,XBOOLE_0:def 2,XZ;
                suppose
                E0: x in Gk_1.labeledE(); then
                E1: x in the_Edges_of M \/ {ep} by XBOOLE_0:def 2,BD;
                    not x in {em} by TARSKI:def 1,CY,E0;
                    hence x in the_Edges_of M2' by E1,Bk, XBOOLE_0:def 4; end;
                suppose
                E1: x in {ep}; then
                E2: x in the_Edges_of M \/ {ep} by XBOOLE_0:def 2;
                    x = ep by E1, TARSKI:def 1; then
                    not x in {em} by Be, TARSKI:def 1;
                    hence x in the_Edges_of M2' by Bk, E2, XBOOLE_0:def 4; end;
                end;
                hence x in the_Edges_of M2';
            end; then
        CZ: Gk.labeledE() c= the_Edges_of M2' by TARSKI:def 3;
        C5: now assume k2 < k; then
                k2+1 <= k by NAT_1:38; then
                (PCS.->(k2+1)).labeledE() c= Gk.labeledE() by lPRIMCS13;
                hence contradiction by C4,CZ,XBOOLE_1:1;
            end;
        C6: k_1 >= k2 by C8,Bq,Br,B5,C4;
            k_1 + 1 - 1 < k - 0 by BB, REAL_1:92;            
            hence contradiction by C6,C5,AXIOMS:22;
        end;
        now assume {em} /\ the_Edges_of G2 <> {}; then
            consider x being set such that
        C1: x in {em} /\ the_Edges_of G2 by XBOOLE_0:def 1; 
            x in {em} & x in the_Edges_of G2 by C1,XBOOLE_0:def 3;
            hence contradiction by Bx,TARSKI:def 1;
        end; then
    Bo: MG2' = MG2 \/ ({ep} /\ the_Edges_of G2) by Bl,XBOOLE_1:23;
        now assume MG2 /\ {ep} <> {}; then
            consider x being set such that
        C1: x in MG2 /\ {ep} by XBOOLE_0:def 1;
            x in MG2 & x in {ep} by C1,XBOOLE_0:def 3; then
            x in the_Edges_of M & x = ep by XBOOLE_0:def 3, TARSKI:def 1;
            hence contradiction by XY,ZFMISC_1:37;
        end; then
        MG2 misses {ep} by XBOOLE_0:def 7; then
        card MG2' = card MG2 + card {ep} by Bo,BU,CARD_2:53
                 .= card MG2 + 1 by CARD_1:79; then
        card MG2 + 0 >= card MG2 + 1 by Bq,B5;
        hence contradiction by REAL_1:53;
    end;
    hence thesis;
end;
