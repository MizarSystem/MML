:: Proof of Dijkstra's Shortest Path Algorithm & Prim's Minimum Spanning
:: Tree Algorithm
::  by Gilbert Lee and Piotr Rudnicki
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies ALGSEQ_1, AMI_1, ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSEQ_2, FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003, GLIB_004, GRAPH_1, MATRIX_2, MSAFREE2,
      NEWTON, PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, QUANTAL1, REALSET1,
      RELAT_1, RELAT_2, RLVECT_1, SQUARE_1, TARSKI, TREES_1, UPROOTS;
 notations TARSKI, XBOOLE_0, ZFMISC_1, ENUMSET1, CARD_1, NUMBERS, SUBSET_1,
      XCMPLX_0,
      XXREAL_0, XREAL_0, DOMAIN_1, REAL_1, RELAT_1, PARTFUN1, FUNCT_1,
      FINSEQ_1, FINSEQ_2, SEQ_1, PBOOLE, FUNCT_2, RVSUM_1, ABIAN,
      ORDINAL1, POLYNOM1, UPROOTS, FINSET_1, NAT_1, FUNCOP_1, FUNCT_4,
      GLIB_000, GLIB_001, GLIB_002, GLIB_003;
 constructors DOMAIN_1, REAL_1, SQUARE_1, BINOP_2, FINSOP_1, RVSUM_1, GRAPH_2,
      UPROOTS, GLIB_002, GLIB_003;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, CARD_1, MEMBERED, GLIB_000,
      ABIAN, POLYNOM1, GLIB_001, GLIB_002, GLIB_003;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, GLIB_000, GLIB_003, RVSUM_1, FUNCOP_1;
 theorems BAGORDER, CARD_1, CARD_2, FUNCOP_1, ENUMSET1, FINSEQ_1, FINSEQ_2,
      FINSEQ_3, FINSET_1, FRAENKEL, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003, HEYTING3, INT_1, JORDAN12, NAT_1, PARTFUN1,
      PBOOLE, POLYNOM1, REAL_1, RELAT_1, RVSUM_1, SEQ_1, TARSKI, TREES_1,
      UPROOTS, XBOOLE_0, XBOOLE_1, XREAL_0, ZFMISC_1, XREAL_1, XXREAL_0,
      ORDINAL1, FINSOP_1, FUNCT_7;
 schemes NAT_1, SUBSET_1, RECDEF_1, GRAPH_5, CQC_SIM1;

begin :: Preliminaries on Sum of RBag

theorem Th1: ::tSUPPORT01
  for f, g being Function holds
    support (f +* g) c= support f \/ support g
proof
    let f, g be Function;
    let a be set;
    assume a in support (f +* g);
then A1: (f +* g).a <> 0 by POLYNOM1:def 7;
    assume not a in support f \/ support g;
    then not a in support f & not a in support g by XBOOLE_0:def 2;
then A2: f.a = 0 & g.a = 0 by POLYNOM1:def 7;
     a in dom g or not a in dom g;
    hence contradiction by A1,A2,FUNCT_4:12,14;
end;

theorem Th2: ::tSUPPORT02
  for f being Function, x, y being set holds
    support (f +* (x.-->y)) c= support f \/ {x}
proof
    let f be Function, x, y be set;
    let a be set;
    assume a in support (f +* (x.-->y));
then A1: (f +* (x.-->y)).a <> 0 by POLYNOM1:def 7;
    per cases;
    suppose a = x; then a in {x} by TARSKI:def 1;
        hence a in support f \/ {x} by XBOOLE_0:def 2; end;
    suppose a <> x;
        then (f +* (x.-->y)).a  = f.a by FUNCT_4:88;
        then a in support f by A1,POLYNOM1:def 7;
        hence a in support f \/ {x} by XBOOLE_0:def 2; end;
end;

theorem Th3: ::tRBAGSUM01
  for A,B being set, b being Rbag of A,
      b1 being Rbag of B, b2 being Rbag of A\B
   st b = b1 +* b2 holds Sum b = Sum b1 + Sum b2
proof
   let A, B be set, b be Rbag of A,
          b1 be Rbag of B, b2 be Rbag of A\B such that
A1: b = b1 +* b2;
   set B1 = (EmptyBag A) +* b1;
   set B2 = (EmptyBag A) +* b2;
 rng B1 c= rng (EmptyBag A) \/ rng b1 by FUNCT_4:18;
then A2: rng B1 c= REAL by XBOOLE_1:1;
 support B1 c= (support EmptyBag A) \/ support b1 by Th1;
then A3: support B1 is finite by FINSET_1:13;
    dom b = dom b1 \/ dom b2 by A1,FUNCT_4:def 1;
   then dom b1 c= dom b by XBOOLE_1:7;
   then B c= dom b by PBOOLE:def 3;
then A4: B c= A by PBOOLE:def 3;
    dom B1 = (dom EmptyBag A) \/ dom b1 by FUNCT_4:def 1
        .= A \/ dom b1 by PBOOLE:def 3
        .= A \/ B by PBOOLE:def 3
        .= A by A4,XBOOLE_1:12;
   then reconsider B1 as Rbag of A by A2,A3,PBOOLE:def 3,POLYNOM1:def 8
,SEQ_1:def 1;
 rng B2 c= rng (EmptyBag A) \/ rng b2 by FUNCT_4:18;
then A5: rng B2 c= REAL by XBOOLE_1:1;
 support B2 c= (support EmptyBag A) \/ support b2 by Th1;
then A6: support B2 is finite by FINSET_1:13;
    dom B2 = (dom EmptyBag A) \/ dom b2 by FUNCT_4:def 1
        .= A \/ dom b2 by PBOOLE:def 3
        .= A \/ (A\B) by PBOOLE:def 3
        .= A by XBOOLE_1:12;
   then reconsider B2 as Rbag of A by A5,A6,PBOOLE:def 3,POLYNOM1:def 8
,SEQ_1:def 1;
   consider f1 being FinSequence of REAL such that
A7: Sum b1 = Sum f1 and
A8: f1 = b1*canFS(support b1) by UPROOTS:def 3;
   consider F1 being FinSequence of REAL such that
A9: Sum B1 = Sum F1 and
A10: F1 = B1*canFS(support B1) by UPROOTS:def 3;
A11: rng canFS(support b1) = support b1 by UPROOTS:5;
A12: support b1 c= dom b1 by POLYNOM1:41;
then A13: dom f1 = dom canFS(support b1) by A8,A11,RELAT_1:46;
A14: rng canFS(support B1) = support B1 by UPROOTS:5;
    support B1 c= dom B1 by POLYNOM1:41;
then A15: dom F1 = dom canFS(support B1) by A10,A14,RELAT_1:46;
A16: now let x be set;
     hereby assume
     A17: x in support b1;
     then A18: b1.x <> 0 by POLYNOM1:def 7;
          support b1 c= dom b1 by POLYNOM1:41;
         then B1.x = b1.x by A17,FUNCT_4:14;
      hence x in support B1 by A18,POLYNOM1:def 7;
     end;
     assume A19: x in support B1;
     then A20: B1.x <> 0 by POLYNOM1:def 7;
         per cases;
         suppose not x in dom b1;
            then B1.x = (EmptyBag A).x by FUNCT_4:12 .= 0 by POLYNOM1:56;
           hence x in support b1 by A19,POLYNOM1:def 7;
         end;
         suppose x in dom b1;
            then B1.x = b1.x by FUNCT_4:14;
           hence x in support b1 by A20,POLYNOM1:def 7;
         end;
   end;
then A21: support b1 = support B1 by TARSKI:2;
A22: dom f1 = dom F1 by A13,A15,A16,TARSKI:2;
    now let k be Nat such that
   A23: k in dom f1;
   A24: (canFS(support b1)).k in rng canFS(support b1) by A13,A23,FUNCT_1:12;
    thus f1.k = b1.((canFS(support b1)).k) by A8,A13,A23,FUNCT_1:23
             .= B1.((canFS(support b1)).k) by A11,A12,A24,FUNCT_4:14
             .= F1.k by A10,A13,A21,A23,FUNCT_1:23;
   end;
then A25: Sum B1 = Sum b1 by A7,A9,A22,FINSEQ_1:17;
   consider f2 being FinSequence of REAL such that
A26: Sum b2 = Sum f2 and
A27: f2 = b2*canFS(support b2) by UPROOTS:def 3;
   consider F2 being FinSequence of REAL such that
A28: Sum B2 = Sum F2 and
A29: F2 = B2*canFS(support B2) by UPROOTS:def 3;
A30: rng canFS(support b2) = support b2 by UPROOTS:5;
A31: support b2 c= dom b2 by POLYNOM1:41;
then A32: dom f2 = dom canFS(support b2) by A27,A30,RELAT_1:46;
A33: rng canFS(support B2) = support B2 by UPROOTS:5;
    support B2 c= dom B2 by POLYNOM1:41;
then A34: dom F2 = dom canFS(support B2) by A29,A33,RELAT_1:46;
    now let x be set;
     hereby assume
     A35: x in support b2;
     then A36: b2.x <> 0 by POLYNOM1:def 7;
          support b2 c= dom b2 by POLYNOM1:41;
         then B2.x = b2.x by A35,FUNCT_4:14;
      hence x in support B2 by A36,POLYNOM1:def 7;
     end;
     assume
     A37: x in support B2;
     then A38: B2.x <> 0 by POLYNOM1:def 7;
         per cases;
         suppose not x in dom b2;
            then B2.x = (EmptyBag A).x by FUNCT_4:12 .= 0 by POLYNOM1:56;
           hence x in support b2 by A37,POLYNOM1:def 7;
         end;
         suppose x in dom b2;
            then B2.x = b2.x by FUNCT_4:14;
           hence x in support b2 by A38,POLYNOM1:def 7;
         end;
   end;
then A39: support b2 = support B2 by TARSKI:2;
    now let k be Nat such that
   A40: k in dom f2;
   A41: (canFS(support b2)).k in rng canFS(support b2) by A32,A40,FUNCT_1:12;
    thus f2.k = b2.((canFS(support b2)).k) by A27,A32,A40,FUNCT_1:23
             .= B2.((canFS(support b2)).k) by A30,A31,A41,FUNCT_4:14
             .= F2.k by A29,A32,A39,A40,FUNCT_1:23;
   end;
then A42: Sum B2 = Sum b2 by A26,A28,A32,A34,A39,FINSEQ_1:17;
    now let x be set; assume
   A43: x in A;
   A44: dom b1 = B by PBOOLE:def 3;
   A45: dom b2 = A\B by PBOOLE:def 3;
    per cases;
    suppose A46: x in B;
    then A47: not x in dom b2 by A45,XBOOLE_0:def 4;
    A48: B1.x = b1.x by A44,A46,FUNCT_4:14;
     B2.x = (EmptyBag A).x by A47,FUNCT_4:12 .= 0 by POLYNOM1:56;
     hence b.x =  B1.x + B2.x by A1,A47,A48,FUNCT_4:12
             .= (B1 + B2).x by POLYNOM1:def 5;
    end;
    suppose A49: not x in B;
    then A50: B1.x = (EmptyBag A).x by A44,FUNCT_4:12 .= 0 by POLYNOM1:56;
    A51: x in dom b2 by A43,A45,A49,XBOOLE_0:def 4;
    then B2.x = b2.x by FUNCT_4:14;
    hence b.x = B1.x + B2.x by A1,A50,A51,FUNCT_4:14
             .= (B1 + B2).x by POLYNOM1:def 5;
    end;
   end;
   then b = B1 + B2 by PBOOLE:3;
   hence Sum b = Sum b1 + Sum b2 by A25,A42,UPROOTS:17;
end;

theorem Th4: ::tRBAGSUM02
  for X,x being set, b being Rbag of X
   st dom b = {x} holds Sum b = b.x
proof
    let X,x be set, b be Rbag of X; assume
A1: dom b = {x};
then A2: support b c= {x} by POLYNOM1:41;
     {x} c= X by A1,PBOOLE:def 3;
    then consider f being FinSequence of REAL such that
A3: f = b*canFS({x}) & Sum b = Sum f by A2,UPROOTS:16;
A4: f = b*<*x*> by A3,UPROOTS:6;
     x in dom b by A1,TARSKI:def 1;
    then f = <*b.x*> by A4,BAGORDER:3;
    hence Sum b = b.x by A3,FINSOP_1:12;
end;

theorem Th5: ::tRBAGSUM03
  for A being set, b1,b2 being Rbag of A
   st (for x being set st x in A holds b1.x <= b2.x) holds
   Sum b1 <= Sum b2
proof
   let A be set, b1,b2 be Rbag of A such that
A1: for x being set st x in A holds b1.x <= b2.x;
   set S = support b1 \/ support b2;
A2: dom b1 = A & dom b2 = A by PBOOLE:def 3;
   then support b1 c= A & support b2 c= A by POLYNOM1:41;
   then reconsider S as finite Subset of A by XBOOLE_1:8;
    support b1 c= S by XBOOLE_1:7;
   then consider f1 being FinSequence of REAL such that
A3: f1 = b1*canFS(S) and
A4: Sum b1 = Sum f1 by UPROOTS:16;
    support b2 c= S by XBOOLE_1:7;
   then consider f2 being FinSequence of REAL such that
A5: f2 = b2*canFS(S) and
A6: Sum b2 = Sum f2 by UPROOTS:16;
A7: rng canFS(S) = S by UPROOTS:5;
then A8: dom f1 = dom canFS(S) & dom f2 = dom canFS(S) by A2,A3,A5,RELAT_1:46;
then A9: len f1 = len f2 by FINSEQ_3:31;
A10: f1 is Element of (len f1)-tuples_on REAL by FINSEQ_2:110;
A11: f2 is Element of (len f2)-tuples_on REAL by FINSEQ_2:110;
    now let j be Nat; assume j in Seg len f1;
   then A12: j in dom f1 by FINSEQ_1:def 3;
   then A13: f1.j = b1.((canFS(S)).j) & f2.j = b2.((canFS(S)).j)
               by A3,A5,A8,FUNCT_1:23;
        (canFS(S)).j in S by A7,A8,A12,FUNCT_1:12;
     hence f1.j <= f2.j by A1,A13;
   end;
   hence Sum b1 <= Sum b2 by A4,A6,A9,A10,A11,RVSUM_1:112;
end;

theorem ::tRBAGSUM04
   for A being set, b1,b2 being Rbag of A
   st (for x being set st x in A holds b1.x = b2.x)
   holds Sum b1 = Sum b2
proof
   let A be set, b1,b2 be Rbag of A; assume
A1: for x being set st x in A holds b1.x = b2.x;
    then for x being set st x in A holds b1.x <= b2.x;
then A2: Sum b1 <= Sum b2 by Th5;
     for x being set st x in A holds b2.x <= b1.x by A1;
    then Sum b2 <= Sum b1 by Th5;
    hence thesis by A2,XXREAL_0:1;
end;

theorem ::tRBAGSUM05
   for A1,A2 being set, b1 being Rbag of A1, b2 being Rbag of A2
   st b1 = b2 holds Sum b1 = Sum b2
proof
    let A1,A2 be set, b1 be Rbag of A1, b2 be Rbag of A2; assume
 b1 = b2;
    then consider f1 being FinSequence of REAL such that
A1: Sum b1 = Sum f1 & f1 = b2*canFS(support b2) by UPROOTS:def 3;
    consider f2 being FinSequence of REAL such that
A2: Sum b2 = Sum f2 & f2 = b2*canFS(support b2) by UPROOTS:def 3;
    thus Sum b1 = Sum b2 by A1,A2;
end;

theorem Th8: ::tRBAGSUM06
  for X, x being set, b being Rbag of X, y being real number
   st b = (EmptyBag X) +* (x.-->y) holds Sum b = y
proof
   let X, x be set, b be Rbag of X, y be real number such that
A1: b = (EmptyBag X) +* (x.-->y);
A2: dom (x.-->y) = {x} by FUNCOP_1:19;
     dom b = dom EmptyBag X \/ dom (x.-->y) by A1,FUNCT_4:def 1;
then A3: {x} c= dom b by A2,XBOOLE_1:7;
    then {x} c= X by PBOOLE:def 3;
then A4: x in X by ZFMISC_1:37;
   reconsider S = {x} as finite Subset of X by A3,PBOOLE:def 3;
 support b c= S proof let a be set; assume a in support b;
   then A5: b.a <> 0 by POLYNOM1:def 7;
    assume not a in S; then a <> x by TARSKI:def 1;
      then b.a = (EmptyBag X).a by A1,FUNCT_4:88;
    hence contradiction by A5,POLYNOM1:56;
   end;
   then consider f being FinSequence of REAL such that
A6: f = b*canFS(S) and
A7: Sum b = Sum f by UPROOTS:16;
A8: canFS(S) = <*x*> by UPROOTS:6;
    x in dom b by A4,PBOOLE:def 3;
   then f = <*b.x*> by A6,A8,BAGORDER:3;
 hence Sum b = b.x by A7,FINSOP_1:12
            .= y by A1,FUNCT_7:96;
end;

theorem ::tRBAGSUM07
   for X, x being set, b1, b2 being Rbag of X, y being real number
   st b2 = b1 +* (x.-->y) holds Sum b2 = Sum b1 + y - b1.x
proof
   let X, x be set, b1, b2 be Rbag of X, y be real number such that
A1: b2 = b1 +* (x.-->y);
A2: dom (x.-->y) = {x} by FUNCOP_1:19;
     dom b2 = dom b1 \/ dom (x.-->y) by A1,FUNCT_4:def 1;
    then {x} c= dom b2 by A2,XBOOLE_1:7;
    then {x} c= X by PBOOLE:def 3;
then A3: x in X by ZFMISC_1:37;
   set a = b1 +* (x.-->0);
A4: rng a c= rng b1 \/ rng (x.-->0) by FUNCT_4:18;
A5: rng (x.-->0) = {0} by FUNCOP_1:14;
     {0} c= REAL by ZFMISC_1:37;
    then rng b1 \/ rng (x.-->0) c= REAL by A5,XBOOLE_1:8;
then A6: rng a c= REAL by A4,XBOOLE_1:1;
 support a c= support b1 \/ {x} by Th2;
then A7: support a is finite by FINSET_1:13;
    dom a = dom b1 \/ dom (x.-->0) by FUNCT_4:def 1
        .= X \/ dom (x.-->0) by PBOOLE:def 3
        .= X \/ {x} by FUNCOP_1:19
        .= X by A3,ZFMISC_1:46;
   then reconsider a as Rbag of X by A6,A7,PBOOLE:def 3,POLYNOM1:def 8
,SEQ_1:def 1;
    set b = (EmptyBag X) +* (x .--> b1.x);
A8: rng b c= rng (EmptyBag X) \/ rng (x.-->b1.x) by FUNCT_4:18;
 rng (x.-->b1.x) = {b1.x} by FUNCOP_1:14;
    then rng (EmptyBag X) \/ rng (x.-->b1.x) c= REAL by XBOOLE_1:8;
then A9: rng b c= REAL by A8,XBOOLE_1:1;
 support b c= (support EmptyBag X) \/ {x} by Th2;
then A10: support b is finite by FINSET_1:13;
    dom b = (dom EmptyBag X) \/ dom (x.-->b1.x) by FUNCT_4:def 1
        .= X \/ dom (x.-->b1.x) by PBOOLE:def 3
        .= X \/ {x} by FUNCOP_1:19
        .= X by A3,ZFMISC_1:46;
   then reconsider b as Rbag of X by A9,A10,PBOOLE:def 3,POLYNOM1:def 8
,SEQ_1:def 1
;
   set c = (EmptyBag X) +* (x.-->y);
A11: rng c c= rng (EmptyBag X) \/ rng (x.-->y) by FUNCT_4:18;
A12: rng (x.-->y) = {y} by FUNCOP_1:14;
     y in REAL by XREAL_0:def 1;
   then {y} c= REAL by ZFMISC_1:37;
    then rng (EmptyBag X) \/ rng (x.-->y) c= REAL by A12,XBOOLE_1:8;
then A13: rng c c= REAL by A11,XBOOLE_1:1;
 support c c= (support EmptyBag X) \/ {x} by Th2;
then A14: support c is finite by FINSET_1:13;
    dom c = (dom EmptyBag X) \/ dom (x.-->y) by FUNCT_4:def 1
        .= X \/ dom (x.-->y) by PBOOLE:def 3
        .= X \/ {x} by FUNCOP_1:19
        .= X by A3,ZFMISC_1:46;
   then reconsider c as Rbag of X by A13,A14,PBOOLE:def 3,POLYNOM1:def 8
,SEQ_1:def 1
;
    now let i be set; assume i in X;
   A15: (EmptyBag X).i = 0 by POLYNOM1:56;
    per cases;
    suppose A16: i = x;
     thus (a+b).i = a.i + b.i by POLYNOM1:def 5
                 .= 0 + b.i by A16,FUNCT_7:96 .= b1.i by A16,FUNCT_7:96;
    end;
    suppose A17: i <> x;
     thus (a+b).i = a.i + b.i by POLYNOM1:def 5
       .= b1.i + b.i by A17,FUNCT_4:88
       .= b1.i + 0 by A15,A17,FUNCT_4:88        .= b1.i;
    end;
   end;
   then b1 = a+b by PBOOLE:3;
then A18: Sum b1 - Sum b = Sum a + Sum b - Sum b by UPROOTS:17;
A19: Sum c = y by Th8;
A20: Sum b = b1.x by Th8;
    now let i be set; assume i in X;
   A21: (EmptyBag X).i = 0 by POLYNOM1:56;
    per cases;
     suppose A22: i = x;
      hence b2.i = y by A1,FUNCT_7:96      .= 0 + c.i by A22,FUNCT_7:96
               .= a.i + c.i by A22,FUNCT_7:96 .= (a+c).i by POLYNOM1:def 5;
     end;
     suppose A23: i <> x;
     then A24: c.i = 0 by A21,FUNCT_4:88;
      thus b2.i = b1.i by A1,A23,FUNCT_4:88
               .= a.i + c.i by A23,A24,FUNCT_4:88
               .= (a+c).i by POLYNOM1:def 5;
     end;
   end;
   then b2 = a+c by PBOOLE:3;
 hence Sum b2 = Sum b1 - Sum b + Sum c by A18,UPROOTS:17
             .= Sum b1 + y - b1.x by A19,A20;
end;

begin :: Definitions for Dijkstra's Shortest Path Algorithm

definition let G1 be real-weighted WGraph, G2 be WSubgraph of G1, v be set;
  pred G2 is_mincost_DTree_rooted_at v means :Def1:
    G2 is Tree-like &
    for x being Vertex of G2 holds
      ex W2 being DPath of G2 st W2 is_Walk_from v,x &
      for W1 being DPath of G1 st W1 is_Walk_from v,x holds
        W2.cost() <= W1.cost();
end;

definition let G be real-weighted WGraph, W be DPath of G, x,y be set;
  pred W is_mincost_DPath_from x,y means :Def2: ::dWMINCOSTD
     W is_Walk_from x,y & for W2 being DPath of G st
    W2 is_Walk_from x,y holds W.cost() <= W2.cost();
end;

definition let G be finite real-weighted WGraph, x,y be set;
  func G.min_DPath_cost(x,y) -> Real means :Def3: ::dWGMINDCOST
    ex W being DPath of G st W is_mincost_DPath_from x,y & it = W.cost() if
    ex W being DWalk of G st W is_Walk_from x,y otherwise it = 0;
  existence
  proof
    set X = {W where W is DPath of G: W is_Walk_from x,y};
     now let e be set; assume e in X; then consider
        W being DPath of G such that
    A1: e = W & W is_Walk_from x,y;
         e in {w where w is DPath of G: not contradiction} by A1;
        hence e in G.allDPaths() by GLIB_001:def 38;
    end; then reconsider X as finite Subset of G.allDPaths()
      by FINSET_1:13,TARSKI:def 3;
    hereby assume ex W being DWalk of G st W is_Walk_from x,y;
        then consider W being DWalk of G such that
    A2: W is_Walk_from x,y;
        consider P being DPath of W;
         P is_Walk_from x,y by A2,GLIB_001:161;
        then P in X; then reconsider X as non empty finite Subset of G
.allDPaths();
        deffunc F(Element of X) = $1.cost();
        consider W1 being Element of X such that
    A3: for W2 being Element of X holds F(W1) <= F(W2) from GRAPH_5:sch 2;
         W1 in X; then consider WA being DPath of G such that
    A4: WA = W1 & WA is_Walk_from x,y;
    A5: now let WB be DPath of G; assume WB is_Walk_from x,y;
            then WB in X; then reconsider WB' = WB as Element of X;
             F(W1) <= F(WB') by A3;
            hence WA.cost() <= WB.cost() by A4;
        end;
        reconsider WA as DPath of G;
        set IT = WA.cost();
        take IT, WA;
        thus WA is_mincost_DPath_from x,y by A4,A5,Def2;
        thus IT = WA.cost();
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1,IT2 be Real;
    hereby assume ex W being DWalk of G st W is_Walk_from x,y;
        given W1 being DPath of G such that
    A6: W1 is_mincost_DPath_from x,y & IT1 = W1.cost();
        given W2 being DPath of G such that
    A7: W2 is_mincost_DPath_from x,y & IT2 = W2.cost();
    A8: W1 is_Walk_from x,y & for W2 being DPath of G st
          W2 is_Walk_from x,y holds W1.cost() <= W2.cost() by A6,Def2;
    A9: W2 is_Walk_from x,y & for W1 being DPath of G st
          W1 is_Walk_from x,y holds W2.cost() <= W1.cost() by A7,Def2;
    A10: IT2 <= IT1 by A6,A7,A8,Def2;
         IT1 <= IT2 by A6,A7,A9,Def2;
        hence IT1 = IT2 by A10,XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be real-WEV WEVGraph;
  func DIJK:NextBestEdges(G) -> Subset of the_Edges_of G means :Def4:
  for e1 being set holds e1 in it iff
    e1 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
    for e2 being set st
    e2 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G holds
        (the_VLabel_of G).((the_Source_of G).e1) + (the_Weight_of G).e1 <=
        (the_VLabel_of G).((the_Source_of G).e2) + (the_Weight_of G).e2;
  existence proof
    defpred P[set] means
    $1 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
    for e2 being set
     st e2 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
     holds (the_VLabel_of G).((the_Source_of G).$1)+(the_Weight_of G).$1 <=
           (the_VLabel_of G).((the_Source_of G).e2)+(the_Weight_of G).e2;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
      from SUBSET_1:sch 1;
    take IT;
     now let e1 be set;
        thus e1 in IT implies P[e1] by A1;
        assume
    A2: P[e1];
        then e1 in the_Edges_of G by GLIB_000:def 18;
        hence e1 in IT by A1,A2;
    end;
    hence thesis;
  end;
  uniqueness proof
    defpred P[set] means
    $1 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
    for e2 being set
     st e2 DSJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
     holds (the_VLabel_of G).((the_Source_of G).$1)+(the_Weight_of G).$1 <=
           (the_VLabel_of G).((the_Source_of G).e2)+(the_Weight_of G).e2;
    let IT1,IT2 be Subset of the_Edges_of G such that
A3: for y being set holds y in IT1 iff P[y] and
A4: for y being set holds y in IT2 iff P[y];
     now let x be set;
        hereby assume x in IT1;
            then P[x] by A3;
            hence x in IT2 by A4;
        end;
        assume x in IT2;
        then P[x] by A4;
        hence x in IT1 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

definition let G be real-WEV WEVGraph;
  func DIJK:Step(G) -> real-WEV WEVGraph equals :Def5: ::dDIJKSTEP
    G if DIJK:NextBestEdges(G) = {} otherwise
    G.labelEdge(choose DIJK:NextBestEdges(G),1)
      .labelVertex((the_Target_of G).(choose DIJK:NextBestEdges(G)),
        (the_VLabel_of G).((the_Source_of G).(choose DIJK:NextBestEdges(G)))
          + (the_Weight_of G).(choose DIJK:NextBestEdges(G)));
  coherence;
  consistency;
end;

registration let G be finite real-WEV WEVGraph;
  cluster DIJK:Step(G) -> finite;
  coherence proof
    set e = choose DIJK:NextBestEdges(G);
     now per cases;
    suppose DIJK:NextBestEdges(G) = {};
        hence DIJK:Step(G) is finite by Def5; end;
    suppose DIJK:NextBestEdges(G) <> {};
        then DIJK:Step(G) = G.labelEdge(e,1).labelVertex((the_Target_of G).e,
        (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e)
          by Def5;
        hence DIJK:Step(G) is finite; end;
    end;
    hence thesis;
  end;
end;

registration let G be nonnegative-weighted real-WEV WEVGraph;
  cluster DIJK:Step(G) -> nonnegative-weighted;
  coherence proof
    set e = choose DIJK:NextBestEdges(G);
     now per cases;
    suppose DIJK:NextBestEdges(G) = {};
        hence thesis by Def5; end;
    suppose DIJK:NextBestEdges(G) <> {};
        then DIJK:Step(G) = G.labelEdge(e,1).labelVertex((the_Target_of G).e,
        (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e)
          by Def5;
        hence thesis; end;
    end;
    hence thesis;
  end;
end;

definition let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:Init(G, src) -> real-WEV WEVGraph equals  ::dDIJKINIT:
     G.set(ELabelSelector,{}).set(VLabelSelector,src.-->0);
   coherence proof
    set G2 = G.set(ELabelSelector, {});
     G2 == G by GLIB_003:8;
    then reconsider src'=src as Vertex of G2 by GLIB_000:def 36;
     G2.set(VLabelSelector,(src'.-->0)) is real-WEV WEVGraph;
    hence thesis;
   end;
end;

definition let s be WEVGraphSeq, n be Nat;
 redefine func s.n -> WEVGraph;
 coherence
  proof
   thus s.n is [Weighted] [ELabeled] [VLabeled] _Graph;
  end;
end;

registration let s be real-WEV WEVGraphSeq, n be Nat;
 cluster s.n -> real-WEV WEVGraph;
 coherence by GLIB_003:def 31;
end;

definition let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:CompSeq(G,src) -> real-WEV WEVGraphSeq means :Def7: ::dDIJKCS
    it.0 = DIJK:Init(G,src) &
    for n being Element of NAT holds it.(n+1) = DIJK:Step(it.n);
  existence proof
    defpred P[set,set,set] means
      ($2 is real-WEV WEVGraph &
          ex Gn,Gn1 being real-WEV WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = DIJK:Step(Gn)) or
      (not $2 is real-WEV WEVGraph & $2 = $3);
     now let n,x be set;
         now per cases;
        suppose x is real-WEV WEVGraph;
            then reconsider Gn=x as real-WEV WEVGraph;
             P[n,x,DIJK:Step(Gn)];
            hence ex y being set st P[n,x,y]; end;
        suppose not x is real-WEV WEVGraph;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end;
then A1: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A2: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT &
    IT.0 = DIJK:Init(G,src) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3,PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is real-WEV WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat;
A10:  n in NAT by ORDINAL1:def 13;
      assume P2[n];
        then consider Gn,Gn1 being real-WEV WEVGraph such that
    A6: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = DIJK:Step(Gn) by A3,A10;
        thus P2[n+1] by A6;
    end;
A7: for n being Nat holds P2[n] from NAT_1:sch 2(A4,A5);
    then for n being Nat holds IT.n is _Graph;
    then reconsider IT as GraphSeq by GLIB_000:def 55;
A8: for n be Nat holds IT.n is real-WEV WEVGraph
    proof
      let n be Nat;
       n in NAT by ORDINAL1:def 13;
      hence thesis by A7;
    end;
    then for n being Nat holds
      IT.n is [Weighted] & IT.n is [ELabeled] & IT.n is [VLabeled];
    then reconsider IT as WEVGraphSeq
      by GLIB_003:def 24,def 25,def 26;
     for n being Nat holds IT.n is real-WEV by A8;
    then reconsider IT as real-WEV WEVGraphSeq by GLIB_003:def 31;
    take IT;
    thus IT.0 = DIJK:Init(G,src) by A3;
    let n be Element of NAT;
    consider Gn,Gn1 being real-WEV WEVGraph such that
A9: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = DIJK:Step(Gn) by A3;
    thus IT.(n+1) = DIJK:Step(IT.n) by A9;
  end;
  uniqueness proof
    let IT1,IT2 be real-WEV WEVGraphSeq such that
A10: IT1.0 = DIJK:Init(G,src) &
    for n being Element of NAT holds IT1.(n+1) = DIJK:Step(IT1.n) and
A11: IT2.0 = DIJK:Init(G,src) &
    for n being Element of NAT holds IT2.(n+1) = DIJK:Step(IT2.n);
    defpred P[Element of NAT] means IT1.$1 = IT2.$1;
A12: P[0] by A10,A11;
     now let n be Element of NAT; assume P[n];
        then IT1.(n+1) = DIJK:Step(IT2.n) by A10
                   .= IT2.(n+1) by A11;
        hence P[n+1];
    end;
then A13: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A12,A13);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(G,src) -> finite;
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Nat] means DCS.$1 is finite;
     DCS.0 = DIJK:Init(G,src) by Def7
           .= G.set(ELabelSelector,{})
               .set(VLabelSelector,((src.-->0)));
then A1: P[0];
A2: now let n be Element of NAT; assume P[n];
        then reconsider Gn = DCS.n as finite real-WEV WEVGraph;
         DCS.(n+1) = DIJK:Step(Gn) by Def7;
        hence P[n+1];
    end;
A3: for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
     for n being Nat holds P[n]
    proof
      let n be Nat;
       n in NAT by ORDINAL1:def 13;
      hence thesis by A3;
    end;
    hence thesis by GLIB_000:def 60;
  end;
end;

registration let G be nonnegative-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(G,src) -> nonnegative-weighted;
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Nat] means DCS.$1 is nonnegative-weighted;
     DCS.0 = DIJK:Init(G,src) by Def7
           .= G.set(ELabelSelector,{})
               .set(VLabelSelector,(src.-->0));
then A1: P[0];
A2: now let n be Element of NAT; assume P[n];
        then reconsider Gn = DCS.n as nonnegative-weighted real-WEV WEVGraph;
         DCS.(n+1) = DIJK:Step(Gn) by Def7;
        hence P[n+1];
    end;
A3: for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
     for n being Nat holds P[n]
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A3;
    end;
    hence thesis by GLIB_003:def 28;
  end;
end;

definition let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:SSSP(G,src) -> real-WEV WEVGraph equals  ::dDIJKSSSP
     DIJK:CompSeq(G,src).Result();
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
     DCS.Result() = DCS.(DCS.Lifespan());
    hence thesis;
  end;
end;

registration let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:SSSP(G,src) -> finite;
  coherence proof
    set DCS = DIJK:CompSeq(G,src);
    thus thesis by GLIB_000:def 60;
  end;
end;

begin  :: Dijkstra's Algorithm Theorems

theorem Th10: ::tWGMINDCOST01
  for G being finite nonnegative-weighted WGraph, W being DPath of G,
    x,y being set, m,n being Element of NAT st W is_mincost_DPath_from x,y
    holds
   W.cut(m,n) is_mincost_DPath_from W.cut(m,n).first(),W.cut(m,n).last()
proof
    let G be finite nonnegative-weighted WGraph, W be DPath of G,
    x,y be set, m,n be Element of NAT;
    assume
A1: W is_mincost_DPath_from x,y;
then A2: W is_Walk_from x,y & for W2 being DPath of G st W2 is_Walk_from x,y
holds
      W.cost() <= W2.cost() by Def2;
    set WC = W.cut(m,n);
A3: WC is_Walk_from WC.first(),WC.last() by GLIB_001:def 23;
A4: W.1 = x & W.(len W) = y by A2,GLIB_001:18;
     now per cases;
    suppose
    A5: m is odd & n is odd & m <= n & n <= len W;
        set W1 = W.cut(1,m), W3 = W.cut(n,len W);
    A6: 1 is odd & 1 <= m & 1 <= n by A5,HEYTING3:1,JORDAN12:3;
    then A7: W1.append(WC) = W.cut(1,n) by A5,GLIB_001:39;
    A8: W.cut(1,n).append(W3) = W.cut(1,len W) by A5,A6,GLIB_001:39
                             .= W by GLIB_001:40;
         W.cut(1,n).last() = W.n by A5,A6,GLIB_001:38
                         .= W3.first() by A5,GLIB_001:38;
    then A9: W.cost() = W.cut(1,n).cost() + W3.cost() by A8,GLIB_003:31;
    A10: m <= len W by A5,XXREAL_0:2;
        then W1.last() = W.m by A5,A6,GLIB_001:38
                 .= WC.first() by A5,GLIB_001:38;
        then W.cut(1,n).cost() = W1.cost() + WC.cost() by A7,GLIB_003:31;
    then A11: W.cost() = WC.cost() + (W1.cost() + W3.cost()) by A9;
    A12: W1 is_Walk_from W.1, W.m by A5,A6,A10,GLIB_001:38;
    A13: W3 is_Walk_from W.n, W.(len W) by A5,GLIB_001:38;
         now assume not WC is_mincost_DPath_from WC.first(),WC.last();
            then consider W2 being DPath of G such that
        A14: W2 is_Walk_from WC.first(), WC.last() & W2.cost() < WC.cost()
              by A3,Def2;
        A15: WC.first() = W.m & WC.last() = W.n by A5,GLIB_001:38;
        then A16: W2.first() = W.m & W2.last() = W.n by A14,GLIB_001:def 23;
            set WA = W1.append(W2), WB = WA.append(W3);
             WA is_Walk_from W.1, W.n by A12,A14,A15,GLIB_001:32;
        then A17: WB is_Walk_from x,y by A4,A13,GLIB_001:32;
        A18: W1.last() = W2.first() by A5,A6,A10,A16,GLIB_001:38;
        then A19: WA.cost() = W1.cost() + W2.cost() by GLIB_003:31;
             W3.first() = W2.last() by A5,A16,GLIB_001:38
                      .= WA.last() by A18,GLIB_001:31;
            then WB.cost() = W1.cost() + W2.cost() + W3.cost() by A19,
GLIB_003:31
                     .= W2.cost() + (W1.cost() + W3.cost());
        then A20: WB.cost() < W.cost() by A11,A14,XREAL_1:10;
            consider WB2 being DPath of WB;
             WB2.cost() <= WB.cost() by GLIB_003:37;
        then A21: WB2.cost() < W.cost() by A20,XXREAL_0:2;
             WB2 is_Walk_from x,y by A17,GLIB_001:161;
            hence contradiction by A1,A21,Def2;
        end;
        hence thesis; end;
    suppose
    A22: not (m is odd & n is odd & m <= n & n <= len W);
        then WC = W by GLIB_001:def 11;
        then WC.first() = x & WC.last() = y by A2,GLIB_001:def 23;
        hence thesis by A1,A22,GLIB_001:def 11; end;
    end;
    hence thesis;
end;

theorem Th11: ::tWGMINDCOST02
  for G being finite real-weighted WGraph, W1,W2 being DPath of G,
      x,y being set st
    W1 is_mincost_DPath_from x,y & W2 is_mincost_DPath_from x,y holds
    W1.cost() = W2.cost()
proof
    let G be finite real-weighted WGraph, W1,W2 be DPath of G,
        x,y be set; assume
A1: W1 is_mincost_DPath_from x,y & W2 is_mincost_DPath_from x,y;
then A2: W1 is_Walk_from x,y & for W2 being DPath of G st W2 is_Walk_from x,y
      holds W1.cost() <= W2.cost() by Def2;
     W2 is_Walk_from x,y & for W1 being DPath of G st W1 is_Walk_from x,y
      holds W2.cost() <= W1.cost() by A1,Def2;
    then W1.cost() <= W2.cost() & W2.cost() <= W1.cost() by A2;
    hence thesis by XXREAL_0:1;
end;

theorem Th12: ::tWGMINDCOST03
  for G being finite real-weighted WGraph, W being DPath of G, x,y being set st
    W is_mincost_DPath_from x,y holds G.min_DPath_cost(x,y) = W.cost()
proof
    let G be finite real-weighted WGraph, W be DPath of G, x,y be set; assume
A1: W is_mincost_DPath_from x,y;
    then W is_Walk_from x,y by Def2;
    then consider W2 being DPath of G such that
A2: W2 is_mincost_DPath_from x,y & G.min_DPath_cost(x,y) = W2.cost()
      by Def3;
    thus thesis by A1,A2,Th11;
end;

theorem Th13: ::tDSTEP01
  for G being finite real-WEV WEVGraph holds
    (card DIJK:Step(G).labeledV() = card G.labeledV()
        iff DIJK:NextBestEdges(G) = {}) &
    (card DIJK:Step(G).labeledV() = card G.labeledV() + 1
        iff DIJK:NextBestEdges(G) <> {})
proof
    let G be finite real-WEV WEVGraph;
    set BestEdges = DIJK:NextBestEdges(G), e = choose BestEdges;
    set nextEG = G.labelEdge(e,1), nextG = DIJK:Step(G);
    set VG = the_VLabel_of G, VNextEG = the_VLabel_of nextEG;
    set VNextG = the_VLabel_of nextG;
    set cardG = card VG, cardNextEG = card VNextEG, cardNextG = card VNextG;
    set src = (the_Source_of G).e, target = (the_Target_of G).e;
    set val = (the_VLabel_of G).src + (the_Weight_of G).e;
    hereby assume
    A1: card nextG.labeledV() = card G.labeledV();
         now assume
        A2: BestEdges <> {};
        then A3: e in BestEdges;
             G == nextEG by GLIB_003:41;
            then the_Vertices_of G = the_Vertices_of nextEG by GLIB_000:def 36
;
            then reconsider target as Vertex of nextEG by A3,FUNCT_2:7;
        A4: G.labeledV() = nextEG.labeledV() by GLIB_003:63;
             e DSJoins G.labeledV(),the_Vertices_of G \ G.labeledV(), G
              by A2,Def4;
            then target in the_Vertices_of G \ G.labeledV() by GLIB_000:def 18
;
        then not target in nextEG.labeledV() by A4,XBOOLE_0:def 4;
        then card nextEG.labelVertex(target,val).labeledV() =
              card nextEG.labeledV() + 1 by GLIB_003:61;
        then A5: card G.labeledV() = card nextEG.labeledV() + 1
              by A1,A2,Def5;
             G.labeledV() = dom the_VLabel_of nextEG by GLIB_003:43;
            hence contradiction by A5;
        end;
        hence BestEdges = {};
    end;
    thus BestEdges = {} implies card nextG.labeledV() = card G.labeledV()
      by Def5;
    hereby assume
    A6: card nextG.labeledV() = card G.labeledV() + 1;
         now assume BestEdges = {};
            then 0 + card G.labeledV() = card G.labeledV() + 1 by A6,Def5;
            hence contradiction;
        end;
        hence BestEdges <> {};
    end;
    assume
A7: BestEdges <> {};
then A8: e in BestEdges;
     G == nextEG by GLIB_003:41;
    then the_Vertices_of nextEG = the_Vertices_of G by GLIB_000:def 36;
    then reconsider target as Vertex of nextEG by A8,FUNCT_2:7;
A9: nextEG.labelVertex(target,val).labeledV()
      = nextG.labeledV() by A7,Def5;
     A10: the_VLabel_of G = the_VLabel_of nextEG by GLIB_003:43;
     e DSJoins G.labeledV(),the_Vertices_of G \ G.labeledV(), G
      by A7,Def4;
    then target in the_Vertices_of G \ G.labeledV() by GLIB_000:def 18;
     then not target in nextEG.labeledV() by A10,XBOOLE_0:def 4;
    hence thesis by A9,A10,GLIB_003:61;
end;

theorem Th14: ::tDSTEP02
  for G being real-WEV WEVGraph holds
    G == DIJK:Step(G) &
    the_Weight_of  G = the_Weight_of  DIJK:Step(G) &
    G.labeledE() c= DIJK:Step(G).labeledE() &
    G.labeledV() c= DIJK:Step(G).labeledV()
proof
   let G be real-WEV WEVGraph;
    set NextG = DIJK:Step(G);
    set VG = the_VLabel_of G, VNextG = the_VLabel_of NextG;
    set BestEdges = DIJK:NextBestEdges(G), e = choose BestEdges;
    set NextEG = G.labelEdge(e,1), target = (the_Target_of G).e;
    set val = (the_VLabel_of G).((the_Source_of G).e) + (the_Weight_of G).e;
     now per cases;
    suppose BestEdges = {};
        hence G == DIJK:Step(G) &
              the_Weight_of G  = the_Weight_of DIJK:Step(G) &
              G.labeledE() c= NextG.labeledE() &
              G.labeledV() c= NextG.labeledV() by Def5; end;
    suppose
    A1: BestEdges <> {};
    then A2: NextG = NextEG.labelVertex(target,val) by Def5;
    A3: e in BestEdges by A1;
         G == NextEG by GLIB_003:41;
    then A4: the_Vertices_of G = the_Vertices_of NextEG &
        the_VLabel_of G = the_VLabel_of NextEG
          by GLIB_000:def 36,GLIB_003:43;
        then reconsider target as Vertex of NextEG by A3,FUNCT_2:7;
        set LV = NextEG.labelVertex(target, val);
         G == NextEG & NextEG == NextG by A2,GLIB_003:41,47;
        hence G == NextG by GLIB_000:88;
        thus the_Weight_of G  = the_Weight_of NextEG by GLIB_003:42
                             .= the_Weight_of NextG by A2,GLIB_003:48;
         now let x be set; assume
        A5: x in G.labeledE();
            A6: G.labeledE() c= G.labelEdge(e,1).labeledE()
              by A3,GLIB_003:53;
         the_ELabel_of NextEG = the_ELabel_of NextG by A2,GLIB_003:49;
            hence x in NextG.labeledE() by A5,A6;
        end;
        hence G.labeledE() c= NextG.labeledE() by TARSKI:def 3;
         now let x be set; assume
            A7: x in G.labeledV();
             NextEG.labeledV() c= NextEG.labelVertex(target,val).labeledV()
              by GLIB_003:60;
            hence x in NextG.labeledV() by A2,A4,A7;
        end;
        hence G.labeledV() c= NextG.labeledV() by TARSKI:def 3; end;
  end;
  hence thesis;
end;

theorem Th15: ::tDIJKINIT01
  for G being real-weighted WGraph, src be Vertex of G
   holds DIJK:Init(G,src).labeledV() = {src}
proof
    let G be real-weighted WGraph, src be Vertex of G;
    set G2 = DIJK:Init(G,src);
     the_VLabel_of G2 = src .--> 0 by GLIB_000:11;
    hence thesis by FUNCOP_1:19;
end;

theorem Th16: ::tDCS01
  for G being real-weighted WGraph, src being Vertex of G,
  i,j being Element of NAT
   st i <= j holds
   (DIJK:CompSeq(G,src).i).labeledV() c=
     (DIJK:CompSeq(G,src).j).labeledV() &
   (DIJK:CompSeq(G,src).i).labeledE() c=
     (DIJK:CompSeq(G,src).j).labeledE()
proof
    let G be real-weighted WGraph, src be Vertex of G, i,j be Element of NAT;
    set DCS = DIJK:CompSeq(G,src);
    set dDCS = (DCS.i).labeledV();
    set eDCS = (DCS.i).labeledE(); assume i <= j;
    then consider x being Nat such that
A1: j = i + x by NAT_1:10;
    reconsider x as Element of NAT by ORDINAL1:def 13;
A2: j = i + x by A1;
    defpred P[Element of NAT] means dDCS c= (DCS.(i+$1)).labeledV() &
                         eDCS c= (DCS.(i+$1)).labeledE();
A3: P[0];
     now let k be Element of NAT; assume
    A4: dDCS c= (DCS.(i+k)).labeledV() &
        eDCS c= (DCS.(i+k)).labeledE();
         DCS.(i+k+1) = DIJK:Step(DCS.(i+k)) by Def7;
        then (DCS.(i+k)).labeledV() c= (DCS.(i+k+1)).labeledV() &
        (DCS.(i+k)).labeledE() c= (DCS.(i+k+1)).labeledE()
          by Th14;
        hence dDCS c= (DCS.(i+(k+1))).labeledV() &
              eDCS c= (DCS.(i+(k+1))).labeledE() by A4,XBOOLE_1:1;
    end;
then A5: for k being Element of NAT st P[k] holds P[k+1];
     for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A5);
    hence dDCS c= (DCS.j).labeledV() & eDCS c= (DCS.j).labeledE() by A2;
end;

theorem Th17: ::tDCS02
  for G being real-weighted WGraph, src being Vertex of G,
  n being Element of NAT holds
    G == DIJK:CompSeq(G,src).n &
    the_Weight_of G = the_Weight_of (DIJK:CompSeq(G,src).n)
proof
    let G be real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Element of NAT] means
      G == DIJK:CompSeq(G,src).$1 &
      the_Weight_of G  = the_Weight_of (DIJK:CompSeq(G,src).$1);
    A1: DCS.0 = DIJK:Init(G,src) by Def7;
then A2: DCS.0 == G.set(ELabelSelector,{}) by GLIB_003:8;
A3: G == G.set(ELabelSelector, {}) by GLIB_003:8;
     the_Weight_of G = the_Weight_of G.set(ELabelSelector,{}) by GLIB_000:12
                   .= the_Weight_of (DCS.0) by A1,GLIB_000:12;
then A4: P[0] by A2,A3,GLIB_000:88;
     now let k be Element of NAT; assume
    A5: G == DCS.k & the_Weight_of G = the_Weight_of (DCS.k);
    A6: DCS.(k+1) = DIJK:Step(DCS.k) by Def7;
        then DCS.k == DCS.(k+1) by Th14;
        hence G == DCS.(k+1) by A5,GLIB_000:88;
        thus the_Weight_of G = the_Weight_of (DCS.(k+1)) by A5,A6,Th14;
    end;
then A7: for k being Element of NAT st P[k] holds P[k+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A4,A7);
    hence thesis;
end;

theorem Th18: ::tDCS03
  for G being finite real-weighted WGraph, src being Vertex of G,
      n being Element of NAT holds
    (DIJK:CompSeq(G,src).n).labeledV() c= G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src);
    defpred P[Element of NAT] means
     (DCS.$1).labeledV() c= G.reachableDFrom(src);
     DCS.0 = DIJK:Init(G, src) by Def7;
then A1: (DCS.0).labeledV() = {src} by Th15;
     src in G.reachableDFrom(src) by GLIB_002:18;
then A2: P[0] by A1,ZFMISC_1:37;
     now let k be Element of NAT such that
    A3: (DCS.k).labeledV() c= G.reachableDFrom(src);
        set Gk = DCS.k, NextG = DCS.(k+1);
        set VGk = (the_VLabel_of Gk), VNextG = (the_VLabel_of NextG);
        set BestEdges = DIJK:NextBestEdges(Gk), e = choose BestEdges;
        set NextEG = Gk.labelEdge(e,1);
        set v1 = (the_Source_of Gk).e, target = (the_Target_of Gk).e;
        set pc = (the_VLabel_of Gk).v1, ec = (the_Weight_of Gk).e;
    A4: NextG = DIJK:Step(Gk) by Def7;
         now let x be set; assume
        A5: x in (DCS.(k+1)).labeledV();
             now per cases;
            suppose BestEdges = {};
                then Gk = NextG by A4,Def5;
                hence x in G.reachableDFrom(src) by A3,A5; end;
            suppose
            A6: BestEdges <> {};
            then A7: NextG = NextEG.labelVertex(target, pc+ec) by A4,Def5;
                set xx = x, GE = NextEG.labelVertex(target,pc+ec);
                 G == DCS.(k+1) by Th17;
                then reconsider xx as Vertex of G by A5,GLIB_000:def 36;
                 e DSJoins Gk.labeledV(),the_Vertices_of Gk \ Gk.labeledV(),Gk
                  by A6,Def4;
            then A8: v1 in Gk.labeledV() by GLIB_000:def 18;
                then v1 in G.reachableDFrom(src) by A3;
                then reconsider v1' = v1 as Vertex of G;
                 now per cases;
                suppose xx in Gk.labeledV();
                    hence xx in G.reachableDFrom(src) by A3; end;
                suppose not xx in Gk.labeledV();
                then A9: not xx in NextEG.labeledV() by GLIB_003:43;
                     now
                    A10: e in BestEdges by A6;
                    A11: G == Gk by Th17;
                        then the_Edges_of Gk = the_Edges_of G &
                        the_Source_of Gk = the_Source_of G &
                        the_Target_of Gk = the_Target_of G by GLIB_000:def 36;
                        hence e in the_Edges_of G by A10;
                        thus (the_Source_of G).e = v1 by A11,GLIB_000:def 36;
                         target = xx by A5,A7,A9,GLIB_003:62;
                        hence (the_Target_of G).e = xx by A11,GLIB_000:def 36;
                    end; then e DJoins v1',xx,G by GLIB_000:def 16;
                    hence xx in G.reachableDFrom(src)
                      by A3,A8,GLIB_002:19; end;
                end;
                hence x in G.reachableDFrom(src); end;
            end;
            hence x in G.reachableDFrom(src);
        end;
        hence (DCS.(k+1)).labeledV() c= G.reachableDFrom(src)
          by TARSKI:def 3;
    end;
then A12: for k being Element of NAT st P[k] holds P[k+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A12);
    hence thesis;
end;

registration let s be finite WEVGraphSeq, n be Nat;
 cluster s.n -> finite WEVGraph;
 coherence by GLIB_000:def 60;
end;

theorem Th19: ::tDCS05
  for G being finite real-weighted WGraph, src being Vertex of G,
  n being Element of NAT
    holds DIJK:NextBestEdges(DIJK:CompSeq(G,src).n) = {} iff
   (DIJK:CompSeq(G,src).n).labeledV() = G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G,
    n be Element of NAT;
    set DCS = DIJK:CompSeq(G,src), RFS = G.reachableDFrom(src);
    set Gn = DCS.n, Gn1a = DCS.(n+1), VGn = the_VLabel_of Gn;
    set BestEdges = DIJK:NextBestEdges(Gn), e = choose BestEdges;
    set SG = the_Source_of G, SGn = the_Source_of Gn;
    set TG = the_Target_of G, TGn = the_Target_of Gn;
A1: Gn1a = DIJK:Step(Gn) by Def7;
    hereby assume
    A2: BestEdges = {};
         now assume
        A3: Gn.labeledV() <> RFS;
             Gn.labeledV() c= RFS by Th18;
        then A4: Gn.labeledV() c< RFS by A3,XBOOLE_0:def 8;
            defpred P[set] means SGn.$1 in Gn.labeledV() &
                             not TGn.$1 in Gn.labeledV();
            consider BE1 being Subset of the_Edges_of Gn such that
        A5: for x being set holds x in BE1 iff x in the_Edges_of Gn & P[x]
              from SUBSET_1:sch 1;
             now assume
            A6: BE1 = {};
                consider v being set such that
            A7: v in RFS & not v in Gn.labeledV() by A4,XBOOLE_0:6;
                reconsider v as Vertex of G by A7;
                consider W being directed Walk of G such that
            A8: W is_Walk_from src, v by A7,GLIB_002:def 6;
                 DCS.0 = DIJK:Init(G, src) by Def7;
                then (DCS.0).labeledV() = {src} by Th15;
            then A9: src in (DCS.0).labeledV() by TARSKI:def 1;
            A10: (DCS.0).labeledV() c= Gn.labeledV() by Th16;
                defpred P[Nat] means $1 is odd & $1 <= len W &
                  not (W.$1 in Gn.labeledV());
                 W.(len W) = W.last() by GLIB_001:def 7
                         .= v by A8,GLIB_001:def 23;
            then A11: ex k being Nat st P[k] by A7;
                consider k being Nat such that
            A12: P[k] & for m being Nat st P[m] holds k <= m
                  from NAT_1:sch 5(A11);
                 now per cases;
                suppose k = 1;
                    then W.k = W.first() by GLIB_001:def 6
                       .= src by A8,GLIB_001:def 23;
                    hence contradiction by A9,A10,A12; end;
                suppose
                A13: k <> 1; reconsider k'=k as odd Element of NAT
                   by A12,ORDINAL1:def 13;
                     1 <= k by A12,HEYTING3:1;
                    then 1 < k by A13,REAL_1:def 5;
                    then 1+1 < k+1 by XREAL_1:10;
                    then 2*1 <= k by NAT_1:13;
                    then reconsider k2a = k'-2*1 as odd Element of NAT by
INT_1:18;
                A14: k - 2 < len W - 0 by A12,REAL_1:92;
                     k2a < k - 0 by REAL_1:92;
                then A15: W.(k2a) in Gn.labeledV() by A12,A14;
                    set e = W.(k2a+1);
                     e DJoins W.k2a, W.(k2a+2), G by A14,GLIB_001:123;
                then A16: e in the_Edges_of G & (the_Source_of G).e = W.k2a
                      & (the_Target_of G).e = W.(k2a+2) by GLIB_000:def 16;
                     G == Gn by Th17;
                then e in the_Edges_of Gn & SGn.e = W.k2a & TGn.e = W.(k2a+2)
                      by A16,GLIB_000:def 36;
                    hence contradiction by A5,A6,A12,A15; end;
                end;
                hence contradiction;
            end;
            then reconsider BE1 as non empty finite set;
            deffunc F(Element of BE1) =
               (the_VLabel_of Gn).((the_Source_of Gn).$1) +
               (the_Weight_of Gn).($1);
            consider e1 being Element of BE1 such that
        A17: for e2 being Element of BE1 holds F(e1) <= F(e2)
              from GRAPH_5:sch 2;
        A18: e1 in the_Edges_of Gn & (SGn).e1 in Gn.labeledV() &
              not (TGn).e1 in Gn.labeledV() by A5;
            then (TGn).e1 in the_Vertices_of Gn by FUNCT_2:7;
            then (TGn).e1 in the_Vertices_of Gn \ Gn.labeledV()
              by A18,XBOOLE_0:def 4;
        then A19: e1 DSJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(),
Gn
              by A18,GLIB_000:def 18;
             now let y be set; assume
             y DSJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(),Gn
;
            then A20: y in the_Edges_of Gn & (SGn).y in Gn.labeledV() &
                  (TGn).y in the_Vertices_of Gn \ Gn.labeledV()
                  by GLIB_000:def 18;
                then not (TGn).y in Gn.labeledV() by XBOOLE_0:def 4;
                then y in BE1 by A5,A20;
                hence (the_VLabel_of Gn).((the_Source_of Gn).e1) +
                  (the_Weight_of Gn).e1 <=
                  (the_VLabel_of Gn).((the_Source_of Gn).y) +
                  (the_Weight_of Gn).y by A17;
            end;
            hence contradiction by A2,A19,Def4;
        end;
        hence (DCS.n).labeledV() = RFS;
    end;
    assume
A21: (DCS.n).labeledV() = RFS;
     now assume BestEdges <> {};
    then A22: card Gn1a.labeledV() = card RFS + 1 by A1,A21,Th13;
         Gn1a.labeledV() c= RFS by Th18;
        then card Gn1a.labeledV() <=` card RFS by CARD_1:27;
        then card RFS + 1 <= card RFS + 0 by A22,CARD_2:57;
        hence contradiction by XREAL_1:8;
    end;
    hence BestEdges = {};
end;

theorem Th20: ::tDCS06
  for G being finite real-weighted WGraph, src being Vertex of G,
  n being Element of NAT
    holds Card (DIJK:CompSeq(G,src).n).labeledV() =
      min(n+1, card(G.reachableDFrom(src)))
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
     set DCS = DIJK:CompSeq(G, src), VL0 = (DCS.0).labeledV();
     set RFS = G.reachableDFrom(src);
     defpred P[Element of NAT] means Card (DCS.$1).labeledV() =
       min($1+1, card(G.reachableDFrom(src)));
      DCS.0 = DIJK:Init(G,src) by Def7;
then A1:  Card VL0 = Card {src} by Th15
             .= 1 by CARD_1:79;
      src in RFS by GLIB_002:18;
     then {src} c= RFS by ZFMISC_1:37;
     then card {src} <= card RFS by NAT_1:44;
     then 0+1 <= card RFS by CARD_1:79;
then A2:  P[0] by A1,XXREAL_0:def 8;
      now let k be Element of NAT such that
     A3: Card (DCS.k).labeledV() = min(k+1, card RFS);
     A4: DCS.(k+1) = DIJK:Step(DCS.k) by Def7;
         set Gk = DCS.k, Gk1b = DCS.(k+1);
         set VGk = the_VLabel_of Gk;
         set BestEdges = DIJK:NextBestEdges(Gk), e = choose BestEdges;
          now per cases;
         suppose
         A5: BestEdges = {};
         then A6: card Gk1b.labeledV() = card Gk.labeledV() by A4,Th13;
         A7: card Gk.labeledV() = card RFS by A5,Th19;
         A8: card Gk1b.labeledV() = card RFS by A5,A6,Th19;
              card RFS <= k+1 by A3,A7,XXREAL_0:def 8;
             then card RFS <= k+1+1 by NAT_1:12;
             hence Card Gk1b.labeledV() = min((k+1)+1, card RFS)
               by A8,XXREAL_0:def 8; end;
         suppose
         A9: BestEdges <> {};
         then A10: card Gk1b.labeledV() = card Gk.labeledV() + 1
               by A4,Th13;
         A11: Gk.labeledV() <> RFS by A9,Th19;
         A12: now assume
             A13: card Gk.labeledV() = card RFS;
                  Gk.labeledV() c= RFS by Th18;
                 then Gk.labeledV() c< RFS by A11,XBOOLE_0:def 8;
                 hence contradiction by A13,CARD_2:67;
             end;
         then A14: card Gk1b.labeledV() = (k+1)+1 by A3,A10,XXREAL_0:15;
          k+1 <= card RFS & (k+1) <> card RFS
               by A3,A12,XXREAL_0:def 8;
         then A15: k+1+1 <= card RFS + 1 by XREAL_1:8;
              k+1+1 <> card RFS + 1 by A3,A12;
             then k+1+1 < card RFS + 1 by A15,REAL_1:def 5;
             then (k+1+1) <= card RFS by NAT_1:13;
             hence Card Gk1b.labeledV() = min((k+1)+1, card RFS)
               by A14,XXREAL_0:def 8; end;
         end;
         hence Card (DCS.(k+1)).labeledV() = min((k+1)+1, card RFS);
     end;
then A16: for k being Element of NAT st P[k] holds P[k+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A16);
    hence thesis;
end;

theorem Th21: ::tDCS07
  for G being finite real-weighted WGraph, src being Vertex of G,
  n being Element of NAT
    holds (DIJK:CompSeq(G,src).n).labeledE() c= (DIJK:CompSeq(G,src).n)
      .edgesBetween((DIJK:CompSeq(G,src).n).labeledV())
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src), D0 = DCS.0;
    defpred P[Element of NAT] means (DCS.$1).labeledE() c=
      (DCS.$1).edgesBetween((DCS.$1).labeledV());
     D0=DIJK:Init(G, src) by Def7;
then the_ELabel_of D0 = G.set(ELabelSelector,{}).ELabelSelector by GLIB_000:12
                    .= {} by GLIB_000:11;
    then for x being set st x in D0.labeledE()
      holds x in D0.edgesBetween(D0.labeledV())
      by RELAT_1:60;
then A1: P[0] by TARSKI:def 3;
     now let n be Element of NAT; set Dn = DCS.n, Dn1 = DCS.(n+1);
        set BE = DIJK:NextBestEdges(Dn), e = choose BE;
        set target = (the_Target_of Dn).e;
        set val=(the_VLabel_of Dn).((the_Source_of Dn).e)+(the_Weight_of Dn).e;
        set DnE = Dn.labelEdge(e,1); assume
    A2: Dn.labeledE() c= Dn.edgesBetween(Dn.labeledV());
    A3: Dn1 = DIJK:Step(Dn) by Def7;
         G == Dn & G == Dn1 by Th17;
        then Dn == Dn1 by GLIB_000:88;
    then A4: the_Vertices_of Dn = the_Vertices_of Dn1 &
        the_Edges_of Dn = the_Edges_of Dn1 &
        the_Source_of Dn = the_Source_of Dn1 &
        the_Target_of Dn = the_Target_of Dn1 by GLIB_000:def 36;
         now let x be set; assume
        A5: x in Dn1.labeledE();
             n <= n+1 by NAT_1:12;
        then A6: Dn.labeledV() c= Dn1.labeledV() &
              Dn.labeledE() c= Dn1.labeledE() by Th16;
             now per cases;
            suppose BE = {};
                then Dn1 = Dn by A3,Def5;
                hence x in Dn1.edgesBetween(Dn1.labeledV())
                  by A2,A5; end;
            suppose
            A7: BE <> {};
            then A8: Dn1 = DnE.labelVertex(target,val) by A3,Def5;
            A9: e in BE by A7;
                 Dn == DnE by GLIB_003:41;
                then the_Vertices_of Dn = the_Vertices_of DnE
                  by GLIB_000:def 36;
            then A10: target in the_Vertices_of DnE by A9,FUNCT_2:7;
            A11: DnE.labeledE() = Dn.labeledE() \/ {e} by A9,GLIB_003:52;
                A12: the_ELabel_of DnE = the_ELabel_of Dn1 by A8,GLIB_003:49;
            A13: Dn1.labeledV() = DnE.labeledV()\/{target} by A8,A10,
GLIB_003:59;
                 now per cases by A5,A11,A12,XBOOLE_0:def 2;
                suppose x in Dn.labeledE();
                    then x in the_Edges_of Dn &
                      (the_Source_of Dn).x in Dn.labeledV() &
                      (the_Target_of Dn).x in Dn.labeledV()
                      by A2,GLIB_000:34;
                    hence x in Dn1.edgesBetween(Dn1.labeledV())
                      by A4,A6,GLIB_000:34; end;
                suppose x in {e};
                then A14: x = e by TARSKI:def 1;
                    then (the_Target_of Dn1).x in {target}
                      by A4,TARSKI:def 1;
                then A15: (the_Target_of Dn1).x in Dn1.labeledV()
                      by A13,XBOOLE_0:def 2;
                      e DSJoins Dn.labeledV(),the_Vertices_of Dn \
                       Dn.labeledV(),Dn by A7,Def4;
                    then (the_Source_of Dn1).x in Dn.labeledV()
                      by A4,A14,GLIB_000:def 18;
                    hence x in Dn1.edgesBetween(Dn1.labeledV())
                      by A4,A6,A9,A14,A15,GLIB_000:34; end;
                end;
                hence x in Dn1.edgesBetween(Dn1.labeledV()); end;
            end;
            hence x in Dn1.edgesBetween(Dn1.labeledV());
        end;
        hence Dn1.labeledE() c= Dn1.edgesBetween(Dn1.labeledV())
          by TARSKI:def 3;
    end;
then A16: for k being Element of NAT st P[k] holds P[k+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A16);
    hence thesis;
end;

theorem Th22: ::tDCS08
  for G being finite nonnegative-weighted WGraph, src being Vertex of G,
    n being Element of NAT, G2 being inducedWSubgraph of
    G,(DIJK:CompSeq(G,src).n).labeledV(),
      (DIJK:CompSeq(G,src).n).labeledE()
  holds G2 is_mincost_DTree_rooted_at src &
  for v being Vertex of G st v in (DIJK:CompSeq(G,src).n).labeledV()
    holds G.min_DPath_cost(src,v) =
          (the_VLabel_of (DIJK:CompSeq(G,src).n)).v
proof
    let G be finite nonnegative-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src), D0 = DCS.0;
    defpred P[Element of NAT] means
     for G2 being inducedWSubgraph of
          G,(DCS.$1).labeledV(),(DCS.$1).labeledE() holds
       G2 is_mincost_DTree_rooted_at src &
       for v being Vertex of G st v in (DCS.$1).labeledV()
         holds G.min_DPath_cost(src,v) = (the_VLabel_of (DCS.$1)).v;
    reconsider EL = {} as PartFunc of the_Edges_of G, REAL by PARTFUN1:56;
A1: D0 = DIJK:Init(G,src) by Def7
      .= G.set(ELabelSelector,EL)
          .set(VLabelSelector,src.-->0);
then A2: the_VLabel_of D0 = src .--> 0 by GLIB_000:11;
    then A3: dom (the_VLabel_of D0) = {src} by FUNCOP_1:19;
    A4: the_ELabel_of D0 = G.set(ELabelSelector,EL).ELabelSelector by A1,
GLIB_000:12
                    .= {} by GLIB_000:11;
     now let D0W be inducedWSubgraph of G,D0.labeledV(),D0.labeledE();
         {} c= G.edgesBetween(D0.labeledV()) by XBOOLE_1:2;
    then A5: the_Vertices_of D0W = {src} & the_Edges_of D0W = {}
          by A3,A4,GLIB_000:def 39,RELAT_1:60;
    then A6: card (the_Vertices_of D0W) = 1 & card (the_Edges_of D0W) = 0
          by CARD_1:78,79;
    A7: D0W.order() = D0W.size() + 1 by A5,CARD_1:78,79;
         D0W is trivial by A6,GLIB_000:def 21;
        then D0W is connected by GLIB_002:7;
    then A8: D0W is Tree-like by A7,GLIB_002:47;
         now let x be Vertex of D0W;
        A9: x = src by A5,TARSKI:def 1;
            set W2 = D0W.walkOf(x);
            take W2;
            thus W2 is_Walk_from src,x by A9,GLIB_001:14;
            let W1 be DPath of G; assume W1 is_Walk_from src,x;
         0 <= W1.cost() by GLIB_003:36;
            hence W2.cost() <= W1.cost() by GLIB_003:28;
        end;
        hence D0W is_mincost_DTree_rooted_at src by A8,Def1;
        let v be Vertex of G; assume
    A10: v in D0.labeledV();
    then A11: v = src by A3,TARSKI:def 1;
    A12: (the_VLabel_of D0).src = 0 by A2,FUNCOP_1:87;
         now set W1 = G.walkOf(v);
        A13: W1 is_Walk_from src,v by A11,GLIB_001:14;
            then consider W being DPath of G such that
        A14: W is_mincost_DPath_from src,v & G.min_DPath_cost(src,v) = W.cost()
              by Def3;
             W1.cost() = 0 by GLIB_003:28;
            then W.cost() <= 0 by A13,A14,Def2;
            hence G.min_DPath_cost(src,v) = 0 by A14,GLIB_003:36;
        end;
        hence G.min_DPath_cost(src,v) = (the_VLabel_of D0).v
          by A3,A10,A12,TARSKI:def 1;
    end;
then A15: P[0];
     now let n be Element of NAT; set Dn = DCS.n, Dn1 = DCS.(n+1);
        set BE = DIJK:NextBestEdges(Dn), e = choose BE;
        set source = (the_Source_of Dn).e, target = (the_Target_of Dn).e;
        set DnE = Dn.labelEdge(e,1);
        set pc = (the_VLabel_of Dn).source;
        set ec = (the_Weight_of Dn).e;
        consider DnW being inducedWSubgraph of G,Dn.labeledV(),Dn.labeledE();
        assume
    A16: P[n];
        let Dn1W be inducedWSubgraph of G,Dn1.labeledV(), Dn1.labeledE();
    A17: Dn1 = DIJK:Step(Dn) by Def7;
    then A18: Dn == Dn1 &
        the_Weight_of  Dn = the_Weight_of  Dn1 &
        Dn.labeledE() c= Dn1.labeledE() &
        Dn.labeledV() c= Dn1.labeledV() by Th14;
    A19: G == Dn & the_Weight_of G = the_Weight_of Dn by Th17;
    A20: G == Dn1 & the_Weight_of G = the_Weight_of Dn1 by Th17;
    A21: src in D0.labeledV() by A3,TARSKI:def 1;
    A22: the_Vertices_of G = the_Vertices_of Dn by A19,GLIB_000:def 36;
    A23: D0.labeledV() c= Dn.labeledV() by Th16;
    then A24: Dn.labeledV() is non empty Subset of the_Vertices_of G
          by A19,A21,GLIB_000:def 36;
    A25: Dn.labeledE() c= Dn.edgesBetween(Dn.labeledV()) by Th21;
    then A26: Dn.labeledE() c= G.edgesBetween(Dn.labeledV())
          by A19,GLIB_000:93;
    then A27: the_Vertices_of DnW = Dn.labeledV() &
          the_Edges_of DnW = Dn.labeledE() by A24,GLIB_000:def 39;
    A28: card Dn.labeledV() = DnW.order() &
          card Dn.labeledE() = DnW.size() by A24,A26,GLIB_000:def 39;
    A29: DnW is_mincost_DTree_rooted_at src by A16;
    then A30: DnW is Tree-like by Def1;
    then A31: DnW is connected & DnW.order() = DnW.size() + 1 by GLIB_002:47;
         now per cases;
        suppose BE = {};
            then Dn1 = Dn by A17,Def5;
            hence Dn1W is_mincost_DTree_rooted_at src &
              for v being Vertex of G st v in Dn1.labeledV()
              holds G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v by A16; end
;
        suppose
        A32: BE <> {};
        then A33: e in BE & Dn1 = DnE.labelVertex(target,pc+ec) by A17,Def5;
             Dn == DnE by GLIB_003:41;
        then the_Vertices_of DnE = the_Vertices_of Dn &
            the_Edges_of DnE = the_Edges_of Dn &
            the_Source_of DnE = the_Source_of Dn &
            the_Target_of DnE = the_Target_of Dn by GLIB_000:def 36;
        then A34: target in the_Vertices_of DnE by A33,FUNCT_2:7;
        then A35: Dn1.labeledE() = DnE.labeledE() &
            Dn1.labeledV() = DnE.labeledV() \/ {target}
              by A33,GLIB_003:49,59;
        A36: the_VLabel_of Dn = the_VLabel_of DnE by GLIB_003:43;
        A37: Dn1.labeledE() = Dn.labeledE() \/ {e} &
            Dn1.labeledV() = Dn.labeledV() \/ {target}
              by A33,A35,GLIB_003:43,52;
             now let v be set; assume
            A38: v in Dn1.labeledV();
                 now per cases by A35,A36,A38,XBOOLE_0:def 2;
                suppose v in Dn.labeledV();
                    hence v in the_Vertices_of G by A24; end;
                suppose v in {target};
                    then v = target by TARSKI:def 1;
                    then v in the_Vertices_of Dn by A33,FUNCT_2:7;
                    hence v in the_Vertices_of G by A19,GLIB_000:def 36; end;
                end;
                hence v in the_Vertices_of G;
            end;
        then A39: Dn1.labeledV() is non empty Subset of the_Vertices_of G
              by A35,TARSKI:def 3;
         Dn1.labeledE() c= Dn1.edgesBetween(Dn1.labeledV())
              by Th21;
            then Dn1.labeledE() c= G.edgesBetween(Dn1.labeledV())
              by A20,GLIB_000:93;
        then A40: the_Vertices_of Dn1W = Dn.labeledV() \/ {target} &
            the_Edges_of Dn1W =(Dn.labeledE() \/ {e}) by A37,A39,
GLIB_000:def 39;
        A41: e DSJoins Dn.labeledV(), the_Vertices_of Dn \ Dn.labeledV(), Dn
              by A32,Def4;
        then A42: target in the_Vertices_of Dn\Dn.labeledV() by GLIB_000:def 18
;
then A43: not target in Dn.labeledV() by XBOOLE_0:def 4;
            then A44: card (Dn.labeledV() \/ {target}) = card Dn.labeledV() + 1
              by CARD_2:54;
        A45: not e in Dn.labeledE() by A25,A43,GLIB_000:34;
        then Dn1W.size() = DnW.size() + 1 by A28,A40,CARD_2:54;
        then A46: Dn1W.order() = Dn1W.size() + 1 by A28,A30,A40,A44,GLIB_002:47
;
        A47: DnW is Subgraph of Dn & Dn1W is Subgraph of Dn1
              by A19,A20,GLIB_000:94;
        A48: now thus the_Vertices_of DnW c= the_Vertices_of Dn1W &
                  the_Edges_of DnW c= the_Edges_of Dn1W
                  by A27,A40,XBOOLE_1:7;
                let e be set; assume
            A49: e in the_Edges_of DnW;
            then A50: e in the_Edges_of Dn1W by A27,A40,XBOOLE_0:def 2;
            A51: (the_Source_of DnW).e = (the_Source_of Dn).e &
                (the_Target_of DnW).e = (the_Target_of Dn).e
                  by A47,A49,GLIB_000:def 34;
                 the_Source_of Dn = the_Source_of Dn1 &
                the_Target_of Dn =the_Target_of Dn1 by A18,GLIB_000:def 36;
hence (the_Source_of DnW).e = (the_Source_of Dn1W).e &
                (the_Target_of DnW).e = (the_Target_of Dn1W).e
                  by A47,A50,A51,GLIB_000:def 34;
            end;
        then A52: DnW is Subgraph of Dn1W by GLIB_000:def 34;
            reconsider DnW' = DnW as [Weighted] Subgraph of Dn1W
              by A48,GLIB_000:def 34;
        A53: the_Weight_of DnW' = (the_Weight_of G)| the_Edges_of DnW
              by GLIB_003:def 10;
        A54: the_Weight_of Dn1W = (the_Weight_of G)| the_Edges_of Dn1W
              by GLIB_003:def 10;
         dom the_Weight_of Dn1W = the_Edges_of Dn1W by PBOOLE:def 3;
            then dom (the_Weight_of Dn1W)/\the_Edges_of DnW = the_Edges_of DnW
              by A48,XBOOLE_1:28;
        then A55: dom the_Weight_of DnW'=dom (the_Weight_of Dn1W)/\the_Edges_of
DnW
              by PBOOLE:def 3;
             now let y be set; assume y in dom the_Weight_of DnW';
            then A56: y in the_Edges_of DnW by PBOOLE:def 3;
                hence (the_Weight_of DnW').y = (the_Weight_of G).y
                                                by A53,FUNCT_1:72
                                          .= (the_Weight_of Dn1W).y
                                                by A48,A54,A56,FUNCT_1:72;
            end;
            then the_Weight_of DnW' = (the_Weight_of Dn1W) | the_Edges_of DnW
              by A55,FUNCT_1:68;
        then A57: DnW is WSubgraph of Dn1W by GLIB_003:def 10;
        A58: source in Dn.labeledV() by A41,GLIB_000:def 18;
             e in {e} by TARSKI:def 1;
        then A59: e in the_Edges_of Dn1W by A40,XBOOLE_0:def 2;
             e DJoins source, target, Dn by A33,GLIB_000:def 16;
            then e DJoins source, target, Dn1 by A18,GLIB_000:91;
        then A60: e DJoins source, target, Dn1W by A47,A59,GLIB_000:76;
        then A61: e Joins source, target, Dn1W by GLIB_000:19;
             now let u,v be Vertex of Dn1W;
            A62: now let u,v be set; assume
                     u in Dn.labeledV() & v in Dn.labeledV();
                    then reconsider u'=u, v'=v as Vertex of DnW
                      by A24,A26,GLIB_000:def 39;
                    consider W1 being Walk of DnW such that
                A63: W1 is_Walk_from u',v' by A31,GLIB_002:def 1;
                    reconsider W2=W1 as Walk of Dn1W by A52,GLIB_001:168;
                     W2 is_Walk_from u,v by A63,GLIB_001:20;
                    hence ex W being Walk of Dn1W st W is_Walk_from u,v;
                end;
                 now per cases by A40,XBOOLE_0:def 2;
                suppose u in Dn.labeledV() & v in Dn.labeledV();
                  hence ex W being Walk of Dn1W st W is_Walk_from u,v
                    by A62; end;
                suppose
                A64: u in Dn.labeledV() & v in {target};
                    then consider W being Walk of Dn1W such that
                A65: W is_Walk_from u,source by A58,A62;
                A66: W.addEdge(e) is_Walk_from u,target by A61,A65,GLIB_001:67
;
                     v = target by A64,TARSKI:def 1;
                    hence ex W being Walk of Dn1W st W is_Walk_from u,v
                      by A66; end;
                suppose
                A67: u in {target} & v in Dn.labeledV();
                    then consider W being Walk of Dn1W such that
                A68: W is_Walk_from v,source by A58,A62;
                 W.addEdge(e) is_Walk_from v,target by A61,A68,GLIB_001:67
;
                    then W.addEdge(e) is_Walk_from v,u by A67,TARSKI:def 1;
then W.addEdge(e).reverse() is_Walk_from u,v by GLIB_001:24;
                    hence ex W being Walk of Dn1W st W is_Walk_from u,v; end;
                suppose u in {target} & v in {target};
                then A69: u = target & v = target by TARSKI:def 1;
                    take W = Dn1W.walkOf(u);
                    thus W is_Walk_from u,v by A69,GLIB_001:14; end;
                end;
                hence ex W being Walk of Dn1W st W is_Walk_from u,v;
            end;
            then Dn1W is connected by GLIB_002:def 1;
        then A70: Dn1W is Tree-like by A46,GLIB_002:47;
             now consider WT being DPath of DnW such that
            A71: WT is_Walk_from src,source &
                for W1 being DPath of G st W1 is_Walk_from src,source
                  holds WT.cost() <= W1.cost() by A27,A29,A58,Def1;
                reconsider WT'=WT as DPath of Dn1W by A52,GLIB_001:176;
                set W2 = WT'.addEdge(e);
            A72: WT' is_Walk_from src,source by A71,GLIB_001:20;
                then reconsider W2 as DWalk of Dn1W by A60,GLIB_001:124;
                 now target in {target} by TARSKI:def 1;
                    hence target is Vertex of Dn1W by A40,XBOOLE_0:def 2;
                    thus e Joins WT'.last(),target,Dn1W
                      by A61,A72,GLIB_001:def 23;
                A73: not e in the_Edges_of DnW by A24,A26,A45,GLIB_000:def 39;
                     WT.edges() = WT'.edges() by GLIB_001:111;
                    hence not e in WT'.edges() by A73;
                     now assume
                    A74: WT' is non trivial;
                         now assume WT' is closed;
                        then A75: WT' is Cycle-like by A74,GLIB_001:def 31;
                             Dn1W is acyclic by A70,GLIB_002:def 3;
                            hence contradiction by A75,GLIB_002:def 2;
                        end;
                        hence WT' is open;
                    end;
                    hence WT' is trivial or WT' is open;
                     WT'.vertices() = WT.vertices() by GLIB_001:99;
                then A76: not target in WT'.vertices() by A27,A42,
XBOOLE_0:def 4;
                    let n be odd Element of NAT; assume 1 < n & n <= len WT';
                    hence WT'.n <> target by A76,GLIB_001:88;
                end; then reconsider W2 as DPath of Dn1W by GLIB_001:151;
                take W2;
                thus W2 is_Walk_from src,target by A61,A72,GLIB_001:67;
                reconsider W2G = W2 as DWalk of G by GLIB_001:176;
                 now
                A77: WT'.last() = source by A72,GLIB_001:def 23;
                A78: e in the_Edges_of Dn1W &
                      (the_Source_of Dn1W).e = source by A60,GLIB_000:def 16;
                    hence e in WT'.last().edgesInOut() by A77,GLIB_000:64;
                     (the_Weight_of Dn1W).e =
                      ((the_Weight_of G) | the_Edges_of Dn1W).e
                        by GLIB_003:def 10;
                    hence ec = (the_Weight_of Dn1W).e by A19,A78,FUNCT_1:72;
                A79: pc = G.min_DPath_cost(src,source) by A16,A22,A58;
                    reconsider WTG = WT as DPath of G by GLIB_001:176;
                A80: WTG is_Walk_from src,source by A71,GLIB_001:20;
                    then consider WX being DPath of G such that
                A81: WX is_mincost_DPath_from src,source & pc = WX.cost()
                      by A79,Def3;
                     WX is_Walk_from src,source & for WY being DPath of G
                      st WY is_Walk_from src,source holds
                      pc <= WY.cost() by A81,Def2;
                    then WT.cost() <= pc by A71,A81;
                then A82: WT'.cost() <= pc by A57,GLIB_003:34;
                     pc <= WTG.cost() by A80,A81,Def2;
                    then pc <= WT'.cost() by GLIB_003:34;
                    hence WT'.cost() = pc by A82,XXREAL_0:1;
                end;
                hence W2.cost() = pc + ec by GLIB_003:32;
            end; then consider W2 being DPath of Dn1W such that
        A83: W2 is_Walk_from src,target & W2.cost() = pc+ec;
            reconsider W2G = W2 as DPath of G by GLIB_001:176;
        A84: W2G is_Walk_from src, target by A83,GLIB_001:20;
        A85: W2G.cost() = pc+ec by A83,GLIB_003:34;
        A86: src <> target by A21,A23,A42,XBOOLE_0:def 4;
            set mc = G.min_DPath_cost(src,target);
             now consider WB being DPath of G such that
            A87: WB is_mincost_DPath_from src,target & mc = WB.cost()
                  by A84,Def3;
            A88: WB is_Walk_from src,target & for WA being DPath of G
                  st WA is_Walk_from src,target holds WB.cost() <= WA.cost()
                  by A87,Def2;
                thus mc <= pc+ec by A84,A85,A87,Def2;
                 WB.first() = src & WB.last() = target
                  by A88,GLIB_001:def 23;
                then WB is non trivial by A86,GLIB_001:128;
                then consider lenWB2h being odd Element of NAT such that
            A89: lenWB2h = len WB - 2 &
                  WB.cut(1,lenWB2h).addEdge(WB.(lenWB2h+1)) = WB
                  by GLIB_001:134;
                set WA = WB.cut(1,lenWB2h);
                set sa = WB.lenWB2h, ea = WB.(lenWB2h+1);
            A90: 1 <= lenWB2h & 1 is odd by HEYTING3:1,JORDAN12:3;
            A91: lenWB2h < len WB - 0 by A89,REAL_1:92;
            A92: WB.1 = WB.first() by GLIB_001:def 6
                    .= src by A88,GLIB_001:def 23;
                then WA is_Walk_from src,sa by A90,A91,GLIB_001:38;
                then reconsider sa as Vertex of G by GLIB_001:19;
                reconsider target'=target as Vertex of G by A88,GLIB_001:19;
            A93: ea DJoins sa, WB.(lenWB2h+2), G by A91,GLIB_001:123;
                then ea DJoins sa, WB.last(), G by A89,GLIB_001:def 7;
            then A94: ea DJoins sa, target, G by A88,GLIB_001:def 23;
                then ea Joins sa,target',G by GLIB_000:19;
                then ea in sa.edgesInOut() by GLIB_000:65;
            then A95: ea in WA.last().edgesInOut() by A90,A91,GLIB_001:38;
            then A96: mc = WA.cost() + (the_Weight_of G).ea by A87,A89,
GLIB_003:32;
            A97: WA.first() = src & WA.last() = sa by A90,A91,A92,GLIB_001:38;
then A98: WA is_mincost_DPath_from src,sa by A87,Th10;
            then A99: WA.cost() = G.min_DPath_cost(src,sa) by Th12;
            A100: ea DJoins sa, target, Dn by A19,A94,GLIB_000:91;
                 now assume
                A101: mc < pc+ec;
                    defpred P[Nat] means $1 is odd & $1 <= len WA &
                      not WA.$1 in Dn.labeledV();
                A102: now assume
                    A103: not sa in Dn.labeledV();
                         sa = WA.last() by A90,A91,GLIB_001:38
                          .= WA.(len WA) by GLIB_001:def 7;
                    then A104: ex k being Nat st P[k] by A103;
                        consider k being Nat such that
                    A105: P[k] & for m being Nat st P[m]
                    holds k <= m from NAT_1:sch 5(A104);
                        reconsider k as odd Element of NAT
                          by A105,ORDINAL1:def 13;
                         WA.1 = WA.first() by GLIB_001:def 6
                            .= src by A90,A91,A92,GLIB_001:38;
                    then A106: k <> 1 by A21,A23,A105;
                         1 <= k by HEYTING3:1;
                        then 1 < k by A106,REAL_1:def 5;
                        then 1+1 < k+1 by XREAL_1:10;
                        then 2 <= k by NAT_1:13;
                        then reconsider k2a = k-2*1 as odd Element of NAT
                        by INT_1:18;
                        set sk = WA.k2a, ek = WA.(k2a+1), tk = WA.k;
                    A107: 1 is odd & 1 <= k2a & k2a < len WA - 0
                          by A105,HEYTING3:1,JORDAN12:3,REAL_1:92;
                         k2a < k - 0 by REAL_1:92;
                    then A108: sk in Dn.labeledV() by A105,A107;
                        then reconsider sk as Vertex of G by A19,
GLIB_000:def 36;
                        reconsider tk as Vertex of G by A105,GLIB_001:8;
                        set WK1 = WA.cut(1,k2a), WK2 = WA.cut(k2a,len WA);
                        set WKA = WA.cut(1,k), WKB = WA.cut(k,len WA);
                         tk = WA.(k2a+2);
                    then A109: ek DJoins sk,tk,G by A107,GLIB_001:123;
                        then ek DJoins sk,tk,Dn by A19,GLIB_000:91;
                    then A110: ek in the_Edges_of Dn & (the_Source_of Dn).ek =
sk &
                        (the_Target_of Dn).ek = tk by GLIB_000:def 16;
                    A111: WK1.first() = WA.1 & WK1.last() = sk by A107,
GLIB_001:38;
                        then WK1 is_mincost_DPath_from WA.1, sk
                          by A98,Th10;
                        then WK1 is_mincost_DPath_from WA.first(),sk
                          by GLIB_001:def 6;
                        then G.min_DPath_cost(src,sk) = WK1.cost()
                          by A97,Th12;
                    then A112: (the_VLabel_of Dn).sk = WK1.cost() by A16,A108;
                         tk in the_Vertices_of Dn by A110,FUNCT_2:7;
                        then tk in the_Vertices_of Dn \ Dn.labeledV()
                          by A105,XBOOLE_0:def 4;
                        then ek DSJoins Dn.labeledV(),the_Vertices_of Dn \
                          Dn.labeledV(),Dn by A108,A110,GLIB_000:def 18;
                    then A113: pc+ec <= WK1.cost() + (the_Weight_of G).ek
                          by A19,A32,A110,A112,Def4;
                         k2a + 2 = k;
                    then A114: WK1.addEdge(ek) = WKA by A107,GLIB_001:42;
                         ek in the_Edges_of G & (the_Source_of G).ek = sk &
                          (the_Target_of G).ek = tk by A109,GLIB_000:def 16;
then ek in sk.edgesInOut() by GLIB_000:64;
                    then A115: pc+ec <= WKA.cost() by A111,A113,A114,
GLIB_003:32;
                    A116: 1 <= k & k <= len WA by A105,HEYTING3:1;
                    then A117: WKA.append(WKB) = WA.cut(1,len WA)
                                          by GLIB_001:39,JORDAN12:3
                                       .= WA by GLIB_001:40;
                         WKB.first() = WA.k by A105,GLIB_001:38
                                   .= WKA.last()
                        by A116,GLIB_001:38,JORDAN12:3;
                    then A118: WA.cost() = WKA.cost() + WKB.cost() by A117,
GLIB_003:31;
                         0 <= WKB.cost() by GLIB_003:36;
                        then 0 + WKA.cost() <= WA.cost() by A118,XREAL_1:9;
                    then A119: pc+ec <= WA.cost() by A115,XXREAL_0:2;
                         ea in the_Edges_of G by A93,GLIB_000:def 16;
                        then 0 <= (the_Weight_of G).ea by GLIB_003:38;
                        then pc+ec+0 <= WA.cost()+(the_Weight_of G).ea
                          by A119,XREAL_1:9;
                        hence contradiction by A87,A89,A95,A101,GLIB_003:32;
                    end;
                then A120: WA.cost() = (the_VLabel_of Dn).sa by A16,A99;
                A121: ea in the_Edges_of Dn & (the_Source_of Dn).ea = sa &
                      (the_Target_of Dn).ea=target by A100,GLIB_000:def 16;
then ea DSJoins Dn.labeledV(), the_Vertices_of Dn \
                      Dn.labeledV(),Dn by A42,A102,GLIB_000:def 18;
                    hence contradiction by A19,A32,A96,A101,A120,A121,Def4;
                end;
                hence mc >= pc+ec;
            end;
        then A122: G.min_DPath_cost(src,target) = pc+ec by XXREAL_0:1;
             now let x be Vertex of Dn1W;
                 now per cases by A40,XBOOLE_0:def 2;
                suppose x in Dn.labeledV();
                    then reconsider x'=x as Vertex of DnW by A24,A26,
GLIB_000:def 39
;
                     DnW is_mincost_DTree_rooted_at src by A16;
                    then consider W2 being DPath of DnW such that
                A123: W2 is_Walk_from src,x' &
                    for W1 being DPath of G st W1 is_Walk_from src,x'
                      holds W2.cost() <= W1.cost() by Def1;
                    reconsider W2'=W2 as DPath of Dn1W by A52,GLIB_001:176;
                    take W2';
                    thus W2' is_Walk_from src,x by A123,GLIB_001:20;
                    let W1 be DPath of G; assume
                     W1 is_Walk_from src,x;
                    then W2.cost() <= W1.cost() by A123;
                    hence W2'.cost() <= W1.cost() by A57,GLIB_003:34; end;
                suppose
                A124: x in {target};
                then A125: x = target by TARSKI:def 1;
                    take W2;
                    thus W2 is_Walk_from src,x by A83,A124,TARSKI:def 1;
                    let W1 be DPath of G; assume
                A126: W1 is_Walk_from src,x;
                    consider WX being DPath of G such that
                A127: WX is_mincost_DPath_from src, target & WX.cost()=W2
.cost()
                       by A83,A84,A122,Def3;
                    thus W2.cost() <= W1.cost() by A125,A126,A127,Def2; end;
                end;
                hence ex W2 being DPath of Dn1W st W2 is_Walk_from src,x &
                  for W1 being DPath of G st W1 is_Walk_from src,x
                  holds W2.cost() <= W1.cost();
            end;
            hence Dn1W is_mincost_DTree_rooted_at src by A70,Def1;
            let v be Vertex of G; assume
        A128: v in Dn1.labeledV();
             now per cases by A35,A36,A128,XBOOLE_0:def 2;
            suppose
            A129: v in Dn.labeledV();
            then A130: G.min_DPath_cost(src,v) = (the_VLabel_of DnE).v by A16
,A36;
            A131: the_VLabel_of Dn1 = (the_VLabel_of DnE)+*(target .-->(pc+ec))
                  by A33,A34,GLIB_003:45;
            A132: dom (target .--> (pc+ec)) = {target} by FUNCOP_1:19;
            then not v in dom (target .-->(pc+ec)) by A43,A129,TARSKI:def 1;
                hence G.min_DPath_cost(src,v)=(the_VLabel_of Dn1).v
                  by A35,A128,A130,A131,A132,FUNCT_4:def 1; end;
            suppose
            A133: v in {target};
            then A134: v = target by TARSKI:def 1;
            A135: the_VLabel_of Dn1 = (the_VLabel_of DnE)+*(target .-->(pc+ec))
                  by A33,A34,GLIB_003:45;
            A136: dom (target .--> (pc+ec)) = {target} by FUNCOP_1:19;
                then v in dom (the_VLabel_of DnE) \/ dom (target .--> (pc+ec))
                  by A133,XBOOLE_0:def 2;
                then (the_VLabel_of Dn1).v = (target .--> (pc+ec)).v
                  by A133,A135,A136,FUNCT_4:def 1;
                hence G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v
                  by A122,A134,FUNCOP_1:87; end;
            end;
            hence G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v; end;
         end;
         hence Dn1W is_mincost_DTree_rooted_at src &
         for v being Vertex of G st v in Dn1.labeledV()
           holds G.min_DPath_cost(src,v) = (the_VLabel_of Dn1).v;
    end;
then A137: for k being Element of NAT st P[k] holds P[k+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A15,A137);
    hence thesis;
end;

theorem Th23: ::tDIJK01
  for G being finite real-weighted WGraph, src being Vertex of G
    holds DIJK:CompSeq(G,src) is halting
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G, src);
     now take n = card G.reachableDFrom(src);
        set Gn = DCS.n, Gn1a = DCS.(n+1), VGn = the_VLabel_of Gn;
        set BestEdges = DIJK:NextBestEdges(Gn), e = choose BestEdges;
        set NextEG = Gn.labelEdge(e, 1), target = (the_Target_of Gn).e;
        set RSize = card G.reachableDFrom(src);
        set pc = (the_VLabel_of Gn).((the_Source_of Gn).e);
        set ec = (the_Weight_of Gn).e;
    A1: Gn1a = DIJK:Step(Gn) by Def7;
         now per cases;
        suppose BestEdges = {};
            hence DCS.n = DCS.(n+1) by A1,Def5; end;
        suppose
        A2: BestEdges <> {};
        A3: Card (DCS.n).labeledV() = min(n+1, RSize) by Th20;
             RSize <= RSize + 1 by NAT_1:11;
        then A4: card Gn.labeledV() = RSize by A3,XXREAL_0:def 8;
        A5: card (DIJK:Step(Gn)).labeledV() =
              card Gn.labeledV() + 1 by A2,Th13;
        A6: RSize + 1 <= RSize + 1 + 1 by NAT_1:11;
             RSize <= (RSize+1) by NAT_1:11;
        then A7: RSize <= (n + 1) + 1 by A6,XXREAL_0:2;
             card Gn1a.labeledV() = min((n+1)+1, RSize) by Th20
                                 .= RSize by A7,XXREAL_0:def 8;
            hence DCS.n = DCS.(n+1) by A4,A5,Def7; end;
        end;
        hence DCS.n = DCS.(n+1);
    end;
    hence thesis by GLIB_000:def 68;
end;

registration let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(G,src) -> halting;
  coherence by Th23;
end;

theorem Th24: ::tDIJK02
  for G being finite real-weighted WGraph, src being Vertex of G holds
    DIJK:CompSeq(G,src).Lifespan() + 1 = card G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set DCS = DIJK:CompSeq(G,src), RFS = G.reachableDFrom(src);
     src in RFS by GLIB_002:18;
    then {src} c= RFS by ZFMISC_1:37;
    then card {src} <= card RFS by NAT_1:44;
    then card RFS <> 0 by CARD_1:79;
    then consider k being Nat such that
A1: card RFS = k + 1 by NAT_1:6;
    reconsider k as Element of NAT by ORDINAL1:def 13;
    set Gk = DCS.k, Gk1 = DCS.(k+1);
A2: Gk1 = DIJK:Step(Gk) by Def7;
A3: card Gk1.labeledV() = min(card RFS+1, card RFS) by A1,Th20;
A4: card RFS <= card RFS + 1 by NAT_1:11;
     card Gk.labeledV() = min(card RFS, card RFS) by A1,Th20;
    then card Gk1.labeledV() = card Gk.labeledV() by A3,A4,XXREAL_0:def 8;
    then DIJK:NextBestEdges(Gk) = {} by A2,Th13;
then A5: DCS.k = DCS.(k+1) by A2,Def5;
     now let n be Nat; assume
    A6: DCS.n = DCS.(n+1); set Gn = DCS.n, Gn1 = DCS.(n+1);
         now assume n < k;
        then A7: n + 1 < card RFS by A1,XREAL_1:10;
        n in NAT by ORDINAL1:def 13;
        then card Gn.labeledV() = min(n+1, card RFS) by Th20;
        then A8: card Gn.labeledV() = n+1 by A7,XXREAL_0:def 8;
        A9: card Gn1.labeledV() = min(n+1+1, card RFS) by Th20;
             n + 1 + 1 <= card RFS by A7,NAT_1:13;
            then 0+(n+1) = 1+(n+1) by A6,A8,A9,XXREAL_0:def 8;
            hence contradiction;
        end;
        hence k <= n;
    end;
    hence DIJK:CompSeq(G,src).Lifespan() + 1 = card RFS
      by A1,A5,GLIB_000:def 57;
end;

theorem Th25: ::tDIJK03
  for G being finite real-weighted WGraph, src being Vertex of G
    holds DIJK:SSSP(G,src).labeledV() = G.reachableDFrom(src)
proof
    let G be finite real-weighted WGraph, src be Vertex of G;
    set Gn = DIJK:SSSP(G, src), RFS = G.reachableDFrom(src);
    set DCS = DIJK:CompSeq(G,src), n = DCS.Lifespan();
A1: card Gn.labeledV() = min(n+1, card RFS) by Th20
                             .= min(card RFS, card RFS) by Th24
                             .= card RFS;
     now assume
    A2: Gn.labeledV() <> RFS;
         Gn.labeledV() c= RFS by Th18;
        then Gn.labeledV() c< RFS by A2,XBOOLE_0:def 8;
        hence contradiction by A1,TREES_1:24;
    end;
    hence thesis;
end;

theorem ::tDIJK04
   for G being finite nonnegative-weighted WGraph, src being Vertex of G,
     G2 being inducedWSubgraph of G, DIJK:SSSP(G,src).labeledV(),
                                     DIJK:SSSP(G,src).labeledE() holds
     G2 is_mincost_DTree_rooted_at src &
     for v being Vertex of G st v in G.reachableDFrom(src) holds
       v in the_Vertices_of G2 &
       G.min_DPath_cost(src,v) = (the_VLabel_of DIJK:SSSP(G,src)).v
proof
    let G be finite nonnegative-weighted WGraph, src be Vertex of G,
        G2 be inducedWSubgraph of G, DIJK:SSSP(G,src).labeledV(),
                                     DIJK:SSSP(G,src).labeledE();
    set Res = DIJK:SSSP(G,src), DCS = DIJK:CompSeq(G,src);
    thus G2 is_mincost_DTree_rooted_at src by Th22;
    let v being Vertex of G; assume
A1: v in G.reachableDFrom(src);
then A2: v in Res.labeledV() by Th25;
A3: G == Res by Th17;
A4: Res.labeledV() is non empty Subset of the_Vertices_of G
      by A1,Th25;
     G.edgesBetween(Res.labeledV()) =
      Res.edgesBetween(Res.labeledV()) by A3,GLIB_000:93;
    then Res.labeledE() c= G.edgesBetween(Res.labeledV())
      by Th21;
    hence v in the_Vertices_of G2 by A2,A4,GLIB_000:def 39;
    thus thesis by A2,Th22;
end;

begin :: Prim's Algorithm preliminaries

definition
  func WGraphSelectors -> non empty finite Subset of NAT equals  ::dWGRAPHSEL
     {VertexSelector, EdgeSelector, SourceSelector, TargetSelector,
     WeightSelector};
  coherence;
end;

Lm1:
  for G being WGraph holds
    WGraphSelectors c= dom G
proof
    let G be WGraph;
     now let x be set; assume x in WGraphSelectors;
        then x = VertexSelector or x = EdgeSelector or
        x = SourceSelector or x = TargetSelector or
        x = WeightSelector by ENUMSET1:def 3;
        hence x in dom G by GLIB_000:def 11,GLIB_003:def 4;
    end;
    hence thesis by TARSKI:def 3;
end;

registration let G be WGraph;
  cluster G.strict(WGraphSelectors) -> [Graph-like] [Weighted];
  coherence
  proof
    set G2 = G.strict(WGraphSelectors);
A1: WGraphSelectors c= dom G by Lm1;
A2: dom G2 = dom G /\ WGraphSelectors by RELAT_1:90
          .= WGraphSelectors by A1,XBOOLE_1:28;
A3: VertexSelector in WGraphSelectors &
    EdgeSelector   in WGraphSelectors &
    SourceSelector in WGraphSelectors &
    TargetSelector in WGraphSelectors &
    WeightSelector in WGraphSelectors by ENUMSET1:def 3;
then A4: the_Vertices_of G2 = the_Vertices_of G by FUNCT_1:72;
A5: the_Edges_of G2 = the_Edges_of G by A3,FUNCT_1:72;
A6: the_Source_of G2 = the_Source_of G by A3,FUNCT_1:72;
A7: the_Target_of G2 = the_Target_of G by A3,FUNCT_1:72;
     for x being set st x in _GraphSelectors holds x in dom G2
      by A2,A3,ENUMSET1:def 2;
    then _GraphSelectors c= dom G2 by TARSKI:def 3;
    hence G2 is [Graph-like] by A4,A5,A6,A7,GLIB_000:7;
     G2.WeightSelector = G.WeightSelector by A3,FUNCT_1:72;
    then G2.WeightSelector is ManySortedSet of the_Edges_of G2
      by A5,GLIB_003:def 4;
    hence G2 is [Weighted] by A2,A3,GLIB_003:def 4;
  end;
end;

Lm2:
  for G being WGraph holds
    G == (G.strict(WGraphSelectors)) &
    the_Weight_of G = the_Weight_of (G.strict(WGraphSelectors))
proof
    let G be WGraph; set G2 = G.strict(WGraphSelectors);
A1: VertexSelector in WGraphSelectors &
    EdgeSelector   in WGraphSelectors &
    SourceSelector in WGraphSelectors &
    TargetSelector in WGraphSelectors &
    WeightSelector in WGraphSelectors by ENUMSET1:def 3;
then A2: the_Vertices_of G2 = the_Vertices_of G by FUNCT_1:72;
A3: the_Edges_of G2 = the_Edges_of G by A1,FUNCT_1:72;
A4: the_Source_of G2 = the_Source_of G by A1,FUNCT_1:72;
     the_Target_of G2 = the_Target_of G by A1,FUNCT_1:72;
    hence G == G2 by A2,A3,A4,GLIB_000:def 36;
    thus the_Weight_of G2 = the_Weight_of G by A1,FUNCT_1:72;
end;

Lm3:
  for G being WGraph holds
    dom (G.strict(WGraphSelectors)) = WGraphSelectors
proof
    let G be WGraph; set G2 = G.strict(WGraphSelectors);
     WGraphSelectors c= dom G by Lm1;
    hence thesis by RELAT_1:91;
end;

definition let G be WGraph;
  func G.allWSubgraphs() -> non empty set means :Def10: ::dGALLWSUBG
    for x being set holds x in it iff
      ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors;
  existence
  proof
    set Z = {bool the_Vertices_of G, bool the_Edges_of G,
             bool the_Source_of G, bool the_Target_of G,
             bool the_Weight_of G};
    set Y = union Z;
    set X = Funcs(WGraphSelectors, Y);
    defpred P[set] means $1 is WSubgraph of G;
    consider IT being Subset of X such that
A1: for x being set holds x in IT iff x in X & P[x] from SUBSET_1:sch 1;
    set G' = G.strict(WGraphSelectors);
A2: G == G' & the_Weight_of G = the_Weight_of G' by Lm2;
    then reconsider G' as [Weighted] Subgraph of G by GLIB_000:90;
     dom the_Weight_of G = the_Edges_of G'
      by A2,PBOOLE:def 3;
    then the_Weight_of G' = (the_Weight_of G) | the_Edges_of G'
      by A2,RELAT_1:98;
    then reconsider G' as WSubgraph of G by GLIB_003:def 10;
A3: dom G' = WGraphSelectors by Lm3;
A4: now let G2 be WSubgraph of G; assume
    A5: dom G2 = WGraphSelectors;
         now let y be set; assume y in rng G2;
            then consider x being set such that
        A6: x in WGraphSelectors & G2.x = y by A5,FUNCT_1:def 5;
             now per cases by A6,ENUMSET1:def 3;
            suppose x = VertexSelector;
            then A7: y = the_Vertices_of G2 by A6;
                 bool the_Vertices_of G in Z by ENUMSET1:def 3;
                hence y in Y by A7,TARSKI:def 4;
                end;
            suppose x = EdgeSelector;
            then A8: y = the_Edges_of G2 by A6;
                 bool the_Edges_of G in Z by ENUMSET1:def 3;
                hence y in Y by A8,TARSKI:def 4;
                end;
            suppose x = SourceSelector;
                then y = the_Source_of G2 by A6;
                then y = (the_Source_of G) | the_Edges_of G2 by GLIB_000:48;
            then A9: y c= the_Source_of G by RELAT_1:88;
                 bool the_Source_of G in Z by ENUMSET1:def 3;
                hence y in Y by A9,TARSKI:def 4;
                end;
            suppose x = TargetSelector;
                then y = the_Target_of G2 by A6;
                then y = (the_Target_of G) | the_Edges_of G2 by GLIB_000:48;
            then A10: y c= the_Target_of G by RELAT_1:88;
                 bool the_Target_of G in Z by ENUMSET1:def 3;
                hence y in Y by A10,TARSKI:def 4;
                end;
            suppose x = WeightSelector;
                then y = the_Weight_of G2 by A6;
                then y = (the_Weight_of G) | the_Edges_of G2 by GLIB_003:def 10
;
            then A11: y c= the_Weight_of G by RELAT_1:88;
                 bool the_Weight_of G in Z by ENUMSET1:def 3;
                hence y in Y by A11,TARSKI:def 4;
                end;
            end;
            hence y in Y;
        end;
        hence rng G2 c= Y by TARSKI:def 3;
    end;
    then rng G' c= Y by A3;
    then G' in X by A3,FUNCT_2:def 2;
    then reconsider IT as non empty set by A1;
    take IT;
    let x be set;
    hereby assume
    A12: x in IT;
        then reconsider x' = x as WSubgraph of G by A1;
        take x';
        thus x' = x;
        consider f being Function such that
    A13: f = x & dom f = WGraphSelectors & rng f c= Y by A12,FUNCT_2:def 2;
        thus dom x' = WGraphSelectors by A13;
    end;
    given G2 being WSubgraph of G such that
A14: G2 = x & dom G2 = WGraphSelectors;
     rng G2 c= Y by A4,A14;
    then x in X by A14,FUNCT_2:def 2;
    hence x in IT by A1,A14;
  end;
  uniqueness proof
    let IT1,IT2 be non empty set such that
A15: for x being set holds x in IT1 iff
      ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors and
A16: for x being set holds x in IT2 iff
      ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors;
     now let x be set;
         x in IT1 iff ex G2 being WSubgraph of G
          st x = G2 & dom G2 = WGraphSelectors by A15;
        hence x in IT1 iff x in IT2 by A16;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

registration let G be finite WGraph;
  cluster G.allWSubgraphs() -> finite;
  coherence proof
    set Z = {bool the_Vertices_of G, bool the_Edges_of G,
             bool the_Source_of G, bool the_Target_of G,
             bool the_Weight_of G}, Y = union Z;
     for x being set st x in Z holds x is finite by ENUMSET1:def 3;
    then reconsider Y as finite set by FINSET_1:25;
    set X = Funcs(WGraphSelectors, Y);
A1: X is finite by FRAENKEL:16;
     now let x be set; assume x in G.allWSubgraphs();
        then consider G2 being WSubgraph of G such that
    A2: x = G2 & dom G2 = WGraphSelectors by Def10;
         now let y be set; assume y in rng G2;
            then consider x being set such that
        A3: x in WGraphSelectors & G2.x = y by A2,FUNCT_1:def 5;
             now per cases by A3,ENUMSET1:def 3;
            suppose x = VertexSelector;
            then A4: y = the_Vertices_of G2 by A3;
                 bool the_Vertices_of G in Z by ENUMSET1:def 3;
                hence y in Y by A4,TARSKI:def 4;
                end;
            suppose x = EdgeSelector;
            then A5: y = the_Edges_of G2 by A3;
                 bool the_Edges_of G in Z by ENUMSET1:def 3;
                hence y in Y by A5,TARSKI:def 4;
                end;
            suppose x = SourceSelector;
                then y = the_Source_of G2 by A3;
                then y = (the_Source_of G) | the_Edges_of G2 by GLIB_000:48;
            then A6: y c= the_Source_of G by RELAT_1:88;
                 bool the_Source_of G in Z by ENUMSET1:def 3;
                hence y in Y by A6,TARSKI:def 4;
                end;
            suppose x = TargetSelector;
                then y = the_Target_of G2 by A3;
                then y = (the_Target_of G) | the_Edges_of G2 by GLIB_000:48;
            then A7: y c= the_Target_of G by RELAT_1:88;
                 bool the_Target_of G in Z by ENUMSET1:def 3;
                hence y in Y by A7,TARSKI:def 4;
                end;
            suppose x = WeightSelector;
                then y = the_Weight_of G2 by A3;
                then y = (the_Weight_of G) | the_Edges_of G2 by GLIB_003:def 10
;
            then A8: y c= the_Weight_of G by RELAT_1:88;
                 bool the_Weight_of G in Z by ENUMSET1:def 3;
                hence y in Y by A8,TARSKI:def 4;
                end;
            end;
            hence y in Y;
        end;
        then rng G2 c= Y by TARSKI:def 3;
        hence x in X by A2,FUNCT_2:def 2;
    end;
    then G.allWSubgraphs() c= X by TARSKI:def 3;
    hence thesis by A1,FINSET_1:13;
  end;
end;

definition let G be WGraph, X be non empty Subset of G.allWSubgraphs();
  redefine mode Element of X -> WSubgraph of G;
  coherence
  proof
    let x be Element of X;
    consider G2 being WSubgraph of G such that
A1: G2 = x & dom G2 = WGraphSelectors by Def10;
    thus thesis by A1;
  end;
end;

definition let G be finite real-weighted WGraph;
  func G.cost() -> Real equals  ::dWGCOST
     Sum the_Weight_of G;
  coherence by XREAL_0:def 1;
end;

canceled;

theorem ::tWGRAPHSEL02
   for G being WGraph holds
    WGraphSelectors c= dom G by Lm1;

theorem ::tWSSEL01
   for G being WGraph holds
    G == (G.strict(WGraphSelectors)) &
    the_Weight_of G = the_Weight_of (G.strict(WGraphSelectors)) by Lm2;

theorem ::tWSEL02
   for G being WGraph holds
    dom (G.strict(WGraphSelectors)) = WGraphSelectors by Lm3;

theorem ::tGCOST01
   for G being finite real-weighted WGraph st the_Edges_of G = {} holds
    G.cost() = 0
proof
    let G be finite real-weighted WGraph; assume the_Edges_of G = {};
    then dom (the_Edges_of G --> 0) = {} &
    dom the_Weight_of G = {} by FUNCOP_1:16,PBOOLE:def 3;
    then the_Weight_of G = the_Edges_of G --> 0 by FUNCOP_1:4;
    then the_Weight_of G = EmptyBag the_Edges_of G by POLYNOM1:def 15;
    hence thesis by UPROOTS:13;
end;

theorem  ::tGCOST02
   for G1,G2 being finite real-weighted WGraph
   st the_Edges_of G1 = the_Edges_of G2 & the_Weight_of G1 = the_Weight_of G2
   holds G1.cost() = G2.cost();

theorem Th33: ::tGCOST03
  for G1 being finite real-weighted WGraph, e being set,
      G2 being weight-inheriting ([Weighted] removeEdge of G1,e)
   st e in the_Edges_of G1 holds
      G1.cost() = G2.cost() + (the_Weight_of G1).e
proof
    let G1 be finite real-weighted WGraph, e be set,
        G2 be weight-inheriting ([Weighted] removeEdge of G1,e);
    set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2; assume
A1: e in EG1;
A2: EG2 = EG1 \ {e} by GLIB_000:54;
A3: the_Weight_of G2 = (the_Weight_of G1) | (EG2)
      by GLIB_003:def 10;
    set b2 = (e .--> (the_Weight_of G1).e);
A4: dom b2 = {e} & rng b2 = {(the_Weight_of G1).e} by FUNCOP_1:14,19;
     EG1 \ EG2 = EG1 /\ {e} by A2,XBOOLE_1:48
             .= {e} by A1,ZFMISC_1:52;
    then reconsider b2 as ManySortedSet of EG1 \ EG2 by A4,PBOOLE:def 3;
    reconsider b2 as Rbag of EG1 \ EG2 by A4,SEQ_1:def 1;
A5: dom (the_Weight_of G2 +* b2) = dom the_Weight_of G2 \/ {e}
                                     by A4,FUNCT_4:def 1
                                .= (EG1 \ {e}) \/ {e} by A2,PBOOLE:def 3
                                .= EG1 \/ {e} by XBOOLE_1:39
                                .= EG1 by A1,ZFMISC_1:46;
A6: dom the_Weight_of G1 = EG1 by PBOOLE:def 3;
     now let x be set; assume x in dom the_Weight_of G1;
    then A7: x in EG1 by PBOOLE:def 3;
         now per cases;
        suppose
        A8: x in {e};
        then A9: x = e by TARSKI:def 1;
            hence (the_Weight_of G2 +* b2).x = b2.e by A4,A8,FUNCT_4:14
                                           .= (the_Weight_of G1).x
                                                 by A9,FUNCOP_1:87;
            end;
        suppose
        A10: not x in {e};
        then A11: (the_Weight_of G2 +* b2).x = (the_Weight_of G2).x
              by A4,FUNCT_4:12;
             x in EG1 \ {e} by A7,A10,XBOOLE_0:def 4;
            hence (the_Weight_of G2 +* b2).x = (the_Weight_of G1).x
              by A2,A3,A11,FUNCT_1:72;
            end;
        end;
        hence (the_Weight_of G1).x = (the_Weight_of G2 +* b2).x;
    end;
    then the_Weight_of G1 = the_Weight_of G2 +* b2 by A5,A6,FUNCT_1:9;
    hence G1.cost() = G2.cost() + Sum b2 by Th3
                   .= G2.cost() + b2.e by A4,Th4
                   .= G2.cost() + (the_Weight_of G1).e by FUNCOP_1:87;
end;

theorem Th34: ::tGCOST04
  for G being finite real-weighted WGraph,
      V1 being non empty Subset of the_Vertices_of G,
      E1 being Subset of G.edgesBetween(V1),
      G1 being inducedWSubgraph of G,V1,E1, e being set,
      G2 being inducedWSubgraph of G,V1,E1 \/ {e}
   st not e in E1 & e in G.edgesBetween(V1)
   holds G1.cost() + (the_Weight_of G).e = G2.cost()
proof
    let G be finite real-weighted WGraph,
       V1 be non empty Subset of the_Vertices_of G,
       E1 be Subset of G.edgesBetween(V1),
       G1 be inducedWSubgraph of G,V1,E1, e being set,
       G2 be inducedWSubgraph of G,V1,E1 \/ {e}; assume
A1: not e in E1 & e in G.edgesBetween(V1);
A2: the_Vertices_of G1 = V1 & the_Edges_of G1 = E1 by GLIB_000:def 39;
     {e} c= G.edgesBetween(V1) by A1,ZFMISC_1:37;
    then (E1 \/ {e}) c= G.edgesBetween(V1) by XBOOLE_1:8;
then A3: the_Vertices_of G2 = V1 & the_Edges_of G2 = E1 \/ {e} by
GLIB_000:def 39;
    set W2 = (e .--> (the_Weight_of G).e);
A4: the_Edges_of G2 \ the_Edges_of G1 = {e} \ E1 by A2,A3,XBOOLE_1:40
                                     .= {e} by A1,ZFMISC_1:67;
A5: dom W2 = {e} by FUNCOP_1:19;
    then reconsider W2 as ManySortedSet of (the_Edges_of G2 \ the_Edges_of G1)
      by A4,PBOOLE:def 3;
     now let y be set; assume y in rng W2;
        then y in {(the_Weight_of G).e} by FUNCOP_1:14;
        hence y in REAL;
    end;
    then rng W2 c= REAL by TARSKI:def 3;
    then reconsider W2 as Rbag of (the_Edges_of G2 \ the_Edges_of G1)
      by SEQ_1:def 1;
A6: dom the_Weight_of G2 = E1 \/ {e} by A3,PBOOLE:def 3;
A7: dom ((the_Weight_of G1) +* W2) = dom the_Weight_of G1 \/ dom W2
                                     by FUNCT_4:def 1
                                .= E1 \/ {e} by A2,A5,PBOOLE:def 3;
A8: the_Weight_of G1 = (the_Weight_of G) | E1 by A2,GLIB_003:def 10;
     now let x be set; assume x in dom the_Weight_of G2;
    then A9: x in E1 \/ {e} by A3,PBOOLE:def 3;
         the_Weight_of G2 = (the_Weight_of G) | (E1 \/ {e})
          by A3,GLIB_003:def 10;
    then A10: (the_Weight_of G2).x = (the_Weight_of G).x by A9,FUNCT_1:72;
         now per cases;
        suppose
        A11: not x in dom W2;
        then A12: ((the_Weight_of G1)+*W2).x = (the_Weight_of G1).x by
FUNCT_4:12;
             x in E1 by A5,A9,A11,XBOOLE_0:def 2;
            hence ((the_Weight_of G1)+*W2).x = (the_Weight_of G2).x
              by A8,A10,A12,FUNCT_1:72; end;
        suppose
        A13: x in dom W2;
        then A14: x = e by A5,TARSKI:def 1;
             ((the_Weight_of G1)+*W2).x = W2.x by A13,FUNCT_4:14
                   .= (the_Weight_of G).e by A14,FUNCOP_1:87;
            hence ((the_Weight_of G1)+*W2).x = (the_Weight_of G2).x
              by A5,A10,A13,TARSKI:def 1;
            end;
        end;
        hence (the_Weight_of G2).x = ((the_Weight_of G1) +* W2).x;
    end;
then A15: the_Weight_of G2 = the_Weight_of G1 +* W2 by A6,A7,FUNCT_1:9;
     dom W2 = {e} by FUNCOP_1:19;
    then Sum W2 = W2.e by Th4
          .= (the_Weight_of G).e by FUNCOP_1:87;
    hence G1.cost() + (the_Weight_of G).e = G2.cost() by A15,Th3;
end;

begin :: PRIM's Algorithm definitions

definition let G be real-weighted WVGraph;
  func PRIM:NextBestEdges(G) -> Subset of the_Edges_of G means :Def12
: ::dPRIMNEXT
    for e1 being set holds e1 in it iff
      e1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).e1 <= (the_Weight_of G).e2;
  existence
  proof
   defpred P[set] means
      $1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).$1 <= (the_Weight_of G).e2;
    consider IT being Subset of the_Edges_of G such that
A1: for e1 being set holds e1 in IT iff e1 in the_Edges_of G & P[e1]
      from SUBSET_1:sch 1;
    take IT;
    let e1 be set;
    thus e1 in IT implies P[e1] by A1;
    assume
A2: P[e1];
    then e1 in the_Edges_of G by GLIB_000:def 17;
    hence e1 in IT by A1,A2;
  end;
  uniqueness proof
    let IT1, IT2 be Subset of the_Edges_of G such that
A3: for e1 being set holds e1 in IT1 iff
      e1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).e1 <= (the_Weight_of G).e2 and
A4: for e1 being set holds e1 in IT2 iff
      e1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
       st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
       holds (the_Weight_of G).e1 <= (the_Weight_of G).e2;
    defpred P[set] means
      $1 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G &
      for e2 being set
        st e2 SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
        holds (the_Weight_of G).$1 <= (the_Weight_of G).e2;
     now let e1 be set;
        hereby assume e1 in IT1;
           then P[e1] by A3;
           hence e1 in IT2 by A4;
        end;
        assume e1 in IT2;
        then P[e1] by A4;
        hence e1 in IT1 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

definition let G be real-weighted WGraph;
  func PRIM:Init(G) -> real-WEV WEVGraph equals  ::dPRIMINIT
     G.set(VLabelSelector,(choose the_Vertices_of G).-->1)
     .set(ELabelSelector,{});
  coherence;
end;

definition let G be real-WEV WEVGraph;
  set e = choose PRIM:NextBestEdges(G);
  func PRIM:Step(G) -> real-WEV WEVGraph equals :Def14: ::dPRIMSTEP
    G if PRIM:NextBestEdges(G) = {},
    G.labelEdge(choose PRIM:NextBestEdges(G),1)
       .labelVertex((the_Target_of G).(choose PRIM:NextBestEdges(G)),1)
      if PRIM:NextBestEdges(G) <> {} &
         (the_Source_of G).(choose PRIM:NextBestEdges(G)) in G.labeledV()
           otherwise
    G.labelEdge(choose PRIM:NextBestEdges(G),1)
      .labelVertex((the_Source_of G).(choose PRIM:NextBestEdges(G)),1);
  coherence;
  consistency;
end;

definition let G be real-weighted WGraph;
  func PRIM:CompSeq(G) ->  real-WEV WEVGraphSeq means :Def15: ::dPRIMCS
    it.0 = PRIM:Init(G) &
    for n being Element of NAT holds it.(n+1) = PRIM:Step(it.n);
  existence
  proof
    defpred P[set,set,set] means
      ($2 is real-WEV WEVGraph &
          ex Gn,Gn1 being real-WEV WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = PRIM:Step(Gn)) or
      (not $2 is real-WEV WEVGraph & $2 = $3);
     now let n,x be set;
         now per cases;
        suppose x is real-WEV WEVGraph;
            then reconsider Gn=x as real-WEV WEVGraph;
             P[n,x,PRIM:Step(Gn)];
            hence ex y being set st P[n,x,y]; end;
        suppose not x is real-WEV WEVGraph;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end;
then A1: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A2: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT &
    IT.0 = PRIM:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3,PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is real-WEV WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat;
A10:  n in NAT by ORDINAL1:def 13;
      assume P2[n];
        then consider Gn,Gn1 being real-WEV WEVGraph such that
    A6: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = PRIM:Step(Gn) by A3,A10;
        thus P2[n+1] by A6;
    end;
A7: for n being Nat holds P2[n] from NAT_1:sch 2(A4,A5);
    then for n being Nat holds IT.n is _Graph;
    then reconsider IT as GraphSeq by GLIB_000:def 55;
     for n being Nat holds
      IT.n is [Weighted] & IT.n is [ELabeled] & IT.n is [VLabeled]
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A7;
    end;
    then reconsider IT as WEVGraphSeq
      by GLIB_003:def 24,def 25,def 26;
     for n being Nat holds IT.n is real-WEV
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A7;
    end;
    then reconsider IT as real-WEV WEVGraphSeq by GLIB_003:def 31;
    take IT;
    thus IT.0 = PRIM:Init(G) by A3;
    let n be Element of NAT;
    consider Gn,Gn1 being real-WEV WEVGraph such that
A8: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = PRIM:Step(Gn) by A3;
    thus IT.(n+1) = PRIM:Step(IT.n) by A8;
  end;
  uniqueness proof
    let IT1,IT2 be real-WEV WEVGraphSeq such that
A9: IT1.0 = PRIM:Init(G) &
    for n being Element of NAT holds IT1.(n+1) = PRIM:Step(IT1.n) and
A10: IT2.0 = PRIM:Init(G) &
    for n being Element of NAT holds IT2.(n+1) = PRIM:Step(IT2.n);
    defpred P[Element of NAT] means IT1.$1 = IT2.$1;
A11: P[0] by A9,A10;
     now let n be Element of NAT; assume P[n];
        then IT1.(n+1) = PRIM:Step(IT2.n) by A9
                   .= IT2.(n+1) by A10;
        hence P[n+1];
    end;
then A12: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A11,A12);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite real-weighted WGraph;
  cluster PRIM:CompSeq(G) -> finite;
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
    defpred P[Nat] means PCS.$1 is finite;
     (PCS.0) = PRIM:Init(G) by Def15
             .= G.set(VLabelSelector,(choose the_Vertices_of G).-->1)
                 .set(ELabelSelector,{});
then A1: P[0];
A2: now let n be Element of NAT; assume P[n];
        then reconsider Gn = (PCS.n) as finite real-WEV WEVGraph;
        set Gn1 = PCS.(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    A3: Gn1 = PRIM:Step(Gn) by Def15;
         now per cases;
        suppose Next = {};
            hence P[n+1] by A3,Def14;
            end;
        suppose Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
            then Gn1 = Gn.labelEdge(e,1).labelVertex((the_Target_of Gn).e,1)
              by A3,Def14;
            hence P[n+1];
            end;
        suppose Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
            then Gn1 = Gn.labelEdge(e,1).labelVertex((the_Source_of Gn).e,1)
              by A3,Def14;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end;
A4: for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
     for n being Nat holds P[n]
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A4;
    end;
    hence thesis by GLIB_000:def 60;
  end;
end;

definition let G be real-weighted WGraph;
  func PRIM:MST(G) -> real-WEV WEVGraph equals  ::dPRIMMST
     PRIM:CompSeq(G).Result();
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
     PCS.Result() = PCS.(PCS.Lifespan());
    hence thesis;
  end;
end;

registration let G be finite real-weighted WGraph;
  cluster PRIM:MST(G) -> finite;
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
     PRIM:MST(G) = PCS.(PCS.Lifespan());
    hence thesis;
  end;
end;

Lm4:
  for G being real-weighted WGraph holds
    G == PRIM:Init(G) &
    the_Weight_of G = the_Weight_of PRIM:Init(G) &
    the_ELabel_of PRIM:Init(G) = {} &
    the_VLabel_of PRIM:Init(G) = (choose the_Vertices_of G).-->1
proof
    let G be real-weighted WGraph; set G2 = PRIM:Init(G);
    set X = (choose the_Vertices_of G).-->1;
A1: G == G.set(VLabelSelector,X) by GLIB_003:8;
     G.set(VLabelSelector,X) == G2 by GLIB_003:8;
    hence G == G2 by A1,GLIB_000:88;
    thus the_Weight_of G2 = the_Weight_of G.set(VLabelSelector,X)
                              by GLIB_000:12
                         .= the_Weight_of G by GLIB_000:12;
    thus the_ELabel_of G2 = {} by GLIB_000:11;
     the_VLabel_of G2 = G.set(VLabelSelector,X).VLabelSelector by GLIB_000:12
                    .= X by GLIB_000:11;
    hence thesis;
end;

Lm5:
  for G being real-weighted WGraph holds
    PRIM:Init(G).labeledV() = {choose the_Vertices_of G} &
    PRIM:Init(G).labeledE() = {}
proof
    let G be real-weighted WGraph;
    thus PRIM:Init(G).labeledV() = dom ((choose the_Vertices_of G).-->1)
                                   by Lm4
                                .= {choose the_Vertices_of G}
                                   by FUNCOP_1:19;
    thus PRIM:Init(G).labeledE() = dom {} by Lm4
                                .= {};
end;

Lm6:
  for G being real-WEV WEVGraph st PRIM:NextBestEdges(G) <> {} holds
     ex v being Vertex of G st not v in G.labeledV() &
     PRIM:Step(G) = G.labelEdge(choose PRIM:NextBestEdges(G),1)
                     .labelVertex(v,1)
proof
    let G be real-WEV WEVGraph; set G2 = PRIM:Step(G); assume
A1: PRIM:NextBestEdges(G) <> {};
    set e = choose PRIM:NextBestEdges(G);
    set src = (the_Source_of G).e, tar = (the_Target_of G).e;
A2: e in PRIM:NextBestEdges(G) by A1;
A3: e SJoins G.labeledV(), the_Vertices_of G \ G.labeledV(), G
      by A1,Def12;
    reconsider src,tar as Vertex of G by A2,FUNCT_2:7;
     now per cases;
    suppose
    A4: src in G.labeledV();
        take tar;
         not src in the_Vertices_of G \ G.labeledV() by A4,XBOOLE_0:def 4;
        then tar in the_Vertices_of G \ G.labeledV() by A3,GLIB_000:def 17;
        hence not tar in G.labeledV() by XBOOLE_0:def 4;
        thus G2 = G.labelEdge(e,1).labelVertex(tar,1) by A1,A4,Def14; end;
    suppose
    A5: not src in G.labeledV();
        take src;
        thus not src in G.labeledV() by A5;
        thus G2 = G.labelEdge(e,1).labelVertex(src,1) by A1,A5,Def14; end;
    end;
    hence thesis;
end;

Lm7:
  for G being real-WEV WEVGraph holds
    G == PRIM:Step(G) & the_Weight_of G  = the_Weight_of PRIM:Step(G) &
    G.labeledE() c= PRIM:Step(G).labeledE() &
    G.labeledV() c= PRIM:Step(G).labeledV()
proof
    let G be real-WEV WEVGraph; set G2 = PRIM:Step(G);
    set Next = PRIM:NextBestEdges(G), e = choose Next, GE = G.labelEdge(e,1);
    set src = (the_Source_of G).e, tar = (the_Target_of G).e;
     now per cases;
    suppose Next = {};
        hence thesis by Def14; end;
    suppose
    A1: Next <> {};
        then consider v being Vertex of G such that
    A2: not v in G.labeledV() &
          G2 = GE.labelVertex(v,1) by Lm6;
    A3: G == GE by GLIB_003:41;
         GE == G2 by A2,GLIB_003:47;
        hence G == G2 by A3,GLIB_000:88;
         e SJoins G.labeledV(),the_Vertices_of G \ G.labeledV(),G
          by A1,Def12;
    then A4: e in the_Edges_of G by GLIB_000:def 17;
        thus the_Weight_of G  = the_Weight_of GE by GLIB_003:42
                             .= the_Weight_of G2 by A2,GLIB_003:48;
         G.labeledE() c= GE.labeledE() by A4,GLIB_003:53;
        hence G.labeledE() c= G2.labeledE() by A2,GLIB_003:56;
         the_Vertices_of G = the_Vertices_of GE by A3,GLIB_000:def 36;
        then GE.labeledV() c= G2.labeledV() by A2,GLIB_003:60;
        hence G.labeledV() c= G2.labeledV() by GLIB_003:63; end;
    end;
    hence thesis;
end;

Lm8:
  for G being finite real-weighted WGraph, n being Element of NAT holds
     G == PRIM:CompSeq(G).n &
     the_Weight_of (PRIM:CompSeq(G).n) = the_Weight_of G
proof
   let G be finite real-weighted WGraph; set PCS = PRIM:CompSeq(G);
    defpred P[Element of NAT] means
    G == PCS.$1 & the_Weight_of (PCS.$1) = the_Weight_of G;
     PCS.0 = PRIM:Init(G) by Def15;
then A1: P[0] by Lm4;
A2: now let n be Element of NAT; set Gn = PCS.n, Gn1 = PCS.(n+1);assume
    A3: P[n];
         Gn1 = PRIM:Step(Gn) by Def15;
        then Gn1 == Gn & the_Weight_of Gn1 = the_Weight_of Gn
          by Lm7;
        hence P[n+1] by A3,GLIB_000:88;
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

Lm9:
  for G being finite real-weighted WGraph, n being Element of NAT holds
   (PRIM:CompSeq(G).n).labeledV() is non empty Subset of the_Vertices_of G &
   (PRIM:CompSeq(G).n).labeledE() c=
     G.edgesBetween((PRIM:CompSeq(G).n).labeledV())
proof
    let G be finite real-weighted WGraph;
    set PCS = PRIM:CompSeq(G);
    defpred P[Element of NAT] means
      (PCS.$1).labeledV() is non empty Subset of the_Vertices_of G &
      (PCS.$1).labeledE() c= G.edgesBetween((PCS.$1).labeledV());
     now (PCS.0).labeledV() = PRIM:Init(G).labeledV() by Def15
                            .= {choose the_Vertices_of G} by Lm5;
        hence (PCS.0).labeledV() is non empty Subset of the_Vertices_of G;
         (PCS.0).labeledE() = PRIM:Init(G).labeledE() by Def15
                            .= {} by Lm5;
        hence (PCS.0).labeledE() c=
          G.edgesBetween((PRIM:CompSeq(G).0).labeledV()) by XBOOLE_1:2;
    end;
then A1: P[0];
     now let n be Element of NAT; assume
    A2: P[n];
        set Gn = PCS.n, Gn1 = PCS.(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    A3: Gn1 = PRIM:Step(Gn) by Def15;
         now per cases;
        suppose Next = {};
            then Gn1 = Gn by A3,Def14;
            hence P[n+1] by A2; end;
        suppose
        A4: Next <> {};
            set src = (the_Source_of Gn).e, tar = (the_Target_of Gn).e;
        A5: e in Next by A4;
             Gn == Gn.labelEdge(e,1) by GLIB_003:41;
        then A6: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36;
        then A7: src in the_Vertices_of Gn.labelEdge(e,1) &
            tar in the_Vertices_of Gn.labelEdge(e,1) by A5,FUNCT_2:7;
             Gn == G by Lm8;
        then A8: the_Vertices_of Gn = the_Vertices_of G &
            the_Edges_of Gn = the_Edges_of G &
            the_Source_of Gn = the_Source_of G &
            the_Target_of Gn = the_Target_of G by GLIB_000:def 36;
        A9: e SJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(), Gn
              by A4,Def12;
             now per cases;
            suppose
            A10:(the_Source_of Gn).e in Gn.labeledV();
            then A11: Gn1 = Gn.labelEdge(e,1).labelVertex((the_Target_of Gn).e,
1)
                  by A3,A4,Def14;
                 Gn.labeledV() = Gn.labelEdge(e,1).labeledV()
                  by GLIB_003:63;
            then A12: Gn1.labeledV() = Gn.labeledV() \/ {tar} by A7,A11,
GLIB_003:59;
            A13: Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by A11,
GLIB_003:56
                              .= Gn.labeledE() \/ {e} by A5,GLIB_003:52;
                 now let x be set; assume
                A14: x in Gn1.labeledV();
                     now per cases by A12,A14,XBOOLE_0:def 2;
                    suppose x in Gn.labeledV();
                        hence x in the_Vertices_of G by A2; end;
                    suppose x in {tar};
                        hence x in the_Vertices_of G by A6,A7,A8,TARSKI:def 1;
                        end;
                    end;
                    hence x in the_Vertices_of G;
                end;
                hence Gn1.labeledV() is non empty Subset of the_Vertices_of G
                  by A12,TARSKI:def 3;
            A15: Gn.labeledV() c= Gn1.labeledV() by A12,XBOOLE_1:7;
            then A16: G.edgesBetween(Gn.labeledV()) c=
                  G.edgesBetween(Gn1.labeledV()) by GLIB_000:39;
                 now let x be set; assume
                A17: x in Gn1.labeledE();
                     now per cases by A13,A17,XBOOLE_0:def 2;
                    suppose x in Gn.labeledE();
                        then x in G.edgesBetween(Gn.labeledV()) by A2;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by A16; end;
                    suppose x in {e};
                    then A18: x = e by TARSKI:def 1;
                        then (the_Target_of G).x in {tar} by A8,TARSKI:def 1;
                        then (the_Target_of G).x in Gn1.labeledV()
                          by A12,XBOOLE_0:def 2;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by A5,A8,A10,A15,A18,GLIB_000:34; end;
                    end;
                    hence x in G.edgesBetween(Gn1.labeledV());
                end;
                hence Gn1.labeledE() c= G.edgesBetween(Gn1.labeledV())
                  by TARSKI:def 3; end;
            suppose
            A19: not (the_Source_of Gn).e in Gn.labeledV();
            then A20: Gn1 = Gn.labelEdge(e,1).labelVertex((the_Source_of Gn).e,
1)
                  by A3,A4,Def14;
                 Gn.labeledV() = Gn.labelEdge(e,1).labeledV()
                  by GLIB_003:63;
            then A21: Gn1.labeledV() = Gn.labeledV() \/ {src} by A7,A20,
GLIB_003:59;
            A22: Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by A20,
GLIB_003:56
                              .= Gn.labeledE() \/ {e} by A5,GLIB_003:52;
                 now let x be set; assume
                A23: x in Gn1.labeledV();
                     now per cases by A21,A23,XBOOLE_0:def 2;
                    suppose x in Gn.labeledV();
                        hence x in the_Vertices_of G by A2;
                        end;
                    suppose x in {src};
                        hence x in the_Vertices_of G by A6,A7,A8,TARSKI:def 1;
                        end;
                    end;
                    hence x in the_Vertices_of G;
                end;
                hence Gn1.labeledV() is non empty Subset of the_Vertices_of G
                  by A21,TARSKI:def 3;
            A24: Gn.labeledV() c= Gn1.labeledV() by A21,XBOOLE_1:7;
            then A25: G.edgesBetween(Gn.labeledV()) c=
                  G.edgesBetween(Gn1.labeledV()) by GLIB_000:39;
            A26: tar in Gn.labeledV() by A9,A19,GLIB_000:def 17;
                 now let x be set; assume
                A27: x in Gn1.labeledE();
                     now per cases by A22,A27,XBOOLE_0:def 2;
                    suppose x in Gn.labeledE();
                        then x in G.edgesBetween(Gn.labeledV()) by A2;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by A25; end;
                          suppose x in {e};
                    then A28: x = e by TARSKI:def 1;
                        then (the_Source_of G).x in {src}
                          by A8,TARSKI:def 1;
                        then (the_Source_of G).x in Gn1.labeledV()
                          by A21,XBOOLE_0:def 2;
                        hence x in G.edgesBetween(Gn1.labeledV())
                          by A5,A8,A24,A26,A28,GLIB_000:34; end;
                        end;
                    hence x in G.edgesBetween(Gn1.labeledV());
                end;
                hence Gn1.labeledE() c= G.edgesBetween(Gn1.labeledV())
                  by TARSKI:def 3; end;
            end;
            hence P[n+1]; end;
        end;
        hence P[n+1];

    end;
then A29: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A29);
    hence thesis;
end;

Lm10:
  for G1 being finite real-weighted WGraph, n being Element of NAT,
      G2 being inducedSubgraph of G1,(PRIM:CompSeq(G1).n).labeledV(),
                                     (PRIM:CompSeq(G1).n).labeledE()
  holds G2 is connected
proof
    let G1 be finite real-weighted WGraph;
    defpred P[Element of NAT] means
    for G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).$1).labeledV(),
      (PRIM:CompSeq(G1).$1).labeledE() holds G2 is connected;
    set G0 = PRIM:CompSeq(G1).0, v = choose the_Vertices_of G1;
     now let G be inducedSubgraph of G1, G0.labeledV(), G0.labeledE();
       G0 = PRIM:Init(G1) by Def15;
      then G0.labeledV() = {v} & G0.labeledE() = {} by Lm5;
        then reconsider G' = G as inducedSubgraph of G1,{v},{};
         G' is connected;
        hence G is connected;
    end;
then A1: P[0];
     now let n be Element of NAT; assume
    A2: P[n];
        set Gn = PRIM:CompSeq(G1).n, Gn1 = PRIM:CompSeq(G1).(n+1);
        set e = choose PRIM:NextBestEdges(Gn);
        set v1 = (the_Target_of Gn).e, v2 = (the_Source_of Gn).e;
    A3: Gn1 = PRIM:Step(Gn) by Def15;
         now let Gn1s be inducedSubgraph of G1, Gn1.labeledV(), Gn1.labeledE();
             Gn1.labeledV() is non empty Subset of the_Vertices_of G1 &
            Gn1.labeledE()c=G1.edgesBetween(Gn1.labeledV()) by Lm9;
        then A4: the_Vertices_of Gn1s = Gn1.labeledV() &
            the_Edges_of Gn1s = Gn1.labeledE() by GLIB_000:def 39;
             now per cases;
            suppose PRIM:NextBestEdges(Gn) = {};
                 then Gn1 = Gn by A3,Def14;
                 hence Gn1s is connected by A2; end;
            suppose
            A5: PRIM:NextBestEdges(Gn) <> {} & v2 in Gn.labeledV();
            then A6: Gn1 = Gn.labelEdge(e,1).labelVertex(v1,1) by A3,Def14;
            A7: e in PRIM:NextBestEdges(Gn) by A5;
                then reconsider v1 as Vertex of Gn by FUNCT_2:7;
                 Gn == Gn.labelEdge(e,1) by GLIB_003:41;
                then the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
                  by GLIB_000:def 36;
                then Gn1.labeledV() = Gn.labelEdge(e,1).labeledV() \/ {v1}
                  by A6,GLIB_003:59;
            then A8: Gn1.labeledV() = Gn.labeledV() \/ {v1} by GLIB_003:63;
             Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by A6,GLIB_003:49;
            then A9: Gn1.labeledE() = Gn.labeledE() \/ {e} by A7,GLIB_003:52;
                consider Gns being inducedSubgraph of
                  G1,Gn.labeledV(),Gn.labeledE();
            A10: Gns is connected by A2;
            A11: Gn.labeledV() is non empty Subset of the_Vertices_of G1 &
                  Gn.labeledE() c= G1.edgesBetween(Gn.labeledV())
                  by Lm9;
            then A12: the_Vertices_of Gns = Gn.labeledV() &
                the_Edges_of Gns = Gn.labeledE() by GLIB_000:def 39;
                then the_Vertices_of Gns c= the_Vertices_of Gn1s &
                the_Edges_of Gns c= the_Edges_of Gn1s
                  by A4,A8,A9,XBOOLE_1:7;
                then reconsider Gns as Subgraph of Gn1s by GLIB_000:47;
                consider src being Vertex of Gns;
                reconsider src' = src as Vertex of Gn1s by GLIB_000:45;
            A13: Gn == G1 by Lm8;
                 e Joins v2,v1,Gn by A7,GLIB_000:def 15;
            then A14: e Joins v2,v1,G1 by A13,GLIB_000:91;
                 e in {e} by TARSKI:def 1;
                then e in the_Edges_of Gn1s by A4,A9,XBOOLE_0:def 2;
            then A15: e Joins v2,v1,Gn1s by A14,GLIB_000:76;
                 now let x be Vertex of Gn1s;
                     now per cases;
                    suppose
                    A16: x = v1;
                        reconsider v2'=v2 as Vertex of Gns
                          by A5,A11,GLIB_000:def 39;
                        consider W being Walk of Gns such that
                    A17: W is_Walk_from src,v2' by A10,GLIB_002:def 1;
                        reconsider W as Walk of Gn1s by GLIB_001:168;
                         W is_Walk_from src',v2 by A17,GLIB_001:20;
                        then W.addEdge(e) is_Walk_from src',x by A15,A16,
GLIB_001:67
;
                        hence ex W being Walk of Gn1s st
                          W is_Walk_from src',x; end;
                    suppose x <> v1;
                        then not x in {v1} by TARSKI:def 1;
                        then reconsider x'=x as Vertex of Gns
                          by A4,A8,A12,XBOOLE_0:def 2;
                        consider W being Walk of Gns such that
                    A18: W is_Walk_from src,x' by A10,GLIB_002:def 1;
                        reconsider W'=W as Walk of Gn1s by GLIB_001:168;
                         W' is_Walk_from src',x by A18,GLIB_001:20;
                        hence ex W being Walk of Gn1s st
                          W is_Walk_from src',x; end;
                    end;
                    hence ex W being Walk of Gn1s st W is_Walk_from src',x;
                end;
                hence Gn1s is connected by GLIB_002:6; end;
          suppose
          A19: PRIM:NextBestEdges(Gn) <> {} & not v2 in Gn.labeledV();
          then A20: Gn1 = Gn.labelEdge(e,1).labelVertex(v2,1) by A3,Def14;
               e SJoins Gn.labeledV(),the_Vertices_of Gn\Gn.labeledV(),Gn
                by A19,Def12;
          then A21: e in the_Edges_of Gn & v1 in Gn.labeledV()
                by A19,GLIB_000:def 17;
              then reconsider v2 as Vertex of Gn by FUNCT_2:7;
               Gn == Gn.labelEdge(e,1) by GLIB_003:41;
              then the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
                by GLIB_000:def 36;
              then Gn1.labeledV() = Gn.labelEdge(e,1).labeledV() \/ {v2}
                by A20,GLIB_003:59;
          then A22: Gn1.labeledV() = Gn.labeledV() \/ {v2} by GLIB_003:63;
           Gn1.labeledE() = Gn.labelEdge(e,1).labeledE() by A20,GLIB_003:49;
          then A23: Gn1.labeledE() = Gn.labeledE() \/ {e} by A21,GLIB_003:52;
               consider Gns being inducedSubgraph of
                 G1,Gn.labeledV(),Gn.labeledE();
          A24: Gns is connected by A2;
          A25: Gn.labeledV() is non empty Subset of the_Vertices_of G1 &
                Gn.labeledE()c= G1.edgesBetween(Gn.labeledV())
                by Lm9;
          then A26: the_Vertices_of Gns = Gn.labeledV() &
                the_Edges_of Gns = Gn.labeledE() by GLIB_000:def 39;
              then the_Vertices_of Gns c= the_Vertices_of Gn1s &
                the_Edges_of Gns c= the_Edges_of Gn1s
                by A4,A22,A23,XBOOLE_1:7;
              then reconsider Gns as Subgraph of Gn1s by GLIB_000:47;
              consider src being Vertex of Gns;
              reconsider src' = src as Vertex of Gn1s by GLIB_000:45;
          A27: Gn == G1 by Lm8;
               e Joins v1,v2,Gn by A21,GLIB_000:def 15;
          then A28: e Joins v1,v2,G1 by A27,GLIB_000:91;
               e in {e} by TARSKI:def 1;
              then e in the_Edges_of Gn1s by A4,A23,XBOOLE_0:def 2;
          then A29: e Joins v1,v2,Gn1s by A28,GLIB_000:76;
               now let x be Vertex of Gn1s;
                   now per cases;
                  suppose
                  A30: x = v2;
                      reconsider v1'=v1 as Vertex of Gns
                        by A21,A25,GLIB_000:def 39;
                      consider W being Walk of Gns such that
                  A31: W is_Walk_from src,v1' by A24,GLIB_002:def 1;
                      reconsider W as Walk of Gn1s by GLIB_001:168;
                       W is_Walk_from src',v1 by A31,GLIB_001:20;
                      then W.addEdge(e) is_Walk_from src',x by A29,A30,
GLIB_001:67;
                      hence ex W being Walk of Gn1s st
                        W is_Walk_from src',x; end;
                  suppose x <> v2;
                      then not x in {v2} by TARSKI:def 1;
                      then reconsider x'=x as Vertex of Gns
                        by A4,A22,A26,XBOOLE_0:def 2;
                      consider W being Walk of Gns such that
                  A32: W is_Walk_from src,x' by A24,GLIB_002:def 1;
                      reconsider W'=W as Walk of Gn1s by GLIB_001:168;
                       W' is_Walk_from src',x by A32,GLIB_001:20;
                      hence ex W being Walk of Gn1s st
                        W is_Walk_from src',x; end;
                  end;
                  hence ex W being Walk of Gn1s st W is_Walk_from src',x;
              end;
              hence Gn1s is connected by GLIB_002:6; end;
          end;
          hence Gn1s is connected;
        end;
        hence P[n+1];
    end;
then A33: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A33);
    hence thesis;
end;

Lm11:
  for G1 being finite real-weighted WGraph, n being Element of NAT,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).n).labeledV()
    holds G2 is connected
proof
    let G1 be finite real-weighted WGraph, n be Element of NAT;
    set V = (PRIM:CompSeq(G1).n).labeledV();
    set E = (PRIM:CompSeq(G1).n).labeledE();
    let G2 be inducedSubgraph of G1, V;
    reconsider V as non empty Subset of the_Vertices_of G1 by Lm9;
    reconsider E as Subset of G1.edgesBetween(V) by Lm9;
    consider G3 being inducedSubgraph of G1,V,E;
A1: the_Vertices_of G3 = V & the_Edges_of G3 = E by GLIB_000:def 39;
A2: the_Vertices_of G2 = V & the_Edges_of G2 = G1.edgesBetween(V)
      by GLIB_000:def 39;
    then reconsider G3 as Subgraph of G2 by A1,GLIB_000:47;
A3: G3 is connected by Lm10;
     G3 is spanning by A1,A2,GLIB_000:def 35;
    hence G2 is connected by A3,GLIB_002:23;
end;

registration let G1 be finite real-weighted WGraph, n being Element of NAT;
  cluster
  -> connected inducedSubgraph of G1,(PRIM:CompSeq(G1).n).labeledV();
  coherence by Lm11;
end;

registration let G1 be finite real-weighted WGraph, n being Element of NAT;
  cluster
  -> connected inducedSubgraph of G1, (PRIM:CompSeq(G1).n).labeledV(),
                                      (PRIM:CompSeq(G1).n).labeledE();
  coherence by Lm10;
end;

Lm12:
  for G being finite real-weighted WGraph, n being Element of NAT holds
    (PRIM:CompSeq(G).n).labeledV() c=
      G.reachableFrom(choose the_Vertices_of G)
proof
    let G be finite real-weighted WGraph;
    set src = choose the_Vertices_of G;
    defpred P[Element of NAT] means
    (PRIM:CompSeq(G).$1).labeledV() c=
      G.reachableFrom(choose the_Vertices_of G);
    set G0 = PRIM:CompSeq(G).0;
     G0 = PRIM:Init(G) by Def15;
    then the_VLabel_of G0 = src.-->1 by Lm4;
    then A1: dom the_VLabel_of G0 = {src} by FUNCOP_1:19;
     src in G.reachableFrom(src) by GLIB_002:9;
then A2: P[0] by A1,ZFMISC_1:37;
A3: now let n be Element of NAT; assume
    A4: P[n];
        set Gn = PRIM:CompSeq(G).n, Gn1 = PRIM:CompSeq(G).(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
        set sc = (the_Source_of Gn).e, tar = (the_Target_of Gn).e;
    A5: Gn1 = PRIM:Step(Gn) by Def15;
         now per cases;
        suppose Next = {};
            hence P[n+1] by A4,A5,Def14; end;
        suppose
        A6: Next <> {} & sc in Gn.labeledV();
        then A7: Gn1 = Gn.labelEdge(e,1).labelVertex(tar,1) by A5,Def14;
        A8: e in Next by A6;
        then A9: tar in the_Vertices_of Gn by FUNCT_2:7;
             Gn == Gn.labelEdge(e,1) by GLIB_003:41;
        then A10: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36;
             Gn.labeledV() = Gn.labelEdge(e,1).labeledV() by GLIB_003:63;
        then A11: Gn1.labeledV() = Gn.labeledV() \/ {tar} by A7,A9,A10,
GLIB_003:59;
             now let v be set; assume
            A12: v in Gn1.labeledV();
                 now per cases by A11,A12,XBOOLE_0:def 2;
                suppose v in Gn.labeledV();
                    hence v in G.reachableFrom(src) by A4; end;
                suppose v in {tar};
                    then v = tar by TARSKI:def 1;
                then A13: e Joins sc,v,Gn by A8,GLIB_000:def 15;
                     G == Gn by Lm8;
                    then e Joins sc,v,G by A13,GLIB_000:91;
                    hence v in G.reachableFrom(src) by A4,A6,GLIB_002:10; end;
                end;
                hence v in G.reachableFrom(src);
            end;
            hence P[n+1] by TARSKI:def 3; end;
        suppose
        A14: Next <> {} & not sc in Gn.labeledV();
        then A15: Gn1 = Gn.labelEdge(e,1).labelVertex(sc,1) by A5,Def14;
        A16: e SJoins Gn.labeledV(), the_Vertices_of Gn \ Gn.labeledV(), Gn
              by A14,Def12;
        then A17: tar in Gn.labeledV() by A14,GLIB_000:def 17;
        A18: e in the_Edges_of Gn by A16,GLIB_000:def 17;
        then A19: sc in the_Vertices_of Gn by FUNCT_2:7;
             Gn == Gn.labelEdge(e,1) by GLIB_003:41;
        then A20: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36;
             Gn.labeledV() = Gn.labelEdge(e,1).labeledV() by GLIB_003:63;
        then A21: Gn1.labeledV() = Gn.labeledV() \/ {sc} by A15,A19,A20,
GLIB_003:59;
             now let v be set; assume
            A22: v in Gn1.labeledV();
                 now per cases by A21,A22,XBOOLE_0:def 2;
                suppose v in Gn.labeledV();
                    hence v in G.reachableFrom(src) by A4; end;
                suppose v in {sc};
                    then v = sc by TARSKI:def 1;
                then A23: e Joins tar,v,Gn by A18,GLIB_000:def 15;
                     G == Gn by Lm8;
                    then e Joins tar,v,G by A23,GLIB_000:91;
                    hence v in G.reachableFrom(src) by A4,A17,GLIB_002:10; end;
                end;
                hence v in G.reachableFrom(src);
            end;
            hence P[n+1] by TARSKI:def 3; end;
        end;
        hence P[n+1];
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

Lm13:
  for G being finite real-weighted WGraph, i,j being Nat
  st i <= j holds
    (PRIM:CompSeq(G).i).labeledV() c=
    (PRIM:CompSeq(G).j).labeledV() &
    (PRIM:CompSeq(G).i).labeledE() c=
    (PRIM:CompSeq(G).j).labeledE()
proof
    let G be finite real-weighted WGraph, i,j be Nat;
    set PCS = PRIM:CompSeq(G);
    set vPCS = (PCS.i).labeledV(), ePCS = (PCS.i).labeledE();
    assume i <= j;
    then consider x being Nat such that
A1: j = i + x by NAT_1:10;
    reconsider x as Element of NAT by ORDINAL1:def 13;
A2: j = i+x by A1;
    defpred P[Element of NAT] means vPCS c= (PCS.(i+$1)).labeledV() &
                         ePCS c= (PCS.(i+$1)).labeledE();
A3: P[0];
     now let k be Element of NAT; assume
    A4: vPCS c= (PCS.(i+k)).labeledV() &
        ePCS c= (PCS.(i+k)).labeledE();
         PCS.(i+k+1) = PRIM:Step(PCS.(i+k)) by Def15;
        then (PCS.(i+k)).labeledV() c= (PCS.(i+k+1)).labeledV() &
        (PCS.(i+k)).labeledE() c= (PCS.(i+k+1)).labeledE()
          by Lm7;
        hence vPCS c= (PCS.(i+(k+1))).labeledV() &
              ePCS c= (PCS.(i+(k+1))).labeledE() by A4,XBOOLE_1:1;
    end;
then A5: for k being Element of NAT st P[k] holds P[k+1];
     for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A5);
    hence vPCS c= (PCS.j).labeledV() & ePCS c= (PCS.j).labeledE() by A2;
end;

Lm14:
    for G being finite real-weighted WGraph, n being Element of NAT holds
      PRIM:NextBestEdges(PRIM:CompSeq(G).n) = {} iff
   (PRIM:CompSeq(G).n).labeledV() =
     G.reachableFrom(choose the_Vertices_of G)
proof
    let G be finite real-weighted WGraph, n be Element of NAT;
    set src = choose the_Vertices_of G;
    set PCS = PRIM:CompSeq(G), RFS = G.reachableFrom(src);
    set Gn = PCS.n, Gn1 = PCS.(n+1);
    set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    set GnV = Gn.labeledV(), GnVg = the_Vertices_of Gn \ GnV;
    hereby assume
    A1: Next = {};
         now assume
        A2: GnV <> RFS;
             GnV c= RFS by Lm12;
        then A3: GnV c< RFS by A2,XBOOLE_0:def 8;
            defpred P1[set] means $1 SJoins GnV, GnVg, Gn;
            consider BE1 being Subset of the_Edges_of Gn such that
        A4: for x being set holds x in BE1 iff x in the_Edges_of Gn & P1[x]
              from SUBSET_1:sch 1;
             now assume
            A5: BE1 = {};
                consider v being set such that
            A6: v in RFS & not v in Gn.labeledV() by A3,XBOOLE_0:6;
                reconsider v as Vertex of G by A6;
                consider W being Walk of G such that
            A7: W is_Walk_from src, v by A6,GLIB_002:def 5;
                 src in {src} by TARSKI:def 1;
                then src in PRIM:Init(G).labeledV() by Lm5;
            then A8: src in (PCS.0).labeledV() by Def15;
            A9: (PCS.0).labeledV() c= Gn.labeledV() by Lm13;
                defpred P2[Nat] means
                  $1 is odd & $1 <= len W & not W.$1 in GnV;
                 W.(len W) = W.last() by GLIB_001:def 7
                         .= v by A7,GLIB_001:def 23;
            then A10: ex k being Nat st P2[k] by A6;
                consider k being Nat such that
            A11: P2[k] & for m being Nat st P2[m] holds k <= m
                  from NAT_1:sch 5(A10);
                 now per cases;
                    suppose k = 1;
                    then W.k = W.first() by GLIB_001:def 6
                       .= src by A7,GLIB_001:def 23;
                    hence contradiction by A8,A9,A11;
                    end;
                    suppose
                A12: k <> 1; reconsider k'=k as odd Element of NAT
                     by A11,ORDINAL1:def 13;
                     1 <= k by A11,HEYTING3:1;
                    then 1 < k by A12,REAL_1:def 5;
                    then 1+1 <= k by NAT_1:13;
                    then reconsider k2a = k'-2*1 as odd Element of NAT by
INT_1:18;
                A13: k - 2 < len W - 0 by A11,REAL_1:92;
                     k2a < k - 0 by REAL_1:92;
                then A14: W.k2a in GnV by A11,A13;
                    set e = W.(k2a+1);
                A15: e Joins W.k2a, W.(k2a+2),G by A13,GLIB_001:def 3;
                then A16: W.k in the_Vertices_of G by GLIB_000:16;
                A17: G == Gn by Lm8;
                then A18: the_Vertices_of G = the_Vertices_of Gn &
                    the_Edges_of G = the_Edges_of Gn by GLIB_000:def 36;
                    then W.k in GnVg by A11,A16,XBOOLE_0:def 4;
                    then e SJoins GnV, GnVg, G by A14,A15,GLIB_000:20;
                then A19: P1[e] by A17,GLIB_000:91;
                     e in the_Edges_of Gn by A15,A18,GLIB_000:def 15;
                    hence contradiction by A4,A5,A19;
                    end;
                end;
                hence contradiction;
            end; then reconsider BE1 as non empty finite set;
            deffunc F(Element of BE1) = (the_Weight_of Gn).$1;
            consider e1 being Element of BE1 such that
        A20: for e2 being Element of BE1 holds F(e1)<=F(e2) from GRAPH_5:sch 2;
        A21: e1 SJoins GnV, GnVg, Gn by A4;
             now let e2 be set; assume
            A22: e2 SJoins GnV, GnVg, Gn;
                then e2 in the_Edges_of Gn by GLIB_000:def 17;
                then reconsider e2' = e2 as Element of BE1 by A4,A22;
                 (the_Weight_of Gn).e1 <= (the_Weight_of Gn).e2' by A20;
                hence (the_Weight_of Gn).e1 <= (the_Weight_of Gn).e2;
            end;
            hence contradiction by A1,A21,Def12;
         end;
         hence GnV = RFS;
    end;
    assume
A23: GnV = RFS; set e = choose Next;
     now assume Next <> {};
    then A24: e SJoins GnV, GnVg, Gn by Def12;
    then A25: e in the_Edges_of Gn by GLIB_000:def 17;
    A26: Gn == G by Lm8;
         now per cases by A24,GLIB_000:def 17;
            suppose
        A27: (the_Source_of Gn).e in GnV & (the_Target_of Gn).e in GnVg;
        then A28: not (the_Target_of Gn).e in GnV by XBOOLE_0:def 4;
             e Joins (the_Source_of Gn).e, (the_Target_of Gn).e, Gn
              by A25,GLIB_000:def 15;
            then e Joins (the_Source_of Gn).e, (the_Target_of Gn).e, G
              by A26,GLIB_000:91;
            hence contradiction by A23,A27,A28,GLIB_002:10;
            end;
            suppose
        A29: (the_Source_of Gn).e in GnVg & (the_Target_of Gn).e in GnV;
        then A30: not (the_Source_of Gn).e in GnV by XBOOLE_0:def 4;
             e Joins (the_Target_of Gn).e, (the_Source_of Gn).e, Gn
              by A25,GLIB_000:def 15;
            then e Joins (the_Target_of Gn).e, (the_Source_of Gn).e, G
              by A26,GLIB_000:91;
            hence contradiction by A23,A29,A30,GLIB_002:10;
            end;
        end;
        hence contradiction;
    end;
    hence Next = {};
end;

Lm15:
  for G being finite real-weighted WGraph, n being Element of NAT holds
    card (PRIM:CompSeq(G).n).labeledV() =
      min(n+1, card(G.reachableFrom(choose the_Vertices_of G)))
proof
    let G be finite real-weighted WGraph;
    set CS = PRIM:CompSeq(G), src = choose the_Vertices_of G;
    defpred P[Element of NAT] means
    card (PRIM:CompSeq(G).$1).labeledV() =
      min($1+1, card(G.reachableFrom(src)));
    set G0 = CS.0;
     G0 = PRIM:Init(G) by Def15;
    then the_VLabel_of G0 = src.-->1 by Lm4;
    then {src} = G0.labeledV() by FUNCOP_1:19;
then A1: card G0.labeledV() = 1 by CARD_1:79;
     src in G.reachableFrom(src) by GLIB_002:9;
    then {src} c= G.reachableFrom(src) by ZFMISC_1:37;
    then card {src} <= card G.reachableFrom(src) by NAT_1:44;
    then 0+1 <= card G.reachableFrom(src) by CARD_1:79;
then A2: P[0] by A1,XXREAL_0:def 8;
A3: now let n be Element of NAT; assume
    A4: P[n];
        set Gn = PRIM:CompSeq(G).n, Gn1 = PRIM:CompSeq(G).(n+1);
        set e = choose PRIM:NextBestEdges(Gn);
    A5: Gn1 = PRIM:Step(Gn) by Def15;
         now per cases;
        suppose
        A6: PRIM:NextBestEdges(Gn) = {};
        then A7: card Gn1.labeledV() = min(n+1, card (G.reachableFrom(src)))
              by A4,A5,Def14;
        A8: card Gn.labeledV() = card G.reachableFrom(src) by A6,Lm14;
            then card G.reachableFrom(src) <= n+1 by A4,XXREAL_0:def 8;
            then card G.reachableFrom(src) <= n+1+1 by NAT_1:12;
            hence P[n+1] by A4,A7,A8,XXREAL_0:def 8; end;
        suppose
        A9: PRIM:NextBestEdges(Gn) <> {};
            then consider v being Vertex of Gn such that
        A10: not v in Gn.labeledV() &
              Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by A5,Lm6;
        A11: Gn.labeledV() = Gn.labelEdge(e,1).labeledV() by GLIB_003:63;
             Gn == Gn.labelEdge(e,1) by GLIB_003:41;
            then the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
              by GLIB_000:def 36;
        then A12: card Gn1.labeledV() = card Gn.labeledV() + 1
              by A10,A11,GLIB_003:61;
        A13: Gn.labeledV() <> G.reachableFrom(src) by A9,Lm14;
        A14: Gn.labeledV() c= G.reachableFrom(src) by Lm12;
        then A15: card Gn.labeledV() <= card G.reachableFrom(src) by NAT_1:44;
        A16: now assume
            A17: card Gn.labeledV() = card G.reachableFrom(src);
                 Gn.labeledV() c< G.reachableFrom(src) by A13,A14,
XBOOLE_0:def 8
;
                hence contradiction by A17,CARD_2:67;
            end;
        then A18: card Gn.labeledV() = n+1 by A4,XXREAL_0:15;
            then n+1 < card G.reachableFrom(src) by A15,A16,REAL_1:def 5;
            then n+1+1 <= card G.reachableFrom(src) by NAT_1:13;
            hence P[n+1] by A12,A18,XXREAL_0:def 8; end;
        end;
        hence P[n+1];
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

Lm16:
  for G being finite real-weighted WGraph holds
    PRIM:CompSeq(G) is halting & PRIM:CompSeq(G).Lifespan() + 1 =
      card G.reachableFrom(choose the_Vertices_of G)
proof
    let G be finite real-weighted WGraph;
    set PCS = PRIM:CompSeq(G);
    set src = choose the_Vertices_of G, RFS = G.reachableFrom(src);
     card RFS <> 0 by CARD_2:59;
    then consider n being Nat such that
A1: n + 1 = card RFS by NAT_1:6;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set Gn = PCS.n, Gn1 = PCS.(n+1);
A2: card RFS <= card RFS + 1 by NAT_1:11;
A3: card Gn.labeledV() = min(card RFS, card RFS) by A1,Lm15
                      .= card RFS;
A4: card Gn1.labeledV() = min(card RFS + 1, card RFS) by A1,Lm15
                       .= card RFS by A2,XXREAL_0:def 8;
A5: Gn1 = PRIM:Step(Gn) by Def15;
then A6: Gn.labeledV() c= Gn1.labeledV() by Lm7;
A7: now assume Gn.labeledV() <> Gn1.labeledV();
        then Gn.labeledV() c< Gn1.labeledV() by A6,XBOOLE_0:def 8;
        hence contradiction by A3,A4,CARD_2:67;
    end;
    set e = choose PRIM:NextBestEdges(Gn);
     now assume PRIM:NextBestEdges(Gn) <> {};
        then consider v being Vertex of Gn such that
    A8: not v in Gn.labeledV() &
          Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by A5,Lm6;
         Gn == Gn.labelEdge(e,1) by GLIB_003:41;
        then the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
            by GLIB_000:def 36;
    then A9: Gn1.labeledV() = Gn.labelEdge(e,1).labeledV() \/ {v}
          by A8,GLIB_003:59;
         v in {v} by TARSKI:def 1;
        hence contradiction by A7,A8,A9,XBOOLE_0:def 2;
    end;
then A10: Gn1 = Gn by A5,Def14;
    hence A11: PRIM:CompSeq(G) is halting by GLIB_000:def 56;
     now let m be Nat; assume
    A12: PCS.m = PCS.(m+1);
        set Gm = PCS.m, Gm1 = PCS.(m+1);
         now assume m < n;
        then A13: m+1 <= n by NAT_1:13;
             n+0 < card RFS by A1,XREAL_1:10;
        then A14: m+1 < card RFS by A13,XXREAL_0:2;
        m in NAT by ORDINAL1:def 13;
        then
        A15: card Gm.labeledV() = min(m+1, card RFS) by Lm15
                              .= m+1 by A14,XXREAL_0:def 8;
        A16: m+1+1 <= card RFS by A14,NAT_1:13;
             card Gm.labeledV() = min(m+1+1,card RFS) by A12,Lm15
                              .= m+1+1 by A16,XXREAL_0:def 8;
            hence contradiction by A15;
        end;
        hence n <= m;
    end;
    hence PCS.Lifespan() + 1 = card RFS by A1,A10,A11,GLIB_000:def 57;
end;

Lm17:
  for G1 being finite real-weighted WGraph, n being Element of NAT,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).n).labeledV(),
                                      (PRIM:CompSeq(G1).n).labeledE()
  holds G2 is Tree-like
proof
    let G1 be finite real-weighted WGraph;
    set PCS = PRIM:CompSeq(G1);
    defpred P[Element of NAT] means
       for G2 being inducedSubgraph of G1,(PCS.$1).labeledV(),
                                           (PCS.$1).labeledE()
         holds G2 is Tree-like;
    set G0 = PCS.0, src = choose the_Vertices_of G1;
     G0 = PRIM:Init(G1) by Def15;
then A1: G0.labeledV() = {src} & G0.labeledE() = {} by Lm5;
     now let G2 be inducedSubgraph of G1,G0.labeledV(),G0.labeledE();
        reconsider G2'=G2 as inducedSubgraph of G1,{src},{} by A1;
         G2' is Tree-like;
        hence G2 is Tree-like;
    end;
then A2: P[0];
     now let n be Element of NAT; assume
    A3: P[n];
        set Gn = PCS.n, Gn1 = PCS.(n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    A4: Gn1 = PRIM:Step(Gn) by Def15;
        consider G3 being inducedSubgraph of G1,Gn.labeledV(),Gn.labeledE();
    A5: G3 is Tree-like by A3;
    A6: Gn.labeledV() is non empty Subset of the_Vertices_of G1 &
        Gn.labeledE() c= G1.edgesBetween(Gn.labeledV()) by Lm9;
    then A7: the_Vertices_of G3 = Gn.labeledV() &
        the_Edges_of G3 = Gn.labeledE() by GLIB_000:def 39;
         Gn == G1 by Lm8;
    then A8: the_Source_of Gn = the_Source_of G1 &
        the_Target_of Gn = the_Target_of G1 by GLIB_000:def 36;
         now let G2 be inducedSubgraph of G1,Gn1.labeledV(),Gn1.labeledE();
             Gn1.labeledV() is non empty Subset of the_Vertices_of G1 &
            Gn1.labeledE()c=G1.edgesBetween(Gn1.labeledV()) by Lm9;
        then A9: the_Vertices_of G2 = Gn1.labeledV() &
            the_Edges_of G2 = Gn1.labeledE() by GLIB_000:def 39;
            then the_Vertices_of G3 c= the_Vertices_of G2 &
            the_Edges_of G3 c= the_Edges_of G2 by A4,A7,Lm7;
            then reconsider G3'=G3 as Subgraph of G2 by GLIB_000:47;
            A10: G3.order() = G3.size() + 1 by A5,GLIB_002:46;
             now per cases;
            suppose Next = {};
                then Gn = Gn1 by A4,Def14;
                hence G2 is Tree-like by A3;
                end;
            suppose
            A11: Next <> {};
                then consider v being Vertex of Gn such that
            A12: not v in Gn.labeledV() &
                Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by A4,Lm6;
                set GnV = Gn.labeledV(), GnVg = the_Vertices_of Gn \ GnV;
            A13: e SJoins GnV, GnVg, Gn by A11,Def12;
            then A14: e in the_Edges_of Gn by GLIB_000:def 17;
                 now assume e in Gn.labeledE();
                    then (the_Source_of Gn).e in GnV &
                      (the_Target_of Gn).e in GnV by A6,A8,GLIB_000:34;
                    then not (the_Source_of Gn).e in GnVg &
                    not (the_Target_of Gn).e in GnVg by XBOOLE_0:def 4;
                    hence contradiction by A13,GLIB_000:def 17;
                end;
                then A15: card Gn.labelEdge(e,1).labeledE() =
                card Gn.labeledE() + 1 by A14,GLIB_003:54;
                 Gn == Gn.labelEdge(e,1) by GLIB_003:41;
            then A16: the_Vertices_of Gn = the_Vertices_of Gn.labelEdge(e,1)
                  by GLIB_000:def 36;
                 Gn.labeledV() = Gn.labelEdge(e,1).labeledV()
                  by GLIB_003:63;
                then card Gn1.labeledV() = card Gn.labeledV() + 1
                  by A12,A16,GLIB_003:61;
            then G2.order() = G2.size() + 1 by A7,A9,A10,A12,A15,GLIB_003:56;
                hence G2 is Tree-like by GLIB_002:47;
                end;
            end;
            hence G2 is Tree-like;
        end;
        hence P[n+1];
    end;
then A17: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A17);
    hence thesis;
end;

Lm18:
  for G being finite connected real-weighted WGraph
    holds PRIM:MST(G).labeledV() = the_Vertices_of G
proof
    let G be finite connected real-weighted WGraph;
    set M = PRIM:MST(G), PCS = PRIM:CompSeq(G), V = M.labeledV();
    set src = choose the_Vertices_of G, RFS = G.reachableFrom(src);

     PCS.Lifespan() + 1 = card RFS by Lm16;
then A1: card V = min(card RFS,card RFS) by Lm15;
A2: V c= RFS by Lm12;
     now assume V <> RFS;
        then V c< RFS by A2,XBOOLE_0:def 8;
        hence contradiction by A1,CARD_2:67;
    end;
    hence thesis by GLIB_002:16;
end;

registration let G be finite connected real-weighted WGraph;
  cluster spanning Tree-like WSubgraph of G;
  existence
  proof
    set PCS = PRIM:CompSeq(G), n = PCS.Lifespan();
    consider IT being inducedWSubgraph of G,(PCS.n).labeledV(),
                                            (PCS.n).labeledE();
    take IT;
     (PCS.n).labeledV() is non empty Subset of the_Vertices_of G &
    (PCS.n).labeledE() c= G.edgesBetween((PCS.n).labeledV())
      by Lm9;
then A1: the_Vertices_of IT = (PCS.n).labeledV() by GLIB_000:def 39;
     PRIM:MST(G) = PCS.n;
    then (PCS.n).labeledV() = the_Vertices_of G by Lm18;
    hence IT is spanning by A1,GLIB_000:def 35;
    thus IT is Tree-like by Lm17;
  end;
end;

definition let G1 be finite connected real-weighted WGraph,
               G2 be spanning Tree-like WSubgraph of G1;
  attr G2 is min-cost means :Def17: ::dWGMINCOST
    for G3 being spanning Tree-like WSubgraph of G1 holds
       G2.cost() <= G3.cost();
end;

registration let G1 be finite connected real-weighted WGraph;
  cluster min-cost (spanning Tree-like WSubgraph of G1);
  existence
  proof
    set X = {G2 where G2 is Element of G1.allWSubgraphs() :
             G2 is spanning Tree-like WSubgraph of G1};
     now let x be set; assume x in X;
      then consider G2 being Element of G1.allWSubgraphs() such that
    A1: x = G2 & G2 is spanning Tree-like WSubgraph of G1;
        thus x in G1.allWSubgraphs() by A1;
    end;
    then reconsider X as finite Subset of G1.allWSubgraphs()
      by FINSET_1:13,TARSKI:def 3;
    consider GT being spanning Tree-like WSubgraph of G1;
    set G3 = GT.strict(WGraphSelectors);
A2: G3 == GT & the_Weight_of G3 = the_Weight_of GT by Lm2;
    then reconsider G3 as WSubgraph of G1 by GLIB_003:15;
     the_Vertices_of G3 = the_Vertices_of GT by A2,GLIB_000:def 36
                      .= the_Vertices_of G1 by GLIB_000:def 35;
    then reconsider G3 as spanning Tree-like WSubgraph of G1
      by A2,GLIB_000:def 35,GLIB_002:48;
     dom G3 = WGraphSelectors by Lm3;
    then G3 in G1.allWSubgraphs() by Def10;
    then G3 in X;
    then reconsider X as finite non empty Subset of G1.allWSubgraphs();
    deffunc F(finite real-weighted WGraph) = $1.cost();
    consider x being Element of X such that
A3: for y being Element of X holds F(x) <= F(y) from GRAPH_5:sch 2;
     x in X;
    then consider G2 being Element of G1.allWSubgraphs() such that
A4: x = G2 & G2 is spanning Tree-like WSubgraph of G1;
    reconsider x as spanning Tree-like WSubgraph of G1 by A4;
    take x;
     now let GT be spanning Tree-like WSubgraph of G1;
        set G3 = GT.strict(WGraphSelectors);
    A5: G3 == GT & the_Weight_of G3 = the_Weight_of GT by Lm2;
        then reconsider G3 as WSubgraph of G1 by GLIB_003:15;
         the_Vertices_of G3 = the_Vertices_of GT by A5,GLIB_000:def 36
                          .= the_Vertices_of G1 by GLIB_000:def 35;
        then reconsider G3 as spanning Tree-like WSubgraph of G1
          by A5,GLIB_000:def 35,GLIB_002:48;
         dom G3 = WGraphSelectors by Lm3;
        then G3 in G1.allWSubgraphs() by Def10;
        then G3 in X;
    then x.cost() <= G3.cost() by A3;
        hence x.cost() <= GT.cost() by A5,GLIB_000:def 36;
    end;
    hence x is min-cost by Def17;
  end;
end;

definition let G be finite connected real-weighted WGraph;
  mode minimumSpanningTree of G is
       min-cost (spanning Tree-like WSubgraph of G);
end;

begin :: Prim's Algorithm Theorems

theorem ::tMST01
   for G1,G2 being finite connected real-weighted WGraph,
      G3 being WSubgraph of G1
   st G3 is minimumSpanningTree of G1 &
      G1 == G2 & the_Weight_of G1 = the_Weight_of G2
holds G3 is minimumSpanningTree of G2
proof
    let G1,G2 be finite connected real-weighted WGraph, G3 be WSubgraph of G1;
    assume
A1: G3 is minimumSpanningTree of G1 &
    G1 == G2 & the_Weight_of G1 = the_Weight_of G2;
    set G3' = G3;
    reconsider G3' as Tree-like WSubgraph of G2 by A1,GLIB_003:17;
     the_Vertices_of G3 = the_Vertices_of G1 by A1,GLIB_000:def 35
                      .= the_Vertices_of G2 by A1,GLIB_000:def 36;
    then reconsider G3' as spanning Tree-like WSubgraph of G2 by
GLIB_000:def 35;
     now let G be spanning Tree-like WSubgraph of G2;
        reconsider G'=G as Tree-like WSubgraph of G1 by A1,GLIB_003:17;
         the_Vertices_of G = the_Vertices_of G2 by GLIB_000:def 35
                         .= the_Vertices_of G1 by A1,GLIB_000:def 36;
        then G' is spanning by GLIB_000:def 35;
        hence G3.cost() <= G.cost() by A1,Def17;
    end;
    then G3' is min-cost by Def17;
    hence thesis;
end;

theorem Th36: ::tMST02
  for G being finite connected real-weighted WGraph,
    G1 being minimumSpanningTree of G, G2 being WGraph
   st G1 == G2 & the_Weight_of G1 = the_Weight_of G2 holds
   G2 is minimumSpanningTree of G
proof
    let G be finite connected real-weighted WGraph,
       G1 be minimumSpanningTree of G, G2 be WGraph; assume
A1: G1 == G2 & the_Weight_of G1 = the_Weight_of G2;
    then reconsider G2'=G2 as WSubgraph of G by GLIB_003:15;
     the_Vertices_of G2 = the_Vertices_of G1 by A1,GLIB_000:def 36
                      .= the_Vertices_of G by GLIB_000:def 35;
    then reconsider G2' as spanning Tree-like WSubgraph of G
      by A1,GLIB_000:def 35,GLIB_002:48;
     now let G3 be spanning Tree-like WSubgraph of G;
     G1.cost() <= G3.cost() by Def17;
        hence G2'.cost() <= G3.cost() by A1,GLIB_000:def 36;
    end;
    hence thesis by Def17;
end;

theorem ::tPRIMINIT01
   for G being real-weighted WGraph holds
    G == PRIM:Init(G) &
    the_Weight_of G = the_Weight_of PRIM:Init(G) &
    the_ELabel_of PRIM:Init(G) = {} &
    the_VLabel_of PRIM:Init(G) = (choose the_Vertices_of G).-->1
      by Lm4;

theorem ::tPRIMINIT02
   for G being real-weighted WGraph holds
    PRIM:Init(G).labeledV() = {choose the_Vertices_of G} &
    PRIM:Init(G).labeledE() = {} by Lm5;

theorem ::lPRIMSTEP02
   for G being real-WEV WEVGraph st PRIM:NextBestEdges(G) <> {} holds
     ex v being Vertex of G st not v in G.labeledV() &
     PRIM:Step(G) = G.labelEdge(choose PRIM:NextBestEdges(G),1)
                     .labelVertex(v,1) by Lm6;

theorem ::tPRIMSTEP01
   for G being real-WEV WEVGraph holds
    G == PRIM:Step(G) & the_Weight_of G  = the_Weight_of PRIM:Step(G) &
    G.labeledE() c= PRIM:Step(G).labeledE() &
    G.labeledV() c= PRIM:Step(G).labeledV() by Lm7;

theorem ::tPRIMCS03
   for G being finite real-weighted WGraph, n being Element of NAT holds
     G == PRIM:CompSeq(G).n &
     the_Weight_of (PRIM:CompSeq(G).n) = the_Weight_of G by Lm8;

theorem ::tPRIMCS05
   for G being finite real-weighted WGraph, n being Element of NAT holds
   (PRIM:CompSeq(G).n).labeledV() is non empty Subset of the_Vertices_of G &
   (PRIM:CompSeq(G).n).labeledE() c=
     G.edgesBetween((PRIM:CompSeq(G).n).labeledV()) by Lm9;

theorem ::tPRIMCS02
   for G1 being finite real-weighted WGraph, n being Element of NAT,
      G2 being inducedSubgraph of G1,(PRIM:CompSeq(G1).n).labeledV(),
                                     (PRIM:CompSeq(G1).n).labeledE()
  holds G2 is connected;

theorem ::tPRIMCS04
   for G1 being finite real-weighted WGraph, n being Element of NAT,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).n).labeledV()
    holds G2 is connected;

theorem ::tPRIMCS08
   for G being finite real-weighted WGraph, n being Element of NAT holds
    (PRIM:CompSeq(G).n).labeledV() c=
      G.reachableFrom(choose the_Vertices_of G) by Lm12;

theorem ::tPRIMCS13
   for G being finite real-weighted WGraph, i,j being Element of NAT
  st i <= j holds
    (PRIM:CompSeq(G).i).labeledV() c=
    (PRIM:CompSeq(G).j).labeledV() &
    (PRIM:CompSeq(G).i).labeledE() c=
    (PRIM:CompSeq(G).j).labeledE() by Lm13;

theorem ::tPRIMCS07
     for G being finite real-weighted WGraph, n being Element of NAT holds
      PRIM:NextBestEdges(PRIM:CompSeq(G).n) = {} iff
   (PRIM:CompSeq(G).n).labeledV() =
     G.reachableFrom(choose the_Vertices_of G) by Lm14;

theorem ::tPRIMCS06
   for G being finite real-weighted WGraph, n being Element of NAT holds
    card (PRIM:CompSeq(G).n).labeledV() =
      min(n+1, card(G.reachableFrom(choose the_Vertices_of G))) by Lm15;

theorem ::tPRIMCS09
   for G being finite real-weighted WGraph holds
    PRIM:CompSeq(G) is halting & PRIM:CompSeq(G).Lifespan() + 1 =
      card G.reachableFrom(choose the_Vertices_of G) by Lm16;

theorem ::tPRIMCS11
   for G1 being finite real-weighted WGraph, n being Element of NAT,
      G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).n).labeledV(),
                                      (PRIM:CompSeq(G1).n).labeledE()
  holds G2 is Tree-like by Lm17;

theorem ::tPRIMMST02
   for G being finite connected real-weighted WGraph
    holds PRIM:MST(G).labeledV() = the_Vertices_of G by Lm18;

theorem Th52: ::tPRIMMST03
  for G being finite connected real-weighted WGraph, n being Nat holds
   (PRIM:CompSeq(G).n).labeledE() c= PRIM:MST(G).labeledE()
proof
    let G be finite connected real-weighted WGraph, n be Nat;
    set PCS = PRIM:CompSeq(G), PMST = PRIM:MST(G);
    defpred P[Nat] means
      (PCS.(PCS.Lifespan()+$1)) = PRIM:MST(G);
A1: P[0];
A2: now let n be Nat; assume
    A3: P[n];
        set off = PCS.Lifespan();
        set Gn = PCS.(off+n), Gn1 = PCS.(off+n+1);
        set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    A4: Gn1 = PRIM:Step(Gn) by Def15;
    A5: Gn.labeledV() = the_Vertices_of G by A3,Lm18;
         now assume Next <> {};
            then consider v being Vertex of Gn such that
        A6: not v in Gn.labeledV() &
            Gn1 = Gn.labelEdge(e,1).labelVertex(v,1) by A4,Lm6;
             Gn == G by Lm8;
            then the_Vertices_of G = the_Vertices_of Gn by GLIB_000:def 36;
            hence contradiction by A5,A6;
        end;
        hence P[n+1] by A3,A4,Def14;
    end;
A7: for n being Nat holds P[n] from NAT_1:sch 2(A1,A2);
     now per cases;
    suppose n <= PCS.Lifespan();
        hence thesis by Lm13;
        end;
    suppose PCS.Lifespan() < n;
        then consider k being Nat such that
    A8: n = PCS.Lifespan() + k by NAT_1:10;
     k in NAT by ORDINAL1:def 13;
    hence thesis by A7,A8;
        end;
    end;
    hence thesis;
end;

theorem ::tPRIMMST04
   for G1 being finite connected real-weighted WGraph,
      G2 being inducedWSubgraph of G1, PRIM:MST(G1).labeledV(),
                                       PRIM:MST(G1).labeledE() holds
      G2 is minimumSpanningTree of G1
proof
    let G1 be finite connected real-weighted WGraph; set PMST = PRIM:MST(G1);
    let G2 be inducedWSubgraph of G1, PMST.labeledV(), PMST.labeledE();
    set PCS = PRIM:CompSeq(G1);
     PMST == G1 & the_Weight_of G1 = the_Weight_of PMST by Lm8;
then A1: the_Edges_of G1 = the_Edges_of PMST by GLIB_000:def 36;
A2: PMST.labeledV() = the_Vertices_of G1 by Lm18;
     PMST.labeledE() c= the_Edges_of G1 by A1;
then A3: PMST.labeledE() c= G1.edgesBetween(PMST.labeledV())
      by A2,GLIB_000:37;
     PMST.labeledV() c= the_Vertices_of G1 by Lm18;
then A4: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 = PMST.labeledE() by A2,A3,GLIB_000:def 39;
then A5: G2 is Tree-like & G2 is spanning by Lm17,GLIB_000:def 35;
    reconsider G2'=G2 as Tree-like _Graph by Lm17;
     now assume
    A6: not G2 is minimumSpanningTree of G1;
        set X = {x where x is Element of G1.allWSubgraphs() :
                 x is minimumSpanningTree of G1};
         now let x be set; assume x in X;
            then consider G2 being Element of G1.allWSubgraphs() such that
        A7: x = G2 & G2 is minimumSpanningTree of G1;
            thus x in G1.allWSubgraphs() by A7;
        end;
        then reconsider X as finite Subset of G1.allWSubgraphs()
          by FINSET_1:13,TARSKI:def 3;
         now consider M being minimumSpanningTree of G1;
            set M' = M.strict(WGraphSelectors);
             M' == M & the_Weight_of M' = the_Weight_of M by Lm2;
            then reconsider M' as minimumSpanningTree of G1 by Th36;
             dom M' = WGraphSelectors by Lm3;
            then M' in G1.allWSubgraphs() by Def10;
            then M' in X;
            hence X <> {};
        end;
        then reconsider X as non empty finite Subset of G1.allWSubgraphs();
        defpred Z[finite _Graph, Element of NAT] means
          not (PCS.($2+1)).labeledE() c= the_Edges_of $1 &
          for n being Element of NAT st n <= $2 holds
            (PCS.n).labeledE() c= the_Edges_of $1;
        defpred P[finite _Graph, finite _Graph] means
           card (the_Edges_of $1 /\ the_Edges_of G2) >
           card (the_Edges_of $2 /\ the_Edges_of G2) or
          (card (the_Edges_of $1 /\ the_Edges_of G2) =
           card (the_Edges_of $2 /\ the_Edges_of G2) &
           for k1,k2 being Element of NAT st Z[$1,k1] & Z[$2,k2]
           holds k1 >= k2);
    A8: now let G be Element of X;
             G in X;
            then consider G' being Element of G1.allWSubgraphs() such that
        A9: G = G' & G' is minimumSpanningTree of G1;
            reconsider G' = G as minimumSpanningTree of G1 by A9;
        A10: the_Vertices_of G2 = the_Vertices_of G' by A4,GLIB_000:def 35;
        A11: now assume
            A12: the_Edges_of G2 = the_Edges_of G';
            then A13: G2 == G' by A10,GLIB_000:89;
                 the_Weight_of G2 = (the_Weight_of G1) | the_Edges_of G2
                                   by GLIB_003:def 10
                                .= the_Weight_of G' by A12,GLIB_003:def 10;
                hence contradiction by A6,A13,Th36;
            end;
            defpred P4[Nat] means
             not (PCS.$1).labeledE()c= the_Edges_of G';
             now assume the_Edges_of G2 c= the_Edges_of G';
                then the_Edges_of G2 c< the_Edges_of G' by A11,XBOOLE_0:def 8;
                then G2.size() < card the_Edges_of G' by CARD_2:67;
                then G2.size() + 1 < G'.size() + 1 by XREAL_1:10;
            then A14: G2.order() < G'.size() + 1 by A5,GLIB_002:46;
                 G2.order() = G'.order() by A4,GLIB_000:def 35;
                hence contradiction by A14,GLIB_002:46;
            end;
        then A15: ex n being Nat st P4[n] by A4;
            consider k3 being Nat such that
        A16: P4[k3] & for n being Nat st P4[n] holds k3 <= n
              from NAT_1:sch 5(A15);
             now assume k3 = 0;
            then A17: not PRIM:Init(G1).labeledE() c= the_Edges_of G' by A16,
Def15;
                 the_ELabel_of PRIM:Init(G1) = {} by Lm4;
                hence contradiction by A17,RELAT_1:60,XBOOLE_1:2;
            end; then consider k2 being Nat such that
        A18: k2 + 1 = k3 by NAT_1:6;
        reconsider k2 as Element of NAT by ORDINAL1:def 13;
             k2 + 1 - 1 < k3 - 0 by A18,REAL_1:92;
        then A19: (PCS.k2).labeledE() c= the_Edges_of G' by A16;
             now let n be Element of NAT; assume n <= k2;
             then (PCS.n).labeledE() c= (PCS.k2).labeledE() by Lm13;
                hence (PCS.n).labeledE() c= the_Edges_of G'
                  by A19,XBOOLE_1:1;
            end;
            hence ex k1 being Element of NAT st Z[G,k1] by A16,A18;
        end;
    A20: now let G be Element of X, k1,k2 be Element of NAT;
             G in X;
           then consider G' being Element of G1.allWSubgraphs() such that
        A21: G = G' & G' is minimumSpanningTree of G1;
            reconsider G' = G as minimumSpanningTree of G1 by A21; assume
             Z[G,k1] & Z[G,k2];
            then k1+1 > k2 & k2+1 > k1;
            then k1 >= k2 & k2 >= k1 by NAT_1:13;
            hence k1 = k2 by XXREAL_0:1;
        end;
    A22: X is finite & X <> {} & X c= X;
         now let x,y be Element of X;
             x in X;
            then consider x' being WSubgraph of G1 such that
        A23: x' = x & dom x' = WGraphSelectors by Def10;
             y in X;
            then consider y' being WSubgraph of G1 such that
        A24: y' = y & dom y' = WGraphSelectors by Def10;
            set CX = card (the_Edges_of x' /\ the_Edges_of G2);
            set CY = card (the_Edges_of y' /\ the_Edges_of G2);
             now per cases by REAL_1:def 5;
            suppose CX < CY;
                hence P[x,y] or P[y,x] by A23,A24; end;
            suppose
            A25: CY = CX;
                consider k1 being Element of NAT such that
            A26: Z[x,k1] by A8;
                consider k2 being Element of NAT such that
            A27: Z[y,k2] by A8;
                 now per cases;
                suppose
                A28: k1 >= k2;
                     now let z1,z2 be Element of NAT; assume Z[x,z1] & Z[y,z2]
;
                    then z1 = k1 & z2 = k2 by A20,A26,A27;
                        hence z1 >= z2 by A28;
                    end;
                    hence P[x,y] or P[y,x] by A23,A24,A25; end;
                suppose
                A29: k1 < k2;
                     now let z1,z2 be Element of NAT; assume Z[x,z1] & Z[y,z2]
;
                    then z1 = k1 & z2 = k2 by A20,A26,A27;
                        hence z1 <= z2 by A29;
                    end;
                    hence P[x,y] or P[y,x] by A23,A24,A25; end;
                end;
                hence P[x,y] or P[y,x]; end;
            suppose CX > CY;
                hence P[x,y] or P[y,x] by A23,A24; end;
            end;
            hence P[x,y] or P[y,x];
        end;
    then A30: for x,y being Element of X holds P[x,y] or P[y,x];
         now let x,y,z be Element of X; assume
        A31: P[x,y] & P[y,z];
             x in X;
            then consider x' being WSubgraph of G1 such that
        A32: x' = x & dom x' = WGraphSelectors by Def10;
             y in X;
            then consider y' being WSubgraph of G1 such that
        A33: y' = y & dom y' = WGraphSelectors by Def10;
             z in X;
            then consider z' being WSubgraph of G1 such that
        A34: z' = z & dom z' = WGraphSelectors by Def10;
            set CX = card (the_Edges_of x' /\ the_Edges_of G2);
            set CY = card (the_Edges_of y' /\ the_Edges_of G2);
            set CZ = card (the_Edges_of z' /\ the_Edges_of G2);
             now per cases by A31,A32,A33;
            suppose
            A35: CX > CY;
                 now per cases by A31,A33,A34;
                suppose CY > CZ;
                    hence P[x,z] by A32,A34,A35,XXREAL_0:2; end;
                suppose CY = CZ &
                    for ky,kz being Element of NAT st Z[y',ky] & Z[z',kz]
                    holds ky >= kz;
                    hence P[x,z] by A32,A34,A35; end;
                end;
                hence P[x,z]; end;
            suppose
            A36: CX = CY &
                for kx,ky being Element of NAT st Z[x',kx] & Z[y',ky]
                holds kx >= ky;
                 now per cases by A31,A33,A34;
                suppose CY > CZ;
                    hence P[x,z] by A32,A34,A36; end;
                suppose
                A37: CY = CZ &
                    for ky,kz being Element of NAT st Z[y',ky] & Z[z',kz]
                    holds ky >= kz;
                    consider zx being Element of NAT;
                    consider zy being Element of NAT such that
                A38: Z[y,zy] by A8;
                    consider zz being Element of NAT;
                     now let kx,kz be Element of NAT; assume
                         Z[x',kx] & Z[z',kz];
                        then kx >= zy & zy >= kz by A33,A36,A37,A38;
                        hence kx >= kz by XXREAL_0:2;
                    end;
                    hence P[x,z] by A32,A34,A36,A37; end;
                end;
                hence P[x,z]; end;
            end;
            hence P[x,z];
        end;
    then A39: for x,y,z being Element of X st P[x,y] & P[y,z]
          holds P[x,z];
        consider M being Element of X such that
    A40: M in X & for y being Element of X
          st y in X holds P[M,y] from CQC_SIM1:sch 4(A22,A30,A39);
        consider x being Element of G1.allWSubgraphs() such that
    A41: M = x & x is minimumSpanningTree of G1 by A40;
        reconsider M as minimumSpanningTree of G1 by A41;
    A42: the_Vertices_of G2 = the_Vertices_of M by A4,GLIB_000:def 35;
    A43: now assume
        A44: the_Edges_of G2 = the_Edges_of M;
        then A45: G2 == M by A42,GLIB_000:89;
             the_Weight_of G2 = (the_Weight_of G1) | the_Edges_of G2
                                 by GLIB_003:def 10
                            .= the_Weight_of M by A44,GLIB_003:def 10;
            hence contradiction by A6,A45,Th36;
        end;
        defpred P2[Nat] means
         not (PCS.$1).labeledE() c= the_Edges_of M;
         now assume the_Edges_of G2 c= the_Edges_of M;
            then the_Edges_of G2 c< the_Edges_of M by A43,XBOOLE_0:def 8;
            then G2.size() < card the_Edges_of M by CARD_2:67;
            then G2.size() + 1 < M.size() + 1 by XREAL_1:10;
        then A46: G2.order() < M.size() + 1 by A5,GLIB_002:46;
             G2.order() = M.order() by A4,GLIB_000:def 35;
            hence contradiction by A46,GLIB_002:46;
        end;
    then A47: ex k being Nat st P2[k] by A4;
        consider k being Nat such that
    A48: P2[k] & for n being Nat st P2[n] holds k <= n
    from NAT_1:sch 5(A47);
         now assume k = 0;
        then A49: not PRIM:Init(G1).labeledE() c= the_Edges_of M by A48,Def15;
             the_ELabel_of PRIM:Init(G1) = {} by Lm4;
            hence contradiction by A49,RELAT_1:60,XBOOLE_1:2;
        end;
        then consider k1o being Nat such that
    A50: k = k1o + 1 by NAT_1:6;
    reconsider k1o as Element of NAT by ORDINAL1:def 13;
        set Gk1b = PCS.k1o, Gk = PCS.k;
    A51: Gk = PRIM:Step(Gk1b) by A50,Def15;
         k1o + 1 - 1 < k - 0 by A50,REAL_1:92;
    then A52: Gk1b.labeledE() c= the_Edges_of M by A48;
        set Next = PRIM:NextBestEdges(Gk1b), ep = choose Next;
    A53: Next <> {} by A48,A51,A52,Def14;
    then A54: ep in Next;
        consider v being Vertex of Gk1b such that
    A55: not v in Gk1b.labeledV() &
        Gk = Gk1b.labelEdge(ep,1).labelVertex(v,1) by A51,A53,Lm6;
    A56: Gk.labeledE() = Gk1b.labelEdge(ep,1).labeledE() by A55,GLIB_003:56
                     .= Gk1b.labeledE() \/ {ep} by A54,GLIB_003:52;
    then A57: not {ep} c= the_Edges_of M by A48,A52,XBOOLE_1:8;
    then A58: not ep in the_Edges_of M by ZFMISC_1:37;
        set V = Gk1b.labeledV();
    A59: Gk1b == G1 by Lm8;
    then A60: the_Vertices_of Gk1b = the_Vertices_of G1 by GLIB_000:def 36
                            .= the_Vertices_of M by GLIB_000:def 35;
        then reconsider V as non empty Subset of the_Vertices_of M by Lm9;
        consider Mep being inducedWSubgraph of G1,the_Vertices_of G1,
                                                 the_Edges_of M \/ {ep};
        set v1 = (the_Source_of Mep).ep, v2 = (the_Target_of Mep).ep;
         ep in the_Edges_of Gk1b by A54;
        then ep in the_Edges_of G1 by A59,GLIB_000:def 36;
        then {ep} c= the_Edges_of G1 & the_Edges_of M c= the_Edges_of G1
          by ZFMISC_1:37;
        then the_Edges_of M \/ {ep} c= the_Edges_of G1 by XBOOLE_1:8;
        then the_Vertices_of G1 c= the_Vertices_of G1 &
        the_Edges_of M \/ {ep} c= G1.edgesBetween(the_Vertices_of G1)
          by GLIB_000:37;
    then A61: the_Vertices_of Mep = the_Vertices_of G1 &
        the_Edges_of Mep = the_Edges_of M \/ {ep} by GLIB_000:def 39;
        then the_Vertices_of M c= the_Vertices_of Mep &
          the_Edges_of M c= the_Edges_of Mep by XBOOLE_1:7;
        then reconsider M'=M as connected Subgraph of Mep by GLIB_000:47;
         ep in {ep} by TARSKI:def 1;
    then A62: ep in the_Edges_of Mep by A61,XBOOLE_0:def 2;
         the_Vertices_of Mep = the_Vertices_of M by A61,GLIB_000:def 35;
        then reconsider v1,v2 as Vertex of M by A62,FUNCT_2:7;
        consider W being Walk of M' such that
    A63: W is_Walk_from v2,v1 by GLIB_002:def 1;
        consider PW being Path of W;
    A64: PW is_Walk_from v2,v1 by A63,GLIB_001:161;
    A65: PW.edges() c= the_Edges_of M;
        reconsider P=PW as Path of Mep by GLIB_001:176;
    A66: P.edges() c= the_Edges_of M by A65,GLIB_001:111;
    A67: P is_Walk_from v2,v1 by A64,GLIB_001:20;
         ep in {ep} by TARSKI:def 1;
    then A68: ep in Gk.labeledE() by A56,XBOOLE_0:def 2;
    A69: Gk.labeledE() c= PMST.labeledE() by Th52;
    then A70: {ep} /\ the_Edges_of G2 = {ep} by A4,A68,ZFMISC_1:52;
    A71: ep Joins v1,v2,Mep by A62,GLIB_000:def 15;
        then ep Joins v1,v2,G1 by GLIB_000:75;
    then A72: ep Joins v1,v2,G2' by A4,A68,A69,GLIB_000:76;
        then ((the_Source_of G2).ep = v1 & (the_Target_of G2).ep = v2) or
        ((the_Target_of G2).ep = v1 & (the_Source_of G2).ep = v2)
          by GLIB_000:def 15;
        then v1 <> v2 by A4,A68,A69,A72,GLIB_000:def 20;
        then v1 <> P.first() by A67,GLIB_001:def 23;
        then P.last() <> P.first() by A67,GLIB_001:def 23;
    then A73: P is open by GLIB_001:def 24;
    A74: ep Joins P.last(),v2,Mep by A67,A71,GLIB_001:def 23;
    A75: not ep in P.edges() by A57,A66,ZFMISC_1:37;
         now let n be odd Element of NAT; assume
        A76: 1 < n & n <= len P & P.n = v2;
             v2 = P.first() by A67,GLIB_001:def 23
              .= P.(2*0+1) by GLIB_001:def 6;
            then n = len P by A76,GLIB_001:def 28;
            then P.last() = v2 by A76,GLIB_001:def 7
                    .= P.first() by A67,GLIB_001:def 23;
        then A77: P is closed by GLIB_001:def 24;
            reconsider PM = P as Walk of M;
             PM is Path-like & PM is closed & PM is non trivial
              by A76,A77,GLIB_001:127,177;
            then PM is Cycle-like by GLIB_001:def 31;
            hence contradiction by GLIB_002:def 2;
        end;
    then A78: P.addEdge(ep) is Path-like by A73,A74,A75,GLIB_001:151;
        set C = P.addEdge(ep);
    A79: P.addEdge(ep) is non trivial by A74,GLIB_001:133;
         P.addEdge(ep) is_Walk_from v2,v2 by A67,A71,GLIB_001:67;
        then P.addEdge(ep) is closed by GLIB_001:120;
    then A80: C is Cycle-like by A78,A79,GLIB_001:def 31;
    A81: ep SJoins Gk1b.labeledV(), the_Vertices_of Gk1b \ Gk1b.labeledV(),Gk1b
          by A53,Def12;
         Gk1b == G1 by Lm8;
        then (the_Source_of Gk1b).ep=(the_Source_of G1).ep &
        (the_Target_of Gk1b).ep=(the_Target_of G1).ep by GLIB_000:def 36;
    then A82: (the_Source_of Gk1b).ep = v1 & (the_Target_of Gk1b).ep = v2
          by A62,GLIB_000:def 34;
    A83: v1 = P.(len P) & v2 = P.1 by A64,GLIB_001:18;
         now per cases by A81,A82,GLIB_000:def 17;
        suppose
        A84: v1 in Gk1b.labeledV() & v2 in the_Vertices_of Gk1b\Gk1b.labeledV()
;
            defpred P3[Nat] means
              $1 is odd & $1 <= len P & P.$1 in Gk1b.labeledV();
        A85: ex n being Nat st P3[n] by A83,A84;
            consider m being Nat such that
        A86: P3[m] & for n being Nat st P3[n] holds m <= n
        from NAT_1:sch 5(A85);
            reconsider m as odd Element of NAT by A86,ORDINAL1:def 13;
        A87: 1 <= m & m <= len P by A86,HEYTING3:1;
             m <> 1 by A83,A84,A86,XBOOLE_0:def 4;
            then 1 < m by A87,REAL_1:def 5;
            then 1+1 <= m by NAT_1:13;
            then reconsider m2k = m-2*1 as odd Element of NAT by INT_1:18;
        A88: m2k < m - 0 by REAL_1:92;
        then A89: m2k < len P by A86,XXREAL_0:2;
        then A90: not P.m2k in Gk1b.labeledV() by A86,A88;
        A91: m2k+2 = m;
            set em = P.(m2k+1); take em;
        A92: em in P.edges() by A89,GLIB_001:101;
             C.edges() = P.edges() \/ {ep} by A74,GLIB_001:112;
            hence em in C.edges() by A92,XBOOLE_0:def 2;
            consider i being even Element of NAT such that
        A93: 1 <= i & i <= len P & P.i = em by A92,GLIB_001:100;
             i in dom P by A93,FINSEQ_3:27;
        then A94: C.i = em by A74,A93,GLIB_001:66;
        A95: len C = len P + 2 by A74,GLIB_001:65;
        A96: C.(len P + 1) = ep by A74,GLIB_001:66;
             len P + 0 < len P + 1 by XREAL_1:10;
        then A97: i < len P + 1 by A93,XXREAL_0:2;
        A98: len P + 1 <= len P + 2 by XREAL_1:9;
             C is Trail-like by A78,GLIB_001:def 28;
            hence em <> ep by A93,A94,A95,A96,A97,A98,GLIB_001:139;
        A99: em Joins PW.m2k, PW.m, M by A89,A91,GLIB_001:def 3;
            then PW.m2k in the_Vertices_of M by GLIB_000:16;
            then PW.m2k in the_Vertices_of M\Gk1b.labeledV() by A90,
XBOOLE_0:def 4;
            hence em SJoins V, the_Vertices_of M \ V, M
              by A86,A99,GLIB_000:20; end;
        suppose
        A100: v2 in Gk1b.labeledV() & v1 in the_Vertices_of Gk1b\Gk1b
.labeledV();
            defpred P3[Nat] means
              $1 is odd & $1 <= len P &
              P.$1 in the_Vertices_of Gk1b\Gk1b.labeledV();
        A101: ex n being Nat st P3[n] by A83,A100;
            consider m being Nat such that
        A102: P3[m] & for n being Nat st P3[n] holds m <= n
        from NAT_1:sch 5(A101);
            reconsider m as odd Element of NAT by A102,ORDINAL1:def 13;
        A103: 1 <= m & m <= len P by A102,HEYTING3:1;
             m <> 1 by A83,A100,A102,XBOOLE_0:def 4;
            then 1 < m by A103,REAL_1:def 5;
            then 1+1 <= m by NAT_1:13;
            then reconsider m2k = m-2*1 as odd Element of NAT by INT_1:18;
        A104: m2k < m - 0 by REAL_1:92;
        then A105: m2k < len P by A102,XXREAL_0:2;
        A106: now assume
            A107: not P.m2k in Gk1b.labeledV();
                 P.m2k in the_Vertices_of Gk1b by A60,A105,GLIB_001:8;
                then P.m2k in the_Vertices_of Gk1b\Gk1b.labeledV()
                  by A107,XBOOLE_0:def 4;
                hence contradiction by A102,A104,A105;
            end;
        A108: m2k+2 = m;
            set em = P.(m2k+1); take em;
        A109: em in P.edges() by A105,GLIB_001:101;
             C.edges() = P.edges() \/ {ep} by A74,GLIB_001:112;
            hence em in C.edges() by A109,XBOOLE_0:def 2;
            consider i being even Element of NAT such that
        A110: 1 <= i & i <= len P & P.i = em by A109,GLIB_001:100;
             i in dom P by A110,FINSEQ_3:27;
        then A111: C.i = em by A74,A110,GLIB_001:66;
        A112: len C = len P + 2 by A74,GLIB_001:65;
        A113: C.(len P + 1) = ep by A74,GLIB_001:66;
             len P + 0 < len P + 1 by XREAL_1:10;
        then A114: i < len P + 1 by A110,XXREAL_0:2;
        A115: len P + 1 <= len P + 2 by XREAL_1:9;
             C is Trail-like by A78,GLIB_001:def 28;
            hence em <> ep by A110,A111,A112,A113,A114,A115,GLIB_001:139;
             em Joins PW.m2k, PW.m, M by A105,A108,GLIB_001:def 3;
            hence em SJoins V, the_Vertices_of M \ V, M
              by A60,A102,A106,GLIB_000:20; end;
        end;
        then consider em being set such that
    A116: em in C.edges() & em <> ep & em SJoins V, the_Vertices_of M \ V, M;
    A117: em SJoins V, the_Vertices_of Gk1b \ V, G1 by A60,A116,GLIB_000:75;
then em SJoins V, the_Vertices_of Gk1b \ V, Gk1b by A59,GLIB_000:91;
        then (the_Weight_of Gk1b).ep <= (the_Weight_of Gk1b).em by A53,Def12;
        then (the_Weight_of G1).ep <= (the_Weight_of Gk1b).em by Lm8;
    then A118: (the_Weight_of G1).ep <= (the_Weight_of G1).em by Lm8;
        consider M2 being weight-inheriting ([Weighted] removeEdge of Mep,em);
        reconsider M2 as WSubgraph of G1 by GLIB_003:16;
         the_Vertices_of M c= the_Vertices_of Mep &
          the_Edges_of M c= the_Edges_of Mep by A61,XBOOLE_1:7;
        then reconsider M'=M as connected Subgraph of Mep by GLIB_000:47;
         the_Vertices_of M' = the_Vertices_of Mep by A61,GLIB_000:def 35;
        then M' is spanning by GLIB_000:def 35;
        then Mep is connected by GLIB_002:23;
    then A119: M2 is connected by A80,A116,GLIB_002:5;
    A120: the_Edges_of M2 = the_Edges_of M \/ {ep} \{em} by A61,GLIB_000:54;
         now
         {em} c= the_Edges_of M \/ {ep} by A61,A116,ZFMISC_1:37;
        then A121: M2.size() = card (the_Edges_of M \/{ep})-card {em}
                         by A120,CARD_2:63
                      .= card (the_Edges_of M \/ {ep}) - 1 by CARD_1:79
                      .= card the_Edges_of M + 1 - 1 by A58,CARD_2:54
                      .= M.size();
             M2.order() = card the_Vertices_of G1 by A61,GLIB_000:56
                       .= M.order() by GLIB_000:def 35;
            hence M2.order() = M2.size() + 1 by A121,GLIB_002:46;
        end;
    then A122: M2 is Tree-like by A119,GLIB_002:47;
        set M2' = M2.strict(WGraphSelectors);
    A123: M2' == M2 & the_Weight_of M2' = the_Weight_of M2 by Lm2;
    then A124: the_Edges_of M2' = the_Edges_of M \/ {ep} \ {em} by A120,
GLIB_000:def 36;
        reconsider M2' as WSubgraph of G1 by A123,GLIB_003:15;
         now thus M2' is Tree-like by A122,A123,GLIB_002:48;
             the_Vertices_of M2' = the_Vertices_of M2 by A123,GLIB_000:def 36
                               .= the_Vertices_of G1 by A61,GLIB_000:56;
            hence M2' is spanning by GLIB_000:def 35;
        end;
        then reconsider M2' as spanning Tree-like WSubgraph of G1;
         now
        A125: G1.edgesBetween(the_Vertices_of G1) = the_Edges_of G1
              by GLIB_000:37;
        then A126: the_Edges_of M c= G1.edgesBetween(the_Vertices_of G1) &
            the_Vertices_of G1 c= the_Vertices_of G1;
        A127: the_Edges_of G1 = the_Edges_of Gk1b by A59,GLIB_000:def 36;
             the_Vertices_of G1 = the_Vertices_of M by GLIB_000:def 35;
            then M is inducedWSubgraph of G1,the_Vertices_of G1, the_Edges_of
M
              by A125,GLIB_000:def 39;
        then A128: Mep.cost() = M.cost() + (the_Weight_of G1).ep
              by A54,A58,A125,A126,A127,Th34;
             M2.cost() + (the_Weight_of Mep).em = Mep.cost() by A116,Th33;
        then A129: M2.cost() = Mep.cost() - (the_Weight_of Mep).em;
             the_Weight_of Mep = (the_Weight_of G1) | the_Edges_of Mep
              by GLIB_003:def 10;
        then M2.cost() = M.cost()+(the_Weight_of G1).ep
              - (the_Weight_of G1).em by A116,A128,A129,FUNCT_1:72;
            hence M2'.cost() = M.cost()+(the_Weight_of G1).ep
              - (the_Weight_of G1).em by A123,GLIB_000:def 36;
        end;
    then A130: M2'.cost() + (the_Weight_of G1).em - (the_Weight_of G1).em <=
          M.cost() + (the_Weight_of G1).ep - (the_Weight_of G1).ep
          by A118,REAL_1:92;
         now let G3 being spanning Tree-like WSubgraph of G1;
             M.cost() <= G3.cost() by Def17;
            hence M2'.cost() <= G3.cost() by A130,XXREAL_0:2;
        end;
        then reconsider M2' as minimumSpanningTree of G1 by Def17;
        set MG2' = the_Edges_of M2' /\ the_Edges_of G2;
        set MG2 = the_Edges_of M /\ the_Edges_of G2;
    A131: MG2' = ((the_Edges_of M \/ {ep}) /\ the_Edges_of G2) \
          {em} /\ the_Edges_of G2 by A124,XBOOLE_1:50;
         now assume MG2 /\ {ep} <> {};
            then consider x being set such that
        A132: x in MG2 /\ {ep} by XBOOLE_0:def 1;
             x in MG2 & x in {ep} by A132,XBOOLE_0:def 3;
            then x in the_Edges_of M & x = ep by TARSKI:def 1,XBOOLE_0:def 3;
            hence contradiction by A57,ZFMISC_1:37;
        end;
    then A133: MG2 misses {ep} by XBOOLE_0:def 7;
         dom M2' = WGraphSelectors by Lm3;
        then M2' in G1.allWSubgraphs() by Def10;
    then A134: M2' in X;
    A135: now thus not (PCS.(k1o+1)).labeledE() c= the_Edges_of M by A48,A50;
            let n be Element of NAT; assume n <= k1o;
            then (PCS.n).labeledE() c= Gk1b.labeledE() by Lm13;
            hence (PCS.n).labeledE() c= the_Edges_of M by A52,XBOOLE_1:1;
        end;
    A136: now assume
        A137: em in the_Edges_of G2;
        then A138: MG2'=((the_Edges_of M \/ {ep}) /\ the_Edges_of G2)\{em}
              by A131,ZFMISC_1:52;
             now let x be set; assume x in {em};
                then x = em by TARSKI:def 1;
                hence x in (the_Edges_of M \/ {ep}) /\ the_Edges_of G2
                  by A61,A116,A137,XBOOLE_0:def 3;
            end;
            then {em}c=(the_Edges_of M\/{ep})/\the_Edges_of G2 by TARSKI:def 3
;
        then A139: card MG2' = card (the_Edges_of Mep /\ the_Edges_of G2) -
                        card {em} by A61,A138,CARD_2:63
                     .= card (the_Edges_of Mep /\ the_Edges_of G2) - 1
                          by CARD_1:79
                     .= card (MG2 \/ {ep}) - 1 by A61,A70,XBOOLE_1:23
                     .= card MG2 + card {ep} - 1 by A133,CARD_2:53
                     .= card MG2 + 1 - 1 by CARD_1:79
                     .= card MG2;
            consider k2 being Element of NAT such that
        A140: Z[M2',k2] by A8,A134;
        A141: now set Vr = the_Vertices_of Gk1b \ V; assume
            A142: em in Gk1b.labeledE();
                 Gk1b.labeledE() c= G1.edgesBetween(Gk1b.labeledV())
                  by Lm9;
                then (the_Source_of G1).em in Gk1b.labeledV() &
                (the_Target_of G1).em in Gk1b.labeledV() by A142,GLIB_000:34;
then not (the_Source_of G1).em in Vr &
                  not (the_Target_of G1).em in Vr by XBOOLE_0:def 4;
                hence contradiction by A117,GLIB_000:def 17;
            end;
             now let x be set; assume
            A143: x in Gk.labeledE();
                 now per cases by A56,A143,XBOOLE_0:def 2;
                suppose
                A144: x in Gk1b.labeledE();
                then A145: x in the_Edges_of M \/ {ep} by A52,XBOOLE_0:def 2;
                     not x in {em} by A141,A144,TARSKI:def 1;
                    hence x in the_Edges_of M2' by A124,A145,XBOOLE_0:def 4;
end;
                suppose
                A146: x in {ep};
                then A147: x in the_Edges_of M \/ {ep} by XBOOLE_0:def 2;
                     x = ep by A146,TARSKI:def 1;
                    then not x in {em} by A116,TARSKI:def 1;
                    hence x in the_Edges_of M2' by A124,A147,XBOOLE_0:def 4;
end;
                end;
                hence x in the_Edges_of M2';
            end;
        then A148: Gk.labeledE() c= the_Edges_of M2' by TARSKI:def 3;
        A149: now assume k2 < k;
                then k2+1 <= k by NAT_1:13;
                then (PCS.(k2+1)).labeledE() c= Gk.labeledE() by Lm13;
                hence contradiction by A140,A148,XBOOLE_1:1;
            end;
        A150: k1o >= k2 by A40,A134,A135,A139,A140;
             k1o + 1 - 1 < k - 0 by A50,REAL_1:92;
            hence contradiction by A149,A150,XXREAL_0:2;
        end;
         now assume {em} /\ the_Edges_of G2 <> {};
            then consider x being set such that
        A151: x in {em} /\ the_Edges_of G2 by XBOOLE_0:def 1;
             x in {em} & x in the_Edges_of G2 by A151,XBOOLE_0:def 3;
            hence contradiction by A136,TARSKI:def 1;
        end;
    then A152: MG2' = MG2 \/ ({ep} /\ the_Edges_of G2) by A131,XBOOLE_1:23;
         now assume MG2 /\ {ep} <> {};
            then consider x being set such that
        A153: x in MG2 /\ {ep} by XBOOLE_0:def 1;
             x in MG2 & x in {ep} by A153,XBOOLE_0:def 3;
            then x in the_Edges_of M & x = ep by TARSKI:def 1,XBOOLE_0:def 3;
            hence contradiction by A57,ZFMISC_1:37;
        end;
        then MG2 misses {ep} by XBOOLE_0:def 7;
        then card MG2' = card MG2 + card {ep} by A70,A152,CARD_2:53
                 .= card MG2 + 1 by CARD_1:79;
        then card MG2 + 0 >= card MG2 + 1 by A40,A134;
        hence contradiction by XREAL_1:8;
    end;
    hence thesis;
end;
