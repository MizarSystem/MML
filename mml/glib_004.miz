:: Proof of Dijkstra's Shortest Path Algorithm & Prim's Minimum Spanning
:: Tree Algorithm
::  by Gilbert Lee and Piotr Rudnicki
:: Revised by Piotr Rudnicki, September 2008
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies ALGSEQ_1, AMI_1, ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSEQ_2, FINSET_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003, GLIB_004, GRAPH_1, MATRIX_2, MSAFREE2,
      NEWTON, PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, QUANTAL1, REALSET1,
      RELAT_1, RELAT_2, RLVECT_1, SQUARE_1, TARSKI, TREES_1, UPROOTS,
      MCART_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, ENUMSET1, CARD_1, NUMBERS, SUBSET_1,
      DOMAIN_1, MCART_1, XCMPLX_0, XXREAL_0, XREAL_0, REAL_1, RELAT_1,
      RELSET_1, PARTFUN1, FUNCT_1, FINSEQ_1, FINSEQ_2, SEQ_1, PBOOLE, FUNCT_2,
      RVSUM_1, ABIAN, ORDINAL1, POLYNOM1, UPROOTS, FINSET_1, NAT_1, FUNCOP_1,
      FUNCT_4, GLIB_000, GLIB_001, GLIB_002, GLIB_003, RFUNCT_3;
 constructors DOMAIN_1, BINOP_2, FINSOP_1, RVSUM_1, GRAPH_2, RFUNCT_3, UPROOTS,
      GLIB_002, GLIB_003, SEQ_1, RECDEF_1, XXREAL_2, RELSET_1, PBOOLE;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, PARTFUN1, FRAENKEL, FUNCT_1,
      ORDINAL1, FUNCOP_1, FINSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, CARD_1, UPROOTS,
      MEMBERED, GLIB_000, ABIAN, POLYNOM1, GLIB_001, GLIB_002, GLIB_003,
      VALUED_0, FUNCT_2, RELSET_1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, GLIB_000, GLIB_003, RVSUM_1, FUNCOP_1;
 theorems BAGORDER, CARD_1, CARD_2, FUNCOP_1, ENUMSET1, FINSEQ_1, FINSEQ_2,
      FINSEQ_3, FINSET_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003, HEYTING3, INT_1, JORDAN12, NAT_1, PARTFUN1,
      PBOOLE, POLYNOM1, RELAT_1, RVSUM_1, TARSKI, TREES_1, UPROOTS,
      XBOOLE_0, XBOOLE_1, XREAL_0, ZFMISC_1, XREAL_1, XXREAL_0, ORDINAL1,
      FINSOP_1, FUNCT_7, MCART_1, RELSET_1;
 schemes NAT_1, SUBSET_1, RECDEF_1, GRAPH_5, CQC_SIM1, PBOOLE;

begin :: Preliminaries

Tw0:
for F being Function, x,y being set
 holds dom(F+*(x.-->y)) = dom F \/ {x}
proof let F be Function, x,y be set;
  thus dom(F+*(x.-->y)) = dom F \/ dom(x.-->y) by FUNCT_4:def 1
          .= dom F \/ {x} by FUNCOP_1:19;
end;

Tw3:
for F being Function, x,y,z being set
  st z in dom (F+*(x.-->y)) & not z in dom F holds x = z
proof
  let F be Function, x,y,z be set such that
A: z in dom (F+*(x.-->y)) and
B: not z in dom F;
   dom (x.-->y) = {x} by FUNCOP_1:19;
   then z in dom F \/ {x} by A,FUNCT_4:def 1;
   then z in {x} by B,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th1: ::tSUPPORT01
  for f, g being Function holds support (f +* g) c= support f \/ support g
proof
  let f, g be Function;
  let a be set;
  assume a in support (f +* g);
  then
A1: (f +* g).a <> 0 by POLYNOM1:def 7;
  assume not a in support f \/ support g;
  then not a in support f & not a in support g by XBOOLE_0:def 3;
  then
A2: f.a = 0 & g.a = 0 by POLYNOM1:def 7;
  a in dom g or not a in dom g;
  hence contradiction by A1,A2,FUNCT_4:12,14;
end;

theorem Th2: ::tSUPPORT02
  for f being Function, x, y being set holds
  support (f +* (x.-->y)) c= support f \/ {x}
proof
  let f be Function, x, y be set;
  let a be set;
  assume a in support (f +* (x.-->y));
  then
A1: (f +* (x.-->y)).a <> 0 by POLYNOM1:def 7;
  per cases;
  suppose a = x;
    then a in {x} by TARSKI:def 1;
    hence thesis by XBOOLE_0:def 3;
  end;
  suppose a <> x;
    then (f +* (x.-->y)).a = f.a by FUNCT_4:88;
    then a in support f by A1,POLYNOM1:def 7;
    hence thesis by XBOOLE_0:def 3;
  end;
end;

theorem Th3: ::tRBAGSUM01
  for A,B being set, b being Rbag of A,
  b1 being Rbag of B, b2 being Rbag of A\B
  st b = b1 +* b2 holds Sum b = Sum b1 + Sum b2
proof
  let A, B be set, b be Rbag of A,
  b1 be Rbag of B, b2 be Rbag of A\B such that
A1: b = b1 +* b2;
  set B1 = (EmptyBag A) +* b1;
  set B2 = (EmptyBag A) +* b2;
A2a: support B1 c= (support EmptyBag A) \/ support b1 by Th1;
  dom b = dom b1 \/ dom b2 by A1,FUNCT_4:def 1;
  then dom b1 c= dom b by XBOOLE_1:7;
  then B c= dom b by PARTFUN1:def 4;
  then
A3: B c= A by PARTFUN1:def 4;
  dom B1 = (dom EmptyBag A) \/ dom b1 by FUNCT_4:def 1
    .= A \/ dom b1 by PARTFUN1:def 4
    .= A \/ B by PARTFUN1:def 4
    .= A by A3,XBOOLE_1:12;
  then reconsider B1 as Rbag of A by A2a,PARTFUN1:def 4,POLYNOM1:def 8
,RELAT_1:def 18;
A4a: support B2 c= (support EmptyBag A) \/ support b2 by Th1;
  dom B2 = (dom EmptyBag A) \/ dom b2 by FUNCT_4:def 1
    .= A \/ dom b2 by PARTFUN1:def 4
    .= A \/ (A\B) by PARTFUN1:def 4
    .= A by XBOOLE_1:12;
  then reconsider B2 as Rbag of A by A4a,PARTFUN1:def 4,POLYNOM1:def 8
,RELAT_1:def 18;
  consider f1 being FinSequence of REAL such that
A5: Sum b1 = Sum f1 and
A6: f1 = b1*canFS(support b1) by UPROOTS:def 3;
  consider F1 being FinSequence of REAL such that
A7: Sum B1 = Sum F1 and
A8: F1 = B1*canFS(support B1) by UPROOTS:def 3;
A9: rng canFS(support b1) = support b1 by FUNCT_2:def 3;
A10: support b1 c= dom b1 by POLYNOM1:41;
  then
A11: dom f1 = dom canFS(support b1) by A6,A9,RELAT_1:46;
A12: rng canFS(support B1) = support B1 by FUNCT_2:def 3;
  support B1 c= dom B1 by POLYNOM1:41;
  then
A13: dom F1 = dom canFS(support B1) by A8,A12,RELAT_1:46;
A14: now
    let x be set;
    hereby
      assume
A15:  x in support b1;
      then
A16:  b1.x <> 0 by POLYNOM1:def 7;
      support b1 c= dom b1 by POLYNOM1:41;
      then B1.x = b1.x by A15,FUNCT_4:14;
      hence x in support B1 by A16,POLYNOM1:def 7;
    end;
    assume
A17: x in support B1;
    then
A18: B1.x <> 0 by POLYNOM1:def 7;
    per cases;
    suppose not x in dom b1;
      then B1.x = (EmptyBag A).x by FUNCT_4:12
        .= 0 by POLYNOM1:56;
      hence x in support b1 by A17,POLYNOM1:def 7;
    end;
    suppose x in dom b1;
      then B1.x = b1.x by FUNCT_4:14;
      hence x in support b1 by A18,POLYNOM1:def 7;
    end;
  end;
  then
A19: support b1 = support B1 by TARSKI:2;
A20: dom f1 = dom F1 by A11,A13,A14,TARSKI:2;
  now
    let k be Nat such that
A21: k in dom f1;
A22: (canFS(support b1)).k in rng canFS(support b1) by A11,A21,FUNCT_1:12;
    thus f1.k = b1.((canFS(support b1)).k) by A6,A11,A21,FUNCT_1:23
      .= B1.((canFS(support b1)).k) by A9,A10,A22,FUNCT_4:14
      .= F1.k by A8,A11,A19,A21,FUNCT_1:23;
  end;
  then
A23: Sum B1 = Sum b1 by A5,A7,A20,FINSEQ_1:17;
  consider f2 being FinSequence of REAL such that
A24: Sum b2 = Sum f2 and
A25: f2 = b2*canFS(support b2) by UPROOTS:def 3;
  consider F2 being FinSequence of REAL such that
A26: Sum B2 = Sum F2 and
A27: F2 = B2*canFS(support B2) by UPROOTS:def 3;
A28: rng canFS(support b2) = support b2 by FUNCT_2:def 3;
A29: support b2 c= dom b2 by POLYNOM1:41;
  then
A30: dom f2 = dom canFS(support b2) by A25,A28,RELAT_1:46;
A31: rng canFS(support B2) = support B2 by FUNCT_2:def 3;
  support B2 c= dom B2 by POLYNOM1:41;
  then
A32: dom F2 = dom canFS(support B2) by A27,A31,RELAT_1:46;
  now
    let x be set;
    hereby
      assume
A33:  x in support b2;
      then
A34:  b2.x <> 0 by POLYNOM1:def 7;
      support b2 c= dom b2 by POLYNOM1:41;
      then B2.x = b2.x by A33,FUNCT_4:14;
      hence x in support B2 by A34,POLYNOM1:def 7;
    end;
    assume
A35: x in support B2;
    then
A36: B2.x <> 0 by POLYNOM1:def 7;
    per cases;
    suppose not x in dom b2;
      then B2.x = (EmptyBag A).x by FUNCT_4:12
        .= 0 by POLYNOM1:56;
      hence x in support b2 by A35,POLYNOM1:def 7;
    end;
    suppose x in dom b2;
      then B2.x = b2.x by FUNCT_4:14;
      hence x in support b2 by A36,POLYNOM1:def 7;
    end;
  end;
  then
A37: support b2 = support B2 by TARSKI:2;
  now
    let k be Nat such that
A38: k in dom f2;
A39: (canFS(support b2)).k in rng canFS(support b2) by A30,A38,FUNCT_1:12;
    thus f2.k = b2.((canFS(support b2)).k) by A25,A30,A38,FUNCT_1:23
      .= B2.((canFS(support b2)).k) by A28,A29,A39,FUNCT_4:14
      .= F2.k by A27,A30,A37,A38,FUNCT_1:23;
  end;
  then
A40: Sum B2 = Sum b2 by A24,A26,A32,A37,A25,A28,A29,FINSEQ_1:17,RELAT_1:46;
  now
    let x be set;
    assume
A41: x in A;
A42: dom b1 = B by PARTFUN1:def 4;
A43: dom b2 = A\B by PARTFUN1:def 4;
    per cases;
    suppose
A44:  x in B;
      then
A45:  not x in dom b2 by A43,XBOOLE_0:def 5;
A46:  B1.x = b1.x by A42,A44,FUNCT_4:14;
      B2.x = (EmptyBag A).x by A45,FUNCT_4:12
        .= 0 by POLYNOM1:56;
      hence b.x = B1.x + B2.x by A1,A45,A46,FUNCT_4:12
        .= (B1 + B2).x by POLYNOM1:def 5;
    end;
    suppose
A47:  not x in B;
      then
A48:  B1.x = (EmptyBag A).x by A42,FUNCT_4:12
        .= 0 by POLYNOM1:56;
A49:  x in dom b2 by A41,A43,A47,XBOOLE_0:def 5;
      then B2.x = b2.x by FUNCT_4:14;
      hence b.x = B1.x + B2.x by A1,A48,A49,FUNCT_4:14
        .= (B1 + B2).x by POLYNOM1:def 5;
    end;
  end;
  hence thesis by A23,A40,PBOOLE:3,UPROOTS:17;
end;

theorem Th4: ::tRBAGSUM02
  for X,x being set, b being Rbag of X st dom b = {x} holds Sum b = b.x
proof
  let X,x be set, b be Rbag of X;
  assume
A1: dom b = {x};
  then
A2: support b c= {x} by POLYNOM1:41;
  {x} c= X by A1,PARTFUN1:def 4;
  then consider f being FinSequence of REAL such that
A3: f = b*canFS({x}) & Sum b = Sum f by A2,UPROOTS:16;
A4: f = b*<*x*> by A3,UPROOTS:6;
  x in dom b by A1,TARSKI:def 1;
  then f = <*b.x*> by A4,BAGORDER:3;
  hence thesis by A3,FINSOP_1:12;
end;

theorem Th5: ::tRBAGSUM03
  for A being set, b1,b2 being Rbag of A
  st (for x being set st x in A holds b1.x <= b2.x) holds Sum b1 <= Sum b2
proof
  let A be set, b1,b2 be Rbag of A such that
A1: for x being set st x in A holds b1.x <= b2.x;
  set S = support b1 \/ support b2;
A2: dom b1 = A & dom b2 = A by PARTFUN1:def 4;
  then support b1 c= A & support b2 c= A by POLYNOM1:41;
  then reconsider S as finite Subset of A by XBOOLE_1:8;
  consider f1 being FinSequence of REAL such that
A3: f1 = b1*canFS(S) and
A4: Sum b1 = Sum f1 by UPROOTS:16,XBOOLE_1:7;
  consider f2 being FinSequence of REAL such that
A5: f2 = b2*canFS(S) and
A6: Sum b2 = Sum f2 by UPROOTS:16,XBOOLE_1:7;
A7: rng canFS(S) = S by FUNCT_2:def 3;
  then
A8: dom f1 = dom canFS(S) & dom f2 = dom canFS(S) by A2,A3,A5,RELAT_1:46;
  then
A9: len f1 = len f2 by FINSEQ_3:31;
A10: f1 is Element of (len f1)-tuples_on REAL by FINSEQ_2:110;
A11: f2 is Element of (len f2)-tuples_on REAL by FINSEQ_2:110;
  now
    let j be Nat;
    assume j in Seg len f1;
    then
A12: j in dom f1 by FINSEQ_1:def 3;
    then
A13: f1.j = b1.((canFS(S)).j) & f2.j = b2.((canFS(S)).j)
    by A3,A5,A8,FUNCT_1:23;
    (canFS(S)).j in S by A7,A8,A12,FUNCT_1:12;
    hence f1.j <= f2.j by A1,A13;
  end;
  hence thesis by A4,A6,A9,A10,A11,RVSUM_1:112;
end;

theorem ::tRBAGSUM04
  for A being set, b1,b2 being Rbag of A
  st (for x being set st x in A holds b1.x = b2.x) holds Sum b1 = Sum b2
proof
  let A be set, b1,b2 be Rbag of A;
  assume
A1: for x being set st x in A holds b1.x = b2.x;
  then for x being set st x in A holds b1.x <= b2.x;
  then
A2: Sum b1 <= Sum b2 by Th5;
  for x being set st x in A holds b2.x <= b1.x by A1;
  then Sum b2 <= Sum b1 by Th5;
  hence thesis by A2,XXREAL_0:1;
end;

theorem ::tRBAGSUM05
  for A1,A2 being set, b1 being Rbag of A1, b2 being Rbag of A2
  st b1 = b2 holds Sum b1 = Sum b2
proof
  let A1,A2 be set, b1 be Rbag of A1, b2 be Rbag of A2;
  assume b1 = b2;
  then consider f1 being FinSequence of REAL such that
A1: Sum b1 = Sum f1 & f1 = b2*canFS(support b2) by UPROOTS:def 3;
  consider f2 being FinSequence of REAL such that
A2: Sum b2 = Sum f2 & f2 = b2*canFS(support b2) by UPROOTS:def 3;
  thus thesis by A1,A2;
end;

theorem Th8: ::tRBAGSUM06
  for X, x being set, b being Rbag of X, y being real number
  st b = (EmptyBag X) +* (x.-->y) holds Sum b = y
proof
  let X, x be set, b be Rbag of X, y be real number such that
A1: b = (EmptyBag X) +* (x.-->y);
A2: dom (x.-->y) = {x} by FUNCOP_1:19;
  dom b = dom EmptyBag X \/ dom (x.-->y) by A1,FUNCT_4:def 1;
  then
A3: {x} c= dom b by A2,XBOOLE_1:7;
  then {x} c= X by PARTFUN1:def 4;
  then
A4: x in X by ZFMISC_1:37;
  reconsider S = {x} as finite Subset of X by A3,PARTFUN1:def 4;
  support b c= S
  proof
    let a be set;
    assume a in support b;
    then
A5: b.a <> 0 by POLYNOM1:def 7;
    assume not a in S;
    then a <> x by TARSKI:def 1;
    then b.a = (EmptyBag X).a by A1,FUNCT_4:88;
    hence contradiction by A5,POLYNOM1:56;
  end;
  then consider f being FinSequence of REAL such that
A6: f = b*canFS(S) and
A7: Sum b = Sum f by UPROOTS:16;
A8: canFS(S) = <*x*> by UPROOTS:6;
  x in dom b by A4,PARTFUN1:def 4;
  then f = <*b.x*> by A6,A8,BAGORDER:3;
  hence Sum b = b.x by A7,FINSOP_1:12
    .= y by A1,FUNCT_7:96;
end;

theorem ::tRBAGSUM07
  for X, x being set, b1, b2 being Rbag of X, y being real number
  st b2 = b1 +* (x.-->y) holds Sum b2 = Sum b1 + y - b1.x
proof
  let X, x be set, b1, b2 be Rbag of X, y be real number such that
A1: b2 = b1 +* (x.-->y);
A2: dom (x.-->y) = {x} by FUNCOP_1:19;
  dom b2 = dom b1 \/ dom (x.-->y) by A1,FUNCT_4:def 1;
  then {x} c= dom b2 by A2,XBOOLE_1:7;
  then {x} c= X by PARTFUN1:def 4;
  then
A3: x in X by ZFMISC_1:37;
  set a = b1 +* (x.-->0);
A4a: support a c= support b1 \/ {x} by Th2;
  dom a = dom b1 \/ dom (x.-->0) by FUNCT_4:def 1
    .= X \/ dom (x.-->0) by PARTFUN1:def 4
    .= X \/ {x} by FUNCOP_1:19
    .= X by A3,ZFMISC_1:46;
  then reconsider a as Rbag of X by A4a,PARTFUN1:def 4,POLYNOM1:def 8
,RELAT_1:def 18;
  set b = (EmptyBag X) +* (x .--> b1.x);
A5a: support b c= (support EmptyBag X) \/ {x} by Th2;
  dom b = (dom EmptyBag X) \/ dom (x.-->b1.x) by FUNCT_4:def 1
    .= X \/ dom (x.-->b1.x) by PARTFUN1:def 4
    .= X \/ {x} by FUNCOP_1:19
    .= X by A3,ZFMISC_1:46;
  then reconsider b as Rbag of X by A5a,PARTFUN1:def 4,POLYNOM1:def 8
,RELAT_1:def 18;
  set c = (EmptyBag X) +* (x.-->y);
A6a: support c c= (support EmptyBag X) \/ {x} by Th2;
  dom c = (dom EmptyBag X) \/ dom (x.-->y) by FUNCT_4:def 1
    .= X \/ dom (x.-->y) by PARTFUN1:def 4
    .= X \/ {x} by FUNCOP_1:19
    .= X by A3,ZFMISC_1:46;
  then reconsider c as Rbag of X by A6a,PARTFUN1:def 4,POLYNOM1:def 8
,RELAT_1:def 18;
  now
    let i be set;
    assume i in X;
A7: (EmptyBag X).i = 0 by POLYNOM1:56;
    per cases;
    suppose
A8:   i = x;
      thus (a+b).i = a.i + b.i by POLYNOM1:def 5
        .= 0 qua Nat + b.i by A8,FUNCT_7:96
        .= b1.i by A8,FUNCT_7:96;
    end;
    suppose
A9:   i <> x;
      thus (a+b).i = a.i + b.i by POLYNOM1:def 5
        .= b1.i + b.i by A9,FUNCT_4:88
        .= b1.i + (0 qua Nat) by A7,A9,FUNCT_4:88
        .= b1.i;
    end;
  end;
  then
A10: Sum b1 - Sum b = Sum a + Sum b - Sum b by PBOOLE:3,UPROOTS:17;
A11: Sum c = y by Th8;
A12: Sum b = b1.x by Th8;
  now
    let i be set;
    assume i in X;
A13: (EmptyBag X).i = 0 by POLYNOM1:56;
    per cases;
    suppose
A14:  i = x;
      hence b2.i = y by A1,FUNCT_7:96
        .= 0 qua Nat+ c.i by A14,FUNCT_7:96
        .= a.i + c.i by A14,FUNCT_7:96
        .= (a+c).i by POLYNOM1:def 5;
    end;
    suppose
A15:  i <> x;
      then
A16:  c.i = 0 by A13,FUNCT_4:88;
      thus b2.i = b1.i by A1,A15,FUNCT_4:88
        .= a.i + c.i by A15,A16,FUNCT_4:88
        .= (a+c).i by POLYNOM1:def 5;
    end;
  end;
  hence Sum b2 = Sum b1 - Sum b + Sum c by A10,PBOOLE:3,UPROOTS:17
    .= Sum b1 + y - b1.x by A11,A12;
end;

begin :: Graph preliminaries

definition
  let G1 be real-weighted WGraph, G2 be WSubgraph of G1, v be set;
  pred G2 is_mincost_DTree_rooted_at v means                      :Def1:
  G2 is Tree-like &
  for x being Vertex of G2 holds
  ex W2 being DPath of G2 st W2 is_Walk_from v,x &
  for W1 being DPath of G1 st W1 is_Walk_from v,x holds
  W2.cost() <= W1.cost();
end;

definition
  let G be real-weighted WGraph, W be DPath of G, x,y be set;
  pred W is_mincost_DPath_from x,y means                 :Def2: ::dWMINCOSTD
  W is_Walk_from x,y & for W2 being DPath of G st
  W2 is_Walk_from x,y holds W.cost() <= W2.cost();
end;

definition
  let G be finite real-weighted WGraph, x,y be set;
  func G.min_DPath_cost(x,y) -> Real means              :Def3: ::dWGMINDCOST
  ex W being DPath of G st W is_mincost_DPath_from x,y & it = W.cost() if
  ex W being DWalk of G st W is_Walk_from x,y otherwise it = 0;
  existence
  proof
    set X = {W where W is DPath of G: W is_Walk_from x,y};
    now
      let e be set;
      assume e in X;
      then consider W being DPath of G such that
A1:   e = W & W is_Walk_from x,y;
      e in {w where w is DPath of G: not contradiction} by A1;
      hence e in G.allDPaths() by GLIB_001:def 38;
    end;
    then reconsider X as finite Subset of G.allDPaths() by TARSKI:def 3;
    hereby
      assume ex W being DWalk of G st W is_Walk_from x,y;
      then consider W being DWalk of G such that
A2:   W is_Walk_from x,y;
      consider P being DPath of W;
      P is_Walk_from x,y by A2,GLIB_001:161;
      then P in X;
      then reconsider X as non empty finite Subset of G .allDPaths();
      deffunc F(Element of X) = $1.cost();
      consider W1 being Element of X such that
A3:   for W2 being Element of X holds F(W1) <= F(W2) from GRAPH_5:sch 2;
      W1 in X;
      then consider WA being DPath of G such that
A4:   WA = W1 & WA is_Walk_from x,y;
A5:   now
        let WB be DPath of G;
        assume WB is_Walk_from x,y;
        then WB in X;
        then reconsider WB' = WB as Element of X;
        F(W1) <= F(WB') by A3;
        hence WA.cost() <= WB.cost() by A4;
      end;
      reconsider WA as DPath of G;
      set IT = WA.cost();
      take IT, WA;
      thus WA is_mincost_DPath_from x,y by A4,A5,Def2;
      thus IT = WA.cost();
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be Real;
    hereby
      assume ex W being DWalk of G st W is_Walk_from x,y;
      given W1 being DPath of G such that
A6:   W1 is_mincost_DPath_from x,y & IT1 = W1.cost();
      given W2 being DPath of G such that
A7:   W2 is_mincost_DPath_from x,y & IT2 = W2.cost();
A8:   W1 is_Walk_from x,y & for W2 being DPath of G st
      W2 is_Walk_from x,y holds W1.cost() <= W2.cost() by A6,Def2;
A9:   W2 is_Walk_from x,y & for W1 being DPath of G st
      W1 is_Walk_from x,y holds W2.cost() <= W1.cost() by A7,Def2;
A10:  IT2 <= IT1 by A6,A7,A8,Def2;
      IT1 <= IT2 by A6,A7,A9,Def2;
      hence IT1 = IT2 by A10,XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  func WGraphSelectors -> non empty finite Subset of NAT equals  ::dWGRAPHSEL
  {VertexSelector, EdgeSelector, SourceSelector, TargetSelector,
  WeightSelector};
  coherence;
end;

Lm1: for G being WGraph holds WGraphSelectors c= dom G
proof
  let G be WGraph;
  now
    let x be set;
    assume x in WGraphSelectors;
    then x = VertexSelector or x = EdgeSelector or
    x = SourceSelector or x = TargetSelector or
    x = WeightSelector by ENUMSET1:def 3;
    hence x in dom G by GLIB_000:def 11,GLIB_003:def 4;
  end;
  hence thesis by TARSKI:def 3;
end;

registration
  let G be WGraph;
  cluster G.strict(WGraphSelectors) -> [Graph-like] [Weighted];
  coherence
  proof
    set G2 = G.strict(WGraphSelectors);
A1: dom G2 = dom G /\ WGraphSelectors by RELAT_1:90
      .= WGraphSelectors by Lm1,XBOOLE_1:28;
A2: VertexSelector in WGraphSelectors & EdgeSelector in WGraphSelectors &
    SourceSelector in WGraphSelectors & TargetSelector in WGraphSelectors &
    WeightSelector in WGraphSelectors by ENUMSET1:def 3;
    then
A3: the_Vertices_of G2 = the_Vertices_of G by FUNCT_1:72;
A4: the_Edges_of G2 = the_Edges_of G by A2,FUNCT_1:72;
A5: the_Source_of G2 = the_Source_of G by A2,FUNCT_1:72;
A6: the_Target_of G2 = the_Target_of G by A2,FUNCT_1:72;
    for x being set st x in _GraphSelectors holds x in dom G2
    by A1,A2,ENUMSET1:def 2;
    then _GraphSelectors c= dom G2 by TARSKI:def 3;
    hence G2 is [Graph-like] by A3,A4,A5,A6,GLIB_000:7;
    G2.WeightSelector = G.WeightSelector by A2,FUNCT_1:72;
    then G2.WeightSelector is ManySortedSet of the_Edges_of G2
    by A4,GLIB_003:def 4;
    hence thesis by A1,A2,GLIB_003:def 4;
  end;
end;

Lm2: for G being WGraph holds G == (G.strict(WGraphSelectors)) &
the_Weight_of G = the_Weight_of (G.strict(WGraphSelectors))
proof
  let G be WGraph;
  set G2 = G.strict(WGraphSelectors);
A1: VertexSelector in WGraphSelectors & EdgeSelector in WGraphSelectors &
  SourceSelector in WGraphSelectors & TargetSelector in WGraphSelectors &
  WeightSelector in WGraphSelectors by ENUMSET1:def 3;
  then
A2: the_Vertices_of G2 = the_Vertices_of G by FUNCT_1:72;
A3: the_Edges_of G2 = the_Edges_of G by A1,FUNCT_1:72;
A4: the_Source_of G2 = the_Source_of G by A1,FUNCT_1:72;
  the_Target_of G2 = the_Target_of G by A1,FUNCT_1:72;
  hence G == G2 by A2,A3,A4,GLIB_000:def 36;
  thus thesis by A1,FUNCT_1:72;
end;

Lm3: for G being WGraph holds
dom (G.strict(WGraphSelectors)) = WGraphSelectors
proof
  let G be WGraph;
  WGraphSelectors c= dom G by Lm1;
  hence thesis by RELAT_1:91;
end;

definition
  let G be WGraph;
  func G.allWSubgraphs() -> non empty set means  :Def10: ::dGALLWSUBG
  for x being set holds x in it iff
  ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors;
  existence
  proof
    set Z = {bool the_Vertices_of G, bool the_Edges_of G,
    bool the_Source_of G, bool the_Target_of G, bool the_Weight_of G};
    set Y = union Z;
    set X = Funcs(WGraphSelectors, Y);
    defpred P[set] means $1 is WSubgraph of G;
    consider IT being Subset of X such that
A1: for x being set holds x in IT iff x in X & P[x] from SUBSET_1:sch 1;
    set G' = G.strict(WGraphSelectors);
A2: G == G' & the_Weight_of G = the_Weight_of G' by Lm2;
    then reconsider G' as [Weighted] Subgraph of G by GLIB_000:90;
    dom the_Weight_of G = the_Edges_of G' by A2,PARTFUN1:def 4;
    then the_Weight_of G' = (the_Weight_of G) | the_Edges_of G'
    by A2,RELAT_1:98;
    then reconsider G' as WSubgraph of G by GLIB_003:def 10;
A3: dom G' = WGraphSelectors by Lm3;
A4: now
      let G2 be WSubgraph of G;
      assume
A5:   dom G2 = WGraphSelectors;
      now
        let y be set;
        assume y in rng G2;
        then consider x being set such that
A6:     x in WGraphSelectors & G2.x = y by A5,FUNCT_1:def 5;
        now per cases by A6,ENUMSET1:def 3;
          suppose x = VertexSelector;
            then
A7:         y = the_Vertices_of G2 by A6;
            bool the_Vertices_of G in Z by ENUMSET1:def 3;
            hence y in Y by A7,TARSKI:def 4;
          end;
          suppose x = EdgeSelector;
            then
A8:         y = the_Edges_of G2 by A6;
            bool the_Edges_of G in Z by ENUMSET1:def 3;
            hence y in Y by A8,TARSKI:def 4;
          end;
          suppose x = SourceSelector;
            then y = the_Source_of G2 by A6;
            then y = (the_Source_of G) | the_Edges_of G2 by GLIB_000:48;
            then
A9:         y c= the_Source_of G by RELAT_1:88;
            bool the_Source_of G in Z by ENUMSET1:def 3;
            hence y in Y by A9,TARSKI:def 4;
          end;
          suppose x = TargetSelector;
            then y = the_Target_of G2 by A6;
            then y = (the_Target_of G) | the_Edges_of G2 by GLIB_000:48;
            then
A10:        y c= the_Target_of G by RELAT_1:88;
            bool the_Target_of G in Z by ENUMSET1:def 3;
            hence y in Y by A10,TARSKI:def 4;
          end;
          suppose x = WeightSelector;
            then y = the_Weight_of G2 by A6;
            then y = (the_Weight_of G) | the_Edges_of G2 by GLIB_003:def 10;
            then
A11:        y c= the_Weight_of G by RELAT_1:88;
            bool the_Weight_of G in Z by ENUMSET1:def 3;
            hence y in Y by A11,TARSKI:def 4;
          end;
        end;
        hence y in Y;
      end;
      hence rng G2 c= Y by TARSKI:def 3;
    end;
    then rng G' c= Y by A3;
    then G' in X by A3,FUNCT_2:def 2;
    then reconsider IT as non empty set by A1;
    take IT;
    let x be set;
    hereby
      assume
A12:  x in IT;
      then reconsider x' = x as WSubgraph of G by A1;
      take x';
      thus x' = x;
      consider f being Function such that
A13:  f = x & dom f = WGraphSelectors & rng f c= Y by A12,FUNCT_2:def 2;
      thus dom x' = WGraphSelectors by A13;
    end;
    given G2 being WSubgraph of G such that
A14: G2 = x & dom G2 = WGraphSelectors;
    rng G2 c= Y by A4,A14;
    then x in X by A14,FUNCT_2:def 2;
    hence thesis by A1,A14;
  end;
  uniqueness
  proof
    let IT1,IT2 be non empty set such that
A15: for x being set holds x in IT1 iff
    ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors and
A16: for x being set holds x in IT2 iff
    ex G2 being WSubgraph of G st x = G2 & dom G2 = WGraphSelectors;
    now
      let x be set;
      x in IT1 iff ex G2 being WSubgraph of G
      st x = G2 & dom G2 = WGraphSelectors by A15;
      hence x in IT1 iff x in IT2 by A16;
    end;
    hence thesis by TARSKI:2;
  end;
end;

registration
  let G be finite WGraph;
  cluster G.allWSubgraphs() -> finite;
  coherence
  proof
    set Z = {bool the_Vertices_of G, bool the_Edges_of G,
    bool the_Source_of G, bool the_Target_of G,
    bool the_Weight_of G}, Y = union Z;
    for x being set st x in Z holds x is finite by ENUMSET1:def 3;
    then reconsider Y as finite set by FINSET_1:25;
    set X = Funcs(WGraphSelectors, Y);
    now
      let x be set;
      assume x in G.allWSubgraphs();
      then consider G2 being WSubgraph of G such that
A2:   x = G2 & dom G2 = WGraphSelectors by Def10;
      now
        let y be set;
        assume y in rng G2;
        then consider x being set such that
A3:     x in WGraphSelectors & G2.x = y by A2,FUNCT_1:def 5;
        now per cases by A3,ENUMSET1:def 3;
          suppose x = VertexSelector;
            then
A4:         y = the_Vertices_of G2 by A3;
            bool the_Vertices_of G in Z by ENUMSET1:def 3;
            hence y in Y by A4,TARSKI:def 4;
          end;
          suppose x = EdgeSelector;
            then
A5:         y = the_Edges_of G2 by A3;
            bool the_Edges_of G in Z by ENUMSET1:def 3;
            hence y in Y by A5,TARSKI:def 4;
          end;
          suppose x = SourceSelector;
            then y = the_Source_of G2 by A3;
            then y = (the_Source_of G) | the_Edges_of G2 by GLIB_000:48;
            then
A6:         y c= the_Source_of G by RELAT_1:88;
            bool the_Source_of G in Z by ENUMSET1:def 3;
            hence y in Y by A6,TARSKI:def 4;
          end;
          suppose x = TargetSelector;
            then y = the_Target_of G2 by A3;
            then y = (the_Target_of G) | the_Edges_of G2 by GLIB_000:48;
            then
A7:         y c= the_Target_of G by RELAT_1:88;
            bool the_Target_of G in Z by ENUMSET1:def 3;
            hence y in Y by A7,TARSKI:def 4;
          end;
          suppose x = WeightSelector;
            then y = the_Weight_of G2 by A3;
            then y = (the_Weight_of G) | the_Edges_of G2 by GLIB_003:def 10;
            then
A8:         y c= the_Weight_of G by RELAT_1:88;
            bool the_Weight_of G in Z by ENUMSET1:def 3;
            hence y in Y by A8,TARSKI:def 4;
          end;
        end;
        hence y in Y;
      end;
      then rng G2 c= Y by TARSKI:def 3;
      hence x in X by A2,FUNCT_2:def 2;
    end;
    then G.allWSubgraphs() c= X by TARSKI:def 3;
    hence thesis;
  end;
end;

definition
  let G be WGraph, X be non empty Subset of G.allWSubgraphs();
  redefine mode Element of X -> WSubgraph of G;
  coherence
  proof
    let x be Element of X;
    consider G2 being WSubgraph of G such that
A1: G2 = x & dom G2 = WGraphSelectors by Def10;
    thus thesis by A1;
  end;
end;

definition
  let G be finite real-weighted WGraph;
  func G.cost() -> Real equals  ::dWGCOST
  Sum the_Weight_of G;
  coherence by XREAL_0:def 1;
end;

theorem Th33: ::tGCOST03
  for G1 being finite real-weighted WGraph, e being set,
  G2 being weight-inheriting ([Weighted] removeEdge of G1,e)
  st e in the_Edges_of G1 holds G1.cost() = G2.cost() + (the_Weight_of G1).e
proof
  let G1 be finite real-weighted WGraph, e be set,
  G2 be weight-inheriting ([Weighted] removeEdge of G1,e);
  set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2;
  assume
A1: e in EG1;
A2: EG2 = EG1 \ {e} by GLIB_000:54;
A3: the_Weight_of G2 = (the_Weight_of G1) | (EG2) by GLIB_003:def 10;
  set b2 = (e .--> (the_Weight_of G1).e);
A4: dom b2 = {e} & rng b2 = {(the_Weight_of G1).e} by FUNCOP_1:14,19;
  EG1 \ EG2 = EG1 /\ {e} by A2,XBOOLE_1:48
    .= {e} by A1,ZFMISC_1:52;
  then reconsider b2 as ManySortedSet of EG1 \ EG2;
  reconsider b2 as Rbag of EG1 \ EG2;
A5: dom (the_Weight_of G2 +* b2) = dom the_Weight_of G2 \/ {e}
  by A4,FUNCT_4:def 1
    .= (EG1 \ {e}) \/ {e} by A2,PARTFUN1:def 4
    .= EG1 \/ {e} by XBOOLE_1:39
    .= EG1 by A1,ZFMISC_1:46;
A6: dom the_Weight_of G1 = EG1 by PARTFUN1:def 4;
  now
    let x be set;
    assume x in dom the_Weight_of G1;
    then
A7: x in EG1 by PARTFUN1:def 4;
    now per cases;
      suppose
A8:     x in {e};
        then
A9:     x = e by TARSKI:def 1;
        hence (the_Weight_of G2 +* b2).x = b2.e by A4,A8,FUNCT_4:14
          .= (the_Weight_of G1).x by A9,FUNCOP_1:87;
      end;
      suppose
A10:    not x in {e};
        then
A11:    (the_Weight_of G2 +* b2).x = (the_Weight_of G2).x by A4,FUNCT_4:12;
        x in EG1 \ {e} by A7,A10,XBOOLE_0:def 5;
        hence (the_Weight_of G2 +* b2).x = (the_Weight_of G1).x
        by A2,A3,A11,FUNCT_1:72;
      end;
    end;
    hence (the_Weight_of G1).x = (the_Weight_of G2 +* b2).x;
  end;
  hence G1.cost() = G2.cost() + Sum b2 by Th3,A5,A6,FUNCT_1:9
    .= G2.cost() + b2.e by A4,Th4
    .= G2.cost() + (the_Weight_of G1).e by FUNCOP_1:87;
end;

theorem Th34: ::tGCOST04
  for G being finite real-weighted WGraph,
  V1 being non empty Subset of the_Vertices_of G,
  E1 being Subset of G.edgesBetween(V1),
  G1 being inducedWSubgraph of G,V1,E1, e being set,
  G2 being inducedWSubgraph of G,V1,E1 \/ {e}
  st not e in E1 & e in G.edgesBetween(V1)
  holds G1.cost() + (the_Weight_of G).e = G2.cost()
proof
  let G be finite real-weighted WGraph,
  V1 be non empty Subset of the_Vertices_of G,
  E1 be Subset of G.edgesBetween(V1),
  G1 be inducedWSubgraph of G,V1,E1, e being set,
  G2 be inducedWSubgraph of G,V1,E1 \/ {e};
  assume
A1: not e in E1 & e in G.edgesBetween(V1);
A2: the_Vertices_of G1 = V1 & the_Edges_of G1 = E1 by GLIB_000:def 39;
  {e} c= G.edgesBetween(V1) by A1,ZFMISC_1:37;
  then (E1 \/ {e}) c= G.edgesBetween(V1) by XBOOLE_1:8;
  then
A3: the_Vertices_of G2 = V1 & the_Edges_of G2 = E1 \/ {e} by GLIB_000:def 39;
  set W2 = (e .--> (the_Weight_of G).e);
A4: the_Edges_of G2 \ the_Edges_of G1 = {e} \ E1 by A2,A3,XBOOLE_1:40
    .= {e} by A1,ZFMISC_1:67;
A5: dom W2 = {e} by FUNCOP_1:19;
  reconsider W2 as ManySortedSet of (the_Edges_of G2 \ the_Edges_of G1)
  by A4;
  reconsider W2 as Rbag of (the_Edges_of G2 \ the_Edges_of G1);
A6: dom the_Weight_of G2 = E1 \/ {e} by A3,PARTFUN1:def 4;
A7: dom ((the_Weight_of G1) +* W2) = dom the_Weight_of G1 \/ dom W2
  by FUNCT_4:def 1
    .= E1 \/ {e} by A2,A5,PARTFUN1:def 4;
A8: the_Weight_of G1 = (the_Weight_of G) | E1 by A2,GLIB_003:def 10;
A8a: now
    let x be set;
    assume x in dom the_Weight_of G2;
    then
A9: x in E1 \/ {e} by A3,PARTFUN1:def 4;
    the_Weight_of G2 = (the_Weight_of G) | (E1 \/ {e}) by A3,GLIB_003:def 10;
    then
A10: (the_Weight_of G2).x = (the_Weight_of G).x by A9,FUNCT_1:72;
    now per cases;
      suppose
A11:    not x in dom W2;
        then
A12:    ((the_Weight_of G1)+*W2).x = (the_Weight_of G1).x by FUNCT_4:12;
        x in E1 by A5,A9,A11,XBOOLE_0:def 3;
        hence ((the_Weight_of G1)+*W2).x = (the_Weight_of G2).x
        by A8,A10,A12,FUNCT_1:72;
      end;
      suppose
A13:    x in dom W2;
        then
A14:    x = e by A5,TARSKI:def 1;
        ((the_Weight_of G1)+*W2).x = W2.x by A13,FUNCT_4:14
          .= (the_Weight_of G).e by A14,FUNCOP_1:87;
        hence ((the_Weight_of G1)+*W2).x = (the_Weight_of G2).x
        by A5,A10,A13,TARSKI:def 1;
      end;
    end;
    hence (the_Weight_of G2).x = ((the_Weight_of G1) +* W2).x;
  end;
  dom W2 = {e} by FUNCOP_1:19;
  then Sum W2 = W2.e by Th4
    .= (the_Weight_of G).e by FUNCOP_1:87;
  hence thesis
    by Th3,A8a,A6,A7,FUNCT_1:9;
end;

theorem Th10: ::tWGMINDCOST01
for G being finite nonnegative-weighted WGraph, W being DPath of G,
    x,y being set, m,n being Element of NAT
 st W is_mincost_DPath_from x,y
  holds W.cut(m,n) is_mincost_DPath_from W.cut(m,n).first(),W.cut(m,n).last()
proof
  let G be finite nonnegative-weighted WGraph, W be DPath of G,
  x,y be set, m,n be Element of NAT;
  assume
A1: W is_mincost_DPath_from x,y;
  then
A2: W is_Walk_from x,y & for W2 being DPath of G st W2 is_Walk_from x,y holds
  W.cost() <= W2.cost() by Def2;
  set WC = W.cut(m,n);
A3: WC is_Walk_from WC.first(),WC.last() by GLIB_001:def 23;
A4: W.1 = x & W.(len W) = y by A2,GLIB_001:18;
  now per cases;
    suppose
A5:   m is odd & n is odd & m <= n & n <= len W;
      set W1 = W.cut(1,m), W3 = W.cut(n,len W);
A6:   1 is odd & 1 <= m & 1 <= n by A5,HEYTING3:1,JORDAN12:3;
      then
A7:   W1.append(WC) = W.cut(1,n) by A5,GLIB_001:39;
A8:   W.cut(1,n).append(W3) = W.cut(1,len W) by A5,A6,GLIB_001:39
        .= W by GLIB_001:40;
      W.cut(1,n).last() = W.n by A5,A6,GLIB_001:38
        .= W3.first() by A5,GLIB_001:38;
      then
A9:   W.cost() = W.cut(1,n).cost() + W3.cost() by A8,GLIB_003:31;
A10:  m <= len W by A5,XXREAL_0:2;
      then W1.last() = W.m by A5,A6,GLIB_001:38
        .= WC.first() by A5,GLIB_001:38;
      then W.cut(1,n).cost() = W1.cost() + WC.cost() by A7,GLIB_003:31;
      then
A11:  W.cost() = WC.cost() + (W1.cost() + W3.cost()) by A9;
A12:  W1 is_Walk_from W.1, W.m by A5,A6,A10,GLIB_001:38;
A13:  W3 is_Walk_from W.n, W.(len W) by A5,GLIB_001:38;
      now
        assume not WC is_mincost_DPath_from WC.first(),WC.last();
        then consider W2 being DPath of G such that
A14:    W2 is_Walk_from WC.first(), WC.last() & W2.cost() < WC.cost()
        by A3,Def2;
A15:    WC.first() = W.m & WC.last() = W.n by A5,GLIB_001:38;
        then
A16:    W2.first() = W.m & W2.last() = W.n by A14,GLIB_001:def 23;
        set WA = W1.append(W2), WB = WA.append(W3);
        WA is_Walk_from W.1, W.n by A12,A14,A15,GLIB_001:32;
        then
A17:    WB is_Walk_from x,y by A4,A13,GLIB_001:32;
A18:    W1.last() = W2.first() by A5,A6,A10,A16,GLIB_001:38;
        then
A19:    WA.cost() = W1.cost() + W2.cost() by GLIB_003:31;
        W3.first() = W2.last() by A5,A16,GLIB_001:38
          .= WA.last() by A18,GLIB_001:31;
        then WB.cost() = W1.cost() + W2.cost() + W3.cost() by A19,GLIB_003:31
          .= W2.cost() + (W1.cost() + W3.cost());
        then
A20:    WB.cost() < W.cost() by A11,A14,XREAL_1:10;
        consider WB2 being DPath of WB;
        WB2.cost() <= WB.cost() by GLIB_003:37;
        then
A21:    WB2.cost() < W.cost() by A20,XXREAL_0:2;
        WB2 is_Walk_from x,y by A17,GLIB_001:161;
        hence contradiction by A1,A21,Def2;
      end;
      hence thesis;
    end;
    suppose
A22:  not (m is odd & n is odd & m <= n & n <= len W);
      then WC = W by GLIB_001:def 11;
      then WC.first() = x & WC.last() = y by A2,GLIB_001:def 23;
      hence thesis by A1,A22,GLIB_001:def 11;
    end;
  end;
  hence thesis;
end;

theorem Th11: ::tWGMINDCOST02
for G being finite real-weighted WGraph, W1,W2 being DPath of G,
    x,y being set
 st W1 is_mincost_DPath_from x,y & W2 is_mincost_DPath_from x,y
  holds W1.cost() = W2.cost()
proof
  let G be finite real-weighted WGraph, W1,W2 be DPath of G, x,y be set;
  assume
A1: W1 is_mincost_DPath_from x,y & W2 is_mincost_DPath_from x,y;
  then
A2: W1 is_Walk_from x,y & for W2 being DPath of G st W2 is_Walk_from x,y
  holds W1.cost() <= W2.cost() by Def2;
  W2 is_Walk_from x,y & for W1 being DPath of G st W1 is_Walk_from x,y
  holds W2.cost() <= W1.cost() by A1,Def2;
  then W1.cost() <= W2.cost() & W2.cost() <= W1.cost() by A2;
  hence thesis by XXREAL_0:1;
end;

theorem Th12: ::tWGMINDCOST03
for G being finite real-weighted WGraph, W being DPath of G, x,y being set
 st W is_mincost_DPath_from x,y holds G.min_DPath_cost(x,y) = W.cost()
proof
  let G be finite real-weighted WGraph, W be DPath of G, x,y be set;
  assume
A1: W is_mincost_DPath_from x,y;
  then W is_Walk_from x,y by Def2;
  then consider W2 being DPath of G such that
A2: W2 is_mincost_DPath_from x,y & G.min_DPath_cost(x,y) = W2.cost() by Def3;
  thus thesis by A1,A2,Th11;
end;

begin :: Definitions for Dijkstra's Shortest Path Algorithm

definition
  let G be _Graph;
  mode DIJK:Labeling of G is
     Element of [: PFuncs(the_Vertices_of G, REAL),
                   bool the_Edges_of G :];
end;

definition
  let X1,X3 be set, X2 be non empty set;
  let x be Element of [: PFuncs(X1,X3),X2 :];
  redefine func x`1 -> Element of PFuncs(X1,X3);
  coherence by MCART_1:10;
end;

registration
  let G be finite _Graph, L be DIJK:Labeling of G;
  cluster L`1 -> finite;
  coherence proof
   dom L`1 c= the_Vertices_of G;
   hence thesis by FINSET_1:29;
  end;
  cluster L`2 -> finite;
  coherence proof
   L`2 in bool the_Edges_of G by MCART_1:10;
   hence thesis;
  end;
end;


definition
  let G be real-weighted WGraph, L be DIJK:Labeling of G;
  func DIJK:NextBestEdges(L) -> Subset of the_Edges_of G means   :Def4:
  for e1 being set holds e1 in it iff
     e1 DSJoins dom (L`1), the_Vertices_of G \ dom (L`1), G &
     for e2 being set
      st e2 DSJoins dom (L`1), the_Vertices_of G \ dom (L`1), G
       holds (L`1).((the_Source_of G).e1) + (the_Weight_of G).e1 <=
             (L`1).((the_Source_of G).e2) + (the_Weight_of G).e2;
  existence
  proof
   defpred P[set] means
    $1 DSJoins dom L`1, the_Vertices_of G \ dom L`1, G &
    for e2 being set
    st e2 DSJoins dom L`1, the_Vertices_of G \ dom L`1, G
    holds (L`1).((the_Source_of G).$1)+(the_Weight_of G).$1 <=
    (L`1).((the_Source_of G).e2)+(the_Weight_of G).e2;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
    from SUBSET_1:sch 1;
    take IT;
    now
      let e1 be set;
      thus e1 in IT implies P[e1] by A1;
      assume
A2:   P[e1];
      then e1 in the_Edges_of G by GLIB_000:def 18;
      hence e1 in IT by A1,A2;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    defpred P[set] means
    $1 DSJoins dom L`1, the_Vertices_of G \ dom L`1, G &
    for e2 being set
    st e2 DSJoins dom L`1, the_Vertices_of G \ dom L`1, G
    holds (L`1).((the_Source_of G).$1)+(the_Weight_of G).$1 <=
    (L`1).((the_Source_of G).e2)+(the_Weight_of G).e2;
    let IT1,IT2 be Subset of the_Edges_of G such that
A3: for y being set holds y in IT1 iff P[y] and
A4: for y being set holds y in IT2 iff P[y];
    now
      let x be set;
      hereby
        assume x in IT1;
        then P[x] by A3;
        hence x in IT2 by A4;
      end;
      assume x in IT2;
      then P[x] by A4;
      hence x in IT1 by A3;
    end;
    hence thesis by TARSKI:2;
  end;
end;

definition
  let G be real-weighted WGraph, L be DIJK:Labeling of G;
  func DIJK:Step(L) -> DIJK:Labeling of G equals  :Def5: ::dDIJKSTEP
  L if DIJK:NextBestEdges(L) = {}
    otherwise
  [ L`1+*((the_Target_of G).(choose DIJK:NextBestEdges(L))
      .--> ((L`1).((the_Source_of G).(choose DIJK:NextBestEdges(L)))
            + (the_Weight_of G).(choose DIJK:NextBestEdges(L)))),
    L`2 \/ {choose DIJK:NextBestEdges(L)}
  ];
  coherence proof
  set BE = DIJK:NextBestEdges(L), e = choose BE;
  set nE = L`2 \/ {e}; set V = the_Vertices_of G, E = the_Edges_of G;
  set s = (the_Source_of G).e, t = (the_Target_of G).e;
  set val = (L`1).s + (the_Weight_of G).e;
  now
    assume S1: BE <> {};
       e in BE by S1;
       then
       reconsider e' = e as Element of E;
  AAa: e in BE & BE c= E by S1;
       reconsider t' = t as Element of V by AAa,FUNCT_2:7;
  A2: {t'} c= V;
      dom (L`1+*(t .--> val)) = dom L`1 \/ {t} by Tw0;
      then
  D1: dom (L`1+*(t .--> val)) c= V by A2,XBOOLE_1:8;
      rng (L`1+*(t .--> val)) c= REAL;
      then
  A: L`1+*(t .--> val) in PFuncs(V, REAL) by D1,PARTFUN1:def 5;
  E1a: L`2 in bool E by MCART_1:10;
      {e'} c= E by AAa,ZFMISC_1:37;
     then nE c= E by E1a,XBOOLE_1:8;
   hence [ L`1+*(t .--> val), nE ] is DIJK:Labeling of G by A,ZFMISC_1:def 2;
  end;
  hence thesis;
  end;
  consistency;
end;

definition
  let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:Init(src) -> DIJK:Labeling of G equals  ::dDIJKINIT:
   [src .--> 0, {}];
  coherence proof
       set f = src .--> 0;
       dom f = {src} & rng f = {0} by FUNCOP_1:14,19;
       then
   B1: f in PFuncs(the_Vertices_of G, REAL) by PARTFUN1:def 5;
       {} c= the_Edges_of G by XBOOLE_1:2;
   hence thesis by B1,ZFMISC_1:def 2;
  end;
end;

definition
  let G be real-weighted WGraph;
  mode DIJK:LabelingSeq of G -> ManySortedSet of NAT means  :dDIJKSeq:
  for n being Nat holds it.n is DIJK:Labeling of G;
  existence proof
  defpred P[set,set] means $2 is DIJK:Labeling of G;
A: now let i be set; assume
    i in NAT;
    take r = [{},{}];
       {} is PartFunc of the_Vertices_of G, REAL by RELSET_1:25;
       then
   B1: {} in PFuncs(the_Vertices_of G, REAL) by PARTFUN1:119;
       {} c= the_Edges_of G by XBOOLE_1:2;
    hence P[i,r] by B1,ZFMISC_1:def 2;
   end;
    consider s being ManySortedSet of NAT such that
Z:  for i being set st i in NAT holds P[i,s.i] from PBOOLE:sch 3(A);
    take s;
    let i be Nat;
     i in NAT by ORDINAL1:def 13;
    hence thesis by Z;
  end;
end;

definition
  let G be real-weighted WGraph, S be DIJK:LabelingSeq of G, n be Nat;
  redefine func S.n -> DIJK:Labeling of G;
  coherence by dDIJKSeq;
end;

definition
  let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:CompSeq(src) -> DIJK:LabelingSeq of G means   :Def7: ::dDIJKCS
  it.0 = DIJK:Init(src) &
  for n being Nat holds it.(n+1) = DIJK:Step(it.n);
  existence
  proof
    defpred P[set,set,set] means ($2 is DIJK:Labeling of G &
    ex Gn,Gn1 being DIJK:Labeling of G
     st $2 = Gn & $3 = Gn1 & Gn1 = DIJK:Step(Gn)) or
     (not $2 is DIJK:Labeling of G & $2 = $3);
    now
      let n,x be set;
      now per cases;
        suppose x is DIJK:Labeling of G;
          then reconsider Gn=x as DIJK:Labeling of G;
          P[n,x,DIJK:Step(Gn)];
          hence ex y being set st P[n,x,y];
        end;
        suppose not x is DIJK:Labeling of G;
          hence ex y being set st P[n,x,y];
        end;
      end;
      hence ex y being set st P[n,x,y];
    end;
    then
A1: for n being Element of NAT for x being set ex y being set st P[n,x,y];
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = DIJK:Init(src) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
    from RECDEF_1:sch 1(A1);
    reconsider IT as ManySortedSet of NAT by A3,PARTFUN1:def 4,RELAT_1:def 18;
    defpred P2[Nat] means IT.$1 is DIJK:Labeling of G;
A4: P2[0] by A3;
A5: now
      let n be Nat;
A6:   n in NAT by ORDINAL1:def 13;
      assume P2[n];
      then consider Gn,Gn1 being DIJK:Labeling of G such that
A7:   IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = DIJK:Step(Gn) by A3,A6;
      thus P2[n+1] by A7;
    end;
    for n being Nat holds P2[n] from NAT_1:sch 2(A4,A5);
    then reconsider IT as DIJK:LabelingSeq of G by dDIJKSeq;
    reconsider IT as DIJK:LabelingSeq of G;
    take IT;
    thus IT.0 = DIJK:Init(src) by A3;
    let n be Nat;
    reconsider n'= n as Element of NAT by ORDINAL1:def 13;
    consider Gn,Gn1 being DIJK:Labeling of G such that
A9: IT.n' = Gn & IT.(n+1) = Gn1 & Gn1 = DIJK:Step(Gn) by A3;
    thus thesis by A9;
  end;
  uniqueness
  proof
    let IT1,IT2 be DIJK:LabelingSeq of G such that
A10: IT1.0 = DIJK:Init(src) &
    for n being Nat holds IT1.(n+1) = DIJK:Step(IT1.n) and
A11: IT2.0 = DIJK:Init(src) &
    for n being Nat holds IT2.(n+1) = DIJK:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A12: P[0] by A10,A11;
    now
      let n be Element of NAT;
      assume P[n];
      then IT1.(n+1) = DIJK:Step(IT2.n) by A10
        .= IT2.(n+1) by A11;
      hence P[n+1];
    end;
    then
A13: for n being Element of NAT st P[n] holds P[n+1];
    for n being Element of NAT holds P[n] from NAT_1:sch 1(A12,A13);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

definition
  let G be real-weighted WGraph, src be Vertex of G;
  func DIJK:SSSP(G,src) -> DIJK:Labeling of G equals  ::dDIJKSSSP
  DIJK:CompSeq(src).Result();
  coherence
  proof
    set DCS = DIJK:CompSeq(src);
    DCS.Result() = DCS.(DCS.Lifespan());
    hence thesis;
  end;
end;

begin :: Dijkstra's Algorithm Theorems

theorem Th13: ::tDSTEP01
for G being finite real-weighted WGraph, L be DIJK:Labeling of G
 holds
  (card dom (DIJK:Step(L))`1 = card dom L`1 iff DIJK:NextBestEdges(L) = {}) &
  (card dom (DIJK:Step(L))`1 = card dom L`1 + 1 iff DIJK:NextBestEdges(L)<>{})
proof
  let G be finite real-weighted WGraph, L be DIJK:Labeling of G;
  set BestEdges = DIJK:NextBestEdges(L), e = choose BestEdges;
  set nextEG = L`2 \/ {e}, nL = DIJK:Step(L);
  set src = (the_Source_of G).e, target = (the_Target_of G).e;
  set val = (L`1).src + (the_Weight_of G).e;
  hereby
    assume
A1: card dom nL`1 = card dom L`1;
    now
      assume
A2:   BestEdges <> {};
      then
A3:   e in BestEdges;
      nL = [L`1+*(target .--> val), nextEG] by A2,Def5;
     then nL`1 = L`1+*(target .--> val) by MCART_1:7;
     then
AAd: dom nL`1 = dom L`1 \/ {target} by Tw0;
      reconsider target as Vertex of G by A3,FUNCT_2:7;
      e DSJoins dom L`1,the_Vertices_of G \ dom L`1, G by A2,Def4;
      then target in the_Vertices_of G \ dom L`1 by GLIB_000:def 18;
      then not target in dom L`1 by XBOOLE_0:def 5;
      then card dom nL`1 = card dom L`1 + 1 by AAd,CARD_2:54;
      hence contradiction by A1;
    end;
    hence BestEdges = {};
  end;
  thus BestEdges = {} implies card dom nL`1 = card dom L`1 by Def5;
  hereby
    assume
A6: card dom nL`1 = card dom L`1 + 1;
    now
      assume BestEdges = {};
      then 0 + card dom L`1 = card dom L`1 + 1 by A6,Def5;
      hence contradiction;
    end;
    hence BestEdges <> {};
  end;
  assume
A7: BestEdges <> {};
  then
A8: e in BestEdges;
    nL = [L`1+*(target .--> val), nextEG] by A7,Def5;
    then nL`1 = L`1+*(target .--> val) by MCART_1:7;
     then
AAd: dom nL`1 = dom L`1 \/ {target} by Tw0;
  reconsider target as Vertex of G by A8,FUNCT_2:7;
  e DSJoins dom L`1,the_Vertices_of G \ dom L`1, G by A7,Def4;
  then target in the_Vertices_of G \ dom L`1 by GLIB_000:def 18;
  then not target in dom L`1 by XBOOLE_0:def 5;
  hence thesis by AAd,CARD_2:54;
end;

theorem Th14: ::tDSTEP02
  for G being real-weighted WGraph, L be DIJK:Labeling of G
   holds dom L`1 c= dom (DIJK:Step(L))`1 & L`2 c= (DIJK:Step(L))`2
proof
  let G be real-weighted WGraph, L be DIJK:Labeling of G;
  set nL = DIJK:Step(L);
  set BestEdges = DIJK:NextBestEdges(L), e = choose BestEdges;
  set NextEG = L`2 \/ {e}, target = (the_Target_of G).e;
  set val = (L`1).((the_Source_of G).e) + (the_Weight_of G).e;
  now per cases;
    suppose BestEdges = {};
      hence thesis by Def5;
    end;
    suppose
A1:   BestEdges <> {};
      then
A2:  nL = [L`1+*(target .--> val), NextEG] by Def5;
     then nL`1 = L`1+*(target .--> val) by MCART_1:7;
     then
AAd: dom nL`1 = dom L`1 \/ {target} by Tw0;
     e in BestEdges by A1;
      then reconsider target as Vertex of G by FUNCT_2:7;
      now
        let x be set;
        assume
A7:     x in dom L`1;
        dom L`1 c= dom nL`1 by AAd,XBOOLE_1:7;
        hence x in dom nL`1 by A7;
      end;
      hence dom L`1 c= dom nL`1 by TARSKI:def 3;
      now
        let x be set;
        assume
A5:     x in L`2;
A6:     L`2 c= NextEG by XBOOLE_1:7;
        NextEG = nL`2 by A2,MCART_1:7;
        hence x in nL`2 by A5,A6;
      end;
      hence L`2 c= nL`2 by TARSKI:def 3;
    end;
  end;
  hence thesis;
end;

theorem Th15: ::tDIJKINIT01
  for G being real-weighted WGraph, src be Vertex of G
   holds dom ((DIJK:Init(src))`1) = {src}
proof
  let G be real-weighted WGraph, src be Vertex of G;
  set G2 = DIJK:Init(src);
  G2`1 = src .--> 0 by MCART_1:7;
  hence thesis by FUNCOP_1:19;
end;

theorem Th16: ::tDCS01
for G being real-weighted WGraph, src being Vertex of G, i,j being Nat
 st i <= j
  holds dom ((DIJK:CompSeq(src).i))`1 c= dom (DIJK:CompSeq(src).j)`1 &
        (DIJK:CompSeq(src).i)`2 c= (DIJK:CompSeq(src).j)`2
proof
  let G be real-weighted WGraph, src be Vertex of G, i,j be Nat;
  set DCS = DIJK:CompSeq(src);  set dDCS = dom (DCS.i)`1;
  set eDCS = (DCS.i)`2;
  assume i <= j;
  then consider x being Nat such that
A1: j = i + x by NAT_1:10;
  defpred P[Nat] means dDCS c= dom (DCS.(i+$1))`1 & eDCS c= (DCS.(i+$1))`2;
A3: P[0];
  now
    let k be Nat;
    assume
A4: dDCS c= dom (DCS.(i+k))`1 & eDCS c= (DCS.(i+k))`2;
    DCS.(i+k+1) = DIJK:Step(DCS.(i+k)) by Def7;
    then dom (DCS.(i+k))`1 c= dom (DCS.(i+k+1))`1 &
    (DCS.(i+k))`2 c= (DCS.(i+k+1))`2 by Th14;
    hence dDCS c= dom (DCS.(i+(k+1)))`1 &
    eDCS c= (DCS.(i+(k+1)))`2 by A4,XBOOLE_1:1;
  end;
  then
A5: for k being Nat st P[k] holds P[k+1];
  for k being Nat holds P[k] from NAT_1:sch 2(A3,A5);
  hence thesis by A1;
end;

theorem Th18: ::tDCS03
for G being finite real-weighted WGraph, src being Vertex of G, n being Nat
 holds dom (DIJK:CompSeq(src).n)`1 c= G.reachableDFrom(src)
proof
  let G be finite real-weighted WGraph, src be Vertex of G;
  set DCS = DIJK:CompSeq(src);
  defpred P[Nat] means dom (DCS.$1)`1 c= G.reachableDFrom(src);
  DCS.0 = DIJK:Init(src) by Def7;
  then
A1: dom (DCS.0)`1 = {src} by Th15;
  src in G.reachableDFrom(src) by GLIB_002:18;
  then
A2: P[0] by A1,ZFMISC_1:37;
  now
    let k be Nat such that
A3: dom (DCS.k)`1 c= G.reachableDFrom(src);
    set Gk = DCS.k, NextG = DCS.(k+1);
    set BestEdges = DIJK:NextBestEdges(Gk), e = choose BestEdges;
    set NextEG = Gk`2 \/ {e};
    set v1 = (the_Source_of G).e, target = (the_Target_of G).e;
    set pc = Gk`1.v1, ec = (the_Weight_of G).e;
A4: NextG = DIJK:Step(Gk) by Def7;
    now
      let x be set;
      assume
A5:   x in dom (DCS.(k+1))`1;
      now per cases;
        suppose BestEdges = {};
          then Gk = NextG by A4,Def5;
          hence x in G.reachableDFrom(src) by A3,A5;
        end;
        suppose
A6:       BestEdges <> {};
          then
A6a:      NextG = [Gk`1+*(target .--> (pc+ec)),NextEG] by A4,Def5;
A7:       NextG`1 = Gk`1+*(target .--> (pc+ec)) by A6a,MCART_1:7;
          set xx = x;
          reconsider xx as Vertex of G by A5;
          e DSJoins dom Gk`1,the_Vertices_of G \ dom Gk`1,G
          by A6,Def4;
          then
A8:       v1 in dom Gk`1 by GLIB_000:def 18;
          then reconsider v1' = v1 as Vertex of G;
          now per cases;
            suppose xx in dom Gk`1;
              hence xx in G.reachableDFrom(src) by A3;
            end;
            suppose S1: not xx in dom Gk`1;
              now
                e in BestEdges by A6;
                hence e in the_Edges_of G;
                thus (the_Source_of G).e = v1;
                thus (the_Target_of G).e = xx by A5,A7,S1,Tw3;
              end;
              then e DJoins v1',xx,G by GLIB_000:def 16;
              hence xx in G.reachableDFrom(src) by A3,A8,GLIB_002:19;
            end;
          end;
          hence x in G.reachableDFrom(src);
        end;
      end;
      hence x in G.reachableDFrom(src);
    end;
    hence dom (DCS.(k+1))`1 c= G.reachableDFrom(src) by TARSKI:def 3;
  end;
  then
A12: for k being Nat st P[k] holds P[k+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A2,A12);
  hence thesis;
end;

theorem Th19: ::tDCS05
for G being finite real-weighted WGraph, src being Vertex of G, n being Nat
 holds DIJK:NextBestEdges(DIJK:CompSeq(src).n) = {}
   iff dom (DIJK:CompSeq(src).n)`1 = G.reachableDFrom(src)
proof
  let G be finite real-weighted WGraph, src be Vertex of G,
  n be Nat;
  set DCS = DIJK:CompSeq(src), RFS = G.reachableDFrom(src);
  set Gn = DCS.n, Gn1a = DCS.(n+1);
  set BestEdges = DIJK:NextBestEdges(Gn);
  set SGn = the_Source_of G;
  set TGn = the_Target_of G;
A1: Gn1a = DIJK:Step(Gn) by Def7;
  hereby
    assume
A2: BestEdges = {};
    now
      assume
A3:   dom Gn`1 <> RFS;
      dom Gn`1 c= RFS by Th18;
      then
A4:   dom Gn`1 c< RFS by A3,XBOOLE_0:def 8;
      defpred P[set] means SGn.$1 in dom Gn`1 &
      not TGn.$1 in dom Gn`1;
      consider BE1 being Subset of the_Edges_of G such that
A5:   for x being set holds x in BE1 iff x in the_Edges_of G & P[x]
      from SUBSET_1:sch 1;
      now
        assume
A6:     BE1 = {};
        consider v being set such that
A7:     v in RFS & not v in dom Gn`1 by A4,XBOOLE_0:6;
        reconsider v as Vertex of G by A7;
        consider W being directed Walk of G such that
A8:     W is_Walk_from src, v by A7,GLIB_002:def 6;
        DCS.0 = DIJK:Init(src) by Def7;
        then dom (DCS.0)`1 = {src} by Th15;
        then
A9:     src in dom (DCS.0)`1 by TARSKI:def 1;
A10:    dom (DCS.0)`1 c= dom Gn`1 by Th16;
        defpred P[Nat] means $1 is odd & $1 <= len W &
        not (W.$1 in dom Gn`1);
        W.(len W) = W.last() by GLIB_001:def 7
          .= v by A8,GLIB_001:def 23;
        then
A11:    ex k being Nat st P[k] by A7;
        consider k being Nat such that
A12:    P[k] & for m being Nat st P[m] holds k <= m from NAT_1:sch 5(A11);
        now per cases;
          suppose k = 1;
            then W.k = W.first() by GLIB_001:def 6
              .= src by A8,GLIB_001:def 23;
            hence contradiction by A9,A10,A12;
          end;
          suppose
A13:        k <> 1;
            reconsider k'=k as odd Element of NAT by A12,ORDINAL1:def 13;
            1 <= k by A12,HEYTING3:1;
            then 1 < k by A13,XXREAL_0:1;
            then 1+1 < k+1 by XREAL_1:10;
            then 2*1 <= k by NAT_1:13;
            then reconsider k2a = k'-2*1 as odd Element of NAT by INT_1:18;
A14:        k - 2 < len W - 0 by A12,XREAL_1:17;
            k2a < k - 0 by XREAL_1:17;
            then
A15:        W.(k2a) in dom Gn`1 by A12,A14;
            set e = W.(k2a+1);
            e DJoins W.k2a, W.(k2a+2), G by A14,GLIB_001:123;
            then e in the_Edges_of G & (the_Source_of G).e = W.k2a
            & (the_Target_of G).e = W.(k2a+2) by GLIB_000:def 16;
            hence contradiction by A5,A6,A12,A15;
          end;
        end;
        hence contradiction;
      end;
      then reconsider BE1 as non empty finite set;
      deffunc F(Element of BE1) = (Gn`1).((the_Source_of G).$1) +
      (the_Weight_of G).($1);
      consider e1 being Element of BE1 such that
A17:  for e2 being Element of BE1 holds F(e1) <= F(e2) from GRAPH_5:sch 2;
A18:  e1 in the_Edges_of G & (SGn).e1 in dom Gn`1 &
      not (TGn).e1 in dom Gn`1 by A5;
      then (TGn).e1 in the_Vertices_of G by FUNCT_2:7;
      then (TGn).e1 in the_Vertices_of G \ dom Gn`1
      by A18,XBOOLE_0:def 5;
      then
A19:  e1 DSJoins dom Gn`1, the_Vertices_of G \ dom Gn`1, G
      by A18,GLIB_000:def 18;
      now
        let y be set;
        assume y DSJoins dom Gn`1, the_Vertices_of G \ dom Gn`1,G;
        then
A20:    y in the_Edges_of G & (SGn).y in dom Gn`1 &
        (TGn).y in the_Vertices_of G \ dom Gn`1 by GLIB_000:def 18;
        then not (TGn).y in dom Gn`1 by XBOOLE_0:def 5;
        then y in BE1 by A5,A20;
        hence (Gn`1).((the_Source_of G).e1) +
        (the_Weight_of G).e1 <= (Gn`1).((the_Source_of G).y) +
        (the_Weight_of G).y by A17;
      end;
      hence contradiction by A2,A19,Def4;
    end;
    hence dom (DCS.n)`1 = RFS;
  end;
  assume
A21: dom (DCS.n)`1 = RFS;
  now
    assume BestEdges <> {};
    then
A22: card dom Gn1a`1 = card RFS + 1 by A1,A21,Th13;
    card dom Gn1a`1 c= card RFS by Th18,CARD_1:27;
    then card RFS + 1 <= card RFS + 0 by A22,NAT_1:40;
    hence contradiction by XREAL_1:8;
  end;
  hence thesis;
end;

theorem Th20: ::tDCS06
for G being finite real-weighted WGraph, s being Vertex of G, n being Nat
 holds card dom (DIJK:CompSeq(s).n)`1 = min(n+1, card(G.reachableDFrom(s)))
proof
  let G be finite real-weighted WGraph, src be Vertex of G;
  set DCS = DIJK:CompSeq( src), VL0 = dom (DCS.0)`1;
  set RFS = G.reachableDFrom(src);
  defpred P[Nat] means card dom (DCS.$1)`1 = min($1+1, card RFS);
  DCS.0 = DIJK:Init(src) by Def7;
  then
A1: card VL0 = card {src} by Th15
    .= 1 by CARD_1:50;
  src in RFS by GLIB_002:18;
  then {src} c= RFS by ZFMISC_1:37;
  then card {src} <= card RFS by NAT_1:44;
  then 0+1 <= card RFS by CARD_1:50;
  then
A2: P[0] by A1,XXREAL_0:def 9;
  now
    let k be Nat such that
A3: card dom (DCS.k)`1 = min(k+1, card RFS);
A4: DCS.(k+1) = DIJK:Step(DCS.k) by Def7;
    set Gk = DCS.k, Gk1b = DCS.(k+1);
    set BestEdges = DIJK:NextBestEdges(Gk);
    now per cases;
      suppose
A5:     BestEdges = {};
        then
A6:     card dom Gk1b`1 = card dom Gk`1 by A4,Th13;
A7:     card dom Gk`1 = card RFS by A5,Th19;
A8:     card dom Gk1b`1 = card RFS by A5,A6,Th19;
        card RFS <= k+1 by A3,A7,XXREAL_0:def 9;
        then card RFS <= k+1+1 by NAT_1:12;
        hence card dom Gk1b`1 = min((k+1)+1, card RFS)
        by A8,XXREAL_0:def 9;
      end;
      suppose
A9:     BestEdges <> {};
        then
A10:    card dom Gk1b`1 = card dom Gk`1 + 1 by A4,Th13;
A11:    dom Gk`1 <> RFS by A9,Th19;
A12:    now
          assume
A13:      card dom Gk`1 = card RFS;
          dom Gk`1 c= RFS by Th18;
          then dom Gk`1 c< RFS by A11,XBOOLE_0:def 8;
          hence contradiction by A13,CARD_2:67;
        end;
        then
A14:    card dom Gk1b`1 = (k+1)+1 by A3,A10,XXREAL_0:15;
        k+1 <= card RFS & (k+1) <> card RFS by A3,A12,XXREAL_0:def 9;
        then
A15:    k+1+1 <= card RFS + 1 by XREAL_1:8;
        k+1+1 <> card RFS + 1 by A3,A12;
        then k+1+1 < card RFS + 1 by A15,XXREAL_0:1;
        then (k+1+1) <= card RFS by NAT_1:13;
        hence card dom Gk1b`1 = min((k+1)+1, card RFS)
        by A14,XXREAL_0:def 9;
      end;
    end;
    hence card dom (DCS.(k+1))`1 = min((k+1)+1, card RFS);
  end;
  then
A16: for k being Nat st P[k] holds P[k+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A2,A16);
  hence thesis;
end;

theorem Th21: ::tDCS07
for G being finite real-weighted WGraph, src being Vertex of G, n being Nat
 holds (DIJK:CompSeq(src).n)`2
    c= G.edgesBetween(dom (DIJK:CompSeq(src).n)`1)
proof
  let G be finite real-weighted WGraph, src be Vertex of G;
  set DCS = DIJK:CompSeq(src), D0 = DCS.0;
  defpred P[Nat] means (DCS.$1)`2 c= G.edgesBetween(dom ((DCS.$1)`1));
  D0=DIJK:Init(src) by Def7;  ::  then D0`2 = {} by MCART_1:7;
  then for x being set st x in D0`2 holds x in G.edgesBetween(dom D0`1)
   by MCART_1:7;
  then
A1: P[0] by TARSKI:def 3;
  now
    let n be Nat;
    set Dn = DCS.n, Dn1 = DCS.(n+1);
    set BE = DIJK:NextBestEdges(Dn), e = choose BE;
    set target = (the_Target_of G).e;
    set val= (Dn`1).((the_Source_of G).e)+(the_Weight_of G).e;
    set DnE = Dn`2 \/ {e};
    assume
A2: Dn`2 c= G.edgesBetween(dom Dn`1);
A3: Dn1 = DIJK:Step(Dn) by Def7;

    now
      let x be set;
      assume
A5:   x in Dn1`2;
      n <= n+1 by NAT_1:12;
      then
A6:   dom Dn`1 c= dom Dn1`1 & Dn`2 c= Dn1`2 by Th16;
      now per cases;
        suppose BE = {};
          then Dn1 = Dn by A3,Def5;
          hence x in G.edgesBetween(dom Dn1`1) by A2,A5;
        end;
        suppose
A7:       BE <> {};
          then
AAa:      Dn1 = [Dn`1+*(target .--> val),DnE] by A3,Def5;
A8:       Dn1`1 = Dn`1+*(target .--> val) by AAa,MCART_1:7;
A9:       e in BE by A7;
A11a:     Dn1`2 = DnE by AAa,MCART_1:7;
A13:      dom Dn1`1 = dom Dn`1 \/ {target} by Tw0,A8;
          now per cases by A5,A11a,XBOOLE_0:def 3;
            suppose S1: x in Dn`2;
            B1a:  Dn`2 in bool the_Edges_of G by MCART_1:10;
              x in Dn`2 &
              (the_Source_of G).x in dom Dn`1 &
              (the_Target_of G).x in dom Dn`1 by S1,A2,GLIB_000:34;
              hence x in G.edgesBetween(dom Dn1`1) by A6,B1a,GLIB_000:34;
            end;
            suppose x in {e};
              then
A14:          x = e by TARSKI:def 1;
              then (the_Target_of G).x in {target} by TARSKI:def 1;
              then
A15:          (the_Target_of G).x in dom Dn1`1 by A13,XBOOLE_0:def 3;
              e DSJoins dom Dn`1,the_Vertices_of G \ dom Dn`1,G by A7,Def4;
              then (the_Source_of G).x in dom Dn`1
              by A14,GLIB_000:def 18;
              hence x in G.edgesBetween(dom Dn1`1)
              by A6,A9,A14,A15,GLIB_000:34;
            end;
          end;
          hence x in G.edgesBetween(dom Dn1`1);
        end;
      end;
      hence x in G.edgesBetween(dom Dn1`1);
    end;
    hence Dn1`2 c= G.edgesBetween(dom Dn1`1) by TARSKI:def 3;
  end;
  then
A16: for k being Nat st P[k] holds P[k+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A1,A16);
  hence thesis;
end;

theorem Th22: ::tDCS08
for G being finite nonnegative-weighted WGraph,
    s being Vertex of G, n being Nat,
    G2 being inducedWSubgraph of
                       G, dom (DIJK:CompSeq(s).n)`1, (DIJK:CompSeq(s).n)`2
 holds G2 is_mincost_DTree_rooted_at s &
  for v being Vertex of G st v in dom (DIJK:CompSeq(s).n)`1
   holds G.min_DPath_cost(s,v) = (DIJK:CompSeq(s).n)`1.v
proof
  let G be finite nonnegative-weighted WGraph, src be Vertex of G;
  set DCS = DIJK:CompSeq(src), D0 = DCS.0;
  defpred P[Nat] means
  for G2 being inducedWSubgraph of G,dom (DCS.$1)`1,(DCS.$1)`2
  holds
    G2 is_mincost_DTree_rooted_at src &
    for v being Vertex of G st v in dom (DCS.$1)`1
     holds G.min_DPath_cost(src,v) = (DCS.$1)`1.v;
  reconsider EL = {} as PartFunc of the_Edges_of G, REAL by RELSET_1:25;
A1: D0 = DIJK:Init(src) by Def7;
  then
A2: D0`1 = src .--> 0 by MCART_1:7;
  then
A3: dom D0`1 = {src} by FUNCOP_1:19;
A4: D0`2 = {} by A1,MCART_1:7;
  now
    let D0W be inducedWSubgraph of G,dom D0`1,D0`2;
    {} c= G.edgesBetween(dom D0`1) by XBOOLE_1:2;
    then
A5: the_Vertices_of D0W = {src} & the_Edges_of D0W = {}
    by A3,A4,GLIB_000:def 39;
    then
A6: card (the_Vertices_of D0W) = 1 & card (the_Edges_of D0W) = 0
    by CARD_1:50;
A7: D0W.order() = D0W.size() + 1 by A5,CARD_1:47,50;
    D0W is trivial by A6,GLIB_000:def 21;
    then
A8: D0W is Tree-like by A7,GLIB_002:47;
    now
      let x be Vertex of D0W;
A9:   x = src by A5,TARSKI:def 1;
      set W2 = D0W.walkOf(x);
      take W2;
      thus W2 is_Walk_from src,x by A9,GLIB_001:14;
      let W1 be DPath of G;
      assume W1 is_Walk_from src,x;
      0 <= W1.cost() by GLIB_003:36;
      hence W2.cost() <= W1.cost() by GLIB_003:28;
    end;
    hence D0W is_mincost_DTree_rooted_at src by A8,Def1;
    let v be Vertex of G;
    assume
A10: v in dom D0`1;
    then
A11: v = src by A3,TARSKI:def 1;
A12: D0`1.src = 0 by A2,FUNCOP_1:87;
    now
      set W1 = G.walkOf(v);
A13:  W1 is_Walk_from src,v by A11,GLIB_001:14;
      then consider W being DPath of G such that
A14:  W is_mincost_DPath_from src,v & G.min_DPath_cost(src,v) = W.cost()
      by Def3;
      W1.cost() = 0 by GLIB_003:28;
      then W.cost() <= 0 by A13,A14,Def2;
      hence G.min_DPath_cost(src,v) = 0 by A14,GLIB_003:36;
    end;
    hence G.min_DPath_cost(src,v) = D0`1.v
    by A3,A10,A12,TARSKI:def 1;
  end;
  then
A15: P[0];
  now
    let n be Nat;
    set Dn = DCS.n, Dn1 = DCS.(n+1);
    set BE = DIJK:NextBestEdges(Dn), e = choose BE;
    set source = (the_Source_of G).e, target = (the_Target_of G).e;
    set DnE = Dn`2 \/ {e};
    set pc = Dn`1.source;
    set ec = (the_Weight_of G).e;
    consider DnW being inducedWSubgraph of G,dom Dn`1,Dn`2;
    assume
A16: P[n];
    let Dn1W be inducedWSubgraph of G,dom Dn1`1, Dn1`2;
A17: Dn1 = DIJK:Step(Dn) by Def7;
A21: src in dom D0`1 by A3,TARSKI:def 1;
A23: dom D0`1 c= dom Dn`1 by Th16;
A25: Dn`2 c= G.edgesBetween(dom Dn`1) by Th21;
A26: Dn`2 c= G.edgesBetween(dom Dn`1) by Th21;
    then
A27: the_Vertices_of DnW = dom Dn`1 &
    the_Edges_of DnW = Dn`2 by A21,A23,GLIB_000:def 39;
A28: card dom Dn`1 = DnW.order() &
     card Dn`2 = DnW.size() by A21,A23,A25,GLIB_000:def 39;
A29: DnW is_mincost_DTree_rooted_at src by A16;
    then
A30: DnW is Tree-like by Def1;
    now per cases;
      suppose BE = {};
        then Dn1 = Dn by A17,Def5;
        hence Dn1W is_mincost_DTree_rooted_at src &
        for v being Vertex of G st v in dom Dn1`1
        holds G.min_DPath_cost(src,v) = Dn1`1.v by A16;
      end;
      suppose
A32:    BE <> {};
        then
A33:    e in BE & Dn1 = [Dn`1+*(target .--> (pc+ec)), DnE] by A17,Def5;
        Dn1`1 = Dn`1+*(target .--> (pc+ec)) by A33,MCART_1:7;
        then
A35:    Dn1`2 = DnE &
        dom Dn1`1 = dom Dn`1 \/ {target} by A33,Tw0,MCART_1:7;
        Dn1`2 c= G.edgesBetween(dom Dn1`1) by Th21;
        then
A40:    the_Vertices_of Dn1W = dom Dn`1 \/ {target} &
        the_Edges_of Dn1W =(Dn`2 \/ {e}) by A35,GLIB_000:def 39;
A41:    e DSJoins dom Dn`1, the_Vertices_of G \ dom Dn`1, G
        by A32,Def4;
        then
A42:    target in the_Vertices_of G\dom Dn`1 by GLIB_000:def 18;
        then
A43:    not target in dom Dn`1 by XBOOLE_0:def 5;
        then
A44:    card (dom Dn`1 \/ {target}) = card dom Dn`1 + 1
        by CARD_2:54;
A45:    not e in Dn`2 by A25,A43,GLIB_000:34;
        then Dn1W.size() = DnW.size() + 1 by A28,A40,CARD_2:54;
        then
A46:    Dn1W.order() = Dn1W.size() + 1 by A28,A30,A40,A44,GLIB_002:47;
A48:    now thus the_Vertices_of DnW c= the_Vertices_of Dn1W &
          the_Edges_of DnW c= the_Edges_of Dn1W by A27,A40,XBOOLE_1:7;
          let e be set;
          assume
A49:      e in the_Edges_of DnW;
          then
A50:      e in the_Edges_of Dn1W by A27,A40,XBOOLE_0:def 3;
         (the_Source_of DnW).e = (the_Source_of G).e &
          (the_Target_of DnW).e = (the_Target_of G).e by A49,GLIB_000:def 34;
          hence (the_Source_of DnW).e = (the_Source_of Dn1W).e &
          (the_Target_of DnW).e = (the_Target_of Dn1W).e
          by A50,GLIB_000:def 34;
        end;
        then
A52:    DnW is Subgraph of Dn1W by GLIB_000:def 34;
        reconsider DnW' = DnW as [Weighted] Subgraph of Dn1W
        by A48,GLIB_000:def 34;
A53:    the_Weight_of DnW' = (the_Weight_of G)| the_Edges_of DnW
        by GLIB_003:def 10;
A54:    the_Weight_of Dn1W = (the_Weight_of G)| the_Edges_of Dn1W
        by GLIB_003:def 10;
        dom the_Weight_of Dn1W = the_Edges_of Dn1W by PARTFUN1:def 4
;
        then dom (the_Weight_of Dn1W)/\the_Edges_of DnW = the_Edges_of DnW
        by A48,XBOOLE_1:28;
        then
A55:    dom the_Weight_of DnW'=dom (the_Weight_of Dn1W)/\ the_Edges_of DnW
        by PARTFUN1:def 4;
        now
          let y be set;
          assume y in dom the_Weight_of DnW';
          then
A56:      y in the_Edges_of DnW by PARTFUN1:def 4;
          hence (the_Weight_of DnW').y = (the_Weight_of G).y by A53,FUNCT_1:72
            .= (the_Weight_of Dn1W).y by A48,A54,A56,FUNCT_1:72;
        end;
        then the_Weight_of DnW' = (the_Weight_of Dn1W) | the_Edges_of DnW
        by A55,FUNCT_1:68;
        then
A57:    DnW is WSubgraph of Dn1W by GLIB_003:def 10;
A58:    source in dom Dn`1 by A41,GLIB_000:def 18;
        e in {e} by TARSKI:def 1;
        then
A59:    e in the_Edges_of Dn1W by A40,XBOOLE_0:def 3;
        e DJoins source, target, G by A33,GLIB_000:def 16;
        then
A60:    e DJoins source, target, Dn1W by A59,GLIB_000:76;
        then
A61:    e Joins source, target, Dn1W by GLIB_000:19;
        now
          let u,v be Vertex of Dn1W;
A62:      now
            let u,v be set;
            assume u in dom Dn`1 & v in dom Dn`1;
            then reconsider u'=u, v'=v as Vertex of DnW
            by A26,GLIB_000:def 39;
            consider W1 being Walk of DnW such that
A63:        W1 is_Walk_from u',v' by A30,GLIB_002:def 1;
            reconsider W2=W1 as Walk of Dn1W by A52,GLIB_001:168;
            W2 is_Walk_from u,v by A63,GLIB_001:20;
            hence ex W being Walk of Dn1W st W is_Walk_from u,v;
          end;
          now per cases by A40,XBOOLE_0:def 3;
            suppose u in dom Dn`1 & v in dom Dn`1;
              hence ex W being Walk of Dn1W st W is_Walk_from u,v by A62;
            end;
            suppose
A64:          u in dom Dn`1 & v in {target};
              then consider W being Walk of Dn1W such that
A65:          W is_Walk_from u,source by A58,A62;
A66:          W.addEdge(e) is_Walk_from u,target by A61,A65,GLIB_001:67;
              v = target by A64,TARSKI:def 1;
              hence ex W being Walk of Dn1W st W is_Walk_from u,v by A66;
            end;
            suppose
A67:          u in {target} & v in dom Dn`1;
              then consider W being Walk of Dn1W such that
A68:          W is_Walk_from v,source by A58,A62;
              W.addEdge(e) is_Walk_from v,target by A61,A68,GLIB_001:67;
              then W.addEdge(e) is_Walk_from v,u by A67,TARSKI:def 1;
              then W.addEdge(e).reverse() is_Walk_from u,v by GLIB_001:24;
              hence ex W being Walk of Dn1W st W is_Walk_from u,v;
            end;
            suppose u in {target} & v in {target};
              then
A69:          u = target & v = target by TARSKI:def 1;
              take W = Dn1W.walkOf(u);
              thus W is_Walk_from u,v by A69,GLIB_001:14;
            end;
          end;
          hence ex W being Walk of Dn1W st W is_Walk_from u,v;
        end;
        then Dn1W is connected by GLIB_002:def 1;
        then
A70:    Dn1W is Tree-like by A46,GLIB_002:47;
        now consider WT being DPath of DnW such that
A71:      WT is_Walk_from src,source &
          for W1 being DPath of G st W1 is_Walk_from src,source
          holds WT.cost() <= W1.cost() by A27,A29,A58,Def1;
          reconsider WT'=WT as DPath of Dn1W by A52,GLIB_001:176;
          set W2 = WT'.addEdge(e);
A72:      WT' is_Walk_from src,source by A71,GLIB_001:20;
          then reconsider W2 as DWalk of Dn1W by A60,GLIB_001:124;
          now target in {target} by TARSKI:def 1;
            hence target is Vertex of Dn1W by A40,XBOOLE_0:def 3;
            thus e Joins WT'.last(),target,Dn1W by A61,A72,GLIB_001:def 23;
A73:        not e in the_Edges_of DnW by A21,A23,A25,A45,GLIB_000:def 39;
            WT.edges() = WT'.edges() by GLIB_001:111;
            hence not e in WT'.edges() by A73;
            now
              assume
A74:          WT' is non trivial;
              now
                assume WT' is closed;
                then WT' is Cycle-like by A74,GLIB_001:def 31;
                hence contradiction by A70,GLIB_002:def 2;
              end;
              hence WT' is open;
            end;
            hence WT' is trivial or WT' is open;
            WT'.vertices() = WT.vertices() by GLIB_001:99;
            then
A76:        not target in WT'.vertices() by A27,A42,XBOOLE_0:def 5;
            let n be odd Element of NAT;
            assume 1 < n & n <= len WT';
            hence WT'.n <> target by A76,GLIB_001:88;
          end;
          then reconsider W2 as DPath of Dn1W by GLIB_001:151;
          take W2;
          thus W2 is_Walk_from src,target by A61,A72,GLIB_001:67;
          now
A77:        WT'.last() = source by A72,GLIB_001:def 23;
A78:        e in the_Edges_of Dn1W &
            (the_Source_of Dn1W).e = source by A60,GLIB_000:def 16;
            hence e in WT'.last().edgesInOut() by A77,GLIB_000:64;
            (the_Weight_of Dn1W).e = ((the_Weight_of G) | the_Edges_of Dn1W).e
            by GLIB_003:def 10;
            hence ec = (the_Weight_of Dn1W).e by A78,FUNCT_1:72;
A79:        pc = G.min_DPath_cost(src,source) by A16,A58;
            reconsider WTG = WT as DPath of G by GLIB_001:176;
A80:        WTG is_Walk_from src,source by A71,GLIB_001:20;
            then consider WX being DPath of G such that
A81:        WX is_mincost_DPath_from src,source & pc = WX.cost() by A79,Def3;
            WX is_Walk_from src,source & for WY being DPath of G
            st WY is_Walk_from src,source holds pc <= WY.cost() by A81,Def2;
            then WT.cost() <= pc by A71,A81;
            then
A82:        WT'.cost() <= pc by A57,GLIB_003:34;
            pc <= WTG.cost() by A80,A81,Def2;
            then pc <= WT'.cost() by GLIB_003:34;
            hence WT'.cost() = pc by A82,XXREAL_0:1;
          end;
          hence W2.cost() = pc + ec by GLIB_003:32;
        end;
        then consider W2 being DPath of Dn1W such that
A83:    W2 is_Walk_from src,target & W2.cost() = pc+ec;
        reconsider W2G = W2 as DPath of G by GLIB_001:176;
A84:    W2G is_Walk_from src, target by A83,GLIB_001:20;
A85:    W2G.cost() = pc+ec by A83,GLIB_003:34;
A86:    src <> target by A21,A23,A42,XBOOLE_0:def 5;
        set mc = G.min_DPath_cost(src,target);
        now consider WB being DPath of G such that
A87:      WB is_mincost_DPath_from src,target & mc = WB.cost() by A84,Def3;
A88:      WB is_Walk_from src,target & for WA being DPath of G
          st WA is_Walk_from src,target holds WB.cost() <= WA.cost()
          by A87,Def2;
          thus mc <= pc+ec by A84,A85,A87,Def2;
          WB.first() = src & WB.last() = target by A88,GLIB_001:def 23;
          then
          consider lenWB2h being odd Element of NAT such that
A89:      lenWB2h = len WB - 2 &
          WB.cut(1,lenWB2h).addEdge(WB.(lenWB2h+1)) = WB by A86,GLIB_001:128
,134;
          set WA = WB.cut(1,lenWB2h);
          set sa = WB.lenWB2h, ea = WB.(lenWB2h+1);
A90:      1 <= lenWB2h & 1 is odd by HEYTING3:1,JORDAN12:3;
A91:      lenWB2h < len WB - 0 by A89,XREAL_1:17;
A92:      WB.1 = WB.first() by GLIB_001:def 6
            .= src by A88,GLIB_001:def 23;
          then WA is_Walk_from src,sa by A90,A91,GLIB_001:38;
          then reconsider sa as Vertex of G by GLIB_001:19;
          reconsider target'=target as Vertex of G by A88,GLIB_001:19;
A93:      ea DJoins sa, WB.(lenWB2h+2), G by A91,GLIB_001:123;
          then
A94a: ea DJoins sa, WB.last(), G by A89,GLIB_001:def 7;
          then ea DJoins sa, target, G by A88,GLIB_001:def 23;
          then ea Joins sa,target',G by GLIB_000:19;
          then ea in sa.edgesInOut() by GLIB_000:65;
          then
A95:      ea in WA.last().edgesInOut() by A90,A91,GLIB_001:38;
          then
A96:      mc = WA.cost() + (the_Weight_of G).ea by A87,A89,GLIB_003:32;

          reconsider WA as DPath of G;
A97:      WA.first() = src & WA.last() = sa by A90,A91,A92,GLIB_001:38;
          then
A98:      WA is_mincost_DPath_from src,sa by A87,Th10;
A99:      WA.cost() = G.min_DPath_cost(src,sa) by A87,A97,Th10,Th12;
A100:     ea DJoins sa, target, G by A88,A94a,GLIB_001:def 23;
          now
            assume
A101:       mc < pc+ec;
            defpred P[Nat] means $1 is odd & $1 <= len WA &
            not WA.$1 in dom Dn`1;
A102:       now
              assume
A103:         not sa in dom Dn`1;
              sa = WA.last() by A90,A91,GLIB_001:38
                .= WA.(len WA) by GLIB_001:def 7;
              then
A104:         ex k being Nat st P[k] by A103;
              consider k being Nat such that
A105:         P[k] & for m being Nat st P[m]
              holds k <= m from NAT_1:sch 5(A104);
              reconsider k as odd Element of NAT by A105,ORDINAL1:def 13;
              WA.1 = WA.first() by GLIB_001:def 6
                .= src by A90,A91,A92,GLIB_001:38;
              then
A106:         k <> 1 by A21,A23,A105;
              1 <= k by HEYTING3:1;
              then 1 < k by A106,XXREAL_0:1;
              then 1+1 < k+1 by XREAL_1:10;
              then 2 <= k by NAT_1:13;
              then reconsider k2a = k-2*1 as odd Element of NAT by INT_1:18;
              set sk = WA.k2a, ek = WA.(k2a+1), tk = WA.k;
A107:         1 is odd & 1 <= k2a & k2a < len WA - 0
              by A105,HEYTING3:1,JORDAN12:3,XREAL_1:17;
A108a:        k2a < k - 0 by XREAL_1:17;
              then
A108:         sk in dom Dn`1 by A105,A107;
              then reconsider sk as Vertex of G;
              reconsider tk as Vertex of G by A105,GLIB_001:8;
              set WK1 = WA.cut(1,k2a);
              set WKA = WA.cut(1,k), WKB = WA.cut(k,len WA);
              reconsider WK1, WKA, WKB as DPath of G;
              tk = WA.(k2a+2);
              then
A109:         ek DJoins sk,tk,G by A107,GLIB_001:123;
              then
A110:         ek in the_Edges_of G & (the_Source_of G).ek = sk &
              (the_Target_of G).ek = tk by GLIB_000:def 16;
A111:         WK1.first() = WA.1 & WK1.last() = sk by A107,GLIB_001:38;
              then WK1 is_mincost_DPath_from WA.1, sk by A98,Th10;
              then WK1 is_mincost_DPath_from WA.first(),sk by GLIB_001:def 6;
              then G.min_DPath_cost(src,sk) = WK1.cost() by A97,Th12;
              then
A112:         Dn`1.sk = WK1.cost() by A16,A108a,A105,A107;
              tk in the_Vertices_of G \ dom Dn`1 by A105,XBOOLE_0:def 5;
              then ek DSJoins dom Dn`1,the_Vertices_of G \ dom Dn`1,G
                                                  by A108,A110,GLIB_000:def 18;
              then
A113:         pc+ec <= WK1.cost() + (the_Weight_of G).ek
              by A32,A110,A112,Def4;
              k2a + 2 = k;
              then
A114:         WK1.addEdge(ek) = WKA by A107,GLIB_001:42;
              ek in the_Edges_of G & (the_Source_of G).ek = sk &
              (the_Target_of G).ek = tk by A109,GLIB_000:def 16;
              then ek in sk.edgesInOut() by GLIB_000:64;
              then
A115:         pc+ec <= WKA.cost() by A111,A113,A114,GLIB_003:32;
A116:         1 <= k & k <= len WA by A105,HEYTING3:1;
              then
A117:         WKA.append(WKB) = WA.cut(1,len WA) by GLIB_001:39,JORDAN12:3
                .= WA by GLIB_001:40;
              WKB.first() = WA.k by A105,GLIB_001:38
                .= WKA.last()
              by A116,GLIB_001:38,JORDAN12:3;
              then
A118:         WA.cost() = WKA.cost() + WKB.cost() by A117,GLIB_003:31;
              0 <= WKB.cost() by GLIB_003:36;
              then 0 qua Nat + WKA.cost() <= WA.cost() by A118,XREAL_1:9;
              then
A119:         pc+ec <= WA.cost() by A115,XXREAL_0:2;
              ea in the_Edges_of G by A93,GLIB_000:def 16;
              then 0 <= (the_Weight_of G).ea by GLIB_003:38;
              then pc+ec+(0 qua Nat) <= WA.cost()+(the_Weight_of G).ea
              by A119,XREAL_1:9;
              hence contradiction by A87,A89,A95,A101,GLIB_003:32;
            end;
            then
A120:       WA.cost() = Dn`1.sa by A16,A99;
A121:       ea in the_Edges_of G & (the_Source_of G).ea = sa &
            (the_Target_of G).ea=target by A100,GLIB_000:def 16;
            then ea DSJoins dom Dn`1, the_Vertices_of G \ dom Dn`1,G
             by A42,A102,GLIB_000:def 18;
            hence contradiction by A32,A96,A101,A120,A121,Def4;
          end;
          hence mc >= pc+ec;
        end;
        then
A122:   G.min_DPath_cost(src,target) = pc+ec by XXREAL_0:1;
        now
          let x be Vertex of Dn1W;
          now per cases by A40,XBOOLE_0:def 3;
            suppose x in dom Dn`1;
              then reconsider x'=x as Vertex of DnW
              by A26,GLIB_000:def 39;
              DnW is_mincost_DTree_rooted_at src by A16;
              then consider W2 being DPath of DnW such that
A123:         W2 is_Walk_from src,x' &
              for W1 being DPath of G st W1 is_Walk_from src,x'
              holds W2.cost() <= W1.cost() by Def1;
              reconsider W2'=W2 as DPath of Dn1W by A52,GLIB_001:176;
              take W2';
              thus W2' is_Walk_from src,x by A123,GLIB_001:20;
              let W1 be DPath of G;
              assume W1 is_Walk_from src,x;
              then W2.cost() <= W1.cost() by A123;
              hence W2'.cost() <= W1.cost() by A57,GLIB_003:34;
            end;
            suppose
A124:         x in {target};
              then
A125:         x = target by TARSKI:def 1;
              take W2;
              thus W2 is_Walk_from src,x by A83,A124,TARSKI:def 1;
              let W1 be DPath of G;
              assume
A126:         W1 is_Walk_from src,x;
              consider WX being DPath of G such that
A127:         WX is_mincost_DPath_from src, target & WX.cost()=W2 .cost()
              by A83,A84,A122,Def3;
              thus W2.cost() <= W1.cost() by A125,A126,A127,Def2;
            end;
          end;
          hence ex W2 being DPath of Dn1W st W2 is_Walk_from src,x &
          for W1 being DPath of G st W1 is_Walk_from src,x
          holds W2.cost() <= W1.cost();
        end;
        hence Dn1W is_mincost_DTree_rooted_at src by A70,Def1;
        let v be Vertex of G;
        assume
A128:   v in dom Dn1`1;
        now per cases by A35,A128,XBOOLE_0:def 3;
          suppose
A129:       v in dom Dn`1;
            then
A130:       G.min_DPath_cost(src,v) = Dn`1.v by A16;
A131:       Dn1`1 = Dn`1+*(target .-->(pc+ec)) by A33,MCART_1:7;
A132:       dom (target .--> (pc+ec)) = {target} by FUNCOP_1:19;
            then not v in dom (target .-->(pc+ec)) by A43,A129,TARSKI:def 1;
            hence G.min_DPath_cost(src,v)=(Dn1`1).v
            by A35,A128,A130,A131,A132,FUNCT_4:def 1;
          end;
          suppose
A133:       v in {target};
            then
A134:       v = target by TARSKI:def 1;
A135:       Dn1`1 = Dn`1+*(target .-->(pc+ec)) by A33,MCART_1:7;
            dom (target .--> (pc+ec)) = {target} by FUNCOP_1:19;
            then (Dn1`1).v = (target .--> (pc+ec)).v  by A133,A135,FUNCT_4:14;
            hence G.min_DPath_cost(src,v) = (Dn1`1).v by A122,A134,FUNCOP_1:87;
          end;
        end;
        hence G.min_DPath_cost(src,v) = (Dn1`1).v;
      end;
    end;
    hence Dn1W is_mincost_DTree_rooted_at src &
    for v being Vertex of G st v in dom Dn1`1
    holds G.min_DPath_cost(src,v) = (Dn1`1).v;
  end;
  then
A137: for k being Nat st P[k] holds P[k+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A15,A137);
  hence thesis;
end;

theorem Th23: ::tDIJK01
for G being finite real-weighted WGraph, s being Vertex of G
 holds DIJK:CompSeq(s) is halting
proof
  let G be finite real-weighted WGraph, src be Vertex of G;
  set DCS = DIJK:CompSeq( src);
  now
    take n = card G.reachableDFrom(src);
    set Gn = DCS.n, Gn1a = DCS.(n+1);
    set BestEdges = DIJK:NextBestEdges(Gn);
    set RSize = card G.reachableDFrom(src);
A1: Gn1a = DIJK:Step(Gn) by Def7;
    now per cases;
      suppose BestEdges = {};
        hence DCS.n = DCS.(n+1) by A1,Def5;
      end;
      suppose
A2:     BestEdges <> {};
A3:     card dom (DCS.n)`1 = min(n+1, RSize) by Th20;
        RSize <= RSize + 1 by NAT_1:11;
        then
A4:     card dom Gn`1 = RSize by A3,XXREAL_0:def 9;
A5:     card dom (DIJK:Step(Gn))`1 = card dom Gn`1 + 1 by A2,Th13;
A6:     RSize + 1 <= RSize + 1 + 1 by NAT_1:11;
        RSize <= (RSize+1) by NAT_1:11;
        then
A7:     RSize <= (n + 1) + 1 by A6,XXREAL_0:2;
        card dom Gn1a`1 = min((n+1)+1, RSize) by Th20
          .= RSize by A7,XXREAL_0:def 9;
        hence DCS.n = DCS.(n+1) by A4,A5,Def7;
      end;
    end;
    hence DCS.n = DCS.(n+1);
  end;
  hence thesis by GLIB_000:def 56;
end;

registration
  let G be finite real-weighted WGraph, src be Vertex of G;
  cluster DIJK:CompSeq(src) -> halting;
  coherence by Th23;
end;

theorem Th24: ::tDIJK02
for G being finite real-weighted WGraph, s being Vertex of G
 holds DIJK:CompSeq(s).Lifespan() + 1 = card G.reachableDFrom(s)
proof
  let G be finite real-weighted WGraph, src be Vertex of G;
  set DCS = DIJK:CompSeq(src), RFS = G.reachableDFrom(src);
  consider k being Nat such that
A1: card RFS = k + 1 by NAT_1:6;
  reconsider k as Element of NAT by ORDINAL1:def 13;
  set Gk = DCS.k, Gk1 = DCS.(k+1);
A2: Gk1 = DIJK:Step(Gk) by Def7;
A3: card dom Gk1`1 = min(card RFS+1, card RFS) by A1,Th20;
A4: card RFS <= card RFS + 1 by NAT_1:11;
  card dom Gk`1 = min(card RFS, card RFS) by A1,Th20;
  then card dom Gk1`1 = card dom Gk`1 by A3,A4,XXREAL_0:def 9;
  then DIJK:NextBestEdges(Gk) = {} by A2,Th13;
  then
A5: DCS.k = DCS.(k+1) by A2,Def5;
  now
    let n be Nat;
    assume
A6: DCS.n = DCS.(n+1);
    set Gn = DCS.n, Gn1 = DCS.(n+1);
    now
      assume n < k;
      then
A7:   n + 1 < card RFS by A1,XREAL_1:10;
      card dom Gn`1 = min(n+1, card RFS) by Th20;
      then
A8:   card dom Gn`1 = n+1 by A7,XXREAL_0:def 9;
A9:   card dom Gn1`1 = min(n+1+1, card RFS) by Th20;
      n + 1 + 1 <= card RFS by A7,NAT_1:13;
      then 0+(n+1) = 1+(n+1) by A6,A8,A9,XXREAL_0:def 9;
      hence contradiction;
    end;
    hence k <= n;
  end;
  hence thesis by A1,A5,GLIB_000:def 57;
end;

theorem Th25: ::tDIJK03
for G being finite real-weighted WGraph, s being Vertex of G
  holds dom (DIJK:SSSP(G,s))`1 = G.reachableDFrom(s)
proof
  let G be finite real-weighted WGraph, src be Vertex of G;
  set Gn = DIJK:SSSP(G, src), RFS = G.reachableDFrom(src);
  set DCS = DIJK:CompSeq(src), n = DCS.Lifespan();
A1: card (dom Gn`1) = min(n+1, card RFS) by Th20
    .= min(card RFS, card RFS) by Th24
    .= card RFS;
  now
    assume
A2: dom Gn`1 <> RFS;
    dom Gn`1 c= RFS by Th18;
    then dom Gn`1 c< RFS by A2,XBOOLE_0:def 8;
    hence contradiction by A1,TREES_1:24;
  end;
  hence thesis;
end;

theorem ::tDIJK04
for G being finite nonnegative-weighted WGraph, s being Vertex of G,
    G2 being inducedWSubgraph of G, dom (DIJK:SSSP(G,s))`1, DIJK:SSSP(G,s)`2
 holds G2 is_mincost_DTree_rooted_at s &
  for v being Vertex of G st v in G.reachableDFrom(s)
   holds v in the_Vertices_of G2 &
         G.min_DPath_cost(s,v) = (DIJK:SSSP(G,s))`1.v
proof
  let G be finite nonnegative-weighted WGraph, src be Vertex of G,
  G2 be inducedWSubgraph of G, dom (DIJK:SSSP(G,src))`1, DIJK:SSSP(G,src)`2;
  set Res = DIJK:SSSP(G,src); set dR = dom Res`1;
  thus G2 is_mincost_DTree_rooted_at src by Th22;
  let v being Vertex of G;
  assume v in G.reachableDFrom(src);
  then
A2: v in dR by Th25;
    Res`2 c= G.edgesBetween(dR) by Th21;
  hence v in the_Vertices_of G2 by A2,GLIB_000:def 39;
  thus thesis by A2,Th22;
end;

begin :: Prim's Algorithm definitions

definition
  let G be _Graph;
  mode PRIM:Labeling of G is Element of
                           [: bool the_Vertices_of G, bool the_Edges_of G :];
end;

registration
  let G be finite _Graph, L be PRIM:Labeling of G;
  cluster L`1 -> finite;
  coherence proof
    L`1 in bool the_Vertices_of G by MCART_1:10;
    hence thesis;
  end;
  cluster L`2 -> finite;
  coherence proof
    L`2 in bool the_Edges_of G by MCART_1:10;
    hence thesis;
  end;
end;

definition
  let G be real-weighted WGraph, L being PRIM:Labeling of G;
  func PRIM:NextBestEdges(L) -> Subset of the_Edges_of G means :Def12:
  for e1 being set
   holds e1 in it iff
      e1 SJoins L`1, the_Vertices_of G \ L`1, G &
      for e2 being set
       st e2 SJoins L`1, the_Vertices_of G \ L`1, G
        holds (the_Weight_of G).e1 <= (the_Weight_of G).e2;
  existence
  proof
    defpred P[set] means
    $1 SJoins L`1, the_Vertices_of G \ L`1, G &
    for e2 being set
    st e2 SJoins L`1, the_Vertices_of G \ L`1, G
    holds (the_Weight_of G).$1 <= (the_Weight_of G).e2;
    consider IT being Subset of the_Edges_of G such that
A1: for e1 being set holds e1 in IT iff e1 in the_Edges_of G & P[e1]
    from SUBSET_1:sch 1;
    take IT;
    let e1 be set;
    thus e1 in IT implies P[e1] by A1;
    assume
A2: P[e1];
    then e1 in the_Edges_of G by GLIB_000:def 17;
    hence thesis by A1,A2;
  end;
  uniqueness
  proof
    let IT1, IT2 be Subset of the_Edges_of G such that
A3: for e1 being set holds e1 in IT1 iff
    e1 SJoins L`1, the_Vertices_of G \ L`1, G &
    for e2 being set
    st e2 SJoins L`1, the_Vertices_of G \ L`1, G
    holds (the_Weight_of G).e1 <= (the_Weight_of G).e2 and
A4: for e1 being set holds e1 in IT2 iff
    e1 SJoins L`1, the_Vertices_of G \ L`1, G &
    for e2 being set
    st e2 SJoins L`1, the_Vertices_of G \ L`1, G
    holds (the_Weight_of G).e1 <= (the_Weight_of G).e2;
    defpred P[set] means
    $1 SJoins L`1, the_Vertices_of G \ L`1, G &
    for e2 being set
    st e2 SJoins L`1, the_Vertices_of G \ L`1, G
    holds (the_Weight_of G).$1 <= (the_Weight_of G).e2;
    now
      let e1 be set;
      hereby
        assume e1 in IT1;
        then P[e1] by A3;
        hence e1 in IT2 by A4;
      end;
      assume e1 in IT2;
      then P[e1] by A4;
      hence e1 in IT1 by A3;
    end;
    hence thesis by TARSKI:2;
  end;
end;

definition
  let G be real-weighted WGraph;
  func PRIM:Init(G) -> PRIM:Labeling of G equals  ::dPRIMINIT
  [ {choose the_Vertices_of G}, {} ];
  coherence proof
     {} c= the_Edges_of G by XBOOLE_1:2;
   hence thesis by ZFMISC_1:def 2;
  end;
end;

definition
  let G be real-weighted WGraph, L being PRIM:Labeling of G;
  func PRIM:Step(L) -> PRIM:Labeling of G equals  :Def14: ::dPRIMSTEP
  L if PRIM:NextBestEdges(L) = {},
  [ L`1 \/ {(the_Target_of G).(choose PRIM:NextBestEdges(L))},
    L`2 \/ {choose PRIM:NextBestEdges(L)} ]
    if PRIM:NextBestEdges(L) <> {} &
       (the_Source_of G).(choose PRIM:NextBestEdges(L)) in L`1
    otherwise
  [ L`1 \/ {(the_Source_of G).(choose PRIM:NextBestEdges(L))},
    L`2 \/ {choose PRIM:NextBestEdges(L)} ];
  coherence proof
    set BE = PRIM:NextBestEdges(L), e = choose BE;
    set nE = L`2 \/ {e};
    set V = the_Vertices_of G, E = the_Edges_of G;
    set s = (the_Source_of G).e, t = (the_Target_of G).e;
  A1: now
        assume S1: BE <> {} & (the_Source_of G).e in L`1;
      AAa: e in BE & BE c= E by S1;
          reconsider t' = t as Element of V by AAa,FUNCT_2:7;
      B0: L`1 in bool V by MCART_1:10;
      B1: L`2 in bool E by MCART_1:10;
          {e} c= E proof
            let x be set;
            assume x in {e};
            then x = e by TARSKI:def 1;
            then x in BE by S1;
            hence thesis;
          end;
          then L`1 \/ {t'} c= V & L`2 \/ {e} c= E by B0,B1,XBOOLE_1:8;
       hence [L`1 \/ {t}, L`2 \/ {e}] is PRIM:Labeling of G by ZFMISC_1:def 2;
      end;
      now
        assume S1: BE <> {} & not (the_Source_of G).e in L`1;
          e in BE by S1;
          then reconsider e' = e as Element of E;
      AAa: e in BE & BE c= E by S1;
          reconsider s' = s as Element of V by AAa,FUNCT_2:7;
      B0: L`1 in bool V by MCART_1:10;
      B1: L`2 in bool E by MCART_1:10;
          {e} c= E proof
            let x be set;
            assume x in {e};
            then x = e by TARSKI:def 1;
            then x in BE by S1;
            hence thesis;
          end;
          then L`1 \/ {s'} c= V & L`2 \/ {e} c= E by B0,B1,XBOOLE_1:8;
       hence [L`1 \/ {s}, L`2 \/ {e}] is PRIM:Labeling of G by ZFMISC_1:def 2;
      end;
     hence thesis by A1;
   end;
  consistency;
end;

definition
  let G be real-weighted WGraph;
  mode PRIM:LabelingSeq of G -> ManySortedSet of NAT means  :dPRIMSeq:
  for n being Nat holds it.n is PRIM:Labeling of G;
  existence proof
  defpred P[set,set] means $2 is PRIM:Labeling of G;
A: now let i be set; assume
    i in NAT;
    take r = [{},{}];
       {} c= the_Vertices_of G & {} c= the_Edges_of G by XBOOLE_1:2;
    hence P[i,r] by ZFMISC_1:def 2;
   end;
    consider s being ManySortedSet of NAT such that
Z:  for i being set st i in NAT holds P[i,s.i] from PBOOLE:sch 3(A);
    take s;
    let i be Nat;
     i in NAT by ORDINAL1:def 13;
    hence thesis by Z;
  end;
end;

definition
  let G be real-weighted WGraph, S be PRIM:LabelingSeq of G, n be Nat;
  redefine func S.n -> PRIM:Labeling of G;
  coherence by dPRIMSeq;
end;

definition
  let G be real-weighted WGraph;
  func PRIM:CompSeq(G) -> PRIM:LabelingSeq of G means  :Def15: ::dPRIMCS
  it.0 = PRIM:Init(G) &
  for n being Nat holds it.(n+1) = PRIM:Step(it.n);
  existence
  proof
    defpred P[set,set,set] means ($2 is PRIM:Labeling of G &
    ex Gn,Gn1 being PRIM:Labeling of G st
      $2 = Gn & $3 = Gn1 & Gn1 = PRIM:Step(Gn)) or
      (not $2 is PRIM:Labeling of G & $2 = $3);
    now
      let n be Element of NAT, x be set;
      now per cases;
        suppose x is PRIM:Labeling of G;
            then reconsider Gn = x as PRIM:Labeling of G;
           P[n,x,PRIM:Step(Gn)];
          hence ex y being set st P[n,x,y];
        end;
        suppose not x is PRIM:Labeling of G;
          hence ex y being set st P[n,x,y];
        end;
      end;
      hence ex y being set st P[n,x,y];
    end;
    then
A1: for n being Element of NAT for x being set ex y being set st P[n,x,y];
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = PRIM:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
    from RECDEF_1:sch 1(A1);
    reconsider IT as ManySortedSet of NAT by A3,PARTFUN1:def 4,RELAT_1:def 18;
    defpred P2[Nat] means IT.$1 is PRIM:Labeling of G;
A4: P2[0] by A3;
A5: now
      let n be Nat;
       reconsider n' = n as Element of NAT by ORDINAL1:def 13;
      assume P2[n];
      then consider Gn,Gn1 being PRIM:Labeling of G such that
A7:   IT.n' = Gn & IT.(n+1) = Gn1 & Gn1 = PRIM:Step(Gn) by A3;
      thus P2[n+1] by A7;
    end;
    for n being Nat holds P2[n] from NAT_1:sch 2(A4,A5);
    then reconsider IT as PRIM:LabelingSeq of G by dPRIMSeq;
    take IT;
    thus IT.0 = PRIM:Init(G) by A3;
    let n be Nat;
       reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    consider Gn,Gn1 being PRIM:Labeling of G such that
A9: IT.n' = Gn & IT.(n+1) = Gn1 & Gn1 = PRIM:Step(Gn) by A3;
    thus thesis by A9;
  end;
  uniqueness
  proof
    let IT1,IT2 be PRIM:LabelingSeq of G such that
A10: IT1.0 = PRIM:Init(G) &
    for n being Nat holds IT1.(n+1) = PRIM:Step(IT1.n) and
A11: IT2.0 = PRIM:Init(G) &
    for n being Nat holds IT2.(n+1) = PRIM:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A12: P[0] by A10,A11;
    now
      let n be Nat;
      assume P[n];
      then IT1.(n+1) = PRIM:Step(IT2.n) by A10
        .= IT2.(n+1) by A11;
      hence P[n+1];
    end;
    then
A13: for n being Nat st P[n] holds P[n+1];
A13a: for n being Nat holds P[n] from NAT_1:sch 2(A12,A13);
     for n being set st n in NAT holds IT1.n = IT2.n by A13a;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

definition
  let G be real-weighted WGraph;
  func PRIM:MST(G) -> PRIM:Labeling of G equals  ::dPRIMMST
  PRIM:CompSeq(G).Result();
  coherence
  proof
    set PCS = PRIM:CompSeq(G);
    PCS.Result() = PCS.(PCS.Lifespan());
    hence thesis;
  end;
end;

theorem Lm6:
for G being real-weighted WGraph, L be PRIM:Labeling of G
 st PRIM:NextBestEdges(L) <> {} holds
  ex v being Vertex of G st not v in L`1 &
     PRIM:Step(L) = [ L`1 \/ {v}, L`2 \/ {choose PRIM:NextBestEdges(L)} ]
proof
  let G be real-weighted WGraph, L be PRIM:Labeling of G;
  set G2 = PRIM:Step(L);
  assume
A1: PRIM:NextBestEdges(L) <> {};
  set e = choose PRIM:NextBestEdges(L);
  set src = (the_Source_of G).e, tar = (the_Target_of G).e;
A2: e in PRIM:NextBestEdges(L) by A1;
A3: e SJoins L`1, the_Vertices_of G \ L`1, G by A1,Def12;
  reconsider src,tar as Vertex of G by A2,FUNCT_2:7;
  now per cases;
    suppose
A4:   src in L`1;
      take tar;
      not src in the_Vertices_of G \ L`1 by A4,XBOOLE_0:def 5;
      then tar in the_Vertices_of G \ L`1 by A3,GLIB_000:def 17;
      hence not tar in L`1 by XBOOLE_0:def 5;
      thus G2 = [L`1 \/ {tar}, L`2 \/ {e}] by A1,A4,Def14;
    end;
    suppose
A5:   not src in L`1;
      take src;
      thus not src in L`1 by A5;
      thus G2 = [L`1 \/ {src}, L`2 \/ {e}] by A1,A5,Def14;
    end;
  end;
  hence thesis;
end;

theorem Lm7:
for G being real-weighted WGraph, L be PRIM:Labeling of G
  holds L`1 c= (PRIM:Step(L))`1 & L`2 c= (PRIM:Step(L))`2
proof
  let G be real-weighted WGraph, L be PRIM:Labeling of G;
  set G2 = PRIM:Step(L);
  set Next = PRIM:NextBestEdges(L), e = choose Next, GE = L \/ {e};
  now per cases;
    suppose Next = {};
      hence thesis by Def14;
    end;
    suppose Next <> {};
      then consider v being Vertex of G such that
A2:   not v in L`1 & G2 = [L`1 \/ {v}, L`2 \/ {e}] by Lm6;
      G2`1 = L`1 \/ {v} by A2,MCART_1:7;
      hence L`1 c= G2`1 by XBOOLE_1:7;
      G2`2 = L`2 \/ {e} by A2,MCART_1:7;
      hence L`2 c= G2`2 by XBOOLE_1:7;
    end;
  end;
  hence thesis;
end;

theorem Lm9:
for G being finite real-weighted WGraph, n being Nat
 holds (PRIM:CompSeq(G).n)`1 is non empty Subset of the_Vertices_of G &
       (PRIM:CompSeq(G).n)`2 c= G.edgesBetween((PRIM:CompSeq(G).n)`1)
proof
  let G be finite real-weighted WGraph;
  set PCS = PRIM:CompSeq(G);
  defpred P[Nat] means
  (PCS.$1)`1 is non empty Subset of the_Vertices_of G &
  (PCS.$1)`2 c= G.edgesBetween((PCS.$1)`1);
  now (PCS.0)`1 = (PRIM:Init(G))`1 by Def15
      .= {choose the_Vertices_of G} by MCART_1:7;
    hence (PCS.0)`1 is non empty Subset of the_Vertices_of G;
    (PCS.0)`2 = (PRIM:Init(G))`2 by Def15
      .= {} by MCART_1:7;
    hence (PCS.0)`2 c=
    G.edgesBetween((PRIM:CompSeq(G).0)`1) by XBOOLE_1:2;
  end;
  then
A1: P[0];
  now
    let n be Nat;
    assume
A2: P[n];
    set Gn = PCS.n, Gn1 = PCS.(n+1);
    set Next = PRIM:NextBestEdges(Gn), e = choose Next;
A3: Gn1 = PRIM:Step(Gn) by Def15;
    now per cases;
      suppose Next = {};
        then Gn1 = Gn by A3,Def14;
        hence P[n+1] by A2;
      end;
      suppose
A4:     Next <> {};
        set src = (the_Source_of G).e, tar = (the_Target_of G).e;
A5:     e in Next by A4;
A9:     e SJoins Gn`1, the_Vertices_of G \ Gn`1, G
        by A4,Def12;
        now per cases;
          suppose
A10:        (the_Source_of G).e in Gn`1;
            then
A11:        Gn1 = [Gn`1 \/ {tar}, Gn`2 \/ {e}] by A3,A4,Def14;
A12:        Gn1`1 = Gn`1 \/ {tar} by A11,MCART_1:7;
A13:        Gn1`2 = Gn`2 \/ {e} by A11,MCART_1:7;
            now
              let x be set;
              assume
A14:          x in Gn1`1;
              now per cases by A12,A14,XBOOLE_0:def 3;
                suppose x in Gn`1;
                  hence x in the_Vertices_of G by A2;
                end;
                suppose x in {tar};
                  then x = tar by TARSKI:def 1;
                  hence x in the_Vertices_of G by A5,FUNCT_2:7;
                end;
              end;
              hence x in the_Vertices_of G;
            end;
            hence Gn1`1 is non empty Subset of the_Vertices_of G
            by A11,MCART_1:7,TARSKI:def 3;
A15:        Gn`1 c= Gn1`1 by A12,XBOOLE_1:7;
A16:        G.edgesBetween(Gn`1) c=
            G.edgesBetween(Gn1`1) by A12,GLIB_000:39,XBOOLE_1:7;
            now
              let x be set;
              assume
A17:          x in Gn1`2;
              now per cases by A13,A17,XBOOLE_0:def 3;
                suppose x in Gn`2;
                  then x in G.edgesBetween(Gn`1) by A2;
                  hence x in G.edgesBetween(Gn1`1) by A16;
                end;
                suppose x in {e};
                  then
A18:              x = e by TARSKI:def 1;
                  then (the_Target_of G).x in {tar} by TARSKI:def 1;
                  then (the_Target_of G).x in Gn1`1
                  by A12,XBOOLE_0:def 3;
                  hence x in G.edgesBetween(Gn1`1)
                  by A5,A10,A15,A18,GLIB_000:34;
                end;
              end;
              hence x in G.edgesBetween(Gn1`1);
            end;
            hence Gn1`2 c= G.edgesBetween(Gn1`1)
            by TARSKI:def 3;
          end;
          suppose
A19:        not (the_Source_of G).e in Gn`1;
            then
A20:        Gn1 = [Gn`1 \/ {(the_Source_of G).e}, Gn`2 \/ {e}] by A3,A4,Def14;
A21:        Gn1`1 = Gn`1 \/ {src} by A20,MCART_1:7;
A22:        Gn1`2 = Gn`2 \/ {e} by A20,MCART_1:7;
            now
              let x be set;
              assume
A23:          x in Gn1`1;
              now per cases by A21,A23,XBOOLE_0:def 3;
                suppose x in Gn`1;
                  hence x in the_Vertices_of G by A2;
                end;
                suppose x in {src};
                  then x = src by TARSKI:def 1;
                  hence x in the_Vertices_of G by A5,FUNCT_2:7;
                end;
              end;
              hence x in the_Vertices_of G;
            end;
            hence Gn1`1 is non empty Subset of the_Vertices_of G
            by A20,MCART_1:7,TARSKI:def 3;
A24:        Gn`1 c= Gn1`1 by A21,XBOOLE_1:7;
A25:        G.edgesBetween(Gn`1) c=
            G.edgesBetween(Gn1`1) by A21,GLIB_000:39,XBOOLE_1:7;
A26:        tar in Gn`1 by A9,A19,GLIB_000:def 17;
            now
              let x be set;
              assume
A27:          x in Gn1`2;
              now per cases by A22,A27,XBOOLE_0:def 3;
                suppose x in Gn`2;
                  then x in G.edgesBetween(Gn`1) by A2;
                  hence x in G.edgesBetween(Gn1`1) by A25;
                end;
                suppose x in {e};
                  then
A28:              x = e by TARSKI:def 1;
                  then (the_Source_of G).x in {src} by TARSKI:def 1;
                  then (the_Source_of G).x in Gn1`1
                  by A21,XBOOLE_0:def 3;
                  hence x in G.edgesBetween(Gn1`1)
                  by A5,A24,A26,A28,GLIB_000:34;
                end;
              end;
              hence x in G.edgesBetween(Gn1`1);
            end;
            hence Gn1`2 c= G.edgesBetween(Gn1`1)
            by TARSKI:def 3;
          end;
        end;
        hence P[n+1];
      end;
    end;
    hence P[n+1];
  end;
  then
A29: for n being Nat st P[n] holds P[n+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A1,A29);
  hence thesis;
end;

theorem Lm10:
for G1 being finite real-weighted WGraph, n being Nat,
  G2 being inducedSubgraph of G1,(PRIM:CompSeq(G1).n)`1, (PRIM:CompSeq(G1).n)`2
 holds G2 is connected
proof
  let G1 be finite real-weighted WGraph;
  defpred P[Nat] means
  for G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).$1)`1,
  (PRIM:CompSeq(G1).$1)`2 holds G2 is connected;
  set G0 = PRIM:CompSeq(G1).0, v = choose the_Vertices_of G1;
  now
    let G be inducedSubgraph of G1, G0`1, G0`2;
    G0 = PRIM:Init(G1) by Def15;
    then G0`1 = {v} & G0`2 = {} by MCART_1:7;
    then reconsider G' = G as inducedSubgraph of G1,{v},{};
    G' is connected;
    hence G is connected;
  end;
  then
A1: P[0];
  now
    let n be Nat;
    assume
A2: P[n];
    set Gn = PRIM:CompSeq(G1).n, Gn1 = PRIM:CompSeq(G1).(n+1);
    set e = choose PRIM:NextBestEdges(Gn);
    set v1 = (the_Target_of G1).e, v2 = (the_Source_of G1).e;
A3: Gn1 = PRIM:Step(Gn) by Def15;
    now
      let Gn1s be inducedSubgraph of G1, Gn1`1, Gn1`2;
      Gn1`1 is non empty Subset of the_Vertices_of G1 &
      Gn1`2c=G1.edgesBetween(Gn1`1) by Lm9;
      then
A4:   the_Vertices_of Gn1s = Gn1`1 &
      the_Edges_of Gn1s = Gn1`2 by GLIB_000:def 39;
      now per cases;
        suppose PRIM:NextBestEdges(Gn) = {};
          then Gn1 = Gn by A3,Def14;
          hence Gn1s is connected by A2;
        end;
        suppose
A5:       PRIM:NextBestEdges(Gn) <> {} & v2 in Gn`1;
          then
A6:       Gn1 = [Gn`1 \/ {v1}, Gn`2 \/ {e} ] by A3,Def14;
A7:       e in PRIM:NextBestEdges(Gn) by A5;
          then reconsider v1 as Vertex of G1 by FUNCT_2:7;
A8:       Gn1`1 = Gn`1 \/ {v1} by A6,MCART_1:7;
A9:       Gn1`2 = Gn`2 \/ {e} by A6,MCART_1:7;
          consider Gns being inducedSubgraph of
          G1,Gn`1,Gn`2;
A10:      Gns is connected by A2;
A11:      Gn`1 is non empty Subset of the_Vertices_of G1 &
          Gn`2 c= G1.edgesBetween(Gn`1) by Lm9;
          then
A12:      the_Vertices_of Gns = Gn`1 &
          the_Edges_of Gns = Gn`2 by GLIB_000:def 39;
          then the_Vertices_of Gns c= the_Vertices_of Gn1s &
          the_Edges_of Gns c= the_Edges_of Gn1s by A4,A8,A9,XBOOLE_1:7;
          then reconsider Gns as Subgraph of Gn1s by GLIB_000:47;
          consider src being Vertex of Gns;
          reconsider src' = src as Vertex of Gn1s by GLIB_000:45;
A14:      e Joins v2,v1,G1 by A7,GLIB_000:def 15;
          e in {e} by TARSKI:def 1;
          then e in the_Edges_of Gn1s by A4,A9,XBOOLE_0:def 3;
          then
A15:      e Joins v2,v1,Gn1s by A14,GLIB_000:76;
          now
            let x be Vertex of Gn1s;
            now per cases;
              suppose
A16:            x = v1;
                reconsider v2'=v2 as Vertex of Gns by A5,A11,GLIB_000:def 39;
                consider W being Walk of Gns such that
A17:            W is_Walk_from src,v2' by A10,GLIB_002:def 1;
                reconsider W as Walk of Gn1s by GLIB_001:168;
                W is_Walk_from src',v2 by A17,GLIB_001:20;
                then W.addEdge(e) is_Walk_from src',x by A15,A16,GLIB_001:67;
                hence ex W being Walk of Gn1s st W is_Walk_from src',x;
              end;
              suppose x <> v1;
                then not x in {v1} by TARSKI:def 1;
                then reconsider x'=x as Vertex of Gns
                by A4,A8,A12,XBOOLE_0:def 3;
                consider W being Walk of Gns such that
A18:            W is_Walk_from src,x' by A10,GLIB_002:def 1;
                reconsider W'=W as Walk of Gn1s by GLIB_001:168;
                W' is_Walk_from src',x by A18,GLIB_001:20;
                hence ex W being Walk of Gn1s st W is_Walk_from src',x;
              end;
            end;
            hence ex W being Walk of Gn1s st W is_Walk_from src',x;
          end;
          hence Gn1s is connected by GLIB_002:6;
        end;
        suppose
A19:      PRIM:NextBestEdges(Gn) <> {} & not v2 in Gn`1;
          then
A20:      Gn1 = [Gn`1 \/ {v2}, Gn`2 \/ {e}] by A3,Def14;
          e SJoins Gn`1,the_Vertices_of G1\Gn`1,G1
          by A19,Def12;
          then
A21:      e in the_Edges_of G1 & v1 in Gn`1 by A19,GLIB_000:def 17;
          then reconsider v2 as Vertex of G1 by FUNCT_2:7;
A22:      Gn1`1 = Gn`1 \/ {v2} by A20,MCART_1:7;
A23:      Gn1`2 = Gn`2 \/ {e} by A20,MCART_1:7;
          consider Gns being inducedSubgraph of G1,Gn`1,Gn`2;
A24:      Gns is connected by A2;
A25:      Gn`1 is non empty Subset of the_Vertices_of G1 &
          Gn`2c= G1.edgesBetween(Gn`1) by Lm9;
          then
A26:      the_Vertices_of Gns = Gn`1 &
          the_Edges_of Gns = Gn`2 by GLIB_000:def 39;
          then the_Vertices_of Gns c= the_Vertices_of Gn1s &
          the_Edges_of Gns c= the_Edges_of Gn1s by A4,A22,A23,XBOOLE_1:7;
          then reconsider Gns as Subgraph of Gn1s by GLIB_000:47;
          consider src being Vertex of Gns;
          reconsider src' = src as Vertex of Gn1s by GLIB_000:45;
A28:      e Joins v1,v2,G1 by A21,GLIB_000:def 15;
          e in {e} by TARSKI:def 1;
          then e in the_Edges_of Gn1s by A4,A23,XBOOLE_0:def 3;
          then
A29:      e Joins v1,v2,Gn1s by A28,GLIB_000:76;
          now
            let x be Vertex of Gn1s;
            now per cases;
              suppose
A30:            x = v2;
                reconsider v1'=v1 as Vertex of Gns by A21,A25,GLIB_000:def 39;
                consider W being Walk of Gns such that
A31:            W is_Walk_from src,v1' by A24,GLIB_002:def 1;
                reconsider W as Walk of Gn1s by GLIB_001:168;
                W is_Walk_from src',v1 by A31,GLIB_001:20;
                then W.addEdge(e) is_Walk_from src',x by A29,A30,GLIB_001:67;
                hence ex W being Walk of Gn1s st W is_Walk_from src',x;
              end;
              suppose x <> v2;
                then not x in {v2} by TARSKI:def 1;
                then reconsider x'=x as Vertex of Gns
                by A4,A22,A26,XBOOLE_0:def 3;
                consider W being Walk of Gns such that
A32:            W is_Walk_from src,x' by A24,GLIB_002:def 1;
                reconsider W'=W as Walk of Gn1s by GLIB_001:168;
                W' is_Walk_from src',x by A32,GLIB_001:20;
                hence ex W being Walk of Gn1s st W is_Walk_from src',x;
              end;
            end;
            hence ex W being Walk of Gn1s st W is_Walk_from src',x;
          end;
          hence Gn1s is connected by GLIB_002:6;
        end;
      end;
      hence Gn1s is connected;
    end;
    hence P[n+1];
  end;
  then
A33: for n being Nat st P[n] holds P[n+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A1,A33);
  hence thesis;
end;

theorem Lm11:
for G1 being finite real-weighted WGraph, n being Nat,
    G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).n)`1
 holds G2 is connected
proof
  let G1 be finite real-weighted WGraph, n be Nat;
  set V = (PRIM:CompSeq(G1).n)`1;
  set E = (PRIM:CompSeq(G1).n)`2;
  let G2 be inducedSubgraph of G1, V;
  reconsider V as non empty Subset of the_Vertices_of G1 by Lm9;
  reconsider E as Subset of G1.edgesBetween(V) by Lm9;
  consider G3 being inducedSubgraph of G1,V,E;
A1: the_Vertices_of G3 = V & the_Edges_of G3 = E by GLIB_000:def 39;
A2: the_Vertices_of G2 = V & the_Edges_of G2 = G1.edgesBetween(V)
  by GLIB_000:def 39;
  then reconsider G3 as Subgraph of G2 by A1,GLIB_000:47;
A3: G3 is connected by Lm10;
  G3 is spanning by A1,A2,GLIB_000:def 35;
  hence thesis by A3,GLIB_002:23;
end;

registration
  let G1 be finite real-weighted WGraph, n being Nat;
  cluster -> connected inducedSubgraph of G1,(PRIM:CompSeq(G1).n)`1;
  coherence by Lm11;
end;

registration
  let G1 be finite real-weighted WGraph, n being Nat;
  cluster -> connected inducedSubgraph of G1, (PRIM:CompSeq(G1).n)`1,
                                              (PRIM:CompSeq(G1).n)`2;
  coherence by Lm10;
end;

theorem Lm12:
for G being finite real-weighted WGraph, n being Nat
 holds (PRIM:CompSeq(G).n)`1 c= G.reachableFrom(choose the_Vertices_of G)
proof
  let G be finite real-weighted WGraph;
  set src = choose the_Vertices_of G;
  defpred P[Nat] means (PRIM:CompSeq(G).$1)`1 c=
  G.reachableFrom(choose the_Vertices_of G);
  set G0 = PRIM:CompSeq(G).0;
  G0 = PRIM:Init(G) by Def15;
  then
A1: G0`1 = {src} by MCART_1:7;
  src in G.reachableFrom(src) by GLIB_002:9;
  then
A2: P[0] by A1,ZFMISC_1:37;
A3: now
    let n be Nat;
    assume
A4: P[n];
    set Gn = PRIM:CompSeq(G).n, Gn1 = PRIM:CompSeq(G).(n+1);
    set Next = PRIM:NextBestEdges(Gn), e = choose Next;
    set sc = (the_Source_of G).e, tar = (the_Target_of G).e;
A5: Gn1 = PRIM:Step(Gn) by Def15;
    now per cases;
      suppose Next = {};
        hence P[n+1] by A4,A5,Def14;
      end;
      suppose
A6:     Next <> {} & sc in Gn`1;
        then
A7:     Gn1 = [Gn`1 \/ {tar}, Gn`2 \/ {e}] by A5,Def14;
A8:     e in Next by A6;
A10:    Gn1`1 = Gn`1 \/ {tar} by A7,MCART_1:7;
        now
          let v be set;
          assume
A11:      v in Gn1`1;
          now per cases by A10,A11,XBOOLE_0:def 3;
            suppose v in Gn`1;
              hence v in G.reachableFrom(src) by A4;
            end;
            suppose v in {tar};
              then v = tar by TARSKI:def 1;
              then
              e Joins sc,v,G by A8,GLIB_000:def 15;
              hence v in G.reachableFrom(src) by A4,A6,GLIB_002:10;
            end;
          end;
          hence v in G.reachableFrom(src);
        end;
        hence P[n+1] by TARSKI:def 3;
      end;
      suppose
A13:    Next <> {} & not sc in Gn`1;
        then
A14:    Gn1 = [Gn`1 \/ {sc}, Gn`2 \/ {e}] by A5,Def14;
A15:    e SJoins Gn`1, the_Vertices_of G \ Gn`1, G
        by A13,Def12;
        then
A16:    tar in Gn`1 by A13,GLIB_000:def 17;
A17:    e in the_Edges_of G by A15,GLIB_000:def 17;
A19:    Gn1`1 = Gn`1 \/ {sc} by A14,MCART_1:7;
        now
          let v be set;
          assume
A20:      v in Gn1`1;
          now per cases by A19,A20,XBOOLE_0:def 3;
            suppose v in Gn`1;
              hence v in G.reachableFrom(src) by A4;
            end;
            suppose v in {sc};
              then v = sc by TARSKI:def 1;
              then
              e Joins tar,v,G by A17,GLIB_000:def 15;
              hence v in G.reachableFrom(src) by A4,A16,GLIB_002:10;
            end;
          end;
          hence v in G.reachableFrom(src);
        end;
        hence P[n+1] by TARSKI:def 3;
      end;
    end;
    hence P[n+1];
  end;
  for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
  hence thesis;
end;

theorem Lm13:
for G being finite real-weighted WGraph, i,j being Nat st i <= j
 holds (PRIM:CompSeq(G).i)`1 c= (PRIM:CompSeq(G).j)`1 &
       (PRIM:CompSeq(G).i)`2 c= (PRIM:CompSeq(G).j)`2
proof
  let G be finite real-weighted WGraph, i,j be Nat;
  set PCS = PRIM:CompSeq(G);
  set vPCS = (PCS.i)`1, ePCS = (PCS.i)`2;
  assume i <= j;
  then consider x being Nat such that
A1: j = i + x by NAT_1:10;
  defpred P[Nat] means vPCS c= (PCS.(i+$1))`1 &
  ePCS c= (PCS.(i+$1))`2;
A3: P[0];
  now
    let k be Nat;
    assume
A4: vPCS c= (PCS.(i+k))`1 & ePCS c= (PCS.(i+k))`2;
    PCS.(i+k+1) = PRIM:Step(PCS.(i+k)) by Def15;
    then (PCS.(i+k))`1 c= (PCS.(i+k+1))`1 &
    (PCS.(i+k))`2 c= (PCS.(i+k+1))`2 by Lm7;
    hence vPCS c= (PCS.(i+(k+1)))`1 &
    ePCS c= (PCS.(i+(k+1)))`2 by A4,XBOOLE_1:1;
  end;
  then
A5: for k being Nat st P[k] holds P[k+1];
  for k being Nat holds P[k] from NAT_1:sch 2(A3,A5);
  hence thesis by A1;
end;

theorem Lm14:
for G being finite real-weighted WGraph, n being Nat
 holds PRIM:NextBestEdges(PRIM:CompSeq(G).n) = {} iff
       (PRIM:CompSeq(G).n)`1 = G.reachableFrom(choose the_Vertices_of G)
proof
  let G be finite real-weighted WGraph, n be Nat;
  set src = choose the_Vertices_of G;
  set PCS = PRIM:CompSeq(G), RFS = G.reachableFrom(src);
  set Gn = PCS.n; set EG = the_Edges_of G;
  set Next = PRIM:NextBestEdges(Gn);
  set GnV = Gn`1, GnVg = the_Vertices_of G \ GnV;
  hereby
    assume
A1: Next = {};
    now
      assume
A2:   GnV <> RFS;
      GnV c= RFS by Lm12;
      then
A3:   GnV c< RFS by A2,XBOOLE_0:def 8;
      defpred P1[set] means $1 SJoins GnV, GnVg, G;
      consider BE1 being Subset of EG such that
A4:   for x being set holds x in BE1 iff x in EG & P1[x]
      from SUBSET_1:sch 1;
      now
        assume
A5:     BE1 = {};
        consider v being set such that
A6:     v in RFS & not v in Gn`1 by A3,XBOOLE_0:6;
        reconsider v as Vertex of G by A6;
        consider W being Walk of G such that
A7:     W is_Walk_from src, v by A6,GLIB_002:def 5;
        src in {src} by TARSKI:def 1;
        then src in (PRIM:Init(G))`1 by MCART_1:7;
        then
A8:     src in (PCS.0)`1 by Def15;
A9:     (PCS.0)`1 c= Gn`1 by Lm13;
        defpred P2[Nat] means $1 is odd & $1 <= len W & not W.$1 in GnV;
        W.(len W) = W.last() by GLIB_001:def 7
          .= v by A7,GLIB_001:def 23;
        then
A10:    ex k being Nat st P2[k] by A6;
        consider k being Nat such that
A11:    P2[k] & for m being Nat st P2[m] holds k <= m from NAT_1:sch 5(A10);
        now per cases;
          suppose k = 1;
            then W.k = W.first() by GLIB_001:def 6
              .= src by A7,GLIB_001:def 23;
            hence contradiction by A8,A9,A11;
          end;
          suppose
A12:        k <> 1;
            reconsider k'=k as odd Element of NAT by A11,ORDINAL1:def 13;
            1 <= k by A11,HEYTING3:1;
            then 1 < k by A12,XXREAL_0:1;
            then 1+1 <= k by NAT_1:13;
            then reconsider k2a = k'-2*1 as odd Element of NAT by INT_1:18;
A13:        k - 2 < len W - 0 by A11,XREAL_1:17;
            k2a < k - 0 by XREAL_1:17;
            then
A14:        W.k2a in GnV by A11,A13;
            set e = W.(k2a+1);
A15:        e Joins W.k2a, W.(k2a+2),G by A13,GLIB_001:def 3;
            then W.k in the_Vertices_of G by GLIB_000:16;
            then W.k in GnVg by A11,XBOOLE_0:def 5;
            then
A19:        P1[e] by A14,A15,GLIB_000:20;
            e in EG by A15,GLIB_000:def 15;
            hence contradiction by A4,A5,A19;
          end;
        end;
        hence contradiction;
      end;
      then reconsider BE1 as non empty finite set;
      deffunc F(Element of BE1) = (the_Weight_of G).$1;
      consider e1 being Element of BE1 such that
A20:  for e2 being Element of BE1 holds F(e1)<=F(e2) from GRAPH_5:sch 2;
A21:  e1 SJoins GnV, GnVg, G by A4;
      now
        let e2 be set;
        assume
A22:    e2 SJoins GnV, GnVg, G;
        then e2 in EG by GLIB_000:def 17;
        then reconsider e2' = e2 as Element of BE1 by A4,A22;
        (the_Weight_of G).e1 <= (the_Weight_of G).e2' by A20;
        hence (the_Weight_of G).e1 <= (the_Weight_of G).e2;
      end;
      hence contradiction by A1,A21,Def12;
    end;
    hence GnV = RFS;
  end;
  assume
A23: GnV = RFS;
  set e = choose Next;
  now
    assume Next <> {};
    then
A24: e SJoins GnV, GnVg, G by Def12;
    then
A25: e in EG by GLIB_000:def 17;
    now per cases by A24,GLIB_000:def 17;
      suppose
A27:    (the_Source_of G).e in GnV & (the_Target_of G).e in GnVg;
        then
A28:    not (the_Target_of G).e in GnV by XBOOLE_0:def 5;
        e Joins (the_Source_of G).e, (the_Target_of G).e, G
        by A25,GLIB_000:def 15;
        hence contradiction by A23,A27,A28,GLIB_002:10;
      end;
      suppose
A29:    (the_Source_of G).e in GnVg & (the_Target_of G).e in GnV;
        then
A30:    not (the_Source_of G).e in GnV by XBOOLE_0:def 5;
        e Joins (the_Target_of G).e, (the_Source_of G).e, G
        by A25,GLIB_000:def 15;
        hence contradiction by A23,A29,A30,GLIB_002:10;
      end;
    end;
    hence contradiction;
  end;
  hence thesis;
end;

theorem Lm15:
for G being finite real-weighted WGraph, n being Nat
 holds card ((PRIM:CompSeq(G).n)`1) =
                    min(n+1, card(G.reachableFrom(choose the_Vertices_of G)))
proof
  let G be finite real-weighted WGraph;
  set CS = PRIM:CompSeq(G), src = choose the_Vertices_of G;
  defpred P[Nat] means
  card (PRIM:CompSeq(G).$1)`1 = min($1+1, card(G.reachableFrom(src)));
  set G0 = CS.0;
  G0 = PRIM:Init(G) by Def15;
  then {src} = G0`1 by MCART_1:7;
  then
A1: card G0`1 = 1 by CARD_1:50;
  src in G.reachableFrom(src) by GLIB_002:9;
  then {src} c= G.reachableFrom(src) by ZFMISC_1:37;
  then card {src} <= card G.reachableFrom(src) by NAT_1:44;
  then 0+1 <= card G.reachableFrom(src) by CARD_1:50;
  then
A2: P[0] by A1,XXREAL_0:def 9;
A3: now
    let n be Nat;
    assume
A4: P[n];
    set Gn = PRIM:CompSeq(G).n, Gn1 = PRIM:CompSeq(G).(n+1);
    set e = choose PRIM:NextBestEdges(Gn);
A5: Gn1 = PRIM:Step(Gn) by Def15;
    now per cases;
      suppose
A6:     PRIM:NextBestEdges(Gn) = {};
        then
A7:     card Gn1`1 = min(n+1, card (G.reachableFrom(src)) )
        by A4,A5,Def14;
A8:     card Gn`1 = card G.reachableFrom(src) by A6,Lm14;
        then card G.reachableFrom(src) <= n+1 by A4,XXREAL_0:def 9;
        then card G.reachableFrom(src) <= n+1+1 by NAT_1:12;
        hence P[n+1] by A4,A7,A8,XXREAL_0:def 9;
      end;
      suppose
A9:     PRIM:NextBestEdges(Gn) <> {};
        then consider v being Vertex of G such that
A10:    not v in Gn`1 &
        Gn1 =  [Gn`1 \/ {v}, Gn`2 \/ {e}] by A5,Lm6;
A12:    card Gn1`1 = card (Gn`1 \/ {v}) by A10,MCART_1:7
          .= card Gn`1 + 1 by A10,CARD_2:54;
A13:    Gn`1 <> G.reachableFrom(src) by A9,Lm14;
A14:    Gn`1 c= G.reachableFrom(src) by Lm12;
A15:    card Gn`1 <= card G.reachableFrom(src) by Lm12,NAT_1:44;
A16:    now
          assume
A17:      card Gn`1 = card G.reachableFrom(src);
          Gn`1 c< G.reachableFrom(src) by A13,A14,XBOOLE_0:def 8;
          hence contradiction by A17,CARD_2:67;
        end;
        then
A18:    card Gn`1 = n+1 by A4,XXREAL_0:15;
        then n+1 < card G.reachableFrom(src) by A15,A16,XXREAL_0:1;
        then n+1+1 <= card G.reachableFrom(src) by NAT_1:13;
        hence P[n+1] by A12,A18,XXREAL_0:def 9;
      end;
    end;
    hence P[n+1];
  end;
  for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
  hence thesis;
end;

theorem Lm16:
for G being finite real-weighted WGraph
 holds PRIM:CompSeq(G) is halting &
       PRIM:CompSeq(G).Lifespan() + 1 =
                               card G.reachableFrom(choose the_Vertices_of G)
proof
  let G be finite real-weighted WGraph;
  set PCS = PRIM:CompSeq(G);
  set src = choose the_Vertices_of G, RFS = G.reachableFrom(src);
  consider n being Nat such that
A1: n + 1 = card RFS by NAT_1:6;
  reconsider n as Element of NAT by ORDINAL1:def 13;
  set Gn = PCS.n, Gn1 = PCS.(n+1);
A2: card RFS <= card RFS + 1 by NAT_1:11;
A3: card Gn`1 = min(card RFS, card RFS) by A1,Lm15
    .= card RFS;
A4: card Gn1`1 = min(card RFS + 1, card RFS) by A1,Lm15
    .= card RFS by A2,XXREAL_0:def 9;
A5: Gn1 = PRIM:Step(Gn) by Def15;
  then
A6: Gn`1 c= Gn1`1 by Lm7;
A7: now
    assume Gn`1 <> Gn1`1;
    then Gn`1 c< Gn1`1 by A6,XBOOLE_0:def 8;
    hence contradiction by A3,A4,CARD_2:67;
  end;
  set e = choose PRIM:NextBestEdges(Gn);
  now
    assume PRIM:NextBestEdges(Gn) <> {};
    then consider v being Vertex of G such that
A8: not v in Gn`1 &
    Gn1 = [Gn`1 \/ {v}, Gn`2 \/ {e}] by A5,Lm6;
A9: Gn1`1 = Gn`1 \/ {v} by A8,MCART_1:7;
    v in {v} by TARSKI:def 1;
    hence contradiction by A7,A8,A9,XBOOLE_0:def 3;
  end;
  then
A10: Gn1 = Gn by A5,Def14;
  hence
A11: PCS is halting by GLIB_000:def 56;
  now
    let m be Nat;
    assume
A12: PCS.m = PCS.(m+1);
    set Gm = PCS.m;
    now
      assume m < n;
      then
A13:  m+1 <= n by NAT_1:13;
      n+0 < card RFS by A1,XREAL_1:10;
      then
A14:  m+1 < card RFS by A13,XXREAL_0:2;
A15:  card Gm`1 = min(m+1, card RFS) by Lm15
        .= m+1 by A14,XXREAL_0:def 9;
A16:  m+1+1 <= card RFS by A14,NAT_1:13;
      card Gm`1 = min(m+1+1,card RFS) by A12,Lm15
        .= m+1+1 by A16,XXREAL_0:def 9;
      hence contradiction by A15;
    end;
    hence n <= m;
  end;
  hence thesis by A1,A10,A11,GLIB_000:def 57;
end;

theorem Lm17:
for G1 being finite real-weighted WGraph, n being Nat,
 G2 being inducedSubgraph of G1, (PRIM:CompSeq(G1).n)`1, (PRIM:CompSeq(G1).n)`2
 holds G2 is Tree-like
proof
  let G1 be finite real-weighted WGraph;
  set PCS = PRIM:CompSeq(G1);
  defpred P[Nat] means
  for G2 being inducedSubgraph of G1,(PCS.$1)`1, (PCS.$1)`2
  holds G2 is Tree-like;
  set G0 = PCS.0, src = choose the_Vertices_of G1;
  G0 = PRIM:Init(G1) by Def15;
  then
A1: G0`1 = {src} & G0`2 = {} by MCART_1:7;
A2: P[0] by A1;
  now
    let n be Nat;
    assume
A3: P[n];
    set Gn = PCS.n, Gn1 = PCS.(n+1);
    set Next = PRIM:NextBestEdges(Gn), e = choose Next;
A4: Gn1 = PRIM:Step(Gn) by Def15;
    consider G3 being inducedSubgraph of G1,Gn`1,Gn`2;
A5: G3 is Tree-like by A3;
A6: Gn`1 is non empty Subset of the_Vertices_of G1 &
    Gn`2 c= G1.edgesBetween(Gn`1) by Lm9;
    then
A7: the_Vertices_of G3 = Gn`1 &
    the_Edges_of G3 = Gn`2 by GLIB_000:def 39;
    now
      let G2 be inducedSubgraph of G1,Gn1`1,Gn1`2;
      Gn1`1 is non empty Subset of the_Vertices_of G1 &
      Gn1`2c=G1.edgesBetween(Gn1`1) by Lm9;
      then
A9:   the_Vertices_of G2 = Gn1`1 &
      the_Edges_of G2 = Gn1`2 by GLIB_000:def 39;
A10:  G3.order() = G3.size() + 1 by A5,GLIB_002:46;
      now per cases;
        suppose Next = {};
          then Gn = Gn1 by A4,Def14;
          hence G2 is Tree-like by A3;
        end;
        suppose
A11:      Next <> {};
          then consider v being Vertex of G1 such that
A12:      not v in Gn`1 &
          Gn1 = [Gn`1\/{v},Gn`2\/{e}] by A4,Lm6;
          set GnV = Gn`1, GnVg = the_Vertices_of G1 \ GnV;
A13:      e SJoins GnV, GnVg, G1 by A11,Def12;
A14a:     now
            assume e in Gn`2;
            then (the_Source_of G1).e in GnV &
            (the_Target_of G1).e in GnV by A6,GLIB_000:34;
            then not (the_Source_of G1).e in GnVg &
            not (the_Target_of G1).e in GnVg by XBOOLE_0:def 5;
            hence contradiction by A13,GLIB_000:def 17;
          end;
A15:      card Gn1`2 = card (Gn`2 \/ {e}) by A12,MCART_1:7
                    .= card Gn`2 + 1 by A14a,CARD_2:54;
          card Gn1`1 = card (Gn`1 \/ {v}) by A12,MCART_1:7
                    .= card Gn`1 + 1 by A12,CARD_2:54;
          then G2.order() = G2.size() + 1 by A7,A9,A10,A15;
          hence G2 is Tree-like by GLIB_002:47;
        end;
      end;
      hence G2 is Tree-like;
    end;
    hence P[n+1];
  end;
  then
A17: for n being Nat st P[n] holds P[n+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A2,A17);
  hence thesis;
end;

theorem Lm18:
for G being finite connected real-weighted WGraph
 holds (PRIM:MST(G))`1 = the_Vertices_of G
proof
  let G be finite connected real-weighted WGraph;
  set M = PRIM:MST(G), PCS = PRIM:CompSeq(G), V = M`1;
  set src = choose the_Vertices_of G, RFS = G.reachableFrom(src);
  PCS.Lifespan() + 1 = card RFS by Lm16;
  then
A1: card V = min(card RFS,card RFS) by Lm15;
A2: V c= RFS by Lm12;
  now
    assume V <> RFS;
    then V c< RFS by A2,XBOOLE_0:def 8;
    hence contradiction by A1,CARD_2:67;
  end;
  hence thesis by GLIB_002:16;
end;

registration
  let G be finite connected real-weighted WGraph;
  cluster spanning Tree-like WSubgraph of G;
  existence
  proof
    set PCS = PRIM:CompSeq(G), n = PCS.Lifespan();
    consider IT being inducedWSubgraph of G,(PCS.n)`1,(PCS.n)`2;
    take IT;
    (PCS.n)`1 is non empty Subset of the_Vertices_of G &
    (PCS.n)`2 c= G.edgesBetween((PCS.n)`1) by Lm9;
    then
A1: the_Vertices_of IT = (PCS.n)`1 by GLIB_000:def 39;
    PRIM:MST(G) = PCS.n;
    then (PCS.n)`1 = the_Vertices_of G by Lm18;
    hence IT is spanning by A1,GLIB_000:def 35;
    thus thesis by Lm17;
  end;
end;

definition
  let G1 be finite connected real-weighted WGraph,
  G2 be spanning Tree-like WSubgraph of G1;
  attr G2 is min-cost means                              :Def17: ::dWGMINCOST
  for G3 being spanning Tree-like WSubgraph of G1 holds G2.cost() <= G3.cost();
end;

registration
  let G1 be finite connected real-weighted WGraph;
  cluster min-cost (spanning Tree-like WSubgraph of G1);
  existence
  proof
    set X = {G2 where G2 is Element of G1.allWSubgraphs() :
    G2 is spanning Tree-like WSubgraph of G1};
    now
      let x be set;
      assume x in X;
      then consider G2 being Element of G1.allWSubgraphs() such that
A1:   x = G2 & G2 is spanning Tree-like WSubgraph of G1;
      thus x in G1.allWSubgraphs() by A1;
    end;
    then reconsider X as finite Subset of G1.allWSubgraphs() by TARSKI:def 3;
    consider GT being spanning Tree-like WSubgraph of G1;
    set G3 = GT.strict(WGraphSelectors);
A2: G3 == GT & the_Weight_of G3 = the_Weight_of GT by Lm2;
    then reconsider G3 as WSubgraph of G1 by GLIB_003:15;
    the_Vertices_of G3 = the_Vertices_of GT by A2,GLIB_000:def 36
      .= the_Vertices_of G1 by GLIB_000:def 35;
    then reconsider G3 as spanning Tree-like WSubgraph of G1
    by A2,GLIB_000:def 35,GLIB_002:48;
    dom G3 = WGraphSelectors by Lm3;
    then G3 in G1.allWSubgraphs() by Def10;
    then G3 in X;
    then reconsider X as finite non empty Subset of G1.allWSubgraphs();
    deffunc F(finite real-weighted WGraph) = $1.cost();
    consider x being Element of X such that
A3: for y being Element of X holds F(x) <= F(y) from GRAPH_5:sch 2;
    x in X;
    then consider G2 being Element of G1.allWSubgraphs() such that
A4: x = G2 & G2 is spanning Tree-like WSubgraph of G1;
    reconsider x as spanning Tree-like WSubgraph of G1 by A4;
    take x;
    now
      let GT be spanning Tree-like WSubgraph of G1;
      set G3 = GT.strict(WGraphSelectors);
A5:   G3 == GT & the_Weight_of G3 = the_Weight_of GT by Lm2;
      then reconsider G3 as WSubgraph of G1 by GLIB_003:15;
      the_Vertices_of G3 = the_Vertices_of GT by A5,GLIB_000:def 36
        .= the_Vertices_of G1 by GLIB_000:def 35;
      then reconsider G3 as spanning Tree-like WSubgraph of G1
      by A5,GLIB_000:def 35,GLIB_002:48;
      dom G3 = WGraphSelectors by Lm3;
      then G3 in G1.allWSubgraphs() by Def10;
      then G3 in X;
      then x.cost() <= G3.cost() by A3;
      hence x.cost() <= GT.cost() by A5,GLIB_000:def 36;
    end;
    hence thesis by Def17;
  end;
end;

definition
  let G be finite connected real-weighted WGraph;
  mode minimumSpanningTree of G is
       min-cost (spanning Tree-like WSubgraph of G);
end;

begin :: Prim's Algorithm Theorems

theorem ::tMST01
  for G1,G2 being finite connected real-weighted WGraph,
  G3 being WSubgraph of G1 st G3 is minimumSpanningTree of G1 &
  G1 == G2 & the_Weight_of G1 = the_Weight_of G2
  holds G3 is minimumSpanningTree of G2
proof
  let G1,G2 be finite connected real-weighted WGraph, G3 be WSubgraph of G1;
  assume
A1: G3 is minimumSpanningTree of G1 &
  G1 == G2 & the_Weight_of G1 = the_Weight_of G2;
  set G3' = G3;
  reconsider G3' as Tree-like WSubgraph of G2 by A1,GLIB_003:17;
  the_Vertices_of G3 = the_Vertices_of G1 by A1,GLIB_000:def 35
    .= the_Vertices_of G2 by A1,GLIB_000:def 36;
  then reconsider G3' as spanning Tree-like WSubgraph of G2 by GLIB_000:def 35;
  now
    let G be spanning Tree-like WSubgraph of G2;
    reconsider G'=G as Tree-like WSubgraph of G1 by A1,GLIB_003:17;
    the_Vertices_of G = the_Vertices_of G2 by GLIB_000:def 35
      .= the_Vertices_of G1 by A1,GLIB_000:def 36;
    then G' is spanning by GLIB_000:def 35;
    hence G3.cost() <= G.cost() by A1,Def17;
  end;
  then G3' is min-cost by Def17;
  hence thesis;
end;

theorem Th36: ::tMST02
for G being finite connected real-weighted WGraph,
    G1 being minimumSpanningTree of G, G2 being WGraph
 st G1 == G2 & the_Weight_of G1 = the_Weight_of G2 holds
    G2 is minimumSpanningTree of G
proof
  let G be finite connected real-weighted WGraph,
  G1 be minimumSpanningTree of G, G2 be WGraph;
  assume
A1: G1 == G2 & the_Weight_of G1 = the_Weight_of G2;
  then reconsider G2'=G2 as WSubgraph of G by GLIB_003:15;
  the_Vertices_of G2 = the_Vertices_of G1 by A1,GLIB_000:def 36
    .= the_Vertices_of G by GLIB_000:def 35;
  then reconsider G2' as spanning Tree-like WSubgraph of G
  by A1,GLIB_000:def 35,GLIB_002:48;
  now
    let G3 be spanning Tree-like WSubgraph of G;
    G1.cost() <= G3.cost() by Def17;
    hence G2'.cost() <= G3.cost() by A1,GLIB_000:def 36;
  end;
  hence thesis by Def17;
end;

theorem Th52: ::tPRIMMST03
for G being finite connected real-weighted WGraph, n being Nat
 holds (PRIM:CompSeq(G).n)`2 c= (PRIM:MST(G))`2
proof
  let G be finite connected real-weighted WGraph, n be Nat;
  set PCS = PRIM:CompSeq(G);
  defpred P[Nat] means (PCS.(PCS.Lifespan()+$1)) = PRIM:MST(G);
A1: P[0];
A2: now
    let n be Nat;
    assume
A3: P[n];
    set off = PCS.Lifespan();
    set Gn = PCS.(off+n), Gn1 = PCS.(off+n+1);
    set Next = PRIM:NextBestEdges(Gn), e = choose Next;
A4: Gn1 = PRIM:Step(Gn) by Def15;
A5: Gn`1 = the_Vertices_of G by A3,Lm18;
    now
      assume Next <> {};
      then consider v being Vertex of G such that
A6:   not v in Gn`1 & Gn1 = [ Gn`1 \/ {v}, Gn`2 \/ {e} ] by A4,Lm6;
      thus contradiction by A5,A6;
    end;
    hence P[n+1] by A3,A4,Def14;
  end;
A7: for n being Nat holds P[n] from NAT_1:sch 2(A1,A2);
  now per cases;
    suppose n <= PCS.Lifespan();
      hence thesis by Lm13;
    end;
    suppose PCS.Lifespan() < n;
      then consider k being Nat such that
A8:   n = PCS.Lifespan() + k by NAT_1:10;
      thus thesis by A7,A8;
    end;
  end;
  hence thesis;
end;

theorem ::tPRIMMST04
for G1 being finite connected real-weighted WGraph,
    G2 being inducedWSubgraph of G1, (PRIM:MST(G1))`1, (PRIM:MST(G1))`2
 holds G2 is minimumSpanningTree of G1
proof
  let G1 be finite connected real-weighted WGraph;
  set PMST = PRIM:MST(G1);
  set VG1 = the_Vertices_of G1, EG1 = the_Edges_of G1;
  set WG1 = the_Weight_of G1;
  let G2 be inducedWSubgraph of G1, PMST`1, PMST`2;
  set PCS = PRIM:CompSeq(G1);
A2: PMST`1 = VG1 by Lm18;
    PMST`2 in bool EG1 by MCART_1:10;
    then PMST`2 c= EG1;
    then
A3: PMST`2 c= G1.edgesBetween(PMST`1) by A2,GLIB_000:37;
  PMST`1 c= VG1 by Lm18;
  then
A4: the_Vertices_of G2 = VG1 &
    the_Edges_of G2 = PMST`2 by A2,A3,GLIB_000:def 39;
    then
A5: G2 is Tree-like & G2 is spanning by Lm17,GLIB_000:def 35;
  reconsider G2'=G2 as Tree-like _Graph by Lm17;
  now
    assume
A6: not G2 is minimumSpanningTree of G1;
    set X = {x where x is Element of G1.allWSubgraphs() :
    x is minimumSpanningTree of G1};
    now
      let x be set;
      assume x in X;
      then consider G2 being Element of G1.allWSubgraphs() such that
A7:   x = G2 & G2 is minimumSpanningTree of G1;
      thus x in G1.allWSubgraphs() by A7;
    end;
    then reconsider X as finite Subset of G1.allWSubgraphs() by TARSKI:def 3;
    now consider M being minimumSpanningTree of G1;
      set M' = M.strict(WGraphSelectors);
      M' == M & the_Weight_of M' = the_Weight_of M by Lm2;
      then reconsider M' as minimumSpanningTree of G1 by Th36;
      dom M' = WGraphSelectors by Lm3;
      then M' in G1.allWSubgraphs() by Def10;
      then M' in X;
      hence X <> {};
    end;
    then reconsider X as non empty finite Subset of G1.allWSubgraphs();
    defpred Z[finite _Graph, Nat] means
       not (PCS.($2+1))`2 c= the_Edges_of $1 &
       for n being Nat st n <= $2 holds
       (PCS.n)`2 c= the_Edges_of $1;
    defpred P[finite _Graph, finite _Graph] means
       card (the_Edges_of $1 /\ the_Edges_of G2) >
       card (the_Edges_of $2 /\ the_Edges_of G2) or
       (card (the_Edges_of $1 /\ the_Edges_of G2) =
       card (the_Edges_of $2 /\ the_Edges_of G2) &
       for k1,k2 being Nat st Z[$1,k1] & Z[$2,k2] holds k1 >= k2);
A8: now
      let G be Element of X;
      G in X;
      then consider G' being Element of G1.allWSubgraphs() such that
A9:   G = G' & G' is minimumSpanningTree of G1;
      reconsider G' = G as minimumSpanningTree of G1 by A9;
A10:  the_Vertices_of G2 = the_Vertices_of G' by A4,GLIB_000:def 35;
A11:  now
        assume
A12:    the_Edges_of G2 = the_Edges_of G';
        the_Weight_of G2 = (WG1) | the_Edges_of G2 by GLIB_003:def 10
          .= the_Weight_of G' by A12,GLIB_003:def 10;
        hence contradiction by A6,A10,A12,Th36,GLIB_000:89;
      end;
      defpred P4[Nat] means not (PCS.$1)`2c= the_Edges_of G';
      now
        assume the_Edges_of G2 c= the_Edges_of G';
        then the_Edges_of G2 c< the_Edges_of G' by A11,XBOOLE_0:def 8;
::        then G2.size() < card the_Edges_of G' by CARD_2:67;
        then G2.size() + 1 < G'.size() + 1 by CARD_2:67,XREAL_1:10;
        then
A13:    G2.order() < G'.size() + 1 by A5,GLIB_002:46;
        G2.order() = G'.order() by A4,GLIB_000:def 35;
        hence contradiction by A13,GLIB_002:46;
      end;
      then
A14:  ex n being Nat st P4[n] by A4;
      consider k3 being Nat such that
A15:  P4[k3] & for n being Nat st P4[n] holds k3 <= n from NAT_1:sch 5(A14);
      now
        assume k3 = 0;
        then
A16:    not (PRIM:Init(G1))`2 c= the_Edges_of G' by A15,Def15;
        (PRIM:Init(G1))`2 = {} by MCART_1:7;
        hence contradiction by A16,XBOOLE_1:2;
      end;
      then consider k2 being Nat such that
A17:  k2 + 1 = k3 by NAT_1:6;
      k2 + 1 - 1 < k3 - 0 by A17,XREAL_1:17;
      then
A18:  (PCS.k2)`2 c= the_Edges_of G' by A15;
      now
        let n be Nat;
        assume n <= k2;
        then (PCS.n)`2 c= (PCS.k2)`2 by Lm13;
        hence (PCS.n)`2 c= the_Edges_of G' by A18,XBOOLE_1:1;
      end;
      hence ex k1 being Nat st Z[G,k1] by A15,A17;
    end;
A19: now
      let G be Element of X, k1,k2 be Nat;
      assume Z[G,k1] & Z[G,k2];
      then k1+1 > k2 & k2+1 > k1;
      then k1 >= k2 & k2 >= k1 by NAT_1:13;
      hence k1 = k2 by XXREAL_0:1;
    end;
A21: X is finite & X <> {} & X c= X;
    now
      let x,y be Element of X;
      x in X;
      then consider x' being WSubgraph of G1 such that
A22:  x' = x & dom x' = WGraphSelectors by Def10;
      y in X;
      then consider y' being WSubgraph of G1 such that
A23:  y' = y & dom y' = WGraphSelectors by Def10;
      set CX = card (the_Edges_of x' /\ the_Edges_of G2);
      set CY = card (the_Edges_of y' /\ the_Edges_of G2);
      now per cases by XXREAL_0:1;
        suppose CX < CY;
          hence P[x,y] or P[y,x] by A22,A23;
        end;
        suppose
A24:      CY = CX;
          consider k1 being Nat such that
A25:      Z[x,k1] by A8;
          consider k2 being Nat such that
A26:      Z[y,k2] by A8;
          now per cases;
            suppose
A27:          k1 >= k2;
              now
                let z1,z2 be Nat;
                assume Z[x,z1] & Z[y,z2 ];
                then z1 = k1 & z2 = k2 by A19,A25,A26;
                hence z1 >= z2 by A27;
              end;
              hence P[x,y] or P[y,x] by A22,A23,A24;
            end;
            suppose
A28:          k1 < k2;
              now
                let z1,z2 be Nat;
                assume Z[x,z1] & Z[y,z2 ];
                then z1 = k1 & z2 = k2 by A19,A25,A26;
                hence z1 <= z2 by A28;
              end;
              hence P[x,y] or P[y,x] by A22,A23,A24;
            end;
          end;
          hence P[x,y] or P[y,x];
        end;
        suppose CX > CY;
          hence P[x,y] or P[y,x] by A22,A23;
        end;
      end;
      hence P[x,y] or P[y,x];
    end;
    then
A29: for x,y being Element of X holds P[x,y] or P[y,x];
    now
      let x,y,z be Element of X;
      assume
A30:  P[x,y] & P[y,z];
      x in X;
      then consider x' being WSubgraph of G1 such that
A31:  x' = x & dom x' = WGraphSelectors by Def10;
      y in X;
      then consider y' being WSubgraph of G1 such that
A32:  y' = y & dom y' = WGraphSelectors by Def10;
      z in X;
      then consider z' being WSubgraph of G1 such that
A33:  z' = z & dom z' = WGraphSelectors by Def10;
      set CX = card (the_Edges_of x' /\ the_Edges_of G2);
      set CY = card (the_Edges_of y' /\ the_Edges_of G2);
      set CZ = card (the_Edges_of z' /\ the_Edges_of G2);
      now per cases by A30,A31,A32;
        suppose
A34:      CX > CY;
          now per cases by A30,A32,A33;
            suppose CY > CZ;
              hence P[x,z] by A31,A33,A34,XXREAL_0:2;
            end;
            suppose CY = CZ &
              for ky,kz being Nat st Z[y',ky] & Z[z',kz]
              holds ky >= kz;
              hence P[x,z] by A31,A33,A34;
            end;
          end;
          hence P[x,z];
        end;
        suppose
A35:      CX = CY & for kx,ky being Nat st Z[x',kx] & Z[y',ky]
          holds kx >= ky;
          now per cases by A30,A32,A33;
            suppose CY > CZ;
              hence P[x,z] by A31,A33,A35;
            end;
            suppose
A36:          CY = CZ & for ky,kz being Nat st Z[y',ky] & Z[z',kz]
              holds ky >= kz;
              consider zx being Nat;
              consider zy being Nat such that
A37:          Z[y,zy] by A8;
              consider zz being Nat;
              now
                let kx,kz be Nat;
                assume Z[x',kx] & Z[z',kz];
                then kx >= zy & zy >= kz by A32,A35,A36,A37;
                hence kx >= kz by XXREAL_0:2;
              end;
              hence P[x,z] by A31,A33,A35,A36;
            end;
          end;
          hence P[x,z];
        end;
      end;
      hence P[x,z];
    end;
    then
A38: for x,y,z being Element of X st P[x,y] & P[y,z] holds P[x,z];
    consider M being Element of X such that
A39: M in X & for y being Element of X
    st y in X holds P[M,y] from CQC_SIM1:sch 4(A21,A29,A38);
    consider x being Element of G1.allWSubgraphs() such that
A40: M = x & x is minimumSpanningTree of G1 by A39;
    reconsider M as minimumSpanningTree of G1 by A40;
A41: the_Vertices_of G2 = the_Vertices_of M by A4,GLIB_000:def 35;
A42: now
      assume
A43:  the_Edges_of G2 = the_Edges_of M;
      the_Weight_of G2 = (WG1) | the_Edges_of G2 by GLIB_003:def 10
        .= the_Weight_of M by A43,GLIB_003:def 10;
      hence contradiction by A6,A41,A43,Th36,GLIB_000:89;
    end;
    defpred P2[Nat] means not (PCS.$1)`2 c= the_Edges_of M;
    now
      assume the_Edges_of G2 c= the_Edges_of M;
      then the_Edges_of G2 c< the_Edges_of M by A42,XBOOLE_0:def 8;
::      then G2.size() < card the_Edges_of M by CARD_2:67;
      then G2.size() + 1 < M.size() + 1 by CARD_2:67,XREAL_1:10;
      then
A44:  G2.order() < M.size() + 1 by A5,GLIB_002:46;
      G2.order() = M.order() by A4,GLIB_000:def 35;
      hence contradiction by A44,GLIB_002:46;
    end;
    then
A45: ex k being Nat st P2[k] by A4;
    consider k being Nat such that
A46: P2[k] & for n being Nat st P2[n] holds k <= n from NAT_1:sch 5(A45);
    now
      assume k = 0;
      then
A47:  not (PRIM:Init(G1))`2 c= the_Edges_of M by A46,Def15;
      (PRIM:Init(G1))`2 = {} by MCART_1:7;
      hence contradiction by A47,XBOOLE_1:2;
    end;
    then consider k1o being Nat such that
A48: k = k1o + 1 by NAT_1:6;
    set Gk1b = PCS.k1o, Gk = PCS.k;
A49: Gk = PRIM:Step(Gk1b) by A48,Def15;
    k1o + 1 - 1 < k - 0 by A48,XREAL_1:17;
    then
A50: Gk1b`2 c= the_Edges_of M by A46;
    set Next = PRIM:NextBestEdges(Gk1b), ep = choose Next;
A51: Next <> {} by A46,A49,A50,Def14;
    then
A52: ep in Next;
    consider v being Vertex of G1 such that
A53: not v in Gk1b`1 & Gk = [ Gk1b`1 \/ {v}, Gk1b`2 \/ {ep} ] by A49,A51,Lm6;
A54: Gk`2 = Gk1b`2 \/ {ep} by A53,MCART_1:7;
    then
A55: not {ep} c= the_Edges_of M by A46,A50,XBOOLE_1:8;
    then
A56: not ep in the_Edges_of M by ZFMISC_1:37;
    set V = Gk1b`1;
A58: VG1 = the_Vertices_of M by GLIB_000:def 35;
    then reconsider V as non empty Subset of the_Vertices_of M by Lm9;
    consider Mep being inducedWSubgraph of G1,VG1,
    the_Edges_of M \/ {ep};
    set v1 = (the_Source_of Mep).ep, v2 = (the_Target_of Mep).ep;
    {ep} c= EG1 & the_Edges_of M c= EG1 by A52,ZFMISC_1:37;
    then the_Edges_of M \/ {ep} c= EG1 by XBOOLE_1:8;
    then VG1 c= VG1 & the_Edges_of M \/ {ep} c= G1.edgesBetween(VG1)
        by GLIB_000:37;
    then
A59: the_Vertices_of Mep = VG1 &
    the_Edges_of Mep = the_Edges_of M \/ {ep} by GLIB_000:def 39;
    then the_Vertices_of M c= the_Vertices_of Mep &
    the_Edges_of M c= the_Edges_of Mep by XBOOLE_1:7;
    then reconsider M'=M as connected Subgraph of Mep by GLIB_000:47;
    ep in {ep} by TARSKI:def 1;
    then
A60: ep in the_Edges_of Mep by A59,XBOOLE_0:def 3;
    the_Vertices_of Mep = the_Vertices_of M by A59,GLIB_000:def 35;
    then reconsider v1,v2 as Vertex of M by A60,FUNCT_2:7;
    consider W being Walk of M' such that
A61: W is_Walk_from v2,v1 by GLIB_002:def 1;
    consider PW being Path of W;
A62: PW is_Walk_from v2,v1 by A61,GLIB_001:161;
A63: PW.edges() c= the_Edges_of M;
    reconsider P=PW as Path of Mep by GLIB_001:176;
A64: P.edges() c= the_Edges_of M by A63,GLIB_001:111;
A65: P is_Walk_from v2,v1 by A62,GLIB_001:20;
    ep in {ep} by TARSKI:def 1;
    then
A66: ep in Gk`2 by A54,XBOOLE_0:def 3;
A67: Gk`2 c= PMST`2 by Th52;
    then
A68: {ep} /\ the_Edges_of G2 = {ep} by A4,A66,ZFMISC_1:52;
A69: ep Joins v1,v2,Mep by A60,GLIB_000:def 15;
    then ep Joins v1,v2,G1 by GLIB_000:75;
    then
A70: ep Joins v1,v2,G2' by A4,A66,A67,GLIB_000:76;
    then ((the_Source_of G2).ep = v1 & (the_Target_of G2).ep = v2) or
    ((the_Target_of G2).ep = v1 & (the_Source_of G2).ep = v2)
    by GLIB_000:def 15;
    then v1 <> v2 by A4,A66,A67,A70,GLIB_000:def 20;
    then v1 <> P.first() by A65,GLIB_001:def 23;
    then P.last() <> P.first() by A65,GLIB_001:def 23;
    then
A71: P is open by GLIB_001:def 24;
A72: ep Joins P.last(),v2,Mep by A65,A69,GLIB_001:def 23;
A73: not ep in P.edges() by A55,A64,ZFMISC_1:37;
    now
      let n be odd Element of NAT;
      assume
A74:  1 < n & n <= len P & P.n = v2;
      v2 = P.first() by A65,GLIB_001:def 23
        .= P.(2*0+1) by GLIB_001:def 6;
      then n = len P by A74,GLIB_001:def 28;
      then P.last() = v2 by A74,GLIB_001:def 7
        .= P.first() by A65,GLIB_001:def 23;
      then
A75:  P is closed by GLIB_001:def 24;
      reconsider PM = P as Walk of M;
      PM is Path-like & PM is closed & PM is non trivial
      by A74,A75,GLIB_001:127,177;
      then PM is Cycle-like by GLIB_001:def 31;
      hence contradiction by GLIB_002:def 2;
    end;
    then
A76: P.addEdge(ep) is Path-like by A71,A72,A73,GLIB_001:151;
    set C = P.addEdge(ep);
A77: P.addEdge(ep) is non trivial by A72,GLIB_001:133;
    P.addEdge(ep) is_Walk_from v2,v2 by A65,A69,GLIB_001:67;
    then P.addEdge(ep) is closed by GLIB_001:120;
    then
A78: C is Cycle-like by A76,A77,GLIB_001:def 31;
A79: ep SJoins Gk1b`1, VG1 \ Gk1b`1,G1 by A51,Def12;
A80: (the_Source_of G1).ep = v1 & (the_Target_of G1).ep = v2
    by A60,GLIB_000:def 34;
A81: v1 = P.(len P) & v2 = P.1 by A62,GLIB_001:18;
    now per cases by A79,A80,GLIB_000:def 17;
      suppose
A82:    v1 in Gk1b`1 & v2 in VG1\Gk1b`1;
        defpred P3[Nat] means
        $1 is odd & $1 <= len P & P.$1 in Gk1b`1;
A83:    ex n being Nat st P3[n] by A81,A82;
        consider m being Nat such that
A84:    P3[m] & for n being Nat st P3[n] holds m <= n from NAT_1:sch 5(A83);
        reconsider m as odd Element of NAT by A84,ORDINAL1:def 13;
A85:    1 <= m & m <= len P by A84,HEYTING3:1;
        m <> 1 by A81,A82,A84,XBOOLE_0:def 5;
        then 1 < m by A85,XXREAL_0:1;
        then 1+1 <= m by NAT_1:13;
        then reconsider m2k = m-2*1 as odd Element of NAT by INT_1:18;
A86:    m2k < m - 0 by XREAL_1:17;
        then
A87:    m2k < len P by A84,XXREAL_0:2;
        then
A88:    not P.m2k in Gk1b`1 by A84,A86;
A89:    m2k+2 = m;
        set em = P.(m2k+1);
        take em;
A90:    em in P.edges() by A87,GLIB_001:101;
        C.edges() = P.edges() \/ {ep} by A72,GLIB_001:112;
        hence em in C.edges() by A90,XBOOLE_0:def 3;
        consider i being even Element of NAT such that
A91:    1 <= i & i <= len P & P.i = em by A90,GLIB_001:100;
        i in dom P by A91,FINSEQ_3:27;
        then
A92:    C.i = em by A72,A91,GLIB_001:66;
A93:    len C = len P + 2 by A72,GLIB_001:65;
A94:    C.(len P + 1) = ep by A72,GLIB_001:66;
        len P + 0 < len P + 1 by XREAL_1:10;
        then
A95:    i < len P + 1 by A91,XXREAL_0:2;
       len P + 1 <= len P + 2 by XREAL_1:9;
        hence em <> ep by A76,A91,A92,A93,A94,A95,GLIB_001:139;
A97:    em Joins PW.m2k, PW.m, M by A87,A89,GLIB_001:def 3;
        then PW.m2k in the_Vertices_of M by GLIB_000:16;
        then PW.m2k in the_Vertices_of M\Gk1b`1 by A88,XBOOLE_0:def 5;
        hence em SJoins V, the_Vertices_of M \ V, M by A84,A97,GLIB_000:20;
      end;
      suppose
A98:    v2 in Gk1b`1 & v1 in VG1\Gk1b `1;
        defpred P3[Nat] means $1 is odd & $1 <= len P &
        P.$1 in VG1\Gk1b`1;
A99:    ex n being Nat st P3[n] by A81,A98;
        consider m being Nat such that
A100:   P3[m] & for n being Nat st P3[n] holds m <= n from NAT_1:sch 5(A99);
        reconsider m as odd Element of NAT by A100,ORDINAL1:def 13;
A101:   1 <= m & m <= len P by A100,HEYTING3:1;
        m <> 1 by A81,A98,A100,XBOOLE_0:def 5;
        then 1 < m by A101,XXREAL_0:1;
        then 1+1 <= m by NAT_1:13;
        then reconsider m2k = m-2*1 as odd Element of NAT by INT_1:18;
A102:   m2k < m - 0 by XREAL_1:17;
        then
A103:   m2k < len P by A100,XXREAL_0:2;
A104:   now
          assume
A105:     not P.m2k in Gk1b`1;
          P.m2k in VG1 by A58,A103,GLIB_001:8;
          then P.m2k in VG1\Gk1b`1 by A105,XBOOLE_0:def 5;
          hence contradiction by A100,A102,A103;
        end;
A106:   m2k+2 = m;
        set em = P.(m2k+1);
        take em;
A107:   em in P.edges() by A103,GLIB_001:101;
        C.edges() = P.edges() \/ {ep} by A72,GLIB_001:112;
        hence em in C.edges() by A107,XBOOLE_0:def 3;
        consider i being even Element of NAT such that
A108:   1 <= i & i <= len P & P.i = em by A107,GLIB_001:100;
        i in dom P by A108,FINSEQ_3:27;
        then
A109:   C.i = em by A72,A108,GLIB_001:66;
A110:   len C = len P + 2 by A72,GLIB_001:65;
A111:   C.(len P + 1) = ep by A72,GLIB_001:66;
        len P + 0 < len P + 1 by XREAL_1:10;
        then
A112:   i < len P + 1 by A108,XXREAL_0:2;
        len P + 1 <= len P + 2 by XREAL_1:9;
        hence em <> ep by A76,A108,A109,A110,A111,A112,GLIB_001:139;
        em Joins PW.m2k, PW.m, M by A103,A106,GLIB_001:def 3;
        hence em SJoins V, the_Vertices_of M \ V, M
        by A58,A100,A104,GLIB_000:20;
      end;
    end;
    then consider em being set such that
A114: em in C.edges() & em <> ep & em SJoins V, the_Vertices_of M \ V, M;
A115: em SJoins V, VG1 \ V, G1 by A58,A114,GLIB_000:75;
    then
A116: (WG1).ep <= (WG1).em by A51,Def12;
    consider M2 being weight-inheriting ([Weighted] removeEdge of Mep,em);
    reconsider M2 as WSubgraph of G1 by GLIB_003:16;
    the_Vertices_of M c= the_Vertices_of Mep &
    the_Edges_of M c= the_Edges_of Mep by A59,XBOOLE_1:7;
    then reconsider M'=M as connected Subgraph of Mep by GLIB_000:47;
    the_Vertices_of M' = the_Vertices_of Mep by A59,GLIB_000:def 35;
    then M' is spanning by GLIB_000:def 35;
    then Mep is connected by GLIB_002:23;
    then
A117: M2 is connected by A78,A114,GLIB_002:5;
A118: the_Edges_of M2 = the_Edges_of M \/ {ep} \{em} by A59,GLIB_000:54;
    now
      {em} c= the_Edges_of M \/ {ep} by A59,A114,ZFMISC_1:37;
      then
A119: M2.size() = card (the_Edges_of M \/{ep})-card {em} by A118,CARD_2:63
        .= card (the_Edges_of M \/ {ep}) - 1 by CARD_1:50
        .= card the_Edges_of M + 1 - 1 by A56,CARD_2:54
        .= M.size();
      M2.order() = card VG1 by A59,GLIB_000:56
        .= M.order() by GLIB_000:def 35;
      hence M2.order() = M2.size() + 1 by A119,GLIB_002:46;
    end;
    then
A120: M2 is Tree-like by A117,GLIB_002:47;
    set M2' = M2.strict(WGraphSelectors);
A121: M2' == M2 & the_Weight_of M2' = the_Weight_of M2 by Lm2;
    then
A122: the_Edges_of M2' = the_Edges_of M \/ {ep} \ {em} by A118,GLIB_000:def 36;
    reconsider M2' as WSubgraph of G1 by A121,GLIB_003:15;
    now thus M2' is Tree-like by A120,Lm2,GLIB_002:48;
      the_Vertices_of M2' = the_Vertices_of M2 by A121,GLIB_000:def 36
        .= VG1 by A59,GLIB_000:56;
      hence M2' is spanning by GLIB_000:def 35;
    end;
    then reconsider M2' as spanning Tree-like WSubgraph of G1;
    now
A123: G1.edgesBetween(VG1) = EG1 by GLIB_000:37;
      then
A124: the_Edges_of M c= G1.edgesBetween(VG1) &
      VG1 c= VG1;
      VG1 = the_Vertices_of M by GLIB_000:def 35;
      then M is inducedWSubgraph of G1,VG1, the_Edges_of M
      by A123,GLIB_000:def 39;
      then
A126: Mep.cost() = M.cost() + (WG1).ep
      by A52,A56,A123,A124,Th34;
      M2.cost() + (the_Weight_of Mep).em = Mep.cost() by A114,Th33;
      then
A127: M2.cost() = Mep.cost() - (the_Weight_of Mep).em;
      the_Weight_of Mep = (WG1) | the_Edges_of Mep
      by GLIB_003:def 10;
      then M2.cost() = M.cost()+(WG1).ep-(WG1).em by A114,A126,A127,FUNCT_1:72;
      hence M2'.cost() = M.cost()+(WG1).ep - (WG1).em by A121,GLIB_000:def 36;
    end;
    then
A128: M2'.cost() + (WG1).em - (WG1).em <=
    M.cost() + (WG1).ep - (WG1).ep by A116,XREAL_1:15;
    now
      let G3 being spanning Tree-like WSubgraph of G1;
      M.cost() <= G3.cost() by Def17;
      hence M2'.cost() <= G3.cost() by A128,XXREAL_0:2;
    end;
    then reconsider M2' as minimumSpanningTree of G1 by Def17;
    set MG2' = the_Edges_of M2' /\ the_Edges_of G2;
    set MG2 = the_Edges_of M /\ the_Edges_of G2;
A129: MG2' = ((the_Edges_of M \/ {ep}) /\ the_Edges_of G2) \
    {em} /\ the_Edges_of G2 by A122,XBOOLE_1:50;
    now
      assume MG2 /\ {ep} <> {};
      then consider x being set such that
A130: x in MG2 /\ {ep} by XBOOLE_0:def 1;
      x in MG2 & x in {ep} by A130,XBOOLE_0:def 4;
      then x in the_Edges_of M & x = ep by TARSKI:def 1,XBOOLE_0:def 4;
      hence contradiction by A55,ZFMISC_1:37;
    end;
    then
A131: MG2 misses {ep} by XBOOLE_0:def 7;
    dom M2' = WGraphSelectors by Lm3;
    then M2' in G1.allWSubgraphs() by Def10;
    then
A132: M2' in X;
A133: now thus not (PCS.(k1o+1))`2 c= the_Edges_of M by A46,A48;
      let n be Nat;
      assume n <= k1o;
      then (PCS.n)`2 c= Gk1b`2 by Lm13;
      hence (PCS.n)`2 c= the_Edges_of M by A50,XBOOLE_1:1;
    end;
A134: now
      assume
A135: em in the_Edges_of G2;
      then
A136: MG2'=((the_Edges_of M\/{ep})/\the_Edges_of G2)\{em} by A129,ZFMISC_1:52;
      now
        let x be set;
        assume x in {em};
        then x = em by TARSKI:def 1;
        hence x in (the_Edges_of M \/ {ep}) /\ the_Edges_of G2
        by A59,A114,A135,XBOOLE_0:def 4;
      end;
      then {em}c=(the_Edges_of M\/{ep})/\the_Edges_of G2 by TARSKI:def 3;
      then
A137: card MG2' = card (the_Edges_of Mep /\ the_Edges_of G2) -
      card {em} by A59,A136,CARD_2:63
        .= card (the_Edges_of Mep /\ the_Edges_of G2) - 1 by CARD_1:50
        .= card (MG2 \/ {ep}) - 1 by A59,A68,XBOOLE_1:23
        .= card MG2 + card {ep} - 1 by A131,CARD_2:53
        .= card MG2 + 1 - 1 by CARD_1:50
        .= card MG2;
      consider k2 being Nat such that
A138: Z[M2',k2] by A8,A132;
A139: now
        set Vr = VG1 \ V;
        assume
A140:   em in Gk1b`2;
        Gk1b`2 c= G1.edgesBetween(Gk1b`1) by Lm9;
        then (the_Source_of G1).em in Gk1b`1 &
        (the_Target_of G1).em in Gk1b`1 by A140,GLIB_000:34;
        then not (the_Source_of G1).em in Vr &
        not (the_Target_of G1).em in Vr by XBOOLE_0:def 5;
        hence contradiction by A115,GLIB_000:def 17;
      end;
      now
        let x be set;
        assume
A141:   x in Gk`2;
        now per cases by A54,A141,XBOOLE_0:def 3;
          suppose
A142:       x in Gk1b`2;
            then
A143:       x in the_Edges_of M \/ {ep} by A50,XBOOLE_0:def 3;
            not x in {em} by A139,A142,TARSKI:def 1;
            hence x in the_Edges_of M2' by A122,A143,XBOOLE_0:def 5;
          end;
          suppose
A144:       x in {ep};
            then
A145:       x in the_Edges_of M \/ {ep} by XBOOLE_0:def 3;
            x = ep by A144,TARSKI:def 1;
            then not x in {em} by A114,TARSKI:def 1;
            hence x in the_Edges_of M2' by A122,A145,XBOOLE_0:def 5;
          end;
        end;
        hence x in the_Edges_of M2';
      end;
      then
A146: Gk`2 c= the_Edges_of M2' by TARSKI:def 3;
A147: now
        assume k2 < k;
        then k2+1 <= k by NAT_1:13;
        then (PCS.(k2+1))`2 c= Gk`2 by Lm13;
        hence contradiction by A138,A146,XBOOLE_1:1;
      end;
A148: k1o >= k2 by A39,A132,A133,A137,A138;
      k1o + 1 - 1 < k - 0 by A48,XREAL_1:17;
      hence contradiction by A147,A148,XXREAL_0:2;
    end;
    now
      assume {em} /\ the_Edges_of G2 <> {};
      then consider x being set such that
A149: x in {em} /\ the_Edges_of G2 by XBOOLE_0:def 1;
      x in {em} & x in the_Edges_of G2 by A149,XBOOLE_0:def 4;
      hence contradiction by A134,TARSKI:def 1;
    end;
    then
A150: MG2' = MG2 \/ ({ep} /\ the_Edges_of G2) by A129,XBOOLE_1:23;
    now
      assume MG2 /\ {ep} <> {};
      then consider x being set such that
A151: x in MG2 /\ {ep} by XBOOLE_0:def 1;
      x in MG2 & x in {ep} by A151,XBOOLE_0:def 4;
      then x in the_Edges_of M & x = ep by TARSKI:def 1,XBOOLE_0:def 4;
      hence contradiction by A55,ZFMISC_1:37;
    end;
    then MG2 misses {ep} by XBOOLE_0:def 7;
    then card MG2' = card MG2 + card {ep} by A68,A150,CARD_2:53
      .= card MG2 + 1 by CARD_1:50;
    then card MG2 + 0 >= card MG2 + 1 by A39,A132;
    hence contradiction by XREAL_1:8;
  end;
  hence thesis;
end;

