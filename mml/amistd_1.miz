:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, ORDINAL2, ARYTM, SQUARE_1, FINSET_1, REALSET1, FINSEQ_1,
      RELAT_1, AMI_1, BOOLE, FUNCT_1, SGRAPH1, FUNCOP_1, CAT_1, GRAPH_2,
      FINSEQ_4, FUNCT_4, CARD_3, AMI_5, SETFAM_1, TARSKI, GOBOARD5, ARYTM_1,
      ORDINAL1, FUNCT_2, FRECHET, PRE_TOPC, WAYBEL_0, CARD_1, AMISTD_1,
      MEMBERED;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4, FUNCOP_1, FINSET_1,
      FUNCT_4, STRUCT_0, NAT_D, XXREAL_2, FUNCT_2, AMI_1;
 constructors RELAT_2, PARTFUN1, WELLORD2, XXREAL_0, REAL_1, NAT_1, FINSEQ_4,
      REALSET1, NAT_D, AMI_1, INT_2, MEMBERED, XXREAL_2, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FUNCOP_1, FINSET_1, NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1,
      CARD_3, REALSET1, FINSEQ_5, FUNCT_7, STRUCT_0, AMI_1, JORDAN1J, CARD_1,
      XXREAL_2, RELSET_1;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, AMI_1, YELLOW_8, XBOOLE_0, FUNCOP_1, NAT_1,
      RELAT_1;
 theorems TARSKI, FINSEQ_4, FINSEQ_1, GRAPH_2, NAT_1, AMI_1, FUNCT_4, FUNCT_1,
      FUNCT_2, RELAT_1, ENUMSET1, ZFMISC_1, CARD_1, FUNCOP_1, CARD_3, ORDINAL1,
      MCART_1, GRFUNC_1, FINSEQ_3, INT_1, SETFAM_1, REVROT_1, FUNCT_7,
      RELSET_1, XBOOLE_0, XBOOLE_1, MEMBERED, XREAL_1, XXREAL_0, FINSEQ_6,
      PARTFUN1, FINSET_1, XXREAL_2, XREAL_0, NAT_D;
 schemes NAT_1, FUNCT_7, FINSEQ_2, AMI_1, DOMAIN_1, FUNCT_2, FINSEQ_4;

begin :: Ami-Struct

reserve x for set,
  D for non empty set,
  k, n for Element of NAT,
  z for natural
  number;

reserve N for with_non-empty_elements set,
  IL for non empty set,
  S for
  IC-Ins-separated definite (non empty stored-program AMI-Struct over IL,N),
  i
  for Element of the Instructions of S,
  l, l1, l2, l3 for Instruction-Location of
  S,
  s for State of S;

canceled 10;

theorem Th11:
  for S being definite (non empty stored-program AMI-Struct over
IL,N), I being Element of the Instructions of S, s being State of S holds s +*
  ((IL) --> I) is State of S
proof
  let S be definite (non empty stored-program AMI-Struct over IL,N), I be
  Element of the Instructions of S, s be State of S;
  set f = (IL) --> I;
  set Ok = the Object-Kind of S;
A1: dom f = IL & IL c= the carrier of S by AMI_1:def 3,FUNCOP_1:19;
A2: for x st x in dom f holds f.x in Ok.x
  proof
    let x;
    assume
A3: x in dom f;
    then
A4: f.x = I by FUNCOP_1:13;
    reconsider x as Instruction-Location of S by A3,AMI_1:def 4;
    Ok.x = ObjectKind x
      .= the Instructions of S by AMI_1:def 14;
    hence thesis by A4;
  end;
A5: dom s = the carrier of S by AMI_1:79;
  then dom Ok = dom s by FUNCT_2:def 1;
  then f in sproduct Ok by A1,A5,A2,CARD_3:def 9;
  hence thesis by CARD_3:69;
end;

registration
  let IL,N be set, S be AMI-Struct over IL,N;
  cluster empty -> IL-defined FinPartState of S;
  coherence
  proof
    let F be FinPartState of S;
    assume
    F is empty;
    then reconsider G = F as empty Function;
    dom G c= IL by XBOOLE_1:2;
    hence dom F c= IL;
  end;
end;

registration
  let IL,N be set, S be AMI-Struct over IL,N;
  cluster empty FinPartState of S;
  existence
  proof
    reconsider a = {} as FinPartState of S by CARD_3:66;
    take a;
    thus thesis;
  end;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite (non
  empty stored-program AMI-Struct over IL,N);
  cluster non empty trivial IL-defined FinPartState of S;
  existence
  proof
    consider l being Instruction-Location of S, I being Instruction of S;
    take l .--> I;
    thus thesis;
  end;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be stored-program AMI-Struct over IL
  ,N, i be Element of the Instructions of S, s be State of S;
  cluster ((the Execution of S).i).s -> Function-like Relation-like;
  coherence
  proof
    reconsider A =(the Execution of S).i as Function of product the
    Object-Kind of S, product the Object-Kind of S by FUNCT_2:121;
    A.s in product the Object-Kind of S;
    hence thesis;
  end;
end;

Lm1: for S being steady-programmed IC-Ins-separated definite (non empty
stored-program AMI-Struct over IL,N), il being Instruction-Location of S, I
being Element of the Instructions of S, f being FinPartState of S st f = il
.--> I holds f is autonomic

proof

  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over IL,N);

  let il be Instruction-Location of S;
  let I be Element of the Instructions of S;
  let f be FinPartState of S such that
A1: f = il .--> I;
A2: dom f = {il} by A1,FUNCOP_1:19;
  let s1, s2 be State of S such that
A3: f c= s1 and
A4: f c= s2;
  let i be Element of NAT;
  set a = ( Computation(s1,i)|dom f), b = ( Computation(s2,i)|dom f);
A5: for s being Function st f c= s holds s.il = I
  proof
A6: il in {il} by TARSKI:def 1;
    let s be Function;
    assume
    f c= s;
    hence s.il = f.il by A2,A6,GRFUNC_1:8
      .= I by A1,FUNCOP_1:87;
  end;
A7: for x st x in {il} holds a.x = b.x
  proof
    let x;
    assume
A8: x in {il};
    then
A9: x = il by TARSKI:def 1;
    thus a.x = Computation(s1,i).x by A2,A8,FUNCT_1:72
      .= I by A1,A3,A5,A9,AMI_1:81
      .= Computation(s2,i).x by A1,A4,A5,A9,AMI_1:81
      .= b.x by A2,A8,FUNCT_1:72;
  end;
A10: {il} c= the carrier of S;
  then {il} c= dom ( Computation(s2,i)) by AMI_1:79;
  then
A11: dom b = {il} by A2,RELAT_1:91;
  {il} c= dom ( Computation(s1,i)) by A10,AMI_1:79;
  then dom a = {il} by A2,RELAT_1:91;

  hence Computation(s1,i)|dom f = Computation(s2,i)|dom f by A11,A7,
  FUNCT_1:9;

end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over IL,N);
  cluster non empty trivial autonomic IL-defined FinPartState of S;
  existence
  proof
    consider I being Instruction of S;
    consider l being Instruction-Location of S;
    take l.-->I;
    thus thesis by Lm1;
  end;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over IL,N), il being Instruction-Location of S, I
  being Element of the Instructions of S holds il .--> I is autonomic by Lm1;

theorem Th13:
  for S being steady-programmed IC-Ins-separated definite (non
  empty stored-program AMI-Struct over IL,N) holds S is programmable
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over IL,N);
  consider l being Instruction-Location of S;
  consider I being Instruction of S;
  take l.-->I;
  thus thesis by Lm1;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  cluster steady-programmed -> programmable (IC-Ins-separated definite (non
    empty stored-program AMI-Struct over IL,N));
  coherence by Th13;
end;

definition
  let IL,N be set, S be AMI-Struct over IL,N;
  mode IL-Subset of S -> Subset of IL means
    :Def1:
    not contradiction;
  existence;
end;

registration
  let IL,N be set, S be AMI-Struct over IL,N;
  cluster empty IL-Subset of S;
  existence
  proof
    {}IL is IL-Subset of S by Def1;
    hence thesis;
  end;
end;

registration
  let IL be non empty set,N be set, S be non empty AMI-Struct over IL,N;
  cluster non empty IL-Subset of S;
  existence
  proof
    consider x being Element of IL;
    {x} is IL-Subset of S by Def1;
    hence thesis;
  end;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be non empty stored-program standard-ins AMI-Struct over IL,N;
  let T be InsType of S;
  canceled;
  attr T is jump-only means
  for s being State of S, o being Object of S, I
  being Instruction of S st InsCode I = T & o <> IC S holds Exec(I, s).o = s.o;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be non empty stored-program standard-ins AMI-Struct over IL,N;
  let I be Instruction of S;
  attr I is jump-only means
  InsCode I is jump-only;
end;

definition
  let IL,N,S,l;
  let i be Element of the Instructions of S;
  func NIC(i,l) -> IL-Subset of S equals
  { IC Following s : IC s = l & s.l = i
  };
  coherence
  proof
    { IC Following s : IC s = l & s.l = i } c= IL
    proof
      let e be set;
      assume
      e in { IC Following s : IC s = l & s.l = i };
      then ex s st e = IC Following s & IC s = l & s.l = i;
      hence thesis by AMI_1:def 4;
    end;
    hence thesis by Def1;
  end;
end;

Lm2: now
  let IL,N;

  let S be realistic IC-Ins-separated definite (non empty stored-program
  AMI-Struct over IL,N), i be Element of the Instructions of S, l be
  Instruction-Location of S, s be State of S, f be FinPartState of S such that

A1: f = (IC S,l) --> (l,i);
  set t = s +* f;
A2: dom f = {IC S,l} by A1,FUNCT_4:65;
  then l in dom f by TARSKI:def 2;
  then
A3: t.l = f.l by FUNCT_4:14
    .= i by A1,FUNCT_4:66;
  IC S in dom f by A2,TARSKI:def 2;
  then IC t = f.IC S by FUNCT_4:14
    .= l by A1,AMI_1:48,FUNCT_4:66;
  hence IC Following t in NIC(i,l) by A3;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be realistic IC-Ins-separated
  definite (non empty stored-program AMI-Struct over IL,N), i be Element of the
  Instructions of S, l be Instruction-Location of S;
  cluster NIC(i,l) -> non empty;
  coherence
  proof
    consider s being State of S;
A1: ObjectKind l = the Instructions of S by AMI_1:def 14;
    l in IL & ObjectKind IC S = IL by AMI_1:def 4,def 11;
    then reconsider f = (IC S,l) --> (l,i) as FinPartState of S by
    A1,AMI_1:58;
    IC Following (s +* f) in NIC(i,l) by Lm2;
    hence thesis;
  end;
end;

definition
  let IL,N,S,i;
  func JUMP i -> Subset of IL equals
  meet { NIC(i,l) : not contradiction };
  coherence
  proof
    set X = { NIC(i,l) : not contradiction };
    X c= bool IL
    proof
      let x be set;
      assume
      x in X;
      then ex l st x = NIC(i,l);
      hence thesis;
    end;
    then reconsider X as Subset-Family of IL;
    meet X c= IL;
    hence thesis;
  end;
end;

definition
  let IL,N,S,l;
  func SUCC l -> Subset of IL equals
  union { NIC(i,l) \ JUMP i : not
  contradiction };
  coherence
  proof
    set X = { NIC(i,l) \ JUMP i : not contradiction };
    X c= bool IL
    proof
      let x be set;
      assume
      x in X;
      then ex i st x = NIC(i,l) \ JUMP i;
      hence thesis;
    end;
    then reconsider X as Subset-Family of IL;
    union X c= IL;
    hence thesis;
  end;
end;

theorem Th14:
  for i being Element of the Instructions of S st IL is non
trivial & (for l being Instruction-Location of S holds NIC(i,l)={l}) holds JUMP
  i is empty
proof
  let i be Element of the Instructions of S;
  given p, q being Element of IL such that
A1: p <> q;
  set X = { NIC(i, l) where l is Instruction-Location of S: not contradiction
  };
  reconsider p,q as Instruction-Location of S by AMI_1:def 4;
  assume
A2: for l being Instruction-Location of S holds NIC(i,l)={l};
  assume
  not thesis;
  then consider x being set such that
A3: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {p} by A2;
  then {p} in X;
  then x in {p} by A3,SETFAM_1:def 1;
  then
A4: x = p by TARSKI:def 1;
  NIC(i,q) = {q} by A2;
  then {q} in X;
  then x in {q} by A3,SETFAM_1:def 1;
  hence contradiction by A1,A4,TARSKI:def 1;
end;

theorem Th15:
  for S being realistic IC-Ins-separated definite (non empty
  stored-program AMI-Struct over IL,N), il being Instruction-Location of S, i
  being Instruction of S st i is halting holds NIC(i,il) = {il}
proof
  let S be realistic IC-Ins-separated definite (non empty stored-program
  AMI-Struct over IL,N), il be Instruction-Location of S, i be Instruction of S
  such that
A1: for s being State of S holds Exec(i,s) = s;
  hereby
    let n be set;
    assume
    n in NIC(i,il);
    then ex s being State of S st n = IC Following s & IC s = il & s.il = i;
    then n = il by A1;
    hence n in {il} by TARSKI:def 1;
  end;
A2: ObjectKind il = the Instructions of S by AMI_1:def 14;
  il in IL & ObjectKind IC S = IL by AMI_1:def 4,def 11;
  then reconsider f = (IC S,il) --> (il,i) as FinPartState of S by
  A2,AMI_1:58;
  consider s being State of S;
  let n be set;
  assume
A3: n in {il};
  set a = s+*f;
A4: dom f = {IC S,il} by FUNCT_4:65;
  then IC S in dom f by TARSKI:def 2;
  then
A5: a.IC S = f.IC S by FUNCT_4:14
    .= il by AMI_1:48,FUNCT_4:66;
  il in dom f by A4,TARSKI:def 2;
  then a.IC a = f.il by A5,FUNCT_4:14
    .= i by FUNCT_4:66;
  then IC Following a = a.IC S by A1
    .= n by A3,A5,TARSKI:def 1;
  hence thesis by Lm2;
end;

begin :: Ordering of Instruction Locations

definition
  let IL,N,S,l1,l2;
  pred l1 <= l2 means
  :Def8:
  ex f being non empty IL-FinSequence of S st f/.1
= l1 & f/.len f = l2 & for n st 1 <= n & n < len f holds f/.(n+1) in SUCC f/.n;
  reflexivity
  proof
    let l;
    take <*l*>;
    l in IL by AMI_1:def 4;
    hence <*l*>/.1 = l by FINSEQ_4:25;
    hence thesis by FINSEQ_1:56;
  end;
end;

theorem
  l1 <= l2 & l2 <= l3 implies l1 <= l3
proof
  given f1 being non empty IL-FinSequence of S such that
A1: f1/.1 = l1 and
A2: f1/.len f1 = l2 and
A3: for n st 1 <= n & n < len f1 holds f1/.(n+1) in SUCC f1/.n;
  given f2 being non empty IL-FinSequence of S such that
A4: f2/.1 = l2 and
A5: f2/.len f2 = l3 and
A6: for n st 1 <= n & n < len f2 holds f2/.(n+1) in SUCC f2/.n;
  take f1^'f2;
  thus (f1^'f2)/.1 = l1 by A1,GRAPH_2:57;
  now
    per cases;
    suppose
      f2 is trivial;
      then
A7:   ex x being Element of IL st f2 = <*x*> by FINSEQ_6:113;
      then f1^'f2 = f1 by GRAPH_2:60;
      hence (f1^'f2)/.len(f1^'f2) = l3 by A2,A4,A5,A7,FINSEQ_1:56;
    end;
    suppose
      f2 is not trivial;
      hence (f1^'f2)/.len(f1^'f2) = l3 by A5,GRAPH_2:58;
    end;
  end;
  hence (f1^'f2)/.len(f1^'f2) = l3;
  let n such that
A8: 1 <= n and
A9: n < len(f1^'f2);
A10: len (f1^'f2) +1 = len f1 + len f2 by GRAPH_2:13;
  per cases by XXREAL_0:1;
  suppose
A11: n < len f1;
    then n+1 <= len f1 by NAT_1:13;
    then
A12: (f1^'f2)/.(n+1) = f1/.(n+1) by GRAPH_2:61,NAT_1:11;
    (f1^'f2)/.n = f1/.n by A8,A11,GRAPH_2:61;
    hence thesis by A3,A8,A11,A12;
  end;
  suppose
A13: n = len f1;
    then
A14: (f1^'f2)/.n = f2/.1 by A2,A4,A8,GRAPH_2:61;
    n+1 < len (f1^'f2) +1 by A9,XREAL_1:8;
    then
A15: 1 < len f2 by A10,A13,XREAL_1:8;
    then (f1^'f2)/.(n+1) = f2/.(1+1) by A13,GRAPH_2:62;
    hence thesis by A6,A14,A15;
  end;
  suppose
A16: n > len f1;
    then consider m being Nat such that
A17: len f1 + m = n by NAT_1:10;
    reconsider m as Element of NAT by ORDINAL1:def 13;
A18: len f1 + m > len f1 + 0 by A16,A17;
    len f1 + m+1 < len f1 + len f2 by A9,A10,A17,XREAL_1:8;
    then len f1 + (m+1) < len f1 + len f2;
    then
A19: m+1 < len f2 by XREAL_1:8;
A20: (f1^'f2)/.(n+1) = (f1^'f2)/.(len f1 + (m+1)) by A17
      .= f2/.(m+1+1) by A19,GRAPH_2:62,NAT_1:11;
    m <= m+1 by NAT_1:11;
    then m < len f2 by A19,XXREAL_0:2;
    then (f1^'f2)/.n = f2/.(m+1) by A17,A18,GRAPH_2:62,NAT_1:14;
    hence thesis by A6,A19,A20,NAT_1:11;
  end;
end;

definition
  let IL, N, S;
  attr S is InsLoc-antisymmetric means
  for l1, l2 st l1 <= l2 & l2 <= l1 holds
  l1 = l2;
end;

definition
  let IL, N, S;
  attr S is standard means
  :Def10:
  ex f being IL-Function of NAT, S st f is
  bijective & for m, n being Element of NAT holds m <= n iff f.m <= f.n;
end;

theorem Th17:
  for f1, f2 being IL-Function of NAT, S st f1 is bijective & (for
m, n being Element of NAT holds m <= n iff f1.m <= f1.n) & f2 is bijective & (
  for m, n being Element of NAT holds m <= n iff f2.m <= f2.n) holds f1 = f2
proof
  let f1, f2 be IL-Function of NAT, S such that
A1: f1 is bijective and
A2: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n and
A3: f2 is bijective and
A4: for m, n being Element of NAT holds m <= n iff f2.m <= f2.n;
A5: dom f1 = NAT by FUNCT_2:def 1;
A6: dom f2 = NAT by FUNCT_2:def 1;
  defpred P[Nat] means f1.$1 <> f2.$1;
  assume
  f1 <> f2;
  then ex c being Element of NAT st P[c] by FUNCT_2:113;
  then
A7: ex c being Nat st P[c];
  consider d being Nat such that
A8: P[d] and
A9: for n being Nat st P[n] holds d <= n from NAT_1:sch 5(A7);
  reconsider d as Element of NAT by ORDINAL1:def 13;
  rng f1 = IL by A1,FUNCT_2:def 3;
  then consider d1 being set such that
A10: d1 in dom f1 and
A11: f2.d = f1.d1 by FUNCT_1:def 5;
  reconsider d1 as Element of NAT by A10;
  rng f2 = IL by A3,FUNCT_2:def 3;
  then consider d2 being set such that
A12: d2 in dom f2 and
A13: f1.d = f2.d2 by FUNCT_1:def 5;
  reconsider d2 as Element of NAT by A12;
  per cases;
  suppose
A14: d1 <= d & d2 <= d;
    then f2.d2 <= f2.d by A4;
    then d <= d1 by A2,A13,A11;
    hence contradiction by A8,A11,A14,XXREAL_0:1;
  end;
  suppose
A15: d <= d1 & d2 <= d;
    f2.d2 = f1.d2
    proof
      assume
      not thesis;
      then d <= d2 by A9;
      hence contradiction by A8,A13,A15,XXREAL_0:1;
    end;
    hence contradiction by A1,A8,A13,A5,FUNCT_1:def 8;
  end;
  suppose
A16: d1 <= d & d <= d2;
    f1.d1 = f2.d1
    proof
      assume
      not thesis;
      then d <= d1 by A9;
      hence contradiction by A8,A11,A16,XXREAL_0:1;
    end;
    hence contradiction by A3,A8,A11,A6,FUNCT_1:def 8;
  end;
  suppose
A17: d <= d1 & d <= d2;
    then f2.d <= f2.d2 by A4;
    then d1 <= d by A2,A13,A11;
    hence contradiction by A8,A11,A17,XXREAL_0:1;
  end;
end;

theorem Th18:
  for f being IL-Function of NAT, S st f is bijective holds (for m
  , n being Element of NAT holds m <= n iff f.m <= f.n) iff for k being Element
of NAT holds f.(k+1) in SUCC (f.k) & for j being Element of NAT st f.j in SUCC
  (f.k) holds k <= j
proof
  let f be IL-Function of NAT, S;
  assume
A1: f is bijective;
  hereby
    assume
A2: for m, n being Element of NAT holds m <= n iff f.m <= f.n;
    let k be Element of NAT;
    k <= k+1 by NAT_1:11;
    then f.k <= f.(k+1) by A2;
    then consider F being non empty IL-FinSequence of S such that
A3: F/.1 = f.k and
A4: F/.len F = f.(k+1) and
A5: for n st 1 <= n & n < len F holds F/.(n+1) in SUCC F/.n by Def8;
    set F1 = F -| f.(k+1);
    set x = (f.(k+1))..F;
A6: f.(k+1) in rng F by A4,REVROT_1:3;
    then
A7: len F1 = x-1 by FINSEQ_4:46;
    then
A8: len F1+1 = x;
A9: x in dom F by A6,FINSEQ_4:30;
    then
A10: F/.(len F1+1) = F.x by A7,PARTFUN1:def 8
      .= f.(k+1) by A6,FINSEQ_4:29;
    x <= len F by A9,FINSEQ_3:27;
    then
A11: len F1 < len F by A8,NAT_1:13;
    1 <= len F by NAT_1:14;
    then
A12: 1 in dom F by FINSEQ_3:27;
    then
A13: F/.1 = F.1 by PARTFUN1:def 8;
A14: F.x = f.(k+1) by A6,FINSEQ_4:29;
A15: dom f = NAT by FUNCT_2:def 1;
A16: f.k <> f.(k+1)
    proof
      assume
      not thesis;
      then 0+k = k+1 by A1,A15,FUNCT_1:def 8;
      hence contradiction;
    end;
    then len F1 <> 0 by A3,A14,A12,A7,PARTFUN1:def 8;
    then
A17: F1 is non empty FinSequence of IL by A6,FINSEQ_4:53;
    1 <= x by A9,FINSEQ_3:27;
    then 1 < x by A3,A16,A14,A13,XXREAL_0:1;
    then
A18: 1 <= len F1 by A8,NAT_1:13;
    reconsider F1 as non empty IL-FinSequence of S by A17,AMI_1:def 34;
    rng f = IL by A1,FUNCT_2:def 3;
    then consider m being set such that
A19: m in dom f and
A20: f.m = F/.len F1 by FUNCT_1:def 5;
    reconsider m as Element of NAT by A19;
A21: len F1 in dom F by A18,A11,FINSEQ_3:27;
A22: len F1 in dom F1 by A18,FINSEQ_3:27;
    then
A23: F1/.len F1 = F1.len F1 by PARTFUN1:def 8
      .= F.len F1 by A6,A22,FINSEQ_4:48
      .= F/.len F1 by A21,PARTFUN1:def 8;
A24: now
      (rng F1) misses {f.(k+1)} by A6,FINSEQ_4:50;
      then rng F1 /\ {f.(k+1)} = {} by XBOOLE_0:def 7;
      then
A25:  not f.(k+1) in rng F1 or not f.(k+1) in {f.(k+1)} by
      XBOOLE_0:
      def 4;
      assume
A26:  m = k+1;
A27:  len F1 in dom F1 by A18,FINSEQ_3:27;
      then F1/.len F1 = F1.len F1 by PARTFUN1:def 8;
      hence contradiction by A20,A23,A26,A25,A27,FUNCT_1:def 5,TARSKI:def 1;
    end;
    reconsider F2 = <*F/.len F1, F/.x*> as non empty IL-FinSequence of S;
A28: len F2 = 2 by FINSEQ_1:61;
    then
A29: 2 in dom F2 by FINSEQ_3:27;
    then
A30: F2/.len F2 = F2.2 by A28,PARTFUN1:def 8
      .= F/.x by FINSEQ_1:61
      .= f.(k+1) by A14,A9,PARTFUN1:def 8;
A31: 1 in dom F2 by A28,FINSEQ_3:27;
A32: now
      let n;
      assume
      1 <= n & n < len F2;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A33:  n = 1 by NAT_1:27;
      then
A34:  F2/.n = F2.1 by A31,PARTFUN1:def 8
        .= F/.len F1 by FINSEQ_1:61;
      F2/.(n+1) = F2.2 by A29,A33,PARTFUN1:def 8
        .= F/.(len F1+1) by A7,FINSEQ_1:61;
      hence F2/.(n+1) in SUCC F2/.n by A5,A18,A11,A34;
    end;
A35: now
      let n;
      assume that
A36:  1 <= n and
A37:  n < len F1;
A38:  1 <= n+1 by A36,NAT_1:13;
A39:  n+1 <= len F1 by A37,NAT_1:13;
      then n+1 <= len F by A11,XXREAL_0:2;
      then
A40:  n+1 in dom F by A38,FINSEQ_3:27;
      n <= len F by A11,A37,XXREAL_0:2;
      then
A41:  n in dom F by A36,FINSEQ_3:27;
A42:  n in dom F1 by A36,A37,FINSEQ_3:27;
      then
A43:  F1/.n = F1.n by PARTFUN1:def 8
        .= F.n by A6,A42,FINSEQ_4:48
        .= F/.n by A41,PARTFUN1:def 8;
A44:  n < len F by A11,A37,XXREAL_0:2;
A45:  n+1 in dom F1 by A38,A39,FINSEQ_3:27;
      then F1/.(n+1) = F1.(n+1) by PARTFUN1:def 8
        .= F.(n+1) by A6,A45,FINSEQ_4:48
        .= F/.(n+1) by A40,PARTFUN1:def 8;
      hence F1/.(n+1) in SUCC F1/.n by A5,A36,A43,A44;
    end;
    F2/.1 = F2.1 by A31,PARTFUN1:def 8
      .= f.m by A20,FINSEQ_1:61;
    then f.m <= f.(k+1) by A30,A32,Def8;
    then
A46: m <= k+1 by A2;
A47: 1 in dom F1 by A18,FINSEQ_3:27;
    then F1/.1 = F1.1 by PARTFUN1:def 8
      .= F.1 by A6,A47,FINSEQ_4:48
      .= f.k by A3,A12,PARTFUN1:def 8;
    then f.k <= f.m by A20,A23,A35,Def8;
    then k <= m by A2;
    then m = k or m = k+1 by A46,NAT_1:9;
    hence f.(k+1) in SUCC (f.k) by A5,A18,A11,A10,A20,A24;
    let j be Element of NAT;
    reconsider F = <*f.k, f.j*> as non empty IL-FinSequence of S;
A48: len F = 2 by FINSEQ_1:61;
    then
A49: 2 in dom F by FINSEQ_3:27;
A50: 1 in dom F by A48,FINSEQ_3:27;
    then
A51: F/.1 = F.1 by PARTFUN1:def 8
      .= f.k by FINSEQ_1:61;
    assume
A52: f.j in SUCC (f.k);
A53: now
      let n be Element of NAT;
      assume
      1 <= n & n < len F;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A54:  n = 1 by NAT_1:27;
      then
A55:  F/.n = F.1 by A50,PARTFUN1:def 8
        .= f.k by FINSEQ_1:61;
      F/.(n+1) = F.2 by A49,A54,PARTFUN1:def 8
        .= f.j by FINSEQ_1:61;
      hence F/.(n+1) in SUCC F/.n by A52,A55;
    end;
    F/.len F = F.2 by A48,A49,PARTFUN1:def 8
      .= f.j by FINSEQ_1:61;
    then f.k <= f.j by A51,A53,Def8;
    hence k <= j by A2;
  end;
  assume
A56: for k being Element of NAT holds f.(k+1) in SUCC (f.k) & for j
  being Element of NAT st f.j in SUCC (f.k) holds k <= j;
  let m, n be Element of NAT;
  hereby
    assume
A57: m <= n;
    per cases by A57,XXREAL_0:1;
    suppose
      m = n;
      hence f.m <= f.n;
    end;
    suppose
A58:  m < n;
      thus f.m <= f.n
      proof
        reconsider f'=f as Function of NAT,IL;
        set mn = n -' m;
        deffunc F(Nat) = f'.(m+$1-'1);
        consider F being FinSequence of IL such that
A59:    len F = mn+1 and
A60:    for j being Nat st j in dom F holds F.j = F(j) from FINSEQ_2:
        sch 1;
        reconsider F as non empty IL-FinSequence of S by A59,AMI_1:def 34;
        take F;
A61:    1 <= mn+1 by NAT_1:11;
        then
A62:    1 in dom F by A59,FINSEQ_3:27;
        hence F/.1 = F.1 by PARTFUN1:def 8
          .= f.(m+1-'1) by A60,A62
          .= f.m by NAT_D:34;
        m+1 <= n by A58,INT_1:20;
        then 1 <= n-m by XREAL_1:21;
        then 0 <= n-m by XXREAL_0:2;
        then
A63:    mn = n - m by XREAL_0:def 2;
A64:    len F in dom F by A59,A61,FINSEQ_3:27;
        hence F/.len F = F.len F by PARTFUN1:def 8
          .= f.(m+(mn+1)-'1) by A59,A60,A64
          .= f.(m+mn+1-'1)
          .= f.n by A63,NAT_D:34;
        let p be Element of NAT;
        assume that
A65:    1 <= p and
A66:    p < len F;
A67:    p in dom F by A65,A66,FINSEQ_3:27;
        then
A68:    F/.p = F.p by PARTFUN1:def 8
          .= f.(m+p-'1) by A60,A67;
A69:    p <= m+p by NAT_1:11;
        1 <= p+1 & p+1 <= len F by A65,A66,NAT_1:13;
        then
A70:    p+1 in dom F by FINSEQ_3:27;
        then F/.(p+1) = F.(p+1) by PARTFUN1:def 8
          .= f.(m+(p+1)-'1) by A60,A70
          .= f.(m+p+1-'1)
          .= f.(m+p-'1+1) by A65,A69,NAT_D:38,XXREAL_0:2;
        hence thesis by A56,A68;
      end;
    end;
  end;
  assume
  f.m <= f.n;
  then consider F being non empty IL-FinSequence of S such that
A71: F/.1 = f.m and
A72: F/.len F = f.n and
A73: for n being Element of NAT st 1 <= n & n < len F holds F/.(n+1) in
  SUCC F/.n by Def8;
  defpred P[Element of NAT] means 1 <= $1 & $1 <= len F implies ex l being
  Element of NAT st F/.$1 = f.l & m <= l;
A74: now
    let k be Element of NAT such that
A75: P[k];
    now
      assume that
      1 <= k+1 and
A76:  k+1 <= len F;
      per cases by NAT_1:3;
      suppose
        k = 0;
        hence ex l being Element of NAT st F/.(k+1) = f.l & m <= l by A71;
      end;
      suppose
A77:    k > 0;
        rng f = IL by A1,FUNCT_2:def 3;
        then consider l1 being set such that
A78:    l1 in dom f and
A79:    f.l1 = F/.(k+1) by FUNCT_1:def 5;
        consider l being Element of NAT such that
A80:    F/.k = f.l and
A81:    m <= l by A75,A76,A77,NAT_1:13,14;
        reconsider l1 as Element of NAT by A78;
        k < len F by A76,NAT_1:13;
        then F/.(k+1) in SUCC F/.k by A73,A77,NAT_1:14;
        then l <= l1 by A56,A80,A79;
        hence
        ex l being Element of NAT st F/.(k+1) = f.l & m <= l by A81,A79
        ,XXREAL_0:2;
      end;
    end;
    hence P[k+1];
  end;
A82: 1 <= len F by NAT_1:14;
A83: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A83, A74);
  then dom f = NAT & ex l being Element of NAT st F/.len F = f.l & m <= l by
  A82,FUNCT_2:def 1;
  hence thesis by A1,A72,FUNCT_1:def 8;
end;

theorem Th19:
  S is standard iff ex f being IL-Function of NAT, S st f is
  bijective & for k being Element of NAT holds f.(k+1) in SUCC (f.k) & for j
  being Element of NAT st f.j in SUCC (f.k) holds k <= j
proof
  hereby
    assume
    S is standard;
    then consider f being IL-Function of NAT, S such that
A1: f is bijective and
A2: for m, n being Element of NAT holds m <= n iff f.m <= f.n by
    Def10;
    thus ex f being IL-Function of NAT, S st f is bijective & for k being
Element of NAT holds f.(k+1) in SUCC (f.k) & for j being Element of NAT st f.j
    in SUCC (f.k) holds k <= j
    proof
      take f;
      thus f is bijective by A1;
      thus thesis by A1,A2,Th18;
    end;
  end;
  given f be IL-Function of NAT, S such that
A3: f is bijective and
A4: for k being Element of NAT holds f.(k+1) in SUCC (f.k) & for j being
  Element of NAT st f.j in SUCC (f.k) holds k <= j;
  take f;
  thus f is bijective by A3;
  thus thesis by A3,A4,Th18;
end;

Lm3: for a,b being set holds dom ((NAT --> a)+*(NAT .-->b)) = NAT \/ {NAT}
proof
  let a,b be set;

  thus dom ((NAT --> a)+*(NAT .-->b)) = dom (NAT --> a) \/ dom (NAT .-->b) by
  FUNCT_4:def 1

    .= NAT \/ dom (NAT .-->b) by FUNCOP_1:19
    .= NAT \/ {NAT} by FUNCOP_1:19;
end;
set III = {[1,0],[0,0]};

begin :: Standard trivial computer

definition
  let N be with_non-empty_elements set;
  func STC N -> strict AMI-Struct over NAT,N means
  :Def11:
  the carrier of it =
NAT \/ {NAT} & the Instruction-Counter of it = NAT & the Instructions of it = {
[0,0],[1,0]} & the Object-Kind of it = (NAT --> {[1,0],[0,0]}) +* (NAT .-->NAT)
& ex f being Function of product the Object-Kind of it, product the Object-Kind
of it st (for s being Element of product the Object-Kind of it holds f.s = s+*(
NAT .-->succ(s.NAT))) & the Execution of it = ([1,0] .--> f) +* ([0,0] .--> id
  product the Object-Kind of it);
  existence
  proof
    set IL = NAT;
    set O = NAT \/ {NAT};
    NAT in {NAT} by TARSKI:def 1;
    then reconsider IC1 = NAT as Element of O by XBOOLE_0:def 3;
    0 in ((union N) \/ O)* by FINSEQ_1:66;
    then
    [1,0] in [:NAT, ((union N) \/ O)*:] & [0,0] in [:NAT, ((union N) \/ O)
    *:] by ZFMISC_1:106;
    then reconsider
    ins = III as non empty Subset of [:NAT, ((union N) \/ O)*:] by
    ZFMISC_1:38;
A1: dom ((NAT --> ins)+*(NAT .-->IL)) = O by Lm3;
    {ins}\/{NAT}= {ins, NAT} by ENUMSET1:41;
    then
A2: {ins}\/{NAT} c= N \/ {ins, NAT} by XBOOLE_1:7;
    rng (NAT --> ins) = {ins} & rng (NAT .-->IL) = {NAT} by FUNCOP_1:14;
    then rng ((NAT --> ins)+*(NAT .-->IL)) c= {ins}\/{NAT} by FUNCT_4:18;
    then rng ((NAT --> ins)+*(NAT .-->IL)) c= N \/ {ins, NAT} by
    A2,XBOOLE_1
    :1;
    then reconsider
    Ok = (NAT --> ins)+*(NAT .-->IL) as Function of O, N \/ {ins,
    IL} by A1,FUNCT_2:def 1,RELSET_1:11;
    deffunc F(Element of product Ok) = $1+*(NAT .-->succ($1.NAT));
A3: now
      let s be Element of product Ok;
      now
        thus dom (s+*(NAT .-->succ(s.NAT))) = dom s \/ dom (NAT .-->succ(s.NAT
        )) by FUNCT_4:def 1
          .= dom s \/ {NAT} by FUNCOP_1:19
          .= dom Ok \/ {NAT} by CARD_3:18
          .= dom Ok by A1,XBOOLE_1:7,12;
        let o be set;
A4:     dom (NAT .-->succ(s.NAT)) = {NAT} by FUNCOP_1:19;
        assume
A5:     o in dom Ok;
        then
A6:     o in NAT or o in {NAT} by XBOOLE_0:def 3;
        per cases by A6,TARSKI:def 1;
        suppose
          o in NAT;
          then not o in {NAT} by TARSKI:def 1;
          then (s+*(NAT .-->succ(s.NAT))).o = s.o by A4,FUNCT_4:12;
          hence (s+*(NAT .-->succ(s.NAT))).o in Ok.o by A5,CARD_3:18;
        end;
        suppose
A7:       o = NAT;
A8:       NAT in {NAT} by TARSKI:def 1;
          dom (NAT .-->IL) = {NAT} by FUNCOP_1:19;
          then NAT in dom (NAT .-->IL) by TARSKI:def 1;
          then
A9:       Ok.o = (NAT .-->IL).NAT by A7,FUNCT_4:14
            .= NAT by A8,FUNCOP_1:13;
A10:      o in {NAT} by A7,TARSKI:def 1;
          then
A11:      (s+*(NAT .-->succ(s.NAT))).o = (NAT .-->succ(s.NAT)).o by A4,
          FUNCT_4:14
            .= succ(s.NAT) by A10,FUNCOP_1:13;
          NAT in {NAT} by TARSKI:def 1;
          then NAT in dom Ok by A1,XBOOLE_0:def 3;
          then reconsider k = s.NAT as Element of NAT by A7,A9,CARD_3:18;
          succ k in NAT;
          hence (s+*(NAT .-->succ(s.NAT))).o in Ok.o by A9,A11;
        end;
      end;
      hence F(s) in product Ok by CARD_3:18;
    end;
    consider f being Function of product Ok, product Ok such that
A12: for s being Element of product Ok holds f.s= F(s) from FUNCT_2:
    sch 8 (A3);
    set E = ([1,0] .--> f) +* ([0,0] .--> id product Ok);
A13: dom E = dom ([1,0] .--> f) \/ dom ([0,0] .--> id product Ok) by
    FUNCT_4:def 1
      .= {[1,0]} \/ dom ([0,0] .--> id product Ok) by FUNCOP_1:19
      .= {[1,0]} \/ {[0,0]} by FUNCOP_1:19
      .= ins by ENUMSET1:41;
A14: rng ([1,0] .--> f) c= {f} & rng ([0,0] .--> id product Ok) c= {id
    product Ok } by FUNCOP_1:19;
A15: rng E c= rng ([1,0] .--> f) \/ rng ([0,0] .--> id product Ok) by
    FUNCT_4:18;
    rng E c= Funcs(product Ok, product Ok)
    proof
      let e be set;
      assume
      e in rng E;
      then e in rng ([1,0] .--> f) or e in rng ([0,0] .--> id product Ok) by
      A15,XBOOLE_0:def 3;
      then e = f or e = id product Ok by A14,TARSKI:def 1;
      hence thesis by FUNCT_2:12;
    end;
    then reconsider
    E as Function of ins, Funcs(product Ok, product Ok) by A13,
    FUNCT_2:def 1,RELSET_1:11;
    set M = AMI-Struct(# O, IC1, ins, Ok, E#);
    take M qua strict AMI-Struct over NAT,N;
    thus the carrier of M = NAT \/ {NAT};
    thus the Instruction-Counter of M = NAT;
    thus the Instructions of M = {[0,0],[1,0]};
    thus the Object-Kind of M = (NAT-->III)+*(NAT .-->NAT);
    reconsider f as Function of product the Object-Kind of M, product the
    Object-Kind of M;
    take f;
    thus for s being Element of product the Object-Kind of M holds f.s = s+*(
    NAT .-->succ(s.NAT)) by A12;
    thus thesis;
  end;
  uniqueness
  proof
    let it1, it2 be strict AMI-Struct over NAT,N such that
A16: the carrier of it1 = NAT \/ {NAT} & the Instruction-Counter of
    it1 = NAT & the Instructions of it1 = {[0,0],[1,0]} and
A17: the Object-Kind of it1 = (NAT --> III)+*(NAT .-->NAT);
    given f1 being Function of product the Object-Kind of it1, product the
    Object-Kind of it1 such that
A18: for s being Element of product the Object-Kind of it1 holds f1.s
    = s+* (NAT .-->succ(s.NAT)) and
A19: the Execution of it1 = ([1,0] .--> f1) +* ([0,0] .--> id product
    the Object-Kind of it1);
    assume that
A20: the carrier of it2 = NAT \/ {NAT} & the Instruction-Counter of
    it2 = NAT & the Instructions of it2 = {[0,0],[1,0]} and
A21: the Object-Kind of it2 = (NAT --> III)+*(NAT .-->NAT);
    given f2 being Function of product the Object-Kind of it2, product the
    Object-Kind of it2 such that
A22: for s being Element of product the Object-Kind of it2 holds f2.s
    = s+* (NAT .-->succ(s.NAT)) and
A23: the Execution of it2 = ([1,0] .--> f2) +* ([0,0] .--> id product
    the Object-Kind of it2);
    now
      let c be Element of product the Object-Kind of it1;
      thus f1.c = c+*(NAT .-->succ(c.NAT)) by A18
        .= f2.c by A17,A21,A22;
    end;
    hence thesis by A16,A17,A19,A20,A21,A23,FUNCT_2:113;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> infinite;
  coherence
  proof
    NAT \/ {NAT} is not finite by FINSET_1:13,XBOOLE_1:7;
    hence the carrier of STC N is infinite by Def11;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> non empty stored-program standard-ins;
  coherence
  proof
    thus the carrier of STC N is non empty;
    the carrier of STC N = NAT \/ {NAT} by Def11;
    hence NAT c= the carrier of STC N by XBOOLE_1:7;
    0 in ((union N) \/ the carrier of STC N)* by FINSEQ_1:66;
    then
A1: {0} c= ((union N) \/ the carrier of STC N)* by ZFMISC_1:37;
A2: the Instructions of STC N = {[0,0],[1,0]} by Def11
      .= [:{0,1},{0}:] by ZFMISC_1:36;
    take X=(union N) \/ the carrier of STC N;
    thus the Instructions of STC N c= [:NAT,X*:] by A1,A2,ZFMISC_1:119;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> IC-Ins-separated definite realistic steady-programmed;
  coherence
  proof
    set IT = STC N;
    set Ok = the Object-Kind of IT;
A1: NAT in {NAT} by TARSKI:def 1;
    dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
    then
A2: NAT in dom (NAT .-->NAT) by TARSKI:def 1;
    Ok.NAT = ((NAT --> III)+*(NAT .-->NAT)).NAT by Def11
      .= (NAT .-->NAT).NAT by A2,FUNCT_4:14
      .= NAT by A1,FUNCOP_1:13;
    then ObjectKind IC IT = NAT by Def11;
    hence STC N is IC-Ins-separated by AMI_1:def 11;
A3: the Instructions of IT = III by Def11;
    thus STC N is definite
    proof
      let l be Instruction-Location of IT;
A4:   l in NAT by AMI_1:def 4;
      dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
      then
A5:   not l in dom (NAT .-->NAT) by A4,TARSKI:def 1;
      thus ObjectKind l = ((NAT --> III)+*(NAT .-->NAT)).l by Def11
        .= (NAT --> III).l by A5,FUNCT_4:12
        .= the Instructions of IT by A3,A4,FUNCOP_1:13;
    end;
    thus IT is realistic
    proof
      assume
      the Instruction-Counter of IT in NAT;
      hence contradiction by Def11;
    end;
    thus IT is steady-programmed
    proof
      let s be State of IT, i be Instruction of IT, l be Instruction-Location
      of IT;
      consider f being Function of product the Object-Kind of IT, product the
      Object-Kind of IT such that
A6:   for s being Element of product the Object-Kind of IT holds f.s
      = s+*(NAT .-->succ(s.NAT)) and
A7:   the Execution of IT = ([1,0] .--> f) +* ([0,0] .--> id product
      the Object-Kind of IT) by Def11;
      l in NAT by AMI_1:def 4;
      then not l in {NAT} by TARSKI:def 1;
      then
A8:   not l in dom (NAT .-->succ(s.NAT)) by FUNCOP_1:19;
      per cases by A3,TARSKI:def 2;
      suppose
A9:     i = [1,0];
        then
A10:    i in {[1,0]} by TARSKI:def 1;
        now
          assume
          i in dom ([0,0] .--> id product the Object-Kind of IT);
          then i in {[0,0]} by FUNCOP_1:19;
          then i = [0,0] by TARSKI:def 1;
          hence contradiction by A9,ZFMISC_1:33;
        end;
        then (the Execution of IT).i = ([1,0] .--> f).i by A7,FUNCT_4:12
          .= f by A10,FUNCOP_1:13;
        hence Exec(i,s).l = (s+*(NAT .-->succ(s.NAT))).l by A6
          .= s.l by A8,FUNCT_4:12;
      end;
      suppose
        i = [0,0];
        then
A11:    i in {[0,0]} by TARSKI:def 1;
        then i in dom ([0,0] .--> id product the Object-Kind of IT) by
        FUNCOP_1:19;
        then (the Execution of IT).i = ([0,0] .--> id product the Object-Kind
        of IT).i by A7,FUNCT_4:14
          .= id product the Object-Kind of IT by A11,FUNCOP_1:13;
        hence thesis by FUNCT_1:35;
      end;
    end;
  end;
end;

Lm4: for i being Instruction of STC N, s being State of STC N st InsCode i = 1
holds Exec(i,s).IC STC N = succ (IC s)

proof
  let i be Instruction of STC N, s be State of STC N;
  set M = STC N;
  assume
A1: InsCode i = 1;
A2: now
    assume
    i in {[0,0]};
    then i = [0,0] by TARSKI:def 1;
    hence contradiction by A1,MCART_1:7;
  end;
  the Instructions of M = III by Def11;
  then i = [1,0] or i = [0,0] by TARSKI:def 2;
  then
A3: i in {[1,0]} by A1,MCART_1:7,TARSKI:def 1;
A4: NAT in {NAT} by TARSKI:def 1;
  then
A5: NAT in dom (NAT .-->succ(s.NAT)) by FUNCOP_1:19;

  consider f be Function of product the Object-Kind of M, product the
  Object-Kind of M such that

A6: for s being Element of product the Object-Kind of M holds f.s = s+*(
  NAT .-->succ(s.NAT)) and

A7: the Execution of M = ([1,0] .--> f) +* ([0,0] .--> id product the
  Object-Kind of M) by Def11;

A8: the Instruction-Counter of M = NAT by Def11;

  dom ([0,0] .--> id product the Object-Kind of M) = {[0,0]} by FUNCOP_1:
  19;

  then (the Execution of M).i = ([1,0] .--> f).i by A7,A2,FUNCT_4:12
    .= f by A3,FUNCOP_1:13;
  hence Exec(i,s).IC STC N = (s+*(NAT .-->succ(s.NAT))).NAT by A8,A6
    .= (NAT .-->succ(s.NAT)).NAT by A5,FUNCT_4:14
    .= succ (IC s) by A8,A4,FUNCOP_1:13;
end;

theorem Th20:
  for i being Instruction of STC N st InsCode i = 0 holds i is
  halting
proof
  let i be Instruction of STC N;
  set M = STC N;
  the Instructions of M = III by Def11;
  then
A1: i = [1,0] or i = [0,0] by TARSKI:def 2;
  assume
  InsCode i = 0;
  then
A2: i in {[0,0]} by A1,MCART_1:7,TARSKI:def 1;
  let s be State of M;
  (ex f be Function of product the Object-Kind of M, product the
Object-Kind of M st ( for s being Element of product the Object-Kind of M holds
f.s = s+*(NAT .-->succ(s.NAT)))& the Execution of M = ([1,0] .--> f) +* ([0,0]
  .--> id product the Object-Kind of M) )& dom ([0,0] .--> id product the
  Object-Kind of M) = {[0,0]} by Def11,FUNCOP_1:19;
  then
  (the Execution of M).i = ({[0,0]} --> id product the Object-Kind of M).i
  by A2,FUNCT_4:14
    .= id product the Object-Kind of M by A2,FUNCOP_1:13;
  hence thesis by FUNCT_1:35;
end;

theorem
  for i being Instruction of STC N st InsCode i = 1 holds i is non
  halting
proof
  let i be Instruction of STC N;
  set M = STC N;
  consider s being State of M;
  assume
  InsCode i = 1;
  then
A1: Exec(i,s).IC M = succ (IC s) by Lm4;
  assume
  for s being State of M holds Exec(i,s) = s;
  then Exec(i,s).IC M = IC s;
  hence thesis by A1,ORDINAL1:14;
end;

theorem Th22:
  for i being Element of the Instructions of STC N holds InsCode i
  = 1 or InsCode i = 0
proof
  let i be Element of the Instructions of STC N;
  the Instructions of STC N = III by Def11;
  then i = [1,0] or i = [0,0] by TARSKI:def 2;
  hence thesis by MCART_1:def 1;
end;

theorem
  for i being Instruction of STC N holds i is jump-only
proof
  let i be Instruction of STC N;
  set M = STC N;
  let s be State of M, o be Object of M, I be Instruction of M such that
  InsCode I = InsCode i and
A1: o <> IC M;
A2: the Instruction-Counter of M = NAT by Def11;
  the carrier of M = NAT \/ {NAT} by Def11;
  then o in NAT or o in {NAT} by XBOOLE_0:def 3;
  then reconsider l = o as Instruction-Location of STC N by A2,A1,
  AMI_1:def 4 ,
  TARSKI:def 1;
  Exec(i,s).l = s.l by AMI_1:def 13;
  hence thesis by AMI_1:def 13;
end;

Lm5: for l being Instruction-Location of STC N, i being Element of the
Instructions of STC N st l = z & InsCode i = 1 holds NIC(i, l) = {z+1}

proof

  let l be Instruction-Location of STC N, i be Element of the Instructions of
  STC N;

  assume that
A1: l = z and
A2: InsCode i = 1;
  set M = STC N;
  set F = { IC Following s where s is State of M: IC s = l & s.l = i };
  now
    set f = (NAT) --> i;
    consider w being State of M;
A3: l in NAT by AMI_1:def 4;
    then reconsider l' = l as Element of ObjectKind IC M by AMI_1:def 11;
    set u = (IC M).-->l';
A4: dom u = {IC M} by FUNCOP_1:19;
    reconsider s = w +* f as State of M by Th11;
    let y be set;
A5: dom f = NAT by FUNCOP_1:19;
    set t = s+*u;
    l <> IC M by AMI_1:48;
    then not l in dom u by A4,TARSKI:def 1;
    then
A6: t.l = s.l by FUNCT_4:12
      .= f.l by A5,A3,FUNCT_4:14
      .= i by A3,FUNCOP_1:13;
    hereby
      assume
      y in F;

      then ex s being State of M st y = IC Following s & IC s = l & s.l = i;

      then y = succ z by A1,A2,Lm4
        .= z+1;
      hence y in {z+1} by TARSKI:def 1;
    end;
    assume
    y in {z+1};
    then
A7: y = z+1 by TARSKI:def 1
      .= succ z;
    IC M in dom u by A4,TARSKI:def 1;
    then
A8: IC t = u.IC M by FUNCT_4:14
      .= z by A1,FUNCOP_1:87;
    then IC Following t = succ z by A1,A2,A6,Lm4;
    hence y in F by A1,A7,A8,A6;
  end;
  hence thesis by TARSKI:2;
end;

Lm6: for i being Element of the Instructions of STC N holds JUMP i is empty
proof
  let i be Element of the Instructions of STC N;
  per cases by Th22;
  suppose
A1: InsCode i = 1;
    reconsider l1 = 0, l2 = 1 as Instruction-Location of STC N by AMI_1:def 4;

    set X = { NIC(i,l) where l is Instruction-Location of STC N : not
    contradiction };

    assume
    not thesis;
    then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
    NIC(i, l1) in X;
    then {0+1} in X by A1,Lm5;
    then x in {1} by A2,SETFAM_1:def 1;
    then
A3: x = 1 by TARSKI:def 1;
    NIC(i, l2) in X;
    then {1+1} in X by A1,Lm5;
    then x in {2} by A2,SETFAM_1:def 1;
    hence contradiction by A3,TARSKI:def 1;
  end;
  suppose
A4: InsCode i = 0;
    reconsider i as Instruction of STC N;

    for l being Instruction-Location of STC N holds NIC(i,l)={l} by A4,
    Th15,Th20;

    hence thesis by Th14;
  end;
end;

theorem Th24:
  for l being Instruction-Location of STC N st l = z holds SUCC l
  = {z, z+1}
proof
  let l be Instruction-Location of STC N such that
A1: l = z;
  set M = STC N;
  set K = { NIC(i,l) \ JUMP i where i is Element of the Instructions of STC N
  : not contradiction };
  now
    let y be set;
    hereby
      assume
      y in K;
      then consider ii being Element of the Instructions of STC N such that
A2:   y = NIC(ii,l) \ JUMP ii and
      not contradiction;
      reconsider ii as Instruction of STC N;
      now
        per cases by Th22;
        suppose
A3:       InsCode ii = 1;
          JUMP ii = {} by Lm6;
          then y = {z+1} by A1,A2,A3,Lm5;
          hence y in {{z},{z+1}} by TARSKI:def 2;
        end;
        suppose
A4:       InsCode ii = 0;
          JUMP ii = {} by Lm6;
          then y = {z} by A1,A2,A4,Th15,Th20;
          hence y in {{z},{z+1}} by TARSKI:def 2;
        end;
      end;
      hence y in {{z},{z+1}};
    end;
    assume
A5: y in {{z},{z+1}};
    per cases by A5,TARSKI:def 2;
    suppose
A6:   y = {z};
      set i = [0,0];
      i in III by TARSKI:def 2;
      then reconsider i as Instruction of M by Def11;
      JUMP i = {} & InsCode i = 0 by Lm6,MCART_1:def 1;
      then NIC(i,l) \ JUMP i = y by A1,A6,Th15,Th20;
      hence y in K;
    end;
    suppose
A7:   y = {z+1};
      set i = [1,0];
      i in III by TARSKI:def 2;
      then reconsider i as Instruction of M by Def11;
      JUMP i = {} & InsCode i = 1 by Lm6,MCART_1:def 1;
      then NIC(i,l) \ JUMP i = y by A1,A7,Lm5;
      hence y in K;
    end;
  end;
  then K = {{z},{z+1}} by TARSKI:2;
  hence thesis by ZFMISC_1:32;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> standard;
  coherence
  proof
    reconsider f = id NAT as IL-Function of NAT, STC N by AMI_1:def 36;
    set M = STC N;
    now
      let k be Element of NAT;
A1:   SUCC (f.k) = {k,k+1} by Th24,FUNCT_1:35;
      f.(k+1) = k+1 by FUNCT_1:35;
      hence f.(k+1) in SUCC (f.k) by A1,TARSKI:def 2;
      let j be Element of NAT;
      assume
      f.j in SUCC (f.k);
      then f.j = k or f.j = k+1 by A1,TARSKI:def 2;
      then j = k+1 or j = k by FUNCT_1:35;
      hence k <= j by NAT_1:11;
    end;
    hence thesis by Th19;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> halting;
  coherence
  proof
    set M = STC N;
    the Instructions of M = III by Def11;
    then reconsider I = [0,0] as Instruction of M by TARSKI:def 2;
    take I;
    InsCode I = 0 by MCART_1:def 1;
    hence thesis by Th20;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster standard halting realistic steady-programmed programmable
standard-ins (IC-Ins-separated definite (non empty stored-program AMI-Struct
    over NAT,N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

reserve T for standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over NAT,N));

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
definite (non empty stored-program AMI-Struct over NAT,N)), k be natural number
  ;
  func il.(S,k) -> Instruction-Location of S means
  :Def12:
  ex f being
IL-Function of NAT, S st f is bijective & (for m, n being Element of NAT holds
  m <= n iff f.m <= f.n) & it = f.k;
  existence
  proof
    reconsider k as Element of NAT by ORDINAL1:def 13;
    consider f being IL-Function of NAT, S such that
A1: f is bijective & for m, n being Element of NAT holds m <= n iff f.
    m <= f.n by Def10;
    take f.k, f;
    thus thesis by A1;
  end;
  uniqueness by Th17;
end;

theorem Th25:
  for k1, k2 being natural number st il.(T,k1) = il.(T,k2) holds
  k1 = k2
proof
  let k1, k2 be natural number;
  assume
A1: il.(T,k1) = il.(T,k2);
A2: k1 is Element of NAT & k2 is Element of NAT by ORDINAL1:def 13;
  consider f2 being IL-Function of NAT, T such that
A3: f2 is bijective & for m, n being Element of NAT holds m <= n iff f2.
  m <= f2. n and
A4: il.(T,k2) = f2.k2 by Def12;
  consider f1 being IL-Function of NAT, T such that
A5: f1 is bijective and
A6: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n and
A7: il.(T,k1) = f1.k1 by Def12;
A8: dom f1 = NAT by FUNCT_2:def 1;
  f1 = f2 by A5,A6,A3,Th17;
  hence thesis by A1,A2,A5,A7,A4,A8,FUNCT_1:def 8;
end;

theorem Th26:
  for l being Instruction-Location of T ex k being natural number
  st l = il.(T,k)
proof
  let l be Instruction-Location of T;
  consider f1 being IL-Function of NAT, T such that
A1: f1 is bijective and
A2: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n and
  il.(T,0) = f1.0 by Def12;
  l in NAT & rng f1 = NAT by A1,AMI_1:def 4,FUNCT_2:def 3;
  then consider k being set such that
A3: k in dom f1 and
A4: f1.k = l by FUNCT_1:def 5;
  reconsider k as Element of NAT by A3;
  take k;
  thus thesis by A1,A2,A4,Def12;
end;

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N)), l be
  Instruction-Location of S;
  func locnum l -> natural number means
  :Def13:
  il.(S,it) = l;
  existence by Th26;
  uniqueness by Th25;
end;

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N)), l be
  Instruction-Location of S;
  redefine func locnum l -> Element of NAT;
  coherence by ORDINAL1:def 13;
end;

theorem Th27:
  for l1, l2 being Instruction-Location of T holds locnum l1 =
  locnum l2 implies l1 = l2
proof
  let l1, l2 be Instruction-Location of T;
  assume
A1: locnum l1 = locnum l2;
  il.(T,locnum l1) = l1 by Def13;
  hence thesis by A1,Def13;
end;

theorem Th28:
  for k1, k2 being natural number holds il.(T,k1) <= il.(T,k2) iff
  k1 <= k2
proof
  let k1, k2 be natural number;
A1: k1 is Element of NAT & k2 is Element of NAT by ORDINAL1:def 13;
  consider f2 being IL-Function of NAT, T such that
A2: f2 is bijective & for m, n being Element of NAT holds m <= n iff f2.
  m <= f2. n and
A3: il.(T,k2) = f2.k2 by Def12;
  consider f1 being IL-Function of NAT, T such that
A4: f1 is bijective and
A5: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n and
A6: il.(T,k1) = f1.k1 by Def12;
  f1 = f2 by A4,A5,A2,Th17;
  hence thesis by A1,A5,A6,A3;
end;

theorem Th29:
  for l1, l2 being Instruction-Location of T holds locnum l1 <=
  locnum l2 iff l1 <= l2
proof
  let l1, l2 be Instruction-Location of T;
  il.(T,locnum l1) = l1 & il.(T,locnum l2) = l2 by Def13;
  hence thesis by Th28;
end;

theorem Th30:
  T is InsLoc-antisymmetric
proof
  let l1, l2 be Instruction-Location of T;
  assume
A1: l1 <= l2 & l2 <= l1;
  reconsider T as standard (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  reconsider l1, l2 as Instruction-Location of T;
  locnum l1 <= locnum l2 & locnum l2 <= locnum l1 by A1,Th29;
  hence thesis by Th27,XXREAL_0:1;
end;

registration
  let N;
  cluster standard -> InsLoc-antisymmetric (IC-Ins-separated definite (non
    empty stored-program AMI-Struct over NAT,N));
  coherence by Th30;
end;

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N)), f be
  Instruction-Location of S, k be natural number;
  func f + k -> Instruction-Location of S equals
  il.(S,locnum f + k);
  coherence;
end;

theorem
  for f being Instruction-Location of T holds f + 0 = f by Def13;

theorem
  for f, g being Instruction-Location of T st f + z = g + z holds f = g
proof
  let f, g be Instruction-Location of T;
  assume
  f + z = g + z;
  then locnum f + z = locnum g + z by Th25;
  hence thesis by Th27;
end;

theorem
  for f being Instruction-Location of T holds locnum f + z = locnum (f +
  z) by Def13;

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N)), f be
  Instruction-Location of S;
  func NextLoc f -> Instruction-Location of S equals
  f + 1;
  coherence;
end;

theorem
  for f being Instruction-Location of T holds NextLoc f = il.(T,locnum f
  + 1);

theorem Th35:
  for f being Instruction-Location of T holds f <> NextLoc f
proof
  let f be Instruction-Location of T;
  assume
  f = NextLoc f;
  then locnum f = locnum f + 1 by Def13;
  hence thesis;
end;

theorem
  for f, g being Instruction-Location of T st NextLoc f = NextLoc g
  holds f = g
proof
  let f, g be Instruction-Location of T such that
A1: NextLoc f = NextLoc g;
  set m = locnum g;
  set k = locnum f;
  k+0 = k+1-1
    .= m+1-1 by A1,Th25
    .= m+0;
  hence thesis by Th27;
end;

theorem Th37:
  il.(STC N, z) = z
proof
  set M = STC N;
  reconsider f2 = id NAT as IL-Function of NAT, STC N by AMI_1:def 36;
  consider f being IL-Function of NAT, M such that
A1: f is bijective & for m, n being Element of NAT holds m <= n iff f.m
  <= f.n and
A2: il.(M,z) = f.z by Def12;
  now
    let k be Element of NAT;
A3: SUCC f2.k = {k,k+1} by Th24,FUNCT_1:35;
    f2.(k+1) = k+1 by FUNCT_1:35;
    hence f2.(k+1) in SUCC (f2.k) by A3,TARSKI:def 2;
    let j be Element of NAT;
A4: j = f2.j by FUNCT_1:35;
    assume
    f2.j in SUCC (f2.k);
    then j = k or j = k+1 by A3,A4,TARSKI:def 2;
    hence k <= j by NAT_1:11;
  end;
  then for m, n being Element of NAT holds m <= n iff f2.m <= f2.n by
  Th18;
  then z is Element of NAT & f = f2 by A1,Th17,ORDINAL1:def 13;
  hence thesis by A2,FUNCT_1:35;
end;

theorem
  for i being Instruction of STC N, s being State of STC N st InsCode i
  = 1 holds Exec(i,s).IC STC N = NextLoc IC s
proof
  let i be Instruction of STC N, s be State of STC N;
  set M = STC N;
  set k = locnum IC s;
  reconsider K = IC s as Element of NAT by AMI_1:def 4;
  assume
  InsCode i = 1;
  then
A1: Exec(i,s).IC STC N = succ IC s by Lm4
    .= K+1 by NAT_1:39;
  il.(M,k) = k & il.(M,k+1) = k+1 by Th37;
  hence thesis by A1,Def13;
end;

theorem
  for l being Instruction-Location of STC N, i being Element of the
  Instructions of STC N st InsCode i = 1 holds NIC(i, l) = {NextLoc l}
proof
  let l be Instruction-Location of STC N, i be Element of the Instructions of
  STC N;
  assume
A1: InsCode i = 1;
  set M = STC N;
  consider k being natural number such that
A2: l = il.(M,k) by Th26;
  k = locnum l by A2,Def13;
  then NextLoc l = k+1 by Th37;
  hence thesis by A1,A2,Lm5,Th37;
end;

theorem
  for l being Instruction-Location of STC N holds SUCC l = {l, NextLoc l
  }
proof
  let l be Instruction-Location of STC N;
  set M = STC N;
  consider k being natural number such that
A1: l = il.(M,k) by Th26;
A2: k = locnum l by A1,Def13;
  thus SUCC l = {k,k+1} by A1,Th24,Th37
    .= {k,il.(M,k+1)} by Th37
    .= {l, NextLoc l} by A1,A2,Th37;
end;

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
definite (non empty stored-program AMI-Struct over NAT,N)), i be Instruction of
  S;
  attr i is sequential means
  for s being State of S holds Exec(i, s).IC S =
  NextLoc IC s;
end;

theorem Th41:
  for S being standard realistic (IC-Ins-separated definite (non
empty stored-program AMI-Struct over NAT,N)), il being Instruction-Location of
  S, i being Instruction of S st i is sequential holds NIC(i,il) = {NextLoc il}
proof
  let S be standard realistic (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N)), il be Instruction-Location of S, i be
  Instruction of S such that
A1: for s being State of S holds Exec(i, s).IC S = NextLoc IC s;
  now
    let x be set;
A2: now
      il in NAT by AMI_1:def 4;
      then reconsider il1 = il as Element of ObjectKind IC S by AMI_1:def 11;
      reconsider I = i as Element of ObjectKind il by AMI_1:def 14;
      consider t being State of S;
      assume
A3:   x = NextLoc il;
      reconsider u = t+*((IC S, il)-->(il1, I) qua FinPartState of S) as State
      of S;
A4:   dom ((IC S, il)-->(il1, I)) = {IC S, il} by FUNCT_4:65;
      then il in dom ((IC S, il)-->(il1, I)) by TARSKI:def 2;
      then
A5:   u.il = ((IC S, il)-->(il1, I)).il by FUNCT_4:14
        .= i by FUNCT_4:66;
      IC S in dom ((IC S, il)-->(il1, I)) by A4,TARSKI:def 2;
      then
A6:   IC u = ((IC S, il)-->(il1, I)).IC S by FUNCT_4:14
        .= il by AMI_1:48,FUNCT_4:66;
      then IC Following u = NextLoc il by A1,A5;
      hence
      x in {IC Following s where s is State of S : IC s = il & s.il=i} by
      A3,A6,A5;
    end;
    now
      assume
      x in {IC Following s where s is State of S : IC s = il & s.il=i
      };
      then ex s being State of S st x = IC Following s & IC s = il & s.il = i;
      hence x = NextLoc il by A1;
    end;
    hence
    x in {NextLoc il} iff x in {IC Following s where s is State of S : IC
    s = il & s.il=i} by A2,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th42:
  for S being realistic standard (IC-Ins-separated definite (non
empty stored-program AMI-Struct over NAT,N)), i being Instruction of S st i is
  sequential holds i is non halting
proof
  let S be realistic standard (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N)), i be Instruction of S such that
A1: i is sequential;
  consider s being State of S;
  NIC(i,IC s) = {NextLoc IC s} by A1,Th41;
  then NIC(i,IC s) <> {IC s} by Th35,ZFMISC_1:6;
  hence thesis by Th15;
end;

registration
  let N;
  let S be realistic standard (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  cluster sequential -> non halting Instruction of S;
  coherence by Th42;
  cluster halting -> non sequential Instruction of S;
  coherence;
end;

theorem
  for i being Instruction of T st JUMP i is non empty holds i is non
  sequential
proof
  let i be Instruction of T;
  set X = { NIC(i,l1) where l1 is Instruction-Location of T: not contradiction
  };
  assume
  JUMP i is non empty;
  then consider l being set such that
A1: l in JUMP i by XBOOLE_0:def 1;
  reconsider l as Instruction-Location of T by A1,AMI_1:def 4;
  NIC(i,l) in X;
  then l in NIC(i,l) by A1,SETFAM_1:def 1;
  then consider s being State of T such that
A2: l = IC Following s & IC s = l & s.l = i;
  take s;
  thus thesis by A2,Th35;
end;

begin :: Closedness of finite partial states

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  IL,N);
  let F be IL-defined FinPartState of S;
  attr F is closed means
  :Def17:
  for l being Instruction-Location of S st l in
  dom F holds NIC (pi(F,l), l) c= dom F;
  attr F is really-closed means
  for s being State of S st F c= s & IC s in dom
  F for k being Element of NAT holds IC Computation(s,k) in dom F;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over NAT,N));
  let F be FinPartState of S;
  attr F is para-closed means
  for s being State of S st F c= s & IC s = il.(S,
  0) for k being Element of NAT holds IC Computation(s,k) in dom F;
end;

theorem Th44:
  for S being standard steady-programmed (IC-Ins-separated
definite (non empty stored-program AMI-Struct over NAT,N)), F being NAT-defined
  FinPartState of S st F is really-closed & il.(S,0) in dom F holds F is
  para-closed
proof
  let S be standard steady-programmed (IC-Ins-separated definite (non empty
stored-program AMI-Struct over NAT,N)), F be NAT-defined FinPartState of S such
  that
A1: ( for s being State of S st F c= s & IC s in dom F for k being
  Element of NAT holds IC Computation(s,k) in dom F)& il.(S,0) in dom F;
  let s be State of S;
  assume
  F c= s & IC s = il.(S,0);
  hence thesis by A1;
end;

theorem Th45:
  for S being IC-Ins-separated definite steady-programmed (non
empty stored-program AMI-Struct over IL,N), F being IL-defined FinPartState of
  S st F is closed holds F is really-closed
proof
  let S be IC-Ins-separated definite steady-programmed (non empty
  stored-program AMI-Struct over IL,N), F be IL-defined FinPartState of S such
  that
A1: F is closed;
  let s be State of S such that
A2: F c= s and
A3: IC s in dom F;
  defpred P[Element of NAT] means IC Computation(s,$1) in dom F;
A4: now
    let k be Element of NAT such that
A5: P[k];
    set t = Computation(s,k);
    set l = IC Computation(s,k);
    pi(F,l) = F.l & F.l = s.l by A2,A5,AMI_1:def 47,GRFUNC_1:8;
    then t.l = pi(F,l) by AMI_1:54;
    then
A6: IC Following t in NIC(pi(F,l),l);
A7: Computation(s,k+1) = Following t by AMI_1:14;
    NIC(pi(F,l), l) c= dom F by A1,A5,Def17;
    hence P[k+1] by A6,A7;
  end;
A8: P[0] by A3,AMI_1:13;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A4);
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  steady-programmed (non empty stored-program AMI-Struct over IL,N);
  cluster closed -> really-closed (IL-defined FinPartState of S);
  coherence by Th45;
end;

theorem Th46:
  for S being standard realistic halting (IC-Ins-separated
definite (non empty stored-program AMI-Struct over NAT,N)) holds il.(S,0) .-->
  halt S qua NAT-defined FinPartState of S is closed
proof
  let S be standard realistic halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  reconsider F = il.(S,0) .--> halt S as NAT-defined FinPartState of S;
  let l be Instruction-Location of S;
  assume
A1: l in dom(il.(S,0) .--> halt S);
A2: dom F = {il.(S,0)} by FUNCOP_1:19;
  then
A3: l = il.(S,0) by A1,TARSKI:def 1;
  pi(F,l) = F.l by A1,AMI_1:def 47
    .= halt S by A3,FUNCOP_1:87;
  hence thesis by A2,A3,Th15;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  IL,N);
  let F be FinPartState of S;
  attr F is lower means
  :Def20:
  for l being Instruction-Location of S st l in
  dom F holds for m being Instruction-Location of S st m <= l holds m in dom F;
end;

theorem Th47:
  for F being empty FinPartState of S holds F is lower
proof
  let F be empty FinPartState of S;
  let l be Instruction-Location of S;
  assume
  l in dom F;
  hence thesis;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite (non
  empty stored-program AMI-Struct over IL,N);
  cluster empty -> lower FinPartState of S;
  coherence by Th47;
end;

theorem Th48:
  for i being Element of the Instructions of T holds il.(T,0) .-->
  i is lower
proof
  let i be Element of the Instructions of T;
  set F = il.(T,0).--> i;
  let l be Instruction-Location of T such that
A1: l in dom F;
  let m be Instruction-Location of T such that
A2: m <= l;
  consider k being natural number such that
A3: m = il.(T,k) by Th26;
  dom F = {il.(T,0)} by FUNCOP_1:19;
  then
A4: l = il.(T,0) by A1,TARSKI:def 1;
  then 0 <= k & k <= 0 by A2,A3,Th28,NAT_1:2;
  hence thesis by A1,A4,A3,XXREAL_0:1;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over NAT,N));
  cluster lower non empty trivial NAT-defined FinPartState of S;
  existence
  proof
    consider i being Instruction of S;
    take il.(S,0).--> i;
    thus thesis by Th48;
  end;
end;

theorem Th49:
  for F being lower non empty NAT-defined FinPartState of T holds
  il.(T,0) in dom F
proof
  let F be lower non empty NAT-defined FinPartState of T;
  consider l being set such that
A1: l in dom F by XBOOLE_0:def 1;
A2: dom F c= NAT by RELAT_1:def 18;
  then reconsider l as Instruction-Location of T by A1,AMI_1:def 4;
  consider f being IL-Function of NAT, T such that
A3: f is bijective and
A4: for m, n being Element of NAT holds m <= n iff f.m <= f.n and
A5: il.(T,0) = f.0 by Def12;
  rng f = NAT by A3,FUNCT_2:def 3;
  then consider x being set such that
A6: x in dom f and
A7: l = f.x by A1,A2,FUNCT_1:def 5;
  reconsider x as Element of NAT by A6;
  0 <= x by NAT_1:2;
  then f.0 <= f.x by A4;
  hence thesis by A1,A5,A7,Def20;
end;

theorem Th50:
  for P being lower NAT-defined FinPartState of T holds z < card P
  iff il.(T,z) in dom P
proof
  let P be lower NAT-defined FinPartState of T;
  deffunc F(Element of NAT) = il.(T,$1);
  defpred P[Element of NAT] means F($1) in dom P;
  set A = { k : P[k]};
A1: A is Subset of NAT from DOMAIN_1:sch 7;
A2: now
    let a, b be Element of NAT;
    assume
    a in A;
    then
A3: ex l being Element of NAT st l = a & il.(T,l) in dom P;
    assume
    b < a;
    then il.(T,b) <= il.(T,a) by Th28;
    then il.(T,b) in dom P by A3,Def20;
    hence b in A;
  end;
A4: now
    let x be set;
A5: dom P c= NAT by RELAT_1:def 18;
    assume
    x in dom P;
    then reconsider l=x as Instruction-Location of T by A5,AMI_1:def 4;
    consider n being natural number such that
A6: l = il.(T,n) by Th26;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    take n;
    thus x = F(n) by A6;
  end;
  reconsider A as Cardinal by A1,A2,FUNCT_7:22;
  set A1 = {k : F(k) in dom P};
A7: z is Element of NAT by ORDINAL1:def 13;
A8: card A = A by CARD_1:def 5;
A9: for k1, k2 being Element of NAT st F(k1) = F(k2) holds k1 = k2 by Th25;
A10: dom P, A1 are_equipotent from FUNCT_7:sch 3(A4,A9);
A11: card z = z by CARD_1:def 5;
  hereby
    assume
    z < card P;
    then card z in card card P by NAT_1:42;
    then z in card dom P by A11,CARD_1:104;
    then z in card A by A10,CARD_1:21;
    then ex d being Element of NAT st d = z & il.(T,d) in dom P by A8;
    hence il.(T,z) in dom P;
  end;
  assume
  il.(T,z) in dom P;
  then z in card A by A7,A8;
  then z in card dom P by A10,CARD_1:21;
  then card z in card card P by A11,CARD_1:104;
  hence thesis by NAT_1:42;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over NAT,N));
  let F be non empty NAT-defined FinPartState of S;
  func LastLoc F -> Instruction-Location of S means
  :Def21:
  ex M being finite
  non empty natural-membered set st M = { locnum l where l is
  Instruction-Location of S : l in dom F } & it = il.(S, max M);
  existence
  proof
    deffunc F(Instruction-Location of S) = locnum $1;
    set M = { F(l) where l is Instruction-Location of S : l in dom F };
    consider l being Element of dom F;
    l in dom F & dom F c= NAT by RELAT_1:def 18;
    then reconsider l as Instruction-Location of S by AMI_1:def 4;
A1: locnum l in M;
A2: M c= NAT
    proof
      let k be set;
      assume
      k in M;
      then
      ex l being Instruction-Location of S st k = locnum l & l in dom F;
      hence thesis;
    end;
A3: dom F is finite;
    M is finite from AMI_1:sch 1(A3);
    then reconsider M as finite non empty Subset of NAT by A1,A2;
    take il.(S, max M), M;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th51:
  for F being non empty NAT-defined FinPartState of T holds
  LastLoc F in dom F
proof
  let F be non empty NAT-defined FinPartState of T;
  consider M being finite non empty natural-membered set such that
A1: M = { locnum l where l is Instruction-Location of T : l in dom F } and
A2: LastLoc F = il.(T, max M) by Def21;
  max M in M by XXREAL_2:def 8;
  then
  ex l being Instruction-Location of T st max M = locnum l & l in dom F by
  A1;
  hence thesis by A2,Def13;
end;

theorem
  for F, G being non empty NAT-defined FinPartState of T st F c= G holds
  LastLoc F <= LastLoc G
proof
  let F, G be non empty NAT-defined FinPartState of T such that
A1: F c= G;
  consider N being finite non empty natural-membered set such that
A2: N = { locnum l where l is Instruction-Location of T : l in dom G } and
A3: LastLoc G = il.(T, max N) by Def21;
  consider M being finite non empty natural-membered set such that
A4: M = { locnum l where l is Instruction-Location of T : l in dom F } and
A5: LastLoc F = il.(T, max M) by Def21;
  reconsider MM = M, NN = N as non empty finite Subset of REAL by MEMBERED:3;
  M c= N
  proof
    let a be set;
    assume
    a in M;
    then
A6: ex l being Instruction-Location of T st a = locnum l & l in dom F by A4;
    dom F c= dom G by A1,GRFUNC_1:8;
    hence thesis by A2,A6;
  end;
  then max MM <= max NN by XXREAL_2:59;
  hence thesis by A5,A3,Th28;
end;

theorem Th53:
  for F being non empty NAT-defined FinPartState of T, l being
  Instruction-Location of T st l in dom F holds l <= LastLoc F
proof
  let F be non empty NAT-defined FinPartState of T, l be Instruction-Location
  of T such that
A1: l in dom F;
  consider M being finite non empty natural-membered set such that
A2: M = { locnum w where w is Instruction-Location of T : w in dom F } and
A3: LastLoc F = il.(T, max M) by Def21;
  locnum l in M by A1,A2;
  then
A4: locnum l <= max M by XXREAL_2:def 8;
  locnum LastLoc F = max M by A3,Def13;
  hence thesis by A4,Th29;
end;

theorem
  for F being lower non empty NAT-defined FinPartState of T, G being non
  empty NAT-defined FinPartState of T holds F c= G & LastLoc F = LastLoc G
  implies F = G
proof
  let F be lower non empty NAT-defined FinPartState of T, G be non empty NAT
  -defined FinPartState of T such that
A1: F c= G and
A2: LastLoc F = LastLoc G;
  dom F = dom G
  proof
    thus dom F c= dom G by A1,GRFUNC_1:8;
    let x be set;
    assume
A3: x in dom G;
    dom G c= NAT by RELAT_1:def 18;
    then reconsider x as Instruction-Location of T by A3,AMI_1:def 4;
A4: LastLoc F in dom F by Th51;
    x <= LastLoc F by A2,A3,Th53;
    hence thesis by A4,Def20;
  end;
  hence thesis by A1,GRFUNC_1:9;
end;

theorem Th55:
  for F being lower non empty NAT-defined FinPartState of T holds
  LastLoc F = il.(T, card F -' 1)
proof
  let F be lower non empty NAT-defined FinPartState of T;
  consider k being natural number such that
A1: LastLoc F = il.(T,k) by Th26;
  reconsider k as Element of NAT by ORDINAL1:def 13;
  LastLoc F in dom F by Th51;
  then k < card F by A1,Th50;
  then
A2: k <= card F -' 1 by NAT_D:49;
  per cases by A2,XXREAL_0:1;
  suppose
    k < card F -' 1;
    then k+1 < card F -' 1 + 1 by XREAL_1:8;
    then k+1 < card F by NAT_1:14,XREAL_1:237;
    then il.(T,k+1) in dom F by Th50;
    then il.(T,k+1) <= LastLoc F by Th53;
    then
A3: k+1 <= k by A1,Th28;
    k <= k+1 by NAT_1:11;
    then k+0 = k+1 by A3,XXREAL_0:1;
    hence thesis;
  end;
  suppose
    k = card F -' 1;
    hence thesis by A1;
  end;
end;

registration
  let N be with_non-empty_elements set, S be standard steady-programmed (
  IC-Ins-separated definite (non empty stored-program AMI-Struct over NAT,N));
  cluster really-closed lower non empty -> para-closed (NAT-defined
    FinPartState of S);
  coherence
  proof
    let F be NAT-defined FinPartState of S;
    assume
A1: F is really-closed;
    assume
    F is lower non empty;
    then il.(S,0) in dom F by Th49;
    hence thesis by A1,Th44;
  end;
end;

Lm7: now
  let IL,N;

  let S be standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));

  set F = il.(S,0) .--> halt S;
A1: dom F = {il.(S,0)} by FUNCOP_1:19;
  then
A2: card dom F = 1 by CARD_1:50;
  F is lower FinPartState of S by Th48;
  then
A3: LastLoc F = il.(S,card F -' 1) by Th55
    .= il.(S,card dom F -' 1) by CARD_1:104
    .= il.(S,0) by A2,XREAL_1:234;
  hence F.(LastLoc F) = halt S by FUNCOP_1:87;
  let l be Instruction-Location of S such that
  F.l = halt S;
  assume
  l in dom F;
  hence l = LastLoc F by A1,A3,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements set, S be standard halting (
IC-Ins-separated definite (non empty stored-program AMI-Struct over NAT,N)), F
  be non empty NAT-defined FinPartState of S;
  attr F is halt-ending means
  :Def22:
  F.(LastLoc F) = halt S;
  attr F is unique-halt means
  :Def23:
  for f being Instruction-Location of S st
  F.f = halt S & f in dom F holds f = LastLoc F;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  cluster halt-ending unique-halt trivial (lower non empty NAT-defined
    FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Instruction-Location of S st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting realistic (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  cluster trivial closed lower non empty (NAT-defined FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    FinPartState of S by Th48;
    take F;
    thus thesis by Th46;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting realistic (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  cluster halt-ending unique-halt trivial closed (lower non empty NAT-defined
    FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Instruction-Location of S st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis by Th46;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting realistic steady-programmed (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N));
  cluster halt-ending unique-halt autonomic trivial closed (lower non empty
    NAT-defined FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Instruction-Location of S st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis by Lm1,Th46;
  end;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  mode pre-Macro of S is halt-ending unique-halt (lower non empty NAT-defined
    FinPartState of S);
end;

registration
  let N be with_non-empty_elements set;
  let S be standard realistic halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over NAT,N));
  cluster closed pre-Macro of S;
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    FinPartState of S by Th48;
    F.(LastLoc F) = halt S & for l being Instruction-Location of S st F.l
    = halt S & l in dom F holds l = LastLoc F by Lm7;
    then reconsider F as pre-Macro of S by Def22,Def23;
    take F;
    thus thesis by Th46;
  end;
end;

theorem
  for i being Instruction of Trivial-AMI(IL,N) holds i is halting
proof
  let i be Instruction of Trivial-AMI(IL,N);
  set M = Trivial-AMI(IL,N);
A1: the Instructions of M = {[0,{}]} by AMI_1:def 2;
  let s be State of M;
  the Object-Kind of M = (IL --> {[0,{}]}) +* (IL .--> IL) by AMI_1:def 2;
  then
  (the Execution of M).i = ([0,{}] .--> id product the Object-Kind of M).i
  by AMI_1:def 2
    .= id product the Object-Kind of M by A1,FUNCOP_1:13;
  hence thesis by FUNCT_1:35;
end;

theorem
  for i being Element of the Instructions of Trivial-AMI(IL,N) holds
  InsCode i = 0
proof
  let i be Element of the Instructions of Trivial-AMI(IL,N);
  the Instructions of Trivial-AMI(IL,N) = {[0,{}]} by AMI_1:def 2;
  then i = [0,{}] by TARSKI:def 1;
  hence thesis by MCART_1:def 1;
end;

begin :: Addenda

:: from SCMPDS_9, 2008.03.10, A.T.

theorem
  for IL being non empty set for N being with_non-empty_elements set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over IL,N)
, i being Instruction of S, l being Instruction-Location of S holds JUMP(i) c=
  NIC(i,l)
proof
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite (non
  empty stored-program AMI-Struct over IL,N), i be Instruction of S, l be
  Instruction-Location of S;
  set X = { NIC(i,k) where k is Instruction-Location of S: not contradiction };
  let x be set;
A1: NIC(i,l) in X;
  assume
  x in JUMP(i);
  hence thesis by A1,SETFAM_1:def 1;
end;

theorem
  for IL being non empty set for N being with_non-empty_elements set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over IL,N)
  , l1, l2 being Instruction-Location of S st SUCC(l1) = IL holds l1 <= l2
proof
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite (non
empty stored-program AMI-Struct over IL,N), l1, l2 be Instruction-Location of S
  such that
A1: SUCC(l1) = IL;
  defpred P[set,set] means ($1 = 1 implies $2 = l1) & ($1 = 2 implies $2 = l2);
A2: for n being Nat st n in Seg 2 ex d being Element of IL st P[n,d]
  proof
    let n be Nat;
    assume
A3: n in Seg 2;
    per cases by A3,FINSEQ_1:4,TARSKI:def 2;
    suppose
A4:   n = 1;
      reconsider l1 as Element of IL by AMI_1:def 4;
      take l1;
      thus thesis by A4;
    end;
    suppose
A5:   n = 2;
      reconsider l2 as Element of IL by AMI_1:def 4;
      take l2;
      thus thesis by A5;
    end;
  end;
  consider f being FinSequence of IL such that
A6: len f = 2 and
A7: for n being Nat st n in Seg 2 holds P[n,f/.n] from FINSEQ_4:sch 1(A2
  );
A8: 1 in Seg 2 by FINSEQ_1:4,TARSKI:def 2;
  then
A9: f/.1 = l1 by A7;
  reconsider f as non empty IL-FinSequence of S by A6,AMI_1:def 34;
  take f;
  2 in Seg 2 by FINSEQ_1:4,TARSKI:def 2;
  hence f/.1 = l1 & f/.len f = l2 by A6,A7,A8;
  let n be Element of NAT;
  assume
A10: 1 <= n;
  assume
  n < len f;
  then n < 1+1 by A6;
  then n <= 1 by NAT_1:13;
  then n = 1 by A10,XXREAL_0:1;
  hence thesis by A1,A9;
end;

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  IL for non empty set
  ,
  N for with_non-empty_elements set,
  S for standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  l for Instruction-Location
  of S,
  f for FinPartState of S;

definition
  let N be with_non-empty_elements set, S be standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N)), loc be
  Instruction-Location of S, k be natural number;
  func loc -' k -> Instruction-Location of S equals
  il.(S, (locnum loc) -' k);
  coherence;
end;

theorem
  l -' 0 = l
proof
  thus l -' 0 = il.(S,locnum l) by NAT_D:40
    .= l by Def13;
end;

theorem Th61:
  l + k -' k = l
proof
  thus l + k -' k = il.(S,locnum l + k -' k) by Def13
    .= il.(S,locnum l) by NAT_D:34
    .= l by Def13;
end;

canceled;

theorem
  for l1, l2 being Instruction-Location of S holds Start-At(l1+k) =
  Start-At(l2+k) iff Start-At l1 = Start-At l2
proof
  let l1,l2 be Instruction-Location of S;
  hereby
    assume
    Start-At(l1 + k) = Start-At(l2 + k);
    then {[IC S, l1 + k]} = IC S .--> (l2 + k) by FUNCT_4:87;
    then {[IC S, l1 + k]} = {[IC S, l2 + k]} by FUNCT_4:87;
    then [IC S, l1 + k] = [IC S, l2 + k] by ZFMISC_1:6;
    then l1 + k = l2 + k by ZFMISC_1:33;
    then l1 = l2 + k -' k by Th61;
    hence Start-At l1 = Start-At l2 by Th61;
  end;
  assume
  Start-At l1 = Start-At l2;
  then {[IC S, l1]} = Start-At l2 by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

theorem
  for l1, l2 being Instruction-Location of S st Start-At l1 = Start-At
  l2 holds Start-At(l1 -' k) = Start-At(l2 -' k)
proof
  let l1, l2 be Instruction-Location of S;
  assume
  Start-At l1 = Start-At l2;
  then {[IC S, l1]} = Start-At l2 by FUNCT_4:87
    .= {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

