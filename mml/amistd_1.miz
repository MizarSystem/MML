:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, ORDINAL2, ARYTM, SQUARE_1, FINSET_1, REALSET1, FINSEQ_1,
      RELAT_1, AMI_1, BOOLE, FUNCT_1, SGRAPH1, FUNCOP_1, CAT_1, GRAPH_2,
      FINSEQ_4, FUNCT_4, CARD_3, AMI_5, SETFAM_1, TARSKI, GOBOARD5, ARYTM_1,
      ORDINAL1, FUNCT_2, FRECHET, PRE_TOPC, WAYBEL_0, CARD_1, AMISTD_1,
      MEMBERED;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, REALSET1, FUNCT_1,
      RELSET_1, PARTFUN1, DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4, FUNCOP_1,
      FINSET_1, FUNCT_4, STRUCT_0, NAT_D, XXREAL_2, FUNCT_2, AMI_1;
 constructors RELAT_2, PARTFUN1, WELLORD2, XXREAL_0, REAL_1, NAT_1, FINSEQ_4,
      REALSET1, NAT_D, PRE_CIRC, AMI_1, INT_2, MEMBERED, XXREAL_2;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FUNCOP_1, FINSET_1, FRAENKEL, NUMBERS, XREAL_0, NAT_1, MEMBERED,
      FINSEQ_1, CARD_3, REALSET1, FINSEQ_5, PRE_CIRC, FUNCT_7, STRUCT_0, AMI_1,
      JORDAN1J, CARD_1, XXREAL_2;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, AMI_1, YELLOW_8, XBOOLE_0, FUNCOP_1, NAT_1;
 theorems TARSKI, FINSEQ_4, FINSEQ_1, GRAPH_2, NAT_1, AMI_1, FUNCT_4,
      FUNCT_1, FUNCT_2, RELAT_1, ENUMSET1, ZFMISC_1, CARD_1, FUNCOP_1, CARD_3,
      ORDINAL1, MCART_1, GRFUNC_1, FINSEQ_3, BINARITH, INT_1, SETFAM_1,
      REVROT_1, PRE_CIRC, INTEGRA2, FUNCT_7, RELSET_1, XBOOLE_0, XBOOLE_1,
      MEMBERED, XREAL_1, XXREAL_0, FINSEQ_6, PARTFUN1, FINSET_1, XXREAL_2,
      XREAL_0, NAT_D;
 schemes NAT_1, FUNCT_7, FINSEQ_2, AMI_1, DOMAIN_1, FUNCT_2, FINSEQ_4;

begin :: Ami-Struct

reserve x for set,
  D for non empty set,
  k, n for Element of NAT,
  z for natural number;

reserve N for with_non-empty_elements set,
  IL for non empty set,
  S for IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  i for Element of the Instructions of S,
  l, l1, l2, l3 for Instruction-Location of S,
  s for State of S;

canceled 10;

theorem Th11:
  for S being definite (non empty stored-program AMI-Struct over IL,N),
  I being Element of the Instructions of S, s being State of S
  holds s +* ((IL) --> I) is State of S
proof
  let S be definite (non empty stored-program AMI-Struct over IL,N),
  I be Element of the Instructions of S, s be State of S;
  set f = (IL) --> I;
  set Ok = the Object-Kind of S;
A1: dom f = IL by FUNCOP_1:19;
A2: IL c= the carrier of S by AMI_1:def 3;
A3: dom s = the carrier of S by AMI_1:79;
  then
A4: dom Ok = dom s by FUNCT_2:def 1;
  for x st x in dom f holds f.x in Ok.x
  proof
    let x;
    assume
A5: x in dom f;
    then
A6: f.x = I by FUNCOP_1:13;
    reconsider x as Instruction-Location of S by A5,AMI_1:def 4;
    Ok.x = ObjectKind x
      .= the Instructions of S by AMI_1:def 14;
    hence thesis by A6;
  end;
  then f in sproduct Ok by A1,A2,A3,A4,CARD_3:def 9;
  hence thesis by CARD_3:69;
end;

registration
  let IL,N be set, S be AMI-Struct over IL,N;
  cluster empty -> programmed FinPartState of S;
  coherence
  proof
    let F be FinPartState of S;
    assume F is empty;
    then reconsider G = F as empty Function;
    dom G c= IL by XBOOLE_1:2;
    hence dom F c= IL;
  end;
end;

registration
  let IL,N be set, S be AMI-Struct over IL,N;
  cluster empty FinPartState of S;
  existence
  proof
    reconsider a = {} as FinPartState of S by CARD_3:66;
    take a;
    thus a is empty;
  end;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  cluster non empty trivial programmed FinPartState of S;
  existence
  proof
    consider l being Instruction-Location of S, I being Instruction of S;
    take l .--> I;
    thus thesis;
  end;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over IL,N,
  i be Element of the Instructions of S, s be State of S;
  cluster ((the Execution of S).i).s -> Function-like Relation-like;
  coherence
  proof
    reconsider A =(the Execution of S).i as Function of
    product the Object-Kind of S, product the Object-Kind of S by FUNCT_2:121;
    A.s in product the Object-Kind of S;
    hence thesis;
  end;
end;

Lm1: for S being steady-programmed IC-Ins-separated definite
(non empty stored-program AMI-Struct over IL,N),
il being Instruction-Location of S, I being Element of the Instructions of S,
f being FinPartState of S st f = il .--> I holds f is autonomic
proof
  let S be steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  let il be Instruction-Location of S;
  let I be Element of the Instructions of S;
  let f be FinPartState of S such that
A1: f = il .--> I;
  let s1, s2 be State of S such that
A2: f c= s1 and
A3: f c= s2;
  let i be Element of NAT;
A4: dom f = {il} by A1,FUNCOP_1:19;
A5: for s being Function st f c= s holds s.il = I
  proof
    let s be Function such that
A6: f c= s;
    il in {il} by TARSKI:def 1;
    hence s.il = f.il by A4,A6,GRFUNC_1:8
      .= I by A1,FUNCOP_1:87;
  end;
  set a = ( Computation(s1,i)|dom f), b = ( Computation(s2,i)|dom f);
A7: {il} c= the carrier of S;
  then {il} c= dom ( Computation(s1,i)) by AMI_1:79;
  then
A8: dom a = {il} by A4,RELAT_1:91;
  {il} c= dom ( Computation(s2,i)) by A7,AMI_1:79;
  then
A9: dom b = {il} by A4,RELAT_1:91;
  for x st x in {il} holds a.x = b.x
  proof
    let x;
    assume
A10: x in {il};
    then
A11: x = il by TARSKI:def 1;
    thus a.x =  Computation(s1,i).x by A4,A10,FUNCT_1:72
      .= I by A1,A2,A5,A11,AMI_1:81
      .=  Computation(s2,i).x by A1,A3,A5,A11,AMI_1:81
      .= b.x by A4,A10,FUNCT_1:72;
  end;
  hence  Computation(s1,i)|dom f =  Computation(s2,i)|dom f
  by A8,A9,FUNCT_1:9;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  cluster non empty trivial autonomic programmed FinPartState of S;
  existence
  proof
    consider l being Instruction-Location of S;
    consider I being Instruction of S;
    take l.-->I;
    thus thesis by Lm1;
  end;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  il being Instruction-Location of S, I being Element of the Instructions of S
  holds il .--> I is autonomic by Lm1;

theorem Th13:
  for S being steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N) holds S is programmable
proof
  let S be steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  consider l being Instruction-Location of S;
  consider I being Instruction of S;
  take l.-->I;
  thus thesis by Lm1;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  cluster steady-programmed -> programmable (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over IL,N));
  coherence by Th13;
end;

definition
  let IL,N be set, S be AMI-Struct over IL,N;
  mode IL-Subset of S -> Subset of IL means
    :Def1:
    not contradiction;
  existence;
end;

registration
  let IL,N be set, S be AMI-Struct over IL,N;
  cluster empty IL-Subset of S;
  existence
  proof
    {}IL is IL-Subset of S by Def1;
    hence thesis;
  end;
end;

registration
  let IL be non empty set,N be set, S be non empty AMI-Struct over IL,N;
  cluster non empty IL-Subset of S;
  existence
  proof consider x being Element of IL;
    {x} is IL-Subset of S by Def1;
    hence thesis;
  end;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be non empty stored-program standard-ins AMI-Struct over IL,N;
  let T be InsType of S;
  canceled;
  attr T is jump-only means
  for s being State of S, o being Object of S, I being Instruction of S
  st InsCode I = T & o <> IC S holds Exec(I, s).o = s.o;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be non empty stored-program standard-ins AMI-Struct over IL,N;
  let I be Instruction of S;
  attr I is jump-only means

  InsCode I is jump-only;
end;

definition
  let IL,N,S,l;
  let i be Element of the Instructions of S;
  func NIC(i,l) -> IL-Subset of S equals
  { IC Following s : IC s = l & s.l = i };
  coherence
  proof
    { IC Following s : IC s = l & s.l = i } c= IL
    proof
      let e be set;
      assume e in { IC Following s : IC s = l & s.l = i };
      then ex s st e = IC Following s & IC s = l & s.l = i;
      hence e in IL by AMI_1:def 4;
    end;
    hence thesis by Def1;
  end;
end;

Lm2: now
  let IL,N;
  let S be realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  i be Element of the Instructions of S, l be Instruction-Location of S,
  s be State of S, f be FinPartState of S such that
A1: f = (IC S,l) --> (l,i);
  set t = s +* f;
A3: dom f = {IC S,l} by A1,FUNCT_4:65;
  then IC S in dom f by TARSKI:def 2;
  then
A4: IC t = f.IC S by FUNCT_4:14
    .= l by A1,AMI_1:48,FUNCT_4:66;
  l in dom f by A3,TARSKI:def 2;
  then t.l = f.l by FUNCT_4:14
    .= i by A1,FUNCT_4:66;
  hence IC Following t in NIC(i,l) by A4;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set,
  S be realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  i be Element of the Instructions of S, l be Instruction-Location of S;
  cluster NIC(i,l) -> non empty;
  coherence
  proof
    consider s being State of S;
A1: l in IL by AMI_1:def 4;
    ObjectKind IC S = IL &
    ObjectKind l = the Instructions of S by AMI_1:def 11,def 14;
    then reconsider f = (IC S,l) --> (l,i) as FinPartState of S by A1,AMI_1:58;
    IC Following (s +* f) in NIC(i,l) by Lm2;
    hence thesis;
  end;
end;

definition
  let IL,N,S,i;
  func JUMP i -> Subset of IL equals

  meet { NIC(i,l) : not contradiction };
  coherence
  proof
    set X = { NIC(i,l) : not contradiction };
    X c= bool IL
    proof
      let x be set;
      assume x in X;
      then ex l st x = NIC(i,l);
      hence thesis;
    end;
    then reconsider X as Subset-Family of IL;
    meet X c= IL;
    hence thesis;
  end;
end;

definition
  let IL,N,S,l;
  func SUCC l -> Subset of IL equals
  union { NIC(i,l) \ JUMP i : not contradiction };
  coherence
  proof
    set X = { NIC(i,l) \ JUMP i : not contradiction };
    X c= bool IL
    proof
      let x be set;
      assume x in X;
      then ex i st x = NIC(i,l) \ JUMP i;
      hence thesis;
    end;
    then reconsider X as Subset-Family of IL;
    union X c= IL;
    hence thesis;
  end;
end;

theorem Th14:
  for i being Element of the Instructions of S st IL is non trivial &
  (for l being Instruction-Location of S holds NIC(i,l)={l})
  holds JUMP i is empty
proof
  let i be Element of the Instructions of S;
  given p, q being Element of IL such that
A1: p <> q;
  reconsider p,q as Instruction-Location of S by AMI_1:def 4;
  assume
A2: for l being Instruction-Location of S holds NIC(i,l)={l};

set X = { NIC(i, l) where l is Instruction-Location of S: not contradiction };
  assume not thesis;
  then consider x being set such that
A3: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {p} & NIC(i,q) = {q} by A2;
  then {p} in X & {q} in X;
  then x in {p} & x in {q} by A3,SETFAM_1:def 1;
  then x = p & x = q by TARSKI:def 1;
  hence contradiction by A1;
end;

theorem Th15:
  for S being realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  il being Instruction-Location of S, i being Instruction of S st i is halting
  holds NIC(i,il) = {il}
proof
  let S be realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  il be Instruction-Location of S, i be Instruction of S such that
A1: for s being State of S holds Exec(i,s) = s;
  hereby
    let n be set;
    assume n in NIC(i,il);
    then consider s being State of S such that
A2: n = IC Following s & IC s = il & s.il = i;
    n = il by A1,A2;
    hence n in {il} by TARSKI:def 1;
  end;
  let n be set;
  assume
A3: n in {il};
A4: il in IL by AMI_1:def 4;
  consider s being State of S;
  ObjectKind IC S = IL &
  ObjectKind il = the Instructions of S by AMI_1:def 11,def 14;
  then reconsider f = (IC S,il) --> (il,i) as FinPartState of S
  by A4,AMI_1:58;
  set a = s+*f;
A5: dom f = {IC S,il} by FUNCT_4:65;
  then
A6: IC S in dom f by TARSKI:def 2;
A7: il in dom f by A5,TARSKI:def 2;
A9: a.IC S = f.IC S by A6,FUNCT_4:14
    .= il by AMI_1:48,FUNCT_4:66;
  then a.IC a = f.il by A7,FUNCT_4:14
    .= i by FUNCT_4:66;
  then IC Following a = a.IC S by A1
    .= n by A3,A9,TARSKI:def 1;
  hence n in NIC(i,il) by Lm2;
end;

begin :: Ordering of Instruction Locations

definition
  let IL,N,S,l1,l2;
  pred l1 <= l2 means
  :Def8:
  ex f being non empty IL-FinSequence of S st
  f/.1 = l1 & f/.len f = l2 &
  for n st 1 <= n & n < len f holds f/.(n+1) in SUCC f/.n;
  reflexivity
  proof
    let l;
A1: l in IL by AMI_1:def 4;
    take <*l*>;
    thus <*l*>/.1 = l by A1,FINSEQ_4:25;
    hence thesis by FINSEQ_1:56;
  end;
end;

theorem
  l1 <= l2 & l2 <= l3 implies l1 <= l3
proof
  given f1 being non empty IL-FinSequence of S such that
A1: f1/.1 = l1 and
A2: f1/.len f1 = l2 and
A3: for n st 1 <= n & n < len f1 holds f1/.(n+1) in SUCC f1/.n;
  given f2 being non empty IL-FinSequence of S such that
A4: f2/.1 = l2 and
A5: f2/.len f2 = l3 and
A6: for n st 1 <= n & n < len f2 holds f2/.(n+1) in SUCC f2/.n;
  take f1^'f2;
  thus (f1^'f2)/.1 = l1 by A1,GRAPH_2:57;
  now per cases;
    suppose f2 is trivial;
      then consider x being Element of IL such that
A7:   f2 = <*x*> by FINSEQ_6:113;
      f1^'f2 = f1 by A7,GRAPH_2:60;
      hence (f1^'f2)/.len(f1^'f2) = l3 by A2,A4,A5,A7,FINSEQ_1:56;
    end;
    suppose f2 is not trivial;
      hence (f1^'f2)/.len(f1^'f2) = l3 by A5,GRAPH_2:58;
    end;
  end;
  hence (f1^'f2)/.len(f1^'f2) = l3;
  let n such that
A8: 1 <= n and
A9: n < len(f1^'f2);
A10: len (f1^'f2) +1 = len f1 + len f2 by GRAPH_2:13;
  per cases by XXREAL_0:1;
  suppose
A11: n < len f1;
    then n+1 <= len f1 by NAT_1:13;
    then
A12: (f1^'f2)/.(n+1) = f1/.(n+1) by GRAPH_2:61,NAT_1:11;
    (f1^'f2)/.n = f1/.n by A8,A11,GRAPH_2:61;
    hence (f1^'f2)/.(n+1) in SUCC (f1^'f2)/.n by A3,A8,A11,A12;
  end;
  suppose
A13: n = len f1;
    then
A14: (f1^'f2)/.n = f2/.1 by A2,A4,A8,GRAPH_2:61;
    n+1 < len (f1^'f2) +1 by A9,XREAL_1:8;
    then
A15: 1 < len f2 by A10,A13,XREAL_1:8;
    then (f1^'f2)/.(n+1) = f2/.(1+1) by A13,GRAPH_2:62;
    hence (f1^'f2)/.(n+1) in SUCC (f1^'f2)/.n by A6,A14,A15;
  end;
  suppose
A16: n > len f1;
    then consider m being Nat such that
A17: len f1 + m = n by NAT_1:10;
    reconsider m as Element of NAT by ORDINAL1:def 13;
A18: len f1 + m > len f1 + 0 by A16,A17;
    len f1 + m+1 < len f1 + len f2 by A9,A10,A17,XREAL_1:8;
    then len f1 + (m+1) < len f1 + len f2;
    then
A19: m+1 < len f2 by XREAL_1:8;
    m <= m+1 by NAT_1:11;
    then m < len f2 by A19,XXREAL_0:2;
    then
A20: (f1^'f2)/.n = f2/.(m+1) by A17,A18,GRAPH_2:62,NAT_1:14;
    (f1^'f2)/.(n+1) = (f1^'f2)/.(len f1 + (m+1)) by A17
      .= f2/.(m+1+1) by A19,GRAPH_2:62,NAT_1:11;
    hence (f1^'f2)/.(n+1) in SUCC (f1^'f2)/.n by A6,A19,A20,NAT_1:11;
  end;
end;

definition
  let IL, N, S;
  attr S is InsLoc-antisymmetric means
  for l1, l2 st l1 <= l2 & l2 <= l1 holds l1 = l2;
end;

definition
  let IL, N, S;
  attr S is standard means
  :Def10:
  ex f being IL-Function of NAT, S st
  f is bijective & for m, n being Element of NAT holds m <= n iff f.m <= f.n;
end;

theorem Th17:
  for f1, f2 being IL-Function of NAT, S
  st f1 is bijective & (for m, n being Element of NAT holds m <= n
  iff f1.m <= f1.n) &
  f2 is bijective & (for m, n being Element of NAT holds m <= n
  iff f2.m <= f2.n) holds f1 = f2
proof
  let f1, f2 be IL-Function of NAT, S such that
A1: f1 is bijective and
A2: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n and
A3: f2 is bijective and
A4: for m, n being Element of NAT holds m <= n iff f2.m <= f2.n;
  defpred P[Nat] means f1.$1 <> f2.$1;
  assume f1 <> f2;
  then ex c being Element of NAT st P[c] by FUNCT_2:113;
  then
A5: ex c being Nat st P[c];
  consider d being Nat such that
A6: P[d] and
A7: for n being Nat st P[n] holds d <= n from NAT_1:sch 5(A5);
  reconsider d as Element of NAT by ORDINAL1:def 13;
  f1 is onto & f2 is onto by A1,A3;
  then
A9: rng f1 = IL & rng f2 = IL by FUNCT_2:def 3;
  then consider d2 being set such that
A10: d2 in dom f2 & f1.d = f2.d2 by FUNCT_1:def 5;
  reconsider d2 as Element of NAT by A10;
  consider d1 being set such that
A11: d1 in dom f1 & f2.d = f1.d1 by A9,FUNCT_1:def 5;
  reconsider d1 as Element of NAT by A11;
A12: f1 is one-to-one & f2 is one-to-one by A1,A3;
A13: dom f1 = NAT & dom f2 = NAT by FUNCT_2:def 1;
  per cases;
  suppose
A14: d1 <= d & d2 <= d;
    then f2.d2 <= f2.d by A4;
    then d <= d1 by A2,A10,A11;
    hence contradiction by A6,A11,A14,XXREAL_0:1;
  end;
  suppose
A15: d <= d1 & d2 <= d;
    f2.d2 = f1.d2
    proof
      assume not thesis;
      then d <= d2 by A7;
      hence contradiction by A6,A10,A15,XXREAL_0:1;
    end;
    hence contradiction by A6,A10,A12,A13,FUNCT_1:def 8;
  end;
  suppose
A16: d1 <= d & d <= d2;
    f1.d1 = f2.d1
    proof
      assume not thesis;
      then d <= d1 by A7;
      hence contradiction by A6,A11,A16,XXREAL_0:1;
    end;
    hence contradiction by A6,A11,A12,A13,FUNCT_1:def 8;
  end;
  suppose
A17: d <= d1 & d <= d2;
    then f2.d <= f2.d2 by A4;
    then d1 <= d by A2,A10,A11;
    hence contradiction by A6,A11,A17,XXREAL_0:1;
  end;
end;

theorem Th18:
  for f being IL-Function of NAT, S st f is bijective holds
  (for m, n being Element of NAT holds m <= n iff f.m <= f.n) iff
  (for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
  for j being Element of NAT st f.j in SUCC (f.k) holds k <= j)
proof
  let f be IL-Function of NAT, S;
  assume
A1: f is bijective;
  hereby
    assume
A2: for m, n being Element of NAT holds m <= n iff f.m <= f.n;
    let k be Element of NAT;
    k <= k+1 by NAT_1:11;
    then f.k <= f.(k+1) by A2;
    then consider F being non empty IL-FinSequence of S such that
A3: F/.1 = f.k & F/.len F = f.(k+1) and
A4: for n st 1 <= n & n < len F holds F/.(n+1) in SUCC F/.n by Def8;
A5: 1 <= len F by NAT_1:14;
A6: f is one-to-one onto by A1;
A7: dom f = NAT by FUNCT_2:def 1;
A8: f.k <> f.(k+1)
    proof
      assume not thesis;
      then 0+k = k+1 by A6,A7,FUNCT_1:def 8;
      hence contradiction;
    end;
A9: f.(k+1) in rng F by A3,REVROT_1:3;
    set x = (f.(k+1))..F;
A10: F.x = f.(k+1) by A9,FINSEQ_4:29;
A11: x in dom F by A9,FINSEQ_4:30;
    then
A12: 1 <= x & x <= len F by FINSEQ_3:27;
A13: 1 in dom F by A5,FINSEQ_3:27;
    then F/.1 = F.1 by PARTFUN1:def 8;
    then
A14: 1 < x by A3,A8,A10,A12,XXREAL_0:1;
    set F1 = F -| f.(k+1);
A15: len F1 = x-1 by A9,FINSEQ_4:46;
    then len F1+1 = x;
    then
A16: 1 <= len F1 & len F1 < len F by A12,A14,NAT_1:13;
A17: F/.(len F1+1) = F.x by A11,A15,PARTFUN1:def 8
      .= f.(k+1) by A9,FINSEQ_4:29;
    len F1 <> 0 by A3,A8,A10,A13,A15,PARTFUN1:def 8;
    then F1 is non empty FinSequence of IL
     by A9,FINSEQ_4:53;
    then reconsider F1 as non empty IL-FinSequence of S by AMI_1:def 34;
    rng f = IL by A6,FUNCT_2:def 3;
    then consider m being set such that
A18: m in dom f & f.m = F/.len F1 by FUNCT_1:def 5;
    reconsider m as Element of NAT by A18;
A19: 1 in dom F1 by A16,FINSEQ_3:27;
    then
A20: F1/.1 = F1.1 by PARTFUN1:def 8
      .= F.1 by A9,A19,FINSEQ_4:48
      .= f.k by A3,A13,PARTFUN1:def 8;
A21: len F1 in dom F by A16,FINSEQ_3:27;
A22: len F1 in dom F1 by A16,FINSEQ_3:27;
    then
A23: F1/.len F1 = F1.len F1 by PARTFUN1:def 8
      .= F.len F1 by A9,A22,FINSEQ_4:48
      .= F/.len F1 by A21,PARTFUN1:def 8;
    now
      let n;
      assume
A24:  1 <= n & n < len F1;
      then
A25:  n in dom F1 by FINSEQ_3:27;
A26:  1 <= n+1 & n+1 <= len F1 by A24,NAT_1:13;
      then
A27:  n+1 in dom F1 by FINSEQ_3:27;
      n <= len F by A16,A24,XXREAL_0:2;
      then
A28:  n in dom F by A24,FINSEQ_3:27;
      n+1 <= len F by A16,A26,XXREAL_0:2;
      then
A29:  n+1 in dom F by A26,FINSEQ_3:27;
A30:  F1/.(n+1) = F1.(n+1) by A27,PARTFUN1:def 8
        .= F.(n+1) by A9,A27,FINSEQ_4:48
        .= F/.(n+1) by A29,PARTFUN1:def 8;
A31:  F1/.n = F1.n by A25,PARTFUN1:def 8
        .= F.n by A9,A25,FINSEQ_4:48
        .= F/.n by A28,PARTFUN1:def 8;
      n < len F by A16,A24,XXREAL_0:2;
      hence F1/.(n+1) in SUCC F1/.n by A4,A24,A30,A31;
    end;
    then
A32: f.k <= f.m by A18,A20,A23,Def8;
    reconsider F2 = <*F/.len F1, F/.x*> as non empty IL-FinSequence of S;
A33: len F2 = 2 by FINSEQ_1:61;
    then
A34: 1 in dom F2 & 2 in dom F2 by FINSEQ_3:27;
    then
A35: F2/.1 = F2.1 by PARTFUN1:def 8
      .= f.m by A18,FINSEQ_1:61;
A36: F2/.len F2 = F2.2 by A33,A34,PARTFUN1:def 8
      .= F/.x by FINSEQ_1:61
      .= f.(k+1) by A10,A11,PARTFUN1:def 8;
    now
      let n;
      assume 1 <= n & n < len F2;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A37:  n = 1 by NAT_1:27;
      then
A38:  F2/.(n+1) = F2.2 by A34,PARTFUN1:def 8
        .= F/.(len F1+1) by A15,FINSEQ_1:61;
      F2/.n = F2.1 by A34,A37,PARTFUN1:def 8
        .= F/.len F1 by FINSEQ_1:61;
      hence F2/.(n+1) in SUCC F2/.n by A4,A16,A38;
    end;
    then f.m <= f.(k+1) by A35,A36,Def8;
    then k <= m & m <= k+1 by A2,A32;
    then
A39: m = k or m = k+1 by NAT_1:9;
    now
      assume
A40:  m = k+1;
      (rng F1) misses {f.(k+1)} by A9,FINSEQ_4:50;
      then rng F1 /\ {f.(k+1)} = {} by XBOOLE_0:def 7;
      then
A41:  not f.(k+1) in rng F1 or not f.(k+1) in {f.(k+1)} by XBOOLE_0:def 4;
A42:  len F1 in dom F1 by A16,FINSEQ_3:27;
      then F1/.len F1 = F1.len F1 by PARTFUN1:def 8;
      hence contradiction by A18,A23,A40,A41,A42,FUNCT_1:def 5,TARSKI:def 1;
    end;
    hence f.(k+1) in SUCC (f.k) by A4,A16,A17,A18,A39;
    let j be Element of NAT;
    assume
A43: f.j in SUCC (f.k);
    reconsider F = <*f.k, f.j*> as non empty IL-FinSequence of S;
A44: len F = 2 by FINSEQ_1:61;
    then
A45: 1 in dom F & 2 in dom F by FINSEQ_3:27;
    then
A46: F/.1 = F.1 by PARTFUN1:def 8
      .= f.k by FINSEQ_1:61;
A47: F/.len F = F.2 by A44,A45,PARTFUN1:def 8
      .= f.j by FINSEQ_1:61;
    now
      let n be Element of NAT;
      assume 1 <= n & n < len F;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A48:  n = 1 by NAT_1:27;
      then
A49:  F/.(n+1) = F.2 by A45,PARTFUN1:def 8
        .= f.j by FINSEQ_1:61;
      F/.n = F.1 by A45,A48,PARTFUN1:def 8
        .= f.k by FINSEQ_1:61;
      hence F/.(n+1) in SUCC F/.n by A43,A49;
    end;
    then f.k <= f.j by A46,A47,Def8;
    hence k <= j by A2;
  end;
  assume
A50: for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
  for j being Element of NAT st f.j in SUCC (f.k) holds k <= j;
  let m, n be Element of NAT;
  hereby
    assume
A51: m <= n;
    per cases by A51,XXREAL_0:1;
    suppose m = n;
      hence f.m <= f.n;
    end;
    suppose
A52:  m < n;
      thus f.m <= f.n
      proof
        set mn = n -' m;
        reconsider f'=f as Function of NAT,IL;
        deffunc F(Nat) = f'.(m+$1-'1);
        consider F being FinSequence of IL such that
A53:    len F = mn+1 and
A54:    for j being Nat st j in dom F holds F.j = F(j)
        from FINSEQ_2:sch 1;
        reconsider F as non empty IL-FinSequence of S by A53,AMI_1:def 34
        ;
        take F;
        m+1 <= n by A52,INT_1:20;
        then 1 <= n-m by XREAL_1:21;
        then 0 <= n-m by XXREAL_0:2;
        then
A55:    mn = n - m by XREAL_0:def 2;
        1 <= mn+1 by NAT_1:11;
        then
A56:    1 in dom F & len F in dom F by A53,FINSEQ_3:27;
        thus F/.1 = F.1 by A56,PARTFUN1:def 8
          .= f.(m+1-'1) by A54,A56
          .= f.m by NAT_D:34;
        thus F/.len F = F.len F by A56,PARTFUN1:def 8
          .= f.(m+(mn+1)-'1) by A53,A54,A56
          .= f.(m+mn+1-'1)
          .= f.n by A55,NAT_D:34;
        let p be Element of NAT;
        assume
A58:    1 <= p & p < len F;
        then 1 <= p+1 & p+1 <= len F by NAT_1:13;
        then
A59:    p in dom F & p+1 in dom F by A58,FINSEQ_3:27;
A61:    p <= m+p by NAT_1:11;
A62:    F/.(p+1) = F.(p+1) by A59,PARTFUN1:def 8
          .= f.(m+(p+1)-'1) by A54,A59
          .= f.(m+p+1-'1)
          .= f.(m+p-'1+1) by A58,A61,NAT_D:38,XXREAL_0:2;
        F/.p = F.p by A59,PARTFUN1:def 8
          .= f.(m+p-'1) by A54,A59;
        hence F/.(p+1) in SUCC F/.p by A50,A62;
      end;
    end;
  end;
  assume that
A63: f.m <= f.n;
A64: f is one-to-one onto by A1;
A65: dom f = NAT by FUNCT_2:def 1;
  consider F being non empty IL-FinSequence of S such that
A66: F/.1 = f.m & F/.len F = f.n and
A67: for n being Element of NAT
  st 1 <= n & n < len F holds F/.(n+1) in SUCC F/.n by A63,Def8;
  defpred P[Element of NAT] means 1 <= $1 & $1 <= len F implies
  ex l being Element of NAT st F/.$1 = f.l & m <= l;
A68: P[0];
A69: now
    let k be Element of NAT such that
A70: P[k];
    now
      assume
A71:  1 <= k+1 & k+1 <= len F;
      per cases by NAT_1:3;
      suppose k = 0;
        hence ex l being Element of NAT st F/.(k+1) = f.l & m <= l by A66;
      end;
      suppose
A72:    k > 0;
        k < len F by A71,NAT_1:13;
        then
A73:    F/.(k+1) in SUCC F/.k by A67,A72,NAT_1:14;
        consider l being Element of NAT such that
A74:    F/.k = f.l & m <= l by A70,A71,A72,NAT_1:13,14;
        rng f = IL by A64,FUNCT_2:def 3;
        then consider l1 being set such that
A75:    l1 in dom f & f.l1 = F/.(k+1) by FUNCT_1:def 5;
        reconsider l1 as Element of NAT by A75;
        l <= l1 by A50,A73,A74,A75;
        hence ex l being Element of NAT st F/.(k+1) = f.l & m <= l
        by A74,A75,XXREAL_0:2;
      end;
    end;
    hence P[k+1];
  end;
A76: for k being Element of NAT holds P[k] from NAT_1:sch 1(A68, A69);
  1 <= len F by NAT_1:14;
  then ex l being Element of NAT st F/.len F = f.l & m <= l by A76;
  hence m <= n by A64,A65,A66,FUNCT_1:def 8;
end;

theorem Th19:
  S is standard iff ex f being IL-Function of NAT, S st f is bijective &
  for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
  for j being Element of NAT st f.j in SUCC (f.k) holds k <= j
proof
  hereby
    assume S is standard;
    then consider f being IL-Function of NAT, S such that
A1: f is bijective and
A2: for m, n being Element of NAT holds m <= n iff f.m <= f.n by Def10;
    thus ex f being IL-Function of NAT, S st f is bijective &
    for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
    for j being Element of NAT st f.j in SUCC (f.k) holds k <= j
    proof
      take f;
      thus f is bijective by A1;
      thus thesis by A1,A2,Th18;
    end;
  end;
  given f be IL-Function of NAT, S such that
A3: f is bijective and
A4: for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
  for j being Element of NAT st f.j in SUCC (f.k) holds k <= j;
  take f;
  thus f is bijective by A3;
  thus thesis by A3,A4,Th18;
end;

Lm3: for a,b being set holds dom ((NAT --> a)+*(NAT .-->b)) = NAT \/ {NAT}
proof
  let a,b be set;
  thus dom ((NAT --> a)+*(NAT .-->b))
  = dom (NAT --> a) \/ dom (NAT .-->b) by FUNCT_4:def 1
    .= NAT \/ dom (NAT .-->b) by FUNCOP_1:19
    .= NAT \/ {NAT} by FUNCOP_1:19;
end;
set III = {[1,0],[0,0]};

begin :: Standard trivial computer

definition
  let N be with_non-empty_elements set;
  func STC N -> strict AMI-Struct over NAT,N means
  :Def11:
  the carrier of it = NAT \/ {NAT} & the Instruction-Counter of it = NAT &
  the Instructions of it = {[0,0],[1,0]} & the Object-Kind of it =
  (NAT --> {[1,0],[0,0]}) +* (NAT .-->NAT) &
  ex f being Function of product the Object-Kind of it,
  product the Object-Kind of it
  st (for s being Element of product the Object-Kind of it
  holds f.s = s+*(NAT .-->succ(s.NAT))) & the Execution of it
  = ([1,0] .--> f) +* ([0,0] .--> id product the Object-Kind of it);
  existence
  proof
    set O = NAT \/ {NAT};
    NAT in {NAT} by TARSKI:def 1;
    then reconsider IC1 = NAT as Element of O by XBOOLE_0:def 3;
    set IL = NAT;
    0 in {0,1} & 1 in {0,1} & 0 in ((union N) \/ O)* by FINSEQ_1:66
,TARSKI:def 2;
    then [1,0] in [:NAT, ((union N) \/ O)*:] &
    [0,0] in [:NAT, ((union N) \/ O)*:] by ZFMISC_1:106;
    then reconsider ins = III as
    non empty Subset of [:NAT, ((union N) \/ O)*:] by ZFMISC_1:38;
A1: dom ((NAT --> ins)+*(NAT .-->IL)) = O by Lm3;
A2: rng (NAT --> ins) = {ins} by FUNCOP_1:14;
    rng (NAT .-->IL) = {NAT} by FUNCOP_1:14;
    then
A3: rng ((NAT --> ins)+*(NAT .-->IL)) c= {ins}\/{NAT} by A2,FUNCT_4:18;
    {ins}\/{NAT}= {ins, NAT} by ENUMSET1:41;
    then {ins}\/{NAT} c= N \/ {ins, NAT} by XBOOLE_1:7;
    then rng ((NAT --> ins)+*(NAT .-->IL))
    c= N \/ {ins, NAT} by A3,XBOOLE_1:1;
    then reconsider Ok = (NAT --> ins)+*(NAT .-->IL) as
    Function of O, N \/ {ins, IL} by A1,FUNCT_2:def 1,RELSET_1:11;
    deffunc F(Element of product Ok) = $1+*(NAT .-->succ($1.NAT));
A4: now
      let s be Element of product Ok;
      now thus
        dom (s+*(NAT .-->succ(s.NAT)))
        = dom s \/ dom (NAT .-->succ(s.NAT)) by FUNCT_4:def 1
          .= dom s \/ {NAT} by FUNCOP_1:19
          .= dom Ok \/ {NAT} by CARD_3:18
          .= dom Ok by A1,XBOOLE_1:7,12;
        let o be set;
        assume
A5:     o in dom Ok;
        then
A6:     o in NAT or o in {NAT} by XBOOLE_0:def 3;
A7:     dom (NAT .-->succ(s.NAT)) = {NAT} by FUNCOP_1:19;
        per cases by A6,TARSKI:def 1;
        suppose o in NAT;
          then o <> NAT;
          then not o in {NAT} by TARSKI:def 1;
          then (s+*(NAT .-->succ(s.NAT))).o = s.o by A7,FUNCT_4:12;
          hence (s+*(NAT .-->succ(s.NAT))).o in Ok.o by A5,CARD_3:18;
        end;
        suppose
A8:       o = NAT;
          NAT in {NAT} by TARSKI:def 1;
          then
A9:       NAT in dom Ok by A1,XBOOLE_0:def 3;
          dom (NAT .-->IL) = {NAT} by FUNCOP_1:19;
          then
A10:      NAT in dom (NAT .-->IL) by TARSKI:def 1;
A11:      NAT in {NAT} by TARSKI:def 1;
A12:      Ok.o = (NAT .-->IL).NAT by A8,A10,FUNCT_4:14
            .= NAT by A11,FUNCOP_1:13;
          then reconsider k = s.NAT as Element of NAT by A8,A9,CARD_3:18;
A13:      succ k in NAT;
A14:      o in {NAT} by A8,TARSKI:def 1;
          then (s+*(NAT .-->succ(s.NAT))).o
          = (NAT .-->succ(s.NAT)).o by A7,FUNCT_4:14
            .= succ(s.NAT) by A14,FUNCOP_1:13;
          hence (s+*(NAT .-->succ(s.NAT))).o in Ok.o by A12,A13;
        end;
      end;
      hence F(s) in product Ok by CARD_3:18;
    end;
    consider f being Function of product Ok, product Ok such that
A15: for s being Element of product Ok holds f.s= F(s) from FUNCT_2:sch 8
    (A4);
    set E = ([1,0] .--> f) +* ([0,0] .--> id product Ok);
A16: dom E = dom ([1,0] .--> f) \/ dom ([0,0] .--> id product Ok)
    by FUNCT_4:def 1
      .= {[1,0]} \/ dom ([0,0] .--> id product Ok) by FUNCOP_1:19
      .= {[1,0]} \/ {[0,0]} by FUNCOP_1:19
      .= ins by ENUMSET1:41;
A17: rng E c= rng ([1,0] .--> f) \/ rng ([0,0] .--> id product Ok)
    by FUNCT_4:18;
A18: rng ([1,0] .--> f) c= {f} &
    rng ([0,0] .--> id product Ok) c= {id product Ok} by FUNCOP_1:19;
    rng E c= Funcs(product Ok, product Ok)
    proof
      let e be set;
      assume e in rng E;
      then e in rng ([1,0] .--> f) or e in rng ([0,0] .--> id product Ok)
      by A17,XBOOLE_0:def 3;
      then e = f or e = id product Ok by A18,TARSKI:def 1;
      hence thesis by FUNCT_2:12;
    end;
    then reconsider E as Function of ins, Funcs(product Ok, product Ok)
    by A16,FUNCT_2:def 1,RELSET_1:11;
    set M = AMI-Struct(# O, IC1, ins, Ok, E#);
    take M qua strict AMI-Struct over NAT,N;
    thus the carrier of M = NAT \/ {NAT};
    thus the Instruction-Counter of M = NAT;
    thus the Instructions of M = {[0,0],[1,0]};
    thus the Object-Kind of M = (NAT-->III)+*(NAT .-->NAT);
    reconsider f as Function of product the Object-Kind of M,
    product the Object-Kind of M;
    take f;
    thus for s being Element of product the Object-Kind of M
    holds f.s = s+*(NAT .-->succ(s.NAT)) by A15;
    thus thesis;
  end;
  uniqueness
  proof
    let it1, it2 be strict AMI-Struct over NAT,N such that
A19: the carrier of it1 = NAT \/ {NAT} &
    the Instruction-Counter of it1 = NAT &
    the Instructions of it1 = {[0,0],[1,0]} & the Object-Kind of it1 =
    (NAT --> III)+*(NAT .-->NAT);
    given f1 being Function of product the Object-Kind of it1,
    product the Object-Kind of it1 such that
A20: (for s being Element of product the Object-Kind of it1
    holds f1.s = s+*(NAT .-->succ(s.NAT))) & the Execution of it1 =
    ([1,0] .--> f1) +* ([0,0] .--> id product the Object-Kind of it1);
    assume
A21: the carrier of it2 = NAT \/ {NAT} &
    the Instruction-Counter of it2 = NAT &
    the Instructions of it2 = {[0,0],[1,0]} & the Object-Kind of it2 =
    (NAT --> III)+*(NAT .-->NAT);
    given f2 being Function of product the Object-Kind of it2,
    product the Object-Kind of it2 such that
A22: (for s being Element of product the Object-Kind of it2
    holds f2.s = s+*(NAT .-->succ(s.NAT))) & the Execution of it2 =
    ([1,0] .--> f2) +* ([0,0] .--> id product the Object-Kind of it2);
    now
      let c be Element of product the Object-Kind of it1;
      thus f1.c = c+*(NAT .-->succ(c.NAT)) by A20
        .= f2.c by A19,A21,A22;
    end;
    hence it1 = it2 by A19,A20,A21,A22,FUNCT_2:113;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> infinite;
  coherence
  proof
    NAT \/ {NAT} is not finite by FINSET_1:13,XBOOLE_1:7;
    hence the carrier of STC N is infinite by Def11;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> non empty stored-program standard-ins;
  coherence
  proof
    thus the carrier of STC N is non empty;
    the carrier of STC N = NAT \/ {NAT} by Def11;
    hence NAT c= the carrier of STC N by XBOOLE_1:7;
    0 in ((union N) \/ the carrier of STC N)* by FINSEQ_1:66;
    then
A1: {0} c= ((union N) \/ the carrier of STC N)* by ZFMISC_1:37;
    the Instructions of STC N = {[0,0],[1,0]} by Def11
      .= [:{0,1},{0}:] by ZFMISC_1:36;
    hence the Instructions of STC N c=
    [:NAT, ((union N) \/ the carrier of STC N)*:] by A1,ZFMISC_1:119;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> IC-Ins-separated definite realistic steady-programmed;
  coherence
  proof
    set IT = STC N;
A1: the carrier of IT = NAT \/ {NAT} & the Instruction-Counter of IT = NAT &
    the Instructions of IT = III & the Object-Kind of IT =
    (NAT --> III)+*(NAT .-->NAT) by Def11;
    set Ok = the Object-Kind of IT;
    dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
    then
A2: NAT in dom (NAT .-->NAT) by TARSKI:def 1;
A3: NAT in {NAT} by TARSKI:def 1;
A4: Ok.NAT = ((NAT --> III)+*(NAT .-->NAT)).NAT by Def11
      .= (NAT .-->NAT).NAT by A2,FUNCT_4:14
      .= NAT by A3,FUNCOP_1:13; thus
    STC N is IC-Ins-separated
    proof
      thus ObjectKind IC IT = NAT by A4,Def11;
    end;
    thus STC N is definite
    proof
      let l be Instruction-Location of IT;
A5:   l in NAT by AMI_1:def 4;
      then l <> NAT & dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
      then
A6:   not l in dom (NAT .-->NAT) by TARSKI:def 1;
      thus ObjectKind l = ((NAT --> III)+*(NAT .-->NAT)).l by Def11
        .= (NAT --> III).l by A6,FUNCT_4:12
        .= the Instructions of IT by A1,A5,FUNCOP_1:13;
    end;
    thus IT is realistic
    proof
A7:   the Instruction-Counter of IT = NAT by Def11;
      assume the Instruction-Counter of IT in NAT;
      hence contradiction by A7;
    end;
    thus IT is steady-programmed
    proof
      consider f being Function of product the Object-Kind of IT,
      product the Object-Kind of IT such that
A8:   for s being Element of product the Object-Kind of IT
      holds f.s = s+*(NAT .-->succ(s.NAT)) and
A9:   the Execution of IT
      = ([1,0] .--> f) +* ([0,0] .--> id product the Object-Kind of IT)
      by Def11;
      let s be State of IT, i be Instruction of IT,
      l be Instruction-Location of IT;
      l in NAT by AMI_1:def 4;
      then l <> NAT;
      then not l in {NAT} by TARSKI:def 1;
      then
A10:  not l in dom (NAT .-->succ(s.NAT)) by FUNCOP_1:19;
      per cases by A1,TARSKI:def 2;
      suppose
A11:    i = [1,0];
        then
A12:    i in {[1,0]} by TARSKI:def 1;
        now
          assume i in dom ([0,0] .--> id product the Object-Kind of IT);
          then i in {[0,0]} by FUNCOP_1:19;
          then i = [0,0] by TARSKI:def 1;
          hence contradiction by A11,ZFMISC_1:33;
        end;
        then (the Execution of IT).i = ([1,0] .--> f).i by A9,FUNCT_4:12
          .= f by A12,FUNCOP_1:13;
        hence Exec(i,s).l = (s+*(NAT .-->succ(s.NAT))).l by A8
          .= s.l by A10,FUNCT_4:12;
      end;
      suppose i = [0,0];
        then
A13:    i in {[0,0]} by TARSKI:def 1;

then i in dom ([0,0] .--> id product the Object-Kind of IT) by FUNCOP_1:19;
        then (the Execution of IT).i =
        ([0,0] .--> id product the Object-Kind of IT).i by A9,FUNCT_4:14
          .= id product the Object-Kind of IT by A13,FUNCOP_1:13;
        hence Exec(i,s).l = s.l by FUNCT_1:35;
      end;
    end;
  end;
end;

Lm4: for i being Instruction of STC N, s being State of STC N st InsCode i = 1
holds Exec(i,s).IC STC N = succ (IC s)
proof
  let i be Instruction of STC N, s be State of STC N;
  assume
A1: InsCode i = 1;
  set M = STC N;
A2: the Instruction-Counter of M = NAT & the Instructions of M = III by Def11;
  consider f be Function of product the Object-Kind of M,
  product the Object-Kind of M such that
A3: for s being Element of product the Object-Kind of M
  holds f.s = s+*(NAT .-->succ(s.NAT)) and
A4: the Execution of M =
  ([1,0] .--> f) +* ([0,0] .--> id product the Object-Kind of M) by Def11;
  i = [1,0] or i = [0,0] by A2,TARSKI:def 2;
  then
A5: i in {[1,0]} by A1,MCART_1:7,TARSKI:def 1;
A6: now
    assume i in {[0,0]};
    then i = [0,0] by TARSKI:def 1;
    hence contradiction by A1,MCART_1:7;
  end;
  dom ([0,0] .--> id product the Object-Kind of M) = {[0,0]} by FUNCOP_1:19;
  then
A7: (the Execution of M).i = ([1,0] .--> f).i by A4,A6,FUNCT_4:12
    .= f by A5,FUNCOP_1:13;
A8: NAT in {NAT} by TARSKI:def 1;
  then
A9: NAT in dom (NAT .-->succ(s.NAT)) by FUNCOP_1:19;
  thus Exec(i,s).IC STC N = (s+*(NAT .-->succ(s.NAT))).NAT by A2,A3,A7
    .= (NAT .-->succ(s.NAT)).NAT by A9,FUNCT_4:14
    .= succ (IC s) by A2,A8,FUNCOP_1:13;
end;

theorem Th20:
  for i being Instruction of STC N st InsCode i = 0 holds i is halting
proof
  let i be Instruction of STC N;
  assume
A1: InsCode i = 0;
  set M = STC N;
A2: the Instructions of M = III by Def11;
  let s be State of M;
  consider f be Function of product the Object-Kind of M,
  product the Object-Kind of M such that
  for s being Element of product the Object-Kind of M
  holds f.s = s+*(NAT .-->succ(s.NAT)) and
A3: the Execution of M =
  ([1,0] .--> f) +* ([0,0] .--> id product the Object-Kind of M) by Def11;
  i = [1,0] or i = [0,0] by A2,TARSKI:def 2;
  then
A4: i in {[0,0]} by A1,MCART_1:7,TARSKI:def 1;
  dom ([0,0] .--> id product the Object-Kind of M) = {[0,0]} by FUNCOP_1:19;
  then (the Execution of M).i = ({[0,0]}
  --> id product the Object-Kind of M).i by A3,A4,FUNCT_4:14
    .= id product the Object-Kind of M by A4,FUNCOP_1:13;
  hence Exec(i,s) = s by FUNCT_1:35;
end;

theorem
  for i being Instruction of STC N st InsCode i = 1 holds i is non halting
proof
  let i be Instruction of STC N;
  assume
A1: InsCode i = 1;
  set M = STC N;
  assume
A2: for s being State of M holds Exec(i,s) = s;
  consider s being State of M;
A3: Exec(i,s).IC M = succ (IC s) by A1,Lm4;
  Exec(i,s).IC M = IC s by A2;
  hence thesis by A3,ORDINAL1:14;
end;

theorem Th22:
  for i being Element of the Instructions of STC N holds
  InsCode i = 1 or InsCode i = 0
proof
  let i be Element of the Instructions of STC N;
  the Instructions of STC N = III by Def11;
  then i = [1,0] or i = [0,0] by TARSKI:def 2;
  hence thesis by MCART_1:def 1;
end;

theorem
  for i being Instruction of STC N holds i is jump-only
proof
  let i be Instruction of STC N;
  set M = STC N;
A1: the carrier of M = NAT \/ {NAT} & the Instruction-Counter of M = NAT &
  NAT = NAT by Def11;
  let s be State of M, o be Object of M, I be Instruction of M such that
  InsCode I = InsCode i and
A2: o <> IC M;
  o in NAT or o in {NAT} by A1,XBOOLE_0:def 3;
  then reconsider l = o as Instruction-Location of STC N by A1,A2,AMI_1:def 4
,TARSKI:def 1;
  Exec(i,s).l = s.l by AMI_1:def 13;
  hence Exec(I, s).o = s.o by AMI_1:def 13;
end;

Lm5: for l being Instruction-Location of STC N,
i being Element of the Instructions of STC N
st l = z & InsCode i = 1 holds NIC(i, l) = {z+1}
proof
  let l be Instruction-Location of STC N,
  i be Element of the Instructions of STC N;
  assume that
A1: l = z and
A2: InsCode i = 1;
  set M = STC N;
  set F = { IC Following s where s is State of M: IC s = l & s.l = i };
  now
    let y be set;
    hereby
      assume y in F;
      then consider s being State of M such that
A3:   y = IC Following s & IC s = l & s.l = i;
      y = succ z by A1,A2,A3,Lm4
        .= z+1;
      hence y in {z+1} by TARSKI:def 1;
    end;
    assume y in {z+1};
    then
A4: y = z+1 by TARSKI:def 1
      .= succ z;
    consider w being State of M;
    set f = (NAT) --> i;
A5: dom f = NAT by FUNCOP_1:19;
A6: l in NAT by AMI_1:def 4;
    reconsider s = w +* f as State of M by Th11;
    reconsider l' = l as Element of ObjectKind IC M by A6,AMI_1:def 11;
    set u = (IC M).-->l';
    set t = s+*u;
A7: dom u = {IC M} by FUNCOP_1:19;
    then IC M in dom u by TARSKI:def 1;
    then
A8: IC t = u.IC M by FUNCT_4:14
      .= z by A1,FUNCOP_1:87;
    l <> IC M by AMI_1:48;
    then not l in dom u by A7,TARSKI:def 1;
    then
A9: t.l = s.l by FUNCT_4:12
      .= f.l by A5,A6,FUNCT_4:14
      .= i by A6,FUNCOP_1:13;
    then IC Following t = succ z by A1,A2,A8,Lm4;
    hence y in F by A1,A4,A8,A9;
  end;
  hence NIC(i, l) = {z+1} by TARSKI:2;
end;

Lm6: for i being Element of the Instructions of STC N holds JUMP i is empty
proof
  let i be Element of the Instructions of STC N;
  per cases by Th22;
  suppose
A1: InsCode i = 1;
    set X = { NIC(i,l) where l is Instruction-Location of STC N
    : not contradiction };
    assume not thesis;
    then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
    reconsider l1 = 0, l2 = 1 as Instruction-Location of STC N by AMI_1:def 4;
    NIC(i, l1) in X & NIC(i, l2) in X;
    then {0+1} in X & {1+1} in X by A1,Lm5;
    then x in {1} & x in {2} by A2,SETFAM_1:def 1;
    then x = 1 & x = 2 by TARSKI:def 1;
    hence contradiction;
  end;
  suppose
A3: InsCode i = 0;
    reconsider i as Instruction of STC N;

for l being Instruction-Location of STC N holds NIC(i,l)={l} by A3,Th15,Th20;
    hence thesis by Th14;
  end;
end;

theorem Th24:
  for l being Instruction-Location of STC N st l = z holds SUCC l = {z, z+1}
proof
  let l be Instruction-Location of STC N such that
A1: l = z;
  set K = { NIC(i,l) \ JUMP i where i is Element of the Instructions of STC N
  : not contradiction };
  set M = STC N;
  now
    let y be set;
    hereby
      assume y in K;
      then consider ii being Element of the Instructions of STC N such that
A2:   y = NIC(ii,l) \ JUMP ii & not contradiction;
      reconsider ii as Instruction of STC N;
      now per cases by Th22;
        suppose
A3:       InsCode ii = 1;
          JUMP ii = {} by Lm6;
          then y = {z+1} by A1,A2,A3,Lm5;
          hence y in {{z},{z+1}} by TARSKI:def 2;
        end;
        suppose
A4:       InsCode ii = 0;
          JUMP ii = {} by Lm6;
          then y = {z} by A1,A2,A4,Th15,Th20;
          hence y in {{z},{z+1}} by TARSKI:def 2;
        end;
      end;
      hence y in {{z},{z+1}};
    end;
    assume
A5: y in {{z},{z+1}};
    per cases by A5,TARSKI:def 2;
    suppose
A6:   y = {z};
      set i = [0,0];
      i in III by TARSKI:def 2;
      then reconsider i as Instruction of M by Def11;
A7:   JUMP i = {} by Lm6;
      InsCode i = 0 by MCART_1:def 1;
      then NIC(i,l) \ JUMP i = y by A1,A6,A7,Th15,Th20;
      hence y in K;
    end;
    suppose
A8:   y = {z+1};
      set i = [1,0];
      i in III by TARSKI:def 2;
      then reconsider i as Instruction of M by Def11;
A9:   JUMP i = {} by Lm6;
      InsCode i = 1 by MCART_1:def 1;
      then NIC(i,l) \ JUMP i = y by A1,A8,A9,Lm5;
      hence y in K;
    end;
  end;
  then K = {{z},{z+1}} by TARSKI:2;
  hence SUCC l = {z,z+1} by ZFMISC_1:32;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> standard;
  coherence
  proof
    set M = STC N;
    reconsider f = id NAT as IL-Function of NAT, STC N by AMI_1:def 36;
    now
      let k be Element of NAT;
A1:   f.(k+1) = k+1 & SUCC (f.k) = {k,k+1} by Th24,FUNCT_1:35;
      hence f.(k+1) in SUCC (f.k) by TARSKI:def 2;
      let j be Element of NAT;
      assume f.j in SUCC (f.k);
      then f.j = k or f.j = k+1 by A1,TARSKI:def 2;
      then j = k+1 or j = k by FUNCT_1:35;
      hence k <= j by NAT_1:11;
    end;
    hence M is standard by Th19;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> halting;
  coherence
  proof
    set M = STC N;
    the Instructions of M = III by Def11;
    then reconsider I = [0,0] as Instruction of M by TARSKI:def 2;
    take I;
    InsCode I = 0 by MCART_1:def 1;
    hence I is halting by Th20;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster standard halting realistic steady-programmed programmable
    standard-ins (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over NAT,N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

reserve T for standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), k be natural number;
  func il.(S,k) -> Instruction-Location of S means
  :Def12:
  ex f being IL-Function of NAT, S st f is bijective &
  (for m, n being Element of NAT holds m <= n iff f.m <= f.n) & it = f.k;
  existence
  proof
    consider f being IL-Function of NAT, S such that
A1: f is bijective &
    for m, n being Element of NAT holds m <= n iff f.m <= f.n by Def10;
    reconsider k as Element of NAT by ORDINAL1:def 13;
    take f.k, f;
    thus thesis by A1;
  end;
  uniqueness by Th17;
end;

theorem Th25:
  for k1, k2 being natural number st il.(T,k1) = il.(T,k2) holds k1 = k2
proof
  let k1, k2 be natural number;
  assume
A1: il.(T,k1) = il.(T,k2);
A2: k1 is Element of NAT & k2 is Element of NAT by ORDINAL1:def 13;
  consider f1 being IL-Function of NAT, T such that
A3: f1 is bijective & (for m, n being Element of NAT holds m <= n
  iff f1.m <= f1.n) & il.(T,k1) = f1.k1 by Def12;
  consider f2 being IL-Function of NAT, T such that
A4: f2 is bijective & (for m, n being Element of NAT holds m <= n
  iff f2.m <= f2.n) & il.(T,k2) = f2.k2 by Def12;
A5: f1 = f2 by A3,A4,Th17;
  f1 is one-to-one & dom f1 = NAT by A3,FUNCT_2:def 1;
  hence k1 = k2 by A1,A2,A3,A4,A5,FUNCT_1:def 8;
end;

theorem Th26:
  for l being Instruction-Location of T
  ex k being natural number st l = il.(T,k)
proof
  let l be Instruction-Location of T;
  consider f1 being IL-Function of NAT, T such that
A1: f1 is bijective & (for m, n being Element of NAT holds m <= n
  iff f1.m <= f1.n) & il.(T,0) = f1.0 by Def12;
A2: l in NAT by AMI_1:def 4;
  f1 is onto by A1;
  then rng f1 = NAT by FUNCT_2:def 3;
  then consider k being set such that
A3: k in dom f1 & f1.k = l by A2,FUNCT_1:def 5;
  reconsider k as Element of NAT by A3;
  take k;
  thus l = il.(T,k) by A1,A3,Def12;
end;

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  l be Instruction-Location of S;
  func locnum l -> natural number means
  :Def13:
  il.(S,it) = l;
  existence by Th26;
  uniqueness by Th25;
end;

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  l be Instruction-Location of S;
  redefine func locnum l -> Element of NAT;
  coherence by ORDINAL1:def 13;
end;

theorem Th27:
  for l1, l2 being Instruction-Location of T
  holds locnum l1 = locnum l2 implies l1 = l2
proof
  let l1, l2 be Instruction-Location of T;
  assume
A1: locnum l1 = locnum l2;
  il.(T,locnum l1) = l1 & il.(T,locnum l2) = l2 by Def13;
  hence thesis by A1;
end;

theorem Th28:
  for k1, k2 being natural number holds il.(T,k1) <= il.(T,k2) iff k1 <= k2
proof
  let k1, k2 be natural number;
A1: k1 is Element of NAT & k2 is Element of NAT by ORDINAL1:def 13;
  consider f1 being IL-Function of NAT, T such that
A2: f1 is bijective & (for m, n being Element of NAT holds m <= n
  iff f1.m <= f1.n) & il.(T,k1) = f1.k1 by Def12;
  consider f2 being IL-Function of NAT, T such that
A3: f2 is bijective & (for m, n being Element of NAT holds m <= n
  iff f2.m <= f2.n) & il.(T,k2) = f2.k2 by Def12;
  f1 = f2 by A2,A3,Th17;
  hence thesis by A1,A2,A3;
end;

theorem Th29:
  for l1, l2 being Instruction-Location of T
  holds locnum l1 <= locnum l2 iff l1 <= l2
proof
  let l1, l2 be Instruction-Location of T;
  il.(T,locnum l1) = l1 & il.(T,locnum l2) = l2 by Def13;
  hence thesis by Th28;
end;

theorem Th30:
  T is InsLoc-antisymmetric
proof
  let l1, l2 be Instruction-Location of T;
  assume
A1: l1 <= l2 & l2 <= l1;
  reconsider T as standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N));
  reconsider l1, l2 as Instruction-Location of T;
  locnum l1 <= locnum l2 & locnum l2 <= locnum l1 by A1,Th29;
  hence thesis by Th27,XXREAL_0:1;
end;

registration
  let N;
  cluster standard -> InsLoc-antisymmetric (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over NAT,N));
  coherence by Th30;
end;

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  f be Instruction-Location of S, k be natural number;
  func f + k -> Instruction-Location of S equals

  il.(S,locnum f + k);
  coherence;
end;

theorem
  for f being Instruction-Location of T holds f + 0 = f by Def13;

theorem
  for f, g being Instruction-Location of T st f + z = g + z holds f = g
proof
  let f, g be Instruction-Location of T such that
A1: f + z = g + z;
  locnum f + z = locnum g + z by A1,Th25;
  hence f = g by Th27;
end;

theorem
  for f being Instruction-Location of T
  holds locnum f + z = locnum (f + z) by Def13;

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  f be Instruction-Location of S;
  func NextLoc f -> Instruction-Location of S equals

  f + 1;
  coherence;
end;

theorem
  for f being Instruction-Location of T holds NextLoc f = il.(T,locnum f + 1);

theorem Th35:
  for f being Instruction-Location of T holds f <> NextLoc f
proof
  let f be Instruction-Location of T;
  assume f = NextLoc f;
  then locnum f = locnum f + 1 by Def13;
  hence thesis;
end;

theorem
  for f, g being Instruction-Location of T st NextLoc f = NextLoc g
  holds f = g
proof
  let f, g be Instruction-Location of T such that
A1: NextLoc f = NextLoc g;
  set k = locnum f;
  set m = locnum g;
  k+0 = k+1-1
    .= m+1-1 by A1,Th25
    .= m+0;
  hence f = g by Th27;
end;

theorem Th37:
  il.(STC N, z) = z
proof
  set M = STC N;
A1: z is Element of NAT by ORDINAL1:def 13;
  consider f being IL-Function of NAT, M such that
A2: f is bijective & (for m, n being Element of NAT holds m <= n
  iff f.m <= f.n) & il.(M,z) = f.z by Def12;
  reconsider f2 = id NAT as IL-Function of NAT, STC N by AMI_1:def 36;
  now
    let k be Element of NAT;
A3: f2.(k+1) = k+1 & f2.k = k by FUNCT_1:35;
A4: SUCC f2.k = {k,k+1} by Th24,FUNCT_1:35;
    hence f2.(k+1) in SUCC (f2.k) by A3,TARSKI:def 2;
    let j be Element of NAT;
    assume
A5: f2.j in SUCC (f2.k);
    j = f2.j & j+1 = f2.(j+1) by FUNCT_1:35;
    then j = k or j = k+1 by A4,A5,TARSKI:def 2;
    hence k <= j by NAT_1:11;
  end;
  then for m, n being Element of NAT holds m <= n iff f2.m <= f2.n by Th18;
  then f = f2 by A2,Th17;
  hence il.(STC N, z) = z by A1,A2,FUNCT_1:35;
end;

theorem
  for i being Instruction of STC N, s being State of STC N st InsCode i = 1
  holds Exec(i,s).IC STC N = NextLoc IC s
proof
  let i be Instruction of STC N, s be State of STC N;
  assume
A1: InsCode i = 1;
  set M = STC N;
  set k = locnum IC s;
A2: il.(M,k) = k & il.(M,k+1) = k+1 by Th37;
  reconsider K = IC s as Element of NAT by AMI_1:def 4;
  Exec(i,s).IC STC N = succ IC s by A1,Lm4
    .= K+1 by NAT_1:39;
  hence Exec(i,s).IC STC N = NextLoc IC s by A2,Def13;
end;

theorem
  for l being Instruction-Location of STC N,
  i being Element of the Instructions of STC N st InsCode i = 1
  holds NIC(i, l) = {NextLoc l}
proof
  let l be Instruction-Location of STC N,
  i be Element of the Instructions of STC N;
  assume
A1: InsCode i = 1;
  set M = STC N;
  consider k being natural number such that
A2: l = il.(M,k) by Th26;
  k = locnum l by A2,Def13;
  then NextLoc l = k+1 by Th37;
  hence NIC(i, l) = {NextLoc l} by A1,A2,Lm5,Th37;
end;

theorem
  for l being Instruction-Location of STC N holds SUCC l = {l, NextLoc l}
proof
  let l be Instruction-Location of STC N;
  set M = STC N;
  consider k being natural number such that
A1: l = il.(M,k) by Th26;
A2: k = locnum l by A1,Def13;
  thus SUCC l = {k,k+1} by A1,Th24,Th37
    .= {k,il.(M,k+1)} by Th37
    .= {l, NextLoc l} by A1,A2,Th37;
end;

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), i be Instruction of S;
  attr i is sequential means
  for s being State of S holds Exec(i, s).IC S = NextLoc IC s;
end;

theorem Th41:
  for S being standard realistic (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  il being Instruction-Location of S,
  i being Instruction of S st i is sequential holds NIC(i,il) = {NextLoc il}
proof
  let S be standard realistic (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  il be Instruction-Location of S, i be Instruction of S such that
A1: for s being State of S holds Exec(i, s).IC S = NextLoc IC s;
  now
    let x be set;
A2: now
      assume
A3:   x = NextLoc il;
      consider t being State of S;
      il in NAT by AMI_1:def 4;
      then reconsider il1 = il as Element of ObjectKind IC S by AMI_1:def 11;
      reconsider I = i as Element of ObjectKind il by AMI_1:def 14;
      reconsider u = t+*((IC S, il)-->(il1, I) qua FinPartState of S)
      as State of S;
A4:   dom ((IC S, il)-->(il1, I)) = {IC S, il} by FUNCT_4:65;
      then
A5:   IC S in dom ((IC S, il)-->(il1, I)) by TARSKI:def 2;
A7:   IC u = ((IC S, il)-->(il1, I)).IC S by A5,FUNCT_4:14
        .= il by AMI_1:48,FUNCT_4:66;
      il in dom ((IC S, il)-->(il1, I)) by A4,TARSKI:def 2;
      then
A8:   u.il = ((IC S, il)-->(il1, I)).il by FUNCT_4:14
        .= i by FUNCT_4:66;
      then IC Following u = NextLoc il by A1,A7;
      hence x in {IC Following s where s is State of S : IC s = il & s.il=i}
      by A3,A7,A8;
    end;
    now
      assume x in {IC Following s where s is State of S : IC s = il & s.il=i};
      then consider s being State of S such that
A9:   x = IC Following s & IC s = il & s.il = i;
      thus x = NextLoc il by A1,A9;
    end;
    hence x in {NextLoc il} iff
    x in {IC Following s where s is State of S : IC s = il & s.il=i}
    by A2,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th42:
  for S being realistic standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  i being Instruction of S st i is sequential holds i is non halting
proof
  let S be realistic standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  i be Instruction of S such that
A1: i is sequential;
  consider s being State of S;
  NIC(i,IC s) = {NextLoc IC s} by A1,Th41;
  then NIC(i,IC s) <> {IC s} by Th35,ZFMISC_1:6;
  hence thesis by Th15;
end;

registration
  let N;
  let S be realistic standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster sequential -> non halting Instruction of S;
  coherence by Th42;
  cluster halting -> non sequential Instruction of S;
  coherence;
end;

theorem
  for i being Instruction of T st JUMP i is non empty holds i is non
  sequential
proof
  let i be Instruction of T;
  assume JUMP i is non empty;
  then consider l being set such that
A1: l in JUMP i by XBOOLE_0:def 1;
  reconsider l as Instruction-Location of T by A1,AMI_1:def 4;
  set X = { NIC(i,l1) where
  l1 is Instruction-Location of T: not contradiction };
  NIC(i,l) in X;
  then l in NIC(i,l) by A1,SETFAM_1:def 1;
  then consider s being State of T such that
A2: l = IC Following s and
A3: IC s = l & s.l = i;
  take s;
  thus Exec(i,s).IC T <> NextLoc IC s by A2,A3,Th35;
end;

begin :: Closedness of finite partial states

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  let F be programmed FinPartState of S;
  attr F is closed means
  :Def17:
  for l being Instruction-Location of S st l in dom F
  holds NIC (pi(F,l), l) c= dom F;
  attr F is really-closed means
  for s being State of S st F c= s & IC s in dom F
  for k being Element of NAT holds IC  Computation(s,k) in dom F;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be FinPartState of S;
  attr F is para-closed means
  for s being State of S st F c= s & IC s = il.(S,0)
  for k being Element of NAT holds IC  Computation(s,k) in dom F;
end;

theorem Th44:
  for S being standard steady-programmed (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being programmed FinPartState of S
  st F is really-closed & il.(S,0) in dom F holds F is para-closed
proof
  let S be standard steady-programmed (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be programmed FinPartState of S such that
A1: for s being State of S st F c= s & IC s in dom F
  for k being Element of NAT holds IC  Computation(s,k) in dom F and
A2: il.(S,0) in dom F;
  let s be State of S;
  assume F c= s & IC s = il.(S,0);
  hence thesis by A1,A2;
end;

theorem Th45:
  for S being IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over IL,N),
  F being programmed FinPartState of S
  st F is closed holds F is really-closed
proof
  let S be IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over IL,N),
  F be programmed FinPartState of S such that
A1: F is closed;
  let s be State of S such that
A2: F c= s & IC s in dom F;
  defpred P[Element of NAT] means IC  Computation(s,$1) in dom F;
A3: P[0] by A2,AMI_1:13;
A4: now
    let k be Element of NAT such that
A5: P[k];
    set l = IC  Computation(s,k);
A6: NIC(pi(F,l), l) c= dom F by A1,A5,Def17;
    set t =  Computation(s,k);
A7: pi(F,l) = F.l by A5,AMI_1:def 47;
    F.l = s.l by A2,A5,GRFUNC_1:8;
    then t.l = pi(F,l) by A7,AMI_1:54;
    then
A8: IC Following t in NIC(pi(F,l),l);
     Computation(s,k+1) = Following t by AMI_1:14;
    hence P[k+1] by A6,A8;
  end;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A4);
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set,
  S be IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over IL,N);
  cluster closed -> really-closed (programmed FinPartState of S);
  coherence by Th45;
end;

theorem Th46:
  for S being standard realistic halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N))
  holds il.(S,0) .--> halt S is closed
proof
  let S be standard realistic halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  set F = il.(S,0) .--> halt S;
A1: dom F = {il.(S,0)} by FUNCOP_1:19;
  let l be Instruction-Location of S;
  assume
A2: l in dom F;
  then
A3: l = il.(S,0) by A1,TARSKI:def 1;
  pi(F,l) = F.l by A2,AMI_1:def 47
    .= halt S by A3,FUNCOP_1:87;
  hence NIC(pi(F,l), l) c= dom F by A1,A3,Th15;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  let F be FinPartState of S;
  attr F is lower means
  :Def20:
  for l being Instruction-Location of S st l in dom F
  holds for m being Instruction-Location of S st m <= l holds m in dom F;
end;

theorem Th47:
  for F being empty FinPartState of S holds F is lower
proof
  let F be empty FinPartState of S;
  let l be Instruction-Location of S;
  assume l in dom F;
  hence thesis;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  cluster empty -> lower FinPartState of S;
  coherence by Th47;
end;

theorem Th48:
  for i being Element of the Instructions of T holds il.(T,0) .--> i is lower
proof
  let i be Element of the Instructions of T;
  set F = il.(T,0).--> i;
A1: dom F = {il.(T,0)} by FUNCOP_1:19;
  let l be Instruction-Location of T such that
A2: l in dom F;
A3: l = il.(T,0) by A1,A2,TARSKI:def 1;
  let m be Instruction-Location of T such that
A4: m <= l;
  consider k being natural number such that
A5: m = il.(T,k) by Th26;
  0 <= k & k <= 0 by A3,A4,A5,Th28,NAT_1:2;
  hence m in dom F by A2,A3,A5,XXREAL_0:1;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster lower non empty trivial programmed FinPartState of S;
  existence
  proof
    consider i being Instruction of S;
    take il.(S,0).--> i;
    thus thesis by Th48;
  end;
end;

theorem Th49:
  for F being lower non empty programmed FinPartState of T
  holds il.(T,0) in dom F
proof
  let F be lower non empty programmed FinPartState of T;
  consider l being set such that
A1: l in dom F by XBOOLE_0:def 1;
A2: dom F c= NAT by AMI_1:def 40;
  then reconsider l as Instruction-Location of T by A1,AMI_1:def 4;
  consider f being IL-Function of NAT, T such that
A3: f is bijective and
A4: for m, n being Element of NAT holds m <= n iff f.m <= f.n and
A5: il.(T,0) = f.0 by Def12;
  f is onto by A3;
  then rng f = NAT by FUNCT_2:def 3;
  then consider x being set such that
A6: x in dom f and
A7: l = f.x by A1,A2,FUNCT_1:def 5;
  reconsider x as Element of NAT by A6;
  0 <= x by NAT_1:2;
  then f.0 <= f.x by A4;
  hence thesis by A1,A5,A7,Def20;
end;

theorem Th50:
  for P being lower programmed FinPartState of T holds
  z < card P iff il.(T,z) in dom P
proof
  let P be lower programmed FinPartState of T;
  deffunc F(Element of NAT) = il.(T,$1);
  defpred P[Element of NAT] means F($1) in dom P;
  set A1 = {k : F(k) in dom P};
  set A = { k : P[k]};
A1: now
    let x be set;
    assume
A2: x in dom P;
    dom P c= NAT by AMI_1:def 40;
    then reconsider l=x as Instruction-Location of T by A2,AMI_1:def 4;
    consider n being natural number such that
A3: l = il.(T,n) by Th26;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    take n;
    thus x = F(n) by A3;
  end;
A4: for k1, k2 being Element of NAT st F(k1) = F(k2) holds k1 = k2 by Th25;
A5: dom P, A1 are_equipotent from FUNCT_7:sch 3(A1,A4);
A6: A is Subset of NAT from DOMAIN_1:sch 7;
  now
    let a, b be Element of NAT such that
A7: a in A;
    assume b < a;
    then
A8: il.(T,b) <= il.(T,a) by Th28;
    ex l being Element of NAT st l = a & il.(T,l) in dom P by A7;
    then il.(T,b) in dom P by A8,Def20;
    hence b in A;
  end;
  then reconsider A as Cardinal by A6,FUNCT_7:22;
A9: z is Element of NAT by ORDINAL1:def 13;
A10: Card z = z & Card card P = card P by CARD_1:def 5;
A11: Card A = A by CARD_1:def 5;
  hereby
    assume z < card P;
    then Card z in Card card P by NAT_1:42;
    then z in card dom P by A10,PRE_CIRC:21;
    then z in Card A by A5,CARD_1:21;
    then ex d being Element of NAT st d = z & il.(T,d) in dom P by A11;
    hence il.(T,z) in dom P;
  end;
  assume il.(T,z) in dom P;
  then z in Card A by A9,A11;
  then z in card dom P by A5,CARD_1:21;
  then Card z in Card card P by A10,PRE_CIRC:21;
  hence z < card P by NAT_1:42;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be non empty programmed FinPartState of S;
  func LastLoc F -> Instruction-Location of S means
  :Def21:
  ex M being finite non empty natural-membered set st
  M = { locnum l where l is Instruction-Location of S : l in dom F } &
  it = il.(S, max M);
  existence
  proof
    deffunc F(Instruction-Location of S) = locnum $1;
    set M = { F(l) where l is Instruction-Location of S : l in dom F };
A1: dom F is finite;
A2: M is finite from AMI_1:sch 1(A1);
    consider l being Element of dom F;
    l in dom F & dom F c= NAT by AMI_1:def 40;
    then reconsider l as Instruction-Location of S by AMI_1:def 4;
A3: locnum l in M;
    M c= NAT
    proof
      let k be set;
      assume k in M;
      then ex l being Instruction-Location of S st k = locnum l & l in dom F;
      hence k in NAT;
    end;
    then reconsider M as finite non empty Subset of NAT by A2,A3;
    take il.(S, max M), M;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th51:
  for F being non empty programmed FinPartState of T holds LastLoc F in dom F
proof
  let F be non empty programmed FinPartState of T;
  consider M being finite non empty natural-membered set such that
A1: M = { locnum l where l is Instruction-Location of T : l in dom F } and
A2: LastLoc F = il.(T, max M) by Def21;
  max M in M by XXREAL_2:def 8;
  then ex l being Instruction-Location of T st
  max M = locnum l & l in dom F by A1;
  hence LastLoc F in dom F by A2,Def13;
end;

theorem
  for F, G being non empty programmed FinPartState of T st F c= G
  holds LastLoc F <= LastLoc G
proof
  let F, G be non empty programmed FinPartState of T such that
A1: F c= G;
  consider M being finite non empty natural-membered set such that
A2: M = { locnum l where l is Instruction-Location of T : l in dom F } and
A3: LastLoc F = il.(T, max M) by Def21;
  consider N being finite non empty natural-membered set such that
A4: N = { locnum l where l is Instruction-Location of T : l in dom G } and
A5: LastLoc G = il.(T, max N) by Def21;
  reconsider MM = M, NN = N as non empty finite Subset of REAL by MEMBERED:3;
  M c= N
  proof
    let a be set;
    assume a in M;
    then consider l being Instruction-Location of T such that
A6: a = locnum l & l in dom F by A2;
    dom F c= dom G by A1,GRFUNC_1:8;
    hence a in N by A4,A6;
  end;
  then max MM <= max NN by XXREAL_2:59;
  hence LastLoc F <= LastLoc G by A3,A5,Th28;
end;

theorem Th53:
  for F being non empty programmed FinPartState of T,
  l being Instruction-Location of T st l in dom F holds l <= LastLoc F
proof
  let F be non empty programmed FinPartState of T,
  l be Instruction-Location of T such that
A1: l in dom F;
  consider M being finite non empty natural-membered set such that
A2: M = { locnum w where w is Instruction-Location of T : w in dom F } and
A3: LastLoc F = il.(T, max M) by Def21;
A4: locnum LastLoc F = max M by A3,Def13;
  locnum l in M by A1,A2;
  then locnum l <= max M by XXREAL_2:def 8;
  hence l <= LastLoc F by A4,Th29;
end;

theorem
  for F being lower non empty programmed FinPartState of T,
  G being non empty programmed FinPartState of T
  holds F c= G & LastLoc F = LastLoc G implies F = G
proof
  let F be lower non empty programmed FinPartState of T,
  G be non empty programmed FinPartState of T such that
A1: F c= G and
A2: LastLoc F = LastLoc G;
  dom F = dom G
  proof
    thus dom F c= dom G by A1,GRFUNC_1:8;
    let x be set;
    assume
A3: x in dom G;
    dom G c= NAT by AMI_1:def 40;
    then reconsider x as Instruction-Location of T by A3,AMI_1:def 4;
A4: x <= LastLoc F by A2,A3,Th53;
    LastLoc F in dom F by Th51;
    hence thesis by A4,Def20;
  end;
  hence F = G by A1,GRFUNC_1:9;
end;

theorem Th55:
  for F being lower non empty programmed FinPartState of T
  holds LastLoc F = il.(T, card F -' 1)
proof
  let F be lower non empty programmed FinPartState of T;
A1: LastLoc F in dom F by Th51;
  consider k being natural number such that
A2: LastLoc F = il.(T,k) by Th26;
  reconsider k as Element of NAT by ORDINAL1:def 13;
  k < card F by A1,A2,Th50;
  then
A3: k <= card F -' 1 by NAT_D:49;
  per cases by A3,XXREAL_0:1;
  suppose k < card F -' 1;
    then k+1 < card F -' 1 + 1 by XREAL_1:8;
    then k+1 < card F by NAT_1:14,XREAL_1:237;
    then il.(T,k+1) in dom F by Th50;
    then il.(T,k+1) <= LastLoc F by Th53;
    then
A5: k+1 <= k by A2,Th28;
    k <= k+1 by NAT_1:11;
    then k+0 = k+1 by A5,XXREAL_0:1;
    hence thesis;
  end;
  suppose k = card F -' 1;
    hence thesis by A2;
  end;
end;

registration
  let N be with_non-empty_elements set,
  S be standard steady-programmed (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N));
  cluster really-closed lower non empty  -> para-closed
    (programmed FinPartState of S);
  coherence
  proof
    let F be programmed FinPartState of S;
    assume
A1: F is really-closed;
    assume F is lower non empty;
    then il.(S,0) in dom F by Th49;
    hence thesis by A1,Th44;
  end;
end;

Lm7: now
  let IL,N;
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  set F = il.(S,0) .--> halt S;
A1: dom F = {il.(S,0)} by FUNCOP_1:19;
  then
A2: card dom F = 1 by CARD_1:50;
  F is lower FinPartState of S by Th48;
  then
A3: LastLoc F = il.(S,card F -' 1) by Th55
    .= il.(S,card dom F -' 1) by PRE_CIRC:21
    .= il.(S,0) by A2,XREAL_1:234;
  hence F.(LastLoc F) = halt S by FUNCOP_1:87;
  let l be Instruction-Location of S such that F.l = halt S;
  assume l in dom F;
  hence l = LastLoc F by A1,A3,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be non empty programmed FinPartState of S;
  attr F is halt-ending means

  F.(LastLoc F) = halt S;
  attr F is unique-halt means
  for f being Instruction-Location of S st F.f = halt S & f in dom F
  holds f = LastLoc F;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster halt-ending unique-halt trivial (lower non empty programmed
    FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S
    as lower non empty programmed FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Instruction-Location of S st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus F is trivial;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting realistic (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N));
  cluster trivial closed lower non empty (programmed FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S
    as lower non empty programmed FinPartState of S by Th48;
    take F;
    thus thesis by Th46;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting realistic (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N));
  cluster halt-ending unique-halt trivial closed (lower non empty programmed
    FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S
    as lower non empty programmed FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Instruction-Location of S st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus F is trivial closed by Th46;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard halting realistic steady-programmed
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster halt-ending unique-halt autonomic trivial closed
    (lower non empty programmed FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S
    as lower non empty programmed FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Instruction-Location of S st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus F is autonomic trivial closed by Lm1,Th46;
  end;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  mode pre-Macro of S is halt-ending unique-halt (lower non empty programmed
    FinPartState of S);
end;

registration
  let N be with_non-empty_elements set;
  let S be standard realistic halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster closed pre-Macro of S;
  existence
  proof
    reconsider F = il.(S,0) .--> halt S
    as lower non empty programmed FinPartState of S by Th48;
    F is halt-ending unique-halt
    proof
      thus F.(LastLoc F) = halt S &
      for l being Instruction-Location of S st F.l = halt S & l in dom F
      holds l = LastLoc F by Lm7;
    end;
    then reconsider F as pre-Macro of S;
    take F;
    thus F is closed by Th46;
  end;
end;

theorem
  for i being Instruction of Trivial-AMI(IL,N) holds i is halting
proof
  let i be Instruction of Trivial-AMI(IL,N);
  set M = Trivial-AMI(IL,N);
A1: the Instructions of M = {[0,{}]} by AMI_1:def 2;
  let s be State of M;
  the Object-Kind of M = (IL --> {[0,{}]}) +* (IL .--> IL) by AMI_1:def 2;
  then (the Execution of M).i =
  ([0,{}] .--> id product the Object-Kind of M).i by AMI_1:def 2
    .= id product the Object-Kind of M by A1,FUNCOP_1:13;
  hence Exec(i,s) = s by FUNCT_1:35;
end;

theorem
  for i being Element of the Instructions of Trivial-AMI(IL,N) holds
  InsCode i = 0
proof
  let i be Element of the Instructions of Trivial-AMI(IL,N);
  the Instructions of Trivial-AMI(IL,N) = {[0,{}]} by AMI_1:def 2;
  then i = [0,{}] by TARSKI:def 1;
  hence thesis by MCART_1:def 1;
end;

begin :: Addenda

:: from SCMPDS_9, 2008.03.10, A.T.

theorem
  for IL being non empty set for N being with_non-empty_elements set,
  S being IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N), i being Instruction of S,
  l being Instruction-Location of S holds JUMP(i) c= NIC(i,l)
proof
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N), i be Instruction of S,
  l be Instruction-Location of S;
  set X = { NIC(i,k) where k is Instruction-Location of S:
  not contradiction };
  let x be set;
  assume
A1: x in JUMP(i);
  NIC(i,l) in X;
  hence thesis by A1,SETFAM_1:def 1;
end;

theorem
  for IL being non empty set for N being with_non-empty_elements set,
  S being IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  l1, l2 being Instruction-Location of S st SUCC(l1) = IL holds l1 <= l2
proof
  let IL be non empty set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  l1, l2 be Instruction-Location of S such that
A1: SUCC(l1) = IL;
  defpred P[set,set] means
  ($1 = 1 implies $2 = l1) & ($1 = 2 implies $2 = l2);
A2: for n being Nat st n in Seg 2
  ex d being Element of IL st P[n,d]
  proof
    let n be Nat;
    assume
A3: n in Seg 2;
    per cases by A3,FINSEQ_1:4,TARSKI:def 2;
    suppose
A4:   n = 1;
      reconsider l1 as Element of IL by AMI_1:def 4;
      take l1;
      thus P[n,l1] by A4;
    end;
    suppose
A5:   n = 2;
      reconsider l2 as Element of IL by AMI_1:def 4;
      take l2;
      thus P[n,l2] by A5;
    end;
  end;
  consider f being FinSequence of IL such that
A6: len f = 2 and
A7: for n being Nat st n in Seg 2 holds P[n,f/.n]
  from FINSEQ_4:sch 1(A2);
A8: 1 in Seg 2 & 2 in Seg 2 by FINSEQ_1:4,TARSKI:def 2;
  then
A9: f/.1 = l1 & f/.len f = l2 by A6,A7;
  dom f = Seg 2 by A6,FINSEQ_1:def 3;
  then ex y being set st [1,y] in f by A8,RELAT_1:def 4;
  then reconsider f as non empty IL-FinSequence of S by AMI_1:def 34;
  take f;
  thus f/.1 = l1 & f/.len f = l2 by A8,A6,A7;
  let n be Element of NAT;
  assume
A10: 1 <= n;
  assume n < len f;
  then n < 1+1 by A6;
  then n <= 1 by NAT_1:13;
  then n = 1 by A10,XXREAL_0:1;
  hence f/.(n+1) in SUCC f/.n by A1,A9;
end;

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set,
  S for standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  l for Instruction-Location of S,
  f for FinPartState of S;

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  loc be Instruction-Location of S, k be natural number;
  func loc -' k -> Instruction-Location of S equals

  il.(S, (locnum loc) -' k);
  coherence;
end;

theorem
  l -' 0 = l
proof
  thus l -' 0 = il.(S,locnum l) by NAT_D:40
    .= l by Def13;
end;

theorem Th5:
  l + k -' k = l
proof
  thus l + k -' k = il.(S,locnum l + k -' k) by Def13
    .= il.(S,locnum l) by NAT_D:34
    .= l by Def13;
end;

canceled;

theorem
  for l1, l2 being Instruction-Location of S holds
  Start-At(l1+k) = Start-At(l2+k) iff Start-At l1 = Start-At l2
proof
  let l1,l2 be Instruction-Location of S;
  hereby
    assume
A1: Start-At(l1 + k) = Start-At(l2 + k);
    {[IC S, l1 + k]} = IC S .--> (l2 + k) by A1,FUNCT_4:87;
    then {[IC S, l1 + k]} = {[IC S, l2 + k]} by FUNCT_4:87;
    then [IC S, l1 + k] = [IC S, l2 + k] by ZFMISC_1:6;
    then l1 + k = l2 + k by ZFMISC_1:33;
    then l1 = l2 + k -' k by Th5;
    hence Start-At l1 = Start-At l2 by Th5;
  end;
  assume Start-At l1 = Start-At l2;
  then {[IC S, l1]} = Start-At l2 by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence Start-At(l1 + k) = Start-At(l2 + k) by ZFMISC_1:33;
end;

theorem
  for l1, l2 being Instruction-Location of S
  st Start-At l1 = Start-At l2 holds Start-At(l1 -' k) = Start-At(l2 -' k)
proof
  let l1, l2 be Instruction-Location of S;
  assume Start-At l1 = Start-At l2;
  then {[IC S, l1]} = Start-At l2 by FUNCT_4:87
    .= {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence Start-At(l1 -' k) = Start-At(l2 -' k) by ZFMISC_1:33;
end;

