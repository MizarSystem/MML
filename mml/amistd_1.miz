:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ORDINAL1, SETFAM_1, AMI_1, FSM_1,
      FUNCT_4, FUNCOP_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, CARD_3, ZFMISC_1,
      CIRCUIT2, CAT_1, NAT_1, GLIB_000, XXREAL_0, PARTFUN1, FINSEQ_1, ARYTM_3,
      CARD_1, GOBOARD5, FUNCT_2, FINSEQ_4, ARYTM_1, FINSET_1, FRECHET,
      RCOMP_1, AMISTD_1, SCMNORM, AFINSQ_1, COMPOS_1, AMISTD_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, MCART_1, VALUED_1,
      DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4, FUNCOP_1, FINSET_1,
      FUNCT_4, AFINSQ_1,
      STRUCT_0, GRAPH_2, NAT_D, XXREAL_2, COMPOS_1,
      EXTPRO_1, FUNCT_2;
 constructors WELLORD2, REAL_1, FINSEQ_4, REALSET1, NAT_D, XXREAL_2, COMPOS_1,
      EXTPRO_1, RELSET_1, PRE_POLY, GRAPH_2, AFINSQ_1, MCART_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCOP_1, FINSET_1, NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3,
      REALSET1, FUNCT_7, STRUCT_0, JORDAN1J, CARD_1, XXREAL_2, RELSET_1,
      FUNCT_4, AFINSQ_1, ORDINAL1, ZFMISC_1, SUBSET_1, VALUED_1, COMPOS_1,
      EXTPRO_1;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, COMPOS_1, EXTPRO_1, YELLOW_8, XBOOLE_0,
      FUNCOP_1, NAT_1, RELAT_1, FUNCT_4, NAT_D, AFINSQ_1, VALUED_1;
 theorems TARSKI, FINSEQ_4, FINSEQ_1, NAT_1, FUNCT_4, FUNCT_1,
      FUNCT_2, ENUMSET1, ZFMISC_1, CARD_1, FUNCOP_1, CARD_3, ORDINAL1,
      MCART_1, GRFUNC_1, FINSEQ_3, INT_1, SETFAM_1, REVROT_1, EXTPRO_1,
      RELSET_1, XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, COMPOS_1,
      PARTFUN1, FINSET_1, XREAL_0, NAT_D, PBOOLE, AFINSQ_1, RECDEF_2;
 schemes NAT_1, FINSEQ_2, FUNCT_2;

begin :: Ami-Struct

reserve x for set,
  D for non empty set,
  k, n for Element of NAT,
  z for natural number;

reserve
  N for with_non-empty_elements non empty set,
  S for
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N),
  i for Element of the Instructions of S,
  l, l1, l2, l3 for Element of NAT,
  s for State of S;

registration

  let N be with_non-empty_elements set, S be stored-program
   AMI-Struct over N, i be Element of the Instructions of S, s be State of S;
  cluster ((the Execution of S).i).s -> Function-like Relation-like;
  coherence
  proof
    reconsider A =(the Execution of S).i as Function of product the
    Object-Kind of S, product the Object-Kind of S by FUNCT_2:121;
  reconsider s as Element of product the Object-Kind of S
   by PBOOLE:155;
    A.s in product the Object-Kind of S;
    hence thesis;
  end;
end;

canceled 12;

definition
  let N be with_non-empty_elements non empty set;
  let S be non empty stored-program standard-ins AMI-Struct over N;
  let T be InsType of S;
  canceled 2;
  attr T is jump-only means
  for s being State of S, o being Object of S, I
  being Instruction of S st InsCode I = T &
   o in Data-Locations S
  holds Exec(I, s).o = s.o;
end;

definition

  let N be with_non-empty_elements non empty set;
  let S be non empty stored-program standard-ins AMI-Struct over N;
  let I be Instruction of S;
  attr I is jump-only means
  InsCode I is jump-only;
end;

reserve ss for Element of product the Object-Kind of S;

definition
  let N,S; let l be Nat;
  let i be Element of the Instructions of S;
  func NIC(i,l) -> Subset of NAT equals
   { IC Exec(i,ss) : IC ss = l };
  coherence
  proof
    { IC Exec(i,ss) : IC ss = l } c= NAT
    proof
      let e be set;
      assume e in { IC Exec(i,ss) : IC ss = l };
      then ex ss st e = IC Exec(i,ss) & IC ss = l;
      hence thesis;
    end;
    hence thesis;
  end;
end;

Lm1: now
  let N;

  let S be realistic IC-Ins-separated definite
  (non empty stored-program
  AMI-Struct over N), i be Element of the Instructions of S, l be
  Element of NAT, s be State of S, f be FinPartState of S such that

A1: f = (IC S,l) --> (l,i);
  reconsider t = s +* f as Element of product the Object-Kind of S
   by PBOOLE:155;
A2: dom f = {IC S,l} by A1,FUNCT_4:65;
  then
A3:  l in dom f by TARSKI:def 2;
A4: (ProgramPart t)/.l = t.l by COMPOS_1:38
    .= f.l by A3,FUNCT_4:14
    .= i by A1,FUNCT_4:66;
  IC S in dom f by A2,TARSKI:def 2;
  then IC t = f.IC S by FUNCT_4:14
    .= l by A1,COMPOS_1:3,FUNCT_4:66;
  hence IC Following(ProgramPart(s+*f),s+*f) in NIC(i,l) by A4;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be realistic IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N), i be Element of the
  Instructions of S, l be Element of NAT;
  cluster NIC(i,l) -> non empty;
  coherence
  proof
    set s =the  State of S;
    reconsider f = (IC S,l) --> (l,i) as PartState of S by COMPOS_1:37;
    IC Following(ProgramPart(s+*f),s+*f) in NIC(i,l) by Lm1;
    hence thesis;
  end;
end;

definition
  let N,S,i;
  func JUMP i -> Subset of NAT equals
  meet { NIC(i,l) : not contradiction };
  coherence
  proof
    set X = { NIC(i,l) : not contradiction };
    X c= bool NAT
    proof
      let x be set;
      assume x in X;
      then ex l st x = NIC(i,l);
      hence thesis;
    end;
    then reconsider X as Subset-Family of NAT;
    meet X c= NAT;
    hence thesis;
  end;
end;

definition
  let N,S; let l be Nat;
  func SUCC(l,S) -> Subset of NAT equals
  union { NIC(i,l) \ JUMP i : not
  contradiction };
  coherence
  proof
    set X = { NIC(i,l) \ JUMP i : not contradiction };
    X c= bool NAT
    proof
      let x be set;
      assume x in X;
      then ex i st x = NIC(i,l) \ JUMP i;
      hence thesis;
    end;
    then reconsider X as Subset-Family of NAT;
    union X c= NAT;
    hence thesis;
  end;
end;

canceled;

theorem Th14:
  for i being Element of the Instructions of S
   st for l being Element of NAT holds NIC(i,l)={l}
  holds JUMP i is empty
proof
  let i be Element of the Instructions of S;
  set p = 0, q = 1;
  set X = { NIC(i, l) where l is Element of NAT: not contradiction};
  reconsider p,q as Element of NAT;
  assume
A1: for l being Element of NAT holds NIC(i,l)={l};
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {p} by A1;
  then {p} in X;
  then
A3: x in {p} by A2,SETFAM_1:def 1;
  NIC(i,q) = {q} by A1;
  then {q} in X;
  then x in {q} by A2,SETFAM_1:def 1;
  hence contradiction by A3,TARSKI:def 1;
end;

theorem Th15:
  for S being realistic IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N), il being Element of NAT,
   i being Instruction of S st i is halting holds NIC(i,il) = {il}
proof
  let S be realistic IC-Ins-separated definite
   (non empty stored-program
  AMI-Struct over N), il be Element of NAT, i be Instruction of S
  such that
A1: for s being State of S holds Exec(i,s) = s;
  hereby
    let n be set;
    assume n in NIC(i,il);
    then ex s being Element of product the Object-Kind of S
    st n = IC Exec(i,s) & IC s = il;
    then n = il by A1;
    hence n in {il} by TARSKI:def 1;
  end;
  reconsider f = (IC S,il) --> (il,i) as PartState of S  by COMPOS_1:37;
  set s =the  State of S;
  let n be set;
  assume
A2: n in {il};
  set a = s+*f;
A3: dom f = {IC S,il} by FUNCT_4:65;
  then IC S in dom f by TARSKI:def 2;
  then
A4: a.IC S = f.IC S by FUNCT_4:14
    .= il by COMPOS_1:3,FUNCT_4:66;
A5: il in dom f by A3,TARSKI:def 2;
  (ProgramPart a)/.IC a = a.IC a by COMPOS_1:38
    .= f.il by A4,A5,FUNCT_4:14
    .= i by FUNCT_4:66;
  then IC Following(ProgramPart a,a) = a.IC S by A1
    .= n by A2,A4,TARSKI:def 1;
  hence thesis by Lm1;
end;

begin :: Ordering of Instruction Locations

definition
 canceled 2;
  let N, S;
  attr S is standard means
  :Def10:
  for m, n being Element of NAT holds m <= n iff
   ex f being non empty FinSequence of NAT st f/.1 = m & f/.len f = n &
    for n st 1 <= n & n < len f holds f/.(n+1) in SUCC(f/.n,S);
end;

Lm2:
  ex f being non empty FinSequence of NAT st f/.1
= k & f/.len f = k & for n st 1 <= n & n < len f
 holds f/.(n+1) in SUCC(f/.n,S)
  proof
     reconsider l=k as Element of NAT;
     reconsider f = <*l*> as non empty FinSequence of NAT;
    take f;
    thus f/.1 = k by FINSEQ_4:25;
    hence thesis by FINSEQ_1:56;
  end;

canceled 3;

theorem Th19:
   S is standard iff
   for k being Element of NAT holds k+1 in SUCC(k,S) &
    for j being Element of NAT st j in SUCC(k,S) holds k <= j
proof
  hereby
    assume
A1:  S is standard;
    let k be Element of NAT;
    k <= k+1 by NAT_1:11;
    then consider F being non empty FinSequence of NAT such that
A2: F/.1 = k and
A3: F/.len F = k+1 and
A4: for n st 1 <= n & n < len F holds F/.(n+1) in SUCC(F/.n,S) by A1,Def10;
    set F1 = F -| (k+1);
    set x = (k+1)..F;
A5: k+1 in rng F by A3,REVROT_1:3;
    then
A6: len F1 = x-1 by FINSEQ_4:46;
    then
A7: len F1+1 = x;
A8: x in dom F by A5,FINSEQ_4:30;
    then
A9: F/.(len F1+1) = F.x by A6,PARTFUN1:def 8
      .= k+1 by A5,FINSEQ_4:29;
    x <= len F by A8,FINSEQ_3:27;
    then
A10: len F1 < len F by A7,NAT_1:13;
    1 <= len F by NAT_1:14;
    then
A11: 1 in dom F by FINSEQ_3:27;
    then
A12: F/.1 = F.1 by PARTFUN1:def 8;
A13: F.x = k+1 by A5,FINSEQ_4:29;
A14: k <> k+1;
    then
A15:  len F1 <> 0 by A2,A13,A11,A6,PARTFUN1:def 8;
    1 <= x by A8,FINSEQ_3:27;
    then 1 < x by A2,A14,A13,A12,XXREAL_0:1;
    then
A16: 1 <= len F1 by A7,NAT_1:13;
    reconsider F1 as non empty FinSequence of NAT by A15,A5,FINSEQ_4:53;
    set m = F/.len F1;
    reconsider m as Element of NAT;
A17: len F1 in dom F by A16,A10,FINSEQ_3:27;
A18: len F1 in dom F1 by A16,FINSEQ_3:27;
    then
A19: F1/.len F1 = F1.len F1 by PARTFUN1:def 8
      .= F.len F1 by A5,A18,FINSEQ_4:48
      .= F/.len F1 by A17,PARTFUN1:def 8;
A20: now
      (rng F1) misses {k+1} by A5,FINSEQ_4:50;
      then rng F1 /\ {k+1} = {} by XBOOLE_0:def 7;
      then
A21:  not k+1 in rng F1 or not k+1 in {k+1} by XBOOLE_0:def 4;
      assume
A22:  m = k+1;
A23:  len F1 in dom F1 by A16,FINSEQ_3:27;
      then F1/.len F1 = F1.len F1 by PARTFUN1:def 8;
      hence contradiction by A19,A22,A21,A23,FUNCT_1:def 5,TARSKI:def 1;
    end;
    reconsider F2 = <*F/.len F1, F/.x*> as non empty FinSequence of NAT;
A24: len F2 = 2 by FINSEQ_1:61;
    then
A25: 2 in dom F2 by FINSEQ_3:27;
    then
A26: F2/.len F2 = F2.2 by A24,PARTFUN1:def 8
      .= F/.x by FINSEQ_1:61
      .= k+1 by A13,A8,PARTFUN1:def 8;
A27: 1 in dom F2 by A24,FINSEQ_3:27;
A28: now
      let n;
      assume 1 <= n & n < len F2;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A29:  n = 1 by NAT_1:27;
      then
A30:  F2/.n = F2.1 by A27,PARTFUN1:def 8
        .= F/.len F1 by FINSEQ_1:61;
      F2/.(n+1) = F2.2 by A25,A29,PARTFUN1:def 8
        .= F/.(len F1+1) by A6,FINSEQ_1:61;
      hence F2/.(n+1) in SUCC(F2/.n,S) by A4,A16,A10,A30;
    end;
A31: now
      let n;
      assume that
A32:  1 <= n and
A33:  n < len F1;
A34:  1 <= n+1 by A32,NAT_1:13;
A35:  n+1 <= len F1 by A33,NAT_1:13;
      then n+1 <= len F by A10,XXREAL_0:2;
      then
A36:  n+1 in dom F by A34,FINSEQ_3:27;
      n <= len F by A10,A33,XXREAL_0:2;
      then
A37:  n in dom F by A32,FINSEQ_3:27;
A38:  n in dom F1 by A32,A33,FINSEQ_3:27;
      then
A39:  F1/.n = F1.n by PARTFUN1:def 8
        .= F.n by A5,A38,FINSEQ_4:48
        .= F/.n by A37,PARTFUN1:def 8;
A40:  n < len F by A10,A33,XXREAL_0:2;
A41:  n+1 in dom F1 by A34,A35,FINSEQ_3:27;
      then F1/.(n+1) = F1.(n+1) by PARTFUN1:def 8
        .= F.(n+1) by A5,A41,FINSEQ_4:48
        .= F/.(n+1) by A36,PARTFUN1:def 8;
      hence F1/.(n+1) in SUCC(F1/.n,S) by A4,A32,A39,A40;
    end;
    F2/.1 = F2.1 by A27,PARTFUN1:def 8
      .= m by FINSEQ_1:61;
    then
A42: m <= k+1 by A1,A26,A28,Def10;
A43: 1 in dom F1 by A16,FINSEQ_3:27;
    then F1/.1 = F1.1 by PARTFUN1:def 8
      .= F.1 by A5,A43,FINSEQ_4:48
      .= k by A2,A11,PARTFUN1:def 8;
    then k <= m by A1,A19,A31,Def10;
    then m = k or m = k+1 by A42,NAT_1:9;
    hence k+1 in SUCC(k,S) by A4,A16,A10,A9,A20;
    let j be Element of NAT;
    reconsider fk=k, fj=j as Element of NAT;
    reconsider F = <*fk, fj*> as non empty FinSequence of NAT;
A44: len F = 2 by FINSEQ_1:61;
    then
A45: 2 in dom F by FINSEQ_3:27;
A46: 1 in dom F by A44,FINSEQ_3:27;
    then
A47: F/.1 = F.1 by PARTFUN1:def 8
      .= k by FINSEQ_1:61;
    assume
A48: j in SUCC(k,S);
A49: now
      let n be Element of NAT;
      assume 1 <= n & n < len F;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A50:  n = 1 by NAT_1:27;
      then
A51:  F/.n = F.1 by A46,PARTFUN1:def 8
        .= k by FINSEQ_1:61;
      F/.(n+1) = F.2 by A45,A50,PARTFUN1:def 8
        .= j by FINSEQ_1:61;
      hence F/.(n+1) in SUCC(F/.n,S) by A48,A51;
    end;
    F/.len F = F.2 by A44,A45,PARTFUN1:def 8
      .= j by FINSEQ_1:61;
    hence k <= j by A1,A47,A49,Def10;
  end;
  assume
A52: for k being Element of NAT holds k+1 in SUCC(k,S) & for j
  being Element of NAT st j in SUCC(k,S) holds k <= j;
  thus S is standard
  proof
  let m, n be Element of NAT;
  thus m <= n implies ex f being non empty FinSequence of NAT st f/.1
= m & f/.len f = n &
 for k st 1 <= k & k < len f holds f/.(k+1) in SUCC(f/.k,S)
  proof
    assume
A53: m <= n;
    per cases by A53,XXREAL_0:1;
    suppose
      m = n;
    hence ex f being non empty FinSequence of NAT st f/.1
= m & f/.len f = n & for n st 1 <= n & n < len f
 holds f/.(n+1) in SUCC(f/.n,S) by Lm2;
    end;
    suppose
A54:  m < n;
      thus ex f being non empty FinSequence of NAT st f/.1
= m & f/.len f = n & for n st 1 <= n & n < len f
 holds f/.(n+1) in SUCC(f/.n,S)
      proof
        set mn = n -' m;
        deffunc F(Nat) = m+$1-'1;
        consider F being FinSequence of NAT such that
A55:    len F = mn+1 and
A56:    for j being Nat st j in dom F holds F.j = F(j) from FINSEQ_2:
        sch 1;
        reconsider F as non empty FinSequence of NAT by A55;
        take F;
A57:    1 <= mn+1 by NAT_1:11;
        then
A58:    1 in dom F by A55,FINSEQ_3:27;
        hence F/.1 = F.1 by PARTFUN1:def 8
          .= m+1-'1 by A56,A58
          .= m by NAT_D:34;
        m+1 <= n by A54,INT_1:20;
        then 1 <= n-m by XREAL_1:21;
        then 0 <= n-m by XXREAL_0:2;
        then
A59:    mn = n - m by XREAL_0:def 2;
A60:    len F in dom F by A55,A57,FINSEQ_3:27;
        hence F/.len F = F.len F by PARTFUN1:def 8
          .= m+(mn+1)-'1 by A55,A56,A60
          .= m+mn+1-'1
          .= n by A59,NAT_D:34;
        let p be Element of NAT;
        assume that
A61:    1 <= p and
A62:    p < len F;
A63:    p in dom F by A61,A62,FINSEQ_3:27;
        then
A64:    F/.p = F.p by PARTFUN1:def 8
          .= m+p-'1 by A56,A63;
A65:    p <= m+p by NAT_1:11;
        1 <= p+1 & p+1 <= len F by A61,A62,NAT_1:13;
        then
A66:    p+1 in dom F by FINSEQ_3:27;
        then F/.(p+1) = F.(p+1) by PARTFUN1:def 8
          .= m+(p+1)-'1 by A56,A66
          .= m+p+1-'1
          .= m+p-'1+1 by A61,A65,NAT_D:38,XXREAL_0:2;
        hence thesis by A52,A64;
      end;
    end;
  end;
  given F being non empty FinSequence of NAT such that
A67: F/.1 = m and
A68: F/.len F = n and
A69: for n being Element of NAT st 1 <= n & n < len F holds F/.(n+1) in
  SUCC(F/.n,S);
  defpred P[Element of NAT] means 1 <= $1 & $1 <= len F implies ex l being
  Element of NAT st F/.$1 = l & m <= l;
A70: now
    let k be Element of NAT such that
A71: P[k];
    now
      assume that
      1 <= k+1 and
A72:  k+1 <= len F;
      per cases by NAT_1:3;
      suppose
        k = 0;
        hence ex l being Element of NAT st F/.(k+1) = l & m <= l by A67;
      end;
      suppose
A73:    k > 0;
        set l1 = F/.(k+1);
        consider l being Element of NAT such that
A74:    F/.k = l and
A75:    m <= l by A71,A72,A73,NAT_1:13,14;
        reconsider l1 as Element of NAT;
        k < len F by A72,NAT_1:13;
        then F/.(k+1) in SUCC(F/.k,S) by A69,A73,NAT_1:14;
        then l <= l1 by A52,A74;
        hence
        ex l being Element of NAT st F/.(k+1) = l & m <= l by A75,XXREAL_0:2;
      end;
    end;
    hence P[k+1];
  end;
A76: 1 <= len F by NAT_1:14;
A77: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A77, A70);
  then ex l being Element of NAT st F/.len F = l & m <= l by A76;
  hence thesis by A68;
 end;
end;

Lm3: for a,b being set holds dom ((NAT --> a)+*(NAT .-->b)) = NAT \/ {NAT}
proof
  let a,b be set;

  thus dom ((NAT --> a)+*(NAT .-->b)) = dom (NAT --> a) \/ dom (NAT .-->b) by
FUNCT_4:def 1

    .= NAT \/ dom (NAT .-->b) by FUNCOP_1:19
    .= NAT \/ {NAT} by FUNCOP_1:19;
end;
set III = {[1,0,0],[0,0,0]};

begin :: Standard trivial computer

definition
  let N be with_non-empty_elements set;
  func STC N -> strict AMI-Struct over N means
  :Def11:
  the carrier of it = NAT \/ {NAT} & the ZeroF of it = NAT &
  the Instructions of it = {[0,0,0],[1,0,0]} &
  the haltF of it = [0,0,0] &
  the Object-Kind of it = (NAT --> {[1,0,0],[0,0,0]}) +* (NAT .-->NAT) &
  ex f being Function of product the Object-Kind of it,
                         product the Object-Kind of it st
  (for s being Element of product the Object-Kind of it holds
   f.s = s+*(NAT .-->succ(s.NAT))) &
  the Execution of it = ([1,0,0] .--> f) +*
    ([0,0,0] .--> id product the Object-Kind of it);
  existence
  proof
    set O = NAT \/ {NAT};
    NAT in {NAT} by TARSKI:def 1;
    then reconsider IC1 = NAT as Element of O by XBOOLE_0:def 3;
A1:  0 in NAT* by FINSEQ_1:66;
    0 in ((union N) \/ O)* by FINSEQ_1:66;
    then [1,0,0] in [:NAT, NAT*, ((union N) \/ O)*:] &
    [0,0,0] in [:NAT, NAT*, ((union N) \/ O)*:] by A1,MCART_1:73;
    then reconsider
    ins = III as non empty Subset of [:NAT, NAT*, ((union N) \/ O)*:]
       by ZFMISC_1:38;
    reconsider i = [0,0,0] as Element of ins by TARSKI:def 2;
A2: dom ((NAT --> ins)+*(NAT .-->NAT)) = O by Lm3;
    {ins}\/{NAT}= {ins, NAT} by ENUMSET1:41;
    then
A3: {ins}\/{NAT} c= N \/ {ins, NAT} by XBOOLE_1:7;
    rng (NAT --> ins) = {ins} & rng (NAT .-->NAT) = {NAT} by FUNCOP_1:14;
    then rng ((NAT --> ins)+*(NAT .-->NAT)) c= {ins}\/{NAT} by FUNCT_4:18;
    then rng ((NAT --> ins)+*(NAT .-->NAT)) c= N \/ {ins, NAT} by A3,XBOOLE_1:1
;
    then reconsider
    Ok = (NAT --> ins)+*(NAT .-->NAT) as Function of O, N \/ {ins,
    NAT} by A2,FUNCT_2:def 1,RELSET_1:11;
    deffunc F(Element of product Ok) = $1+*(NAT .-->succ($1.NAT));
A4: now
      let s be Element of product Ok;
      now
        thus dom (s+*(NAT .-->succ(s.NAT))) = dom s \/ dom (NAT .-->succ(s.NAT
        )) by FUNCT_4:def 1
          .= dom s \/ {NAT} by FUNCOP_1:19
          .= NAT \/ {NAT} \/ {NAT} by PARTFUN1:def 4
          .= dom Ok by A2,XBOOLE_1:7,12;
        let o be set;
A5:     dom (NAT .-->succ(s.NAT)) = {NAT} by FUNCOP_1:19;
        assume
A6:     o in dom Ok;
        then
A7:     o in NAT or o in {NAT} by XBOOLE_0:def 3;
        per cases by A7,TARSKI:def 1;
        suppose
          o in NAT;
          then not o in {NAT} by TARSKI:def 1;
          then (s+*(NAT .-->succ(s.NAT))).o = s.o by A5,FUNCT_4:12;
          hence (s+*(NAT .-->succ(s.NAT))).o in Ok.o by A6,CARD_3:18;
        end;
        suppose
A8:       o = NAT;
A9:       NAT in {NAT} by TARSKI:def 1;
          dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
          then NAT in dom (NAT .-->NAT) by TARSKI:def 1;
          then
A10:       Ok.o = (NAT .-->NAT).NAT by A8,FUNCT_4:14
            .= NAT by A9,FUNCOP_1:13;
A11:      o in {NAT} by A8,TARSKI:def 1;
          then
A12:      (s+*(NAT .-->succ(s.NAT))).o = (NAT .-->succ(s.NAT)).o by A5,
FUNCT_4:14
            .= succ(s.NAT) by A11,FUNCOP_1:13;
          NAT in {NAT} by TARSKI:def 1;
          then NAT in dom Ok by A2,XBOOLE_0:def 3;
          then reconsider k = s.NAT as Element of NAT by A8,A10,CARD_3:18;
          succ k in NAT;
          hence (s+*(NAT .-->succ(s.NAT))).o in Ok.o by A10,A12;
        end;
      end;
      hence F(s) in product Ok by CARD_3:18;
    end;
    consider f being Function of product Ok, product Ok such that
A13: for s being Element of product Ok holds f.s= F(s) from FUNCT_2:
    sch 8 (A4);
    set E = ([1,0,0] .--> f) +* ([0,0,0] .--> id product Ok);
A14: dom E = dom ([1,0,0] .--> f) \/ dom ([0,0,0] .--> id product Ok) by
FUNCT_4:def 1
      .= {[1,0,0]} \/ dom ([0,0,0] .--> id product Ok) by FUNCOP_1:19
      .= {[1,0,0]} \/ {[0,0,0]} by FUNCOP_1:19
      .= ins by ENUMSET1:41;
A15: rng ([1,0,0] .--> f) c= {f} & rng ([0,0,0] .--> id product Ok) c= {id
    product Ok } by FUNCOP_1:19;
A16: rng E c= rng ([1,0,0] .--> f) \/ rng ([0,0,0] .--> id product Ok) by
FUNCT_4:18;
    rng E c= Funcs(product Ok, product Ok)
    proof
      let e be set;
      assume e in rng E;
      then e in rng ([1,0,0] .--> f) or
      e in rng ([0,0,0] .--> id product Ok) by A16,XBOOLE_0:def 3;
      then e = f or e = id product Ok by A15,TARSKI:def 1;
      hence thesis by FUNCT_2:12;
    end;
    then reconsider
    E as Function of ins, Funcs(product Ok, product Ok) by A14,FUNCT_2:def 1
,RELSET_1:11;
    set M = AMI-Struct(# O, IC1, ins, i, Ok, E#);
    take M qua strict AMI-Struct over N;
    thus the carrier of M = NAT \/ {NAT};
    thus the ZeroF of M = NAT;
    thus the Instructions of M = {[0,0,0],[1,0,0]};
    thus  the haltF of M = [0,0,0];
    thus the Object-Kind of M = (NAT-->III)+*(NAT .-->NAT);
    reconsider f as Function of product the Object-Kind of M, product the
    Object-Kind of M;
    take f;
    thus for s being Element of product the Object-Kind of M holds f.s = s+*(
    NAT .-->succ(s.NAT)) by A13;
    thus thesis;
  end;
  uniqueness
  proof
    let it1, it2 be strict AMI-Struct over N such that
A17: the carrier of it1 = NAT \/ {NAT} & the ZeroF of
    it1 = NAT & the Instructions of it1 = {[0,0,0],[1,0,0]} &
    the haltF of it1 = [0,0,0]
    and
A18: the Object-Kind of it1 = (NAT --> III)+*(NAT .-->NAT);
    given f1 being Function of product the Object-Kind of it1, product the
    Object-Kind of it1 such that
A19: for s being Element of product the Object-Kind of it1 holds f1.s
    = s+* (NAT .-->succ(s.NAT)) and
A20: the Execution of it1 = ([1,0,0] .--> f1) +* ([0,0,0] .--> id product
    the Object-Kind of it1);
    assume that
A21: the carrier of it2 = NAT \/ {NAT} & the ZeroF of
    it2 = NAT & the Instructions of it2 = {[0,0,0],[1,0,0]}  &
    the haltF of it2 = [0,0,0]
and
A22: the Object-Kind of it2 = (NAT --> III)+*(NAT .-->NAT);
    given f2 being Function of product the Object-Kind of it2, product the
    Object-Kind of it2 such that
A23: for s being Element of product the Object-Kind of it2 holds f2.s
    = s+* (NAT .-->succ(s.NAT)) and
A24: the Execution of it2 = ([1,0,0] .--> f2) +* ([0,0,0] .--> id product
    the Object-Kind of it2);
    now
      let c be Element of product the Object-Kind of it1;
      thus f1.c = c+*(NAT .-->succ(c.NAT)) by A19
        .= f2.c by A18,A22,A23;
    end;
    hence thesis by A17,A18,A20,A21,A22,A24,FUNCT_2:113;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> infinite;
  coherence
  proof
    NAT \/ {NAT} is not finite by FINSET_1:13,XBOOLE_1:7;
    hence the carrier of STC N is infinite by Def11;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> non empty stored-program standard-ins;
  coherence
  proof
    thus the carrier of STC N is non empty;
    the carrier of STC N = NAT \/ {NAT} by Def11;
    hence NAT c= the carrier of STC N by XBOOLE_1:7;
A1: the Instructions of STC N = {[0,0,0],[1,0,0]} by Def11;
    take X=(union N) \/ the carrier of STC N;
A2:   0 in X* by FINSEQ_1:66;
     0 in NAT* by FINSEQ_1:66;
     then [0,0,0] in [:NAT,NAT*,X*:] & [1,0,0] in [:NAT,NAT*,X*:]
      by A2,MCART_1:73;
   hence the Instructions of STC N c= [:NAT,NAT*,X*:] by A1,ZFMISC_1:38;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> IC-Ins-separated definite realistic;
  coherence
  proof
    set IT = STC N;
    set Ok = the Object-Kind of IT;
A1: NAT in {NAT} by TARSKI:def 1;
    dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
    then
A2: NAT in dom (NAT .-->NAT) by TARSKI:def 1;
    Ok.NAT = ((NAT --> III)+*(NAT .-->NAT)).NAT by Def11
      .= (NAT .-->NAT).NAT by A2,FUNCT_4:14
      .= NAT by A1,FUNCOP_1:13;
    then ObjectKind IC IT = NAT by Def11;
    hence STC N is IC-Ins-separated by COMPOS_1:def 6;
A3: the Instructions of IT = III by Def11;
    thus STC N is definite
    proof
      let l be Element of NAT;
      dom (NAT .-->NAT) = {NAT} by FUNCOP_1:19;
      then
A4:   not l in dom (NAT .-->NAT) by TARSKI:def 1;
      thus (the Object-Kind of STC N).l = ((NAT --> III)+*(NAT .-->NAT)).l
                by Def11
        .= (NAT --> III).l by A4,FUNCT_4:12
        .= the Instructions of IT by A3,FUNCOP_1:13;
    end;
    thus not the ZeroF of IT in NAT by Def11;
  end;
end;

Lm4: for i being Instruction of STC N, s being State of STC N st InsCode i = 1
holds Exec(i,s).IC STC N = succ (IC s)

proof
  let i be Instruction of STC N, s be State of STC N;
  set M = STC N;
  assume
A1: InsCode i = 1;
A2: now
    assume i in {[0,0,0]};
    then i = [0,0,0] by TARSKI:def 1;
    hence contradiction by A1,RECDEF_2:def 1;
  end;
  the Instructions of M = III by Def11;
  then i = [1,0,0] or i = [0,0,0] by TARSKI:def 2;
  then
A3: i in {[1,0,0]} by A1,RECDEF_2:def 1,TARSKI:def 1;
A4: NAT in {NAT} by TARSKI:def 1;
  then
A5: NAT in dom (NAT .-->succ(s.NAT)) by FUNCOP_1:19;

  consider f be Function of product the Object-Kind of M, product the
  Object-Kind of M such that
A6: for s being Element of product the Object-Kind of M holds f.s = s+*(
  NAT .-->succ(s.NAT)) and

A7: the Execution of M = ([1,0,0] .--> f) +* ([0,0,0] .--> id product the
  Object-Kind of M) by Def11;
A8: for s being State of M holds f.s = s+*(NAT .-->succ(s.NAT))
 proof let s be State of M;
  reconsider s as Element of product the Object-Kind of M by PBOOLE:155;
  f.s = s+*(NAT .-->succ(s.NAT)) by A6;
  hence thesis;
 end;

A9: the ZeroF of M = NAT by Def11;

  dom ([0,0,0] .--> id product the Object-Kind of M) = {[0,0,0]}
   by FUNCOP_1:19;

  then (the Execution of M).i = ([1,0,0] .--> f).i by A7,A2,FUNCT_4:12
    .= f by A3,FUNCOP_1:13;
  hence Exec(i,s).IC STC N = (s+*(NAT .-->succ(s.NAT))).NAT by A9,A8
    .= (NAT .-->succ(s.NAT)).NAT by A5,FUNCT_4:14
    .= succ (IC s) by A9,A4,FUNCOP_1:13;
end;

theorem Th20:
  for i being Instruction of STC N st InsCode i = 0 holds i is
  halting
proof
  let i be Instruction of STC N;
  set M = STC N;
  the Instructions of M = III by Def11;
  then
A1: i = [1,0,0] or i = [0,0,0] by TARSKI:def 2;
  assume InsCode i = 0;
  then
A2: i in {[0,0,0]} by A1,RECDEF_2:def 1,TARSKI:def 1;
  let s be State of M;
  reconsider s as Element of product the Object-Kind of M by PBOOLE:155;
  (ex f be Function of product the Object-Kind of M, product the
Object-Kind of M st ( for s being Element of product the Object-Kind of M holds
f.s = s+*(NAT .-->succ(s.NAT)))&
   the Execution of M = ([1,0,0] .--> f) +* ([0,0,0]
  .--> id product the Object-Kind of M) )& dom ([0,0,0] .--> id product the
  Object-Kind of M) = {[0,0,0]} by Def11,FUNCOP_1:19;
  then
  (the Execution of M).i = ({[0,0,0]} --> id product the Object-Kind of M).i
  by A2,FUNCT_4:14
    .= id product the Object-Kind of M by A2,FUNCOP_1:13;
   then (the Execution of M).i.s = s by FUNCT_1:35;
  hence thesis;
end;

theorem
  for i being Instruction of STC N st InsCode i = 1 holds i is non
  halting
proof
  let i be Instruction of STC N;
  set M = STC N;
  set s =the  State of M;
  assume InsCode i = 1;
  then
A1: Exec(i,s).IC M = succ (IC s) by Lm4;
  assume for s being State of M holds Exec(i,s) = s;
  then Exec(i,s).IC M = IC s;
  hence thesis by A1;
end;

theorem Th22:
  for i being Element of the Instructions of STC N holds InsCode i
  = 1 or InsCode i = 0
proof
  let i be Element of the Instructions of STC N;
  the Instructions of STC N = III by Def11;
  then i = [1,0,0] or i = [0,0,0] by TARSKI:def 2;
  hence thesis by RECDEF_2:def 1;
end;

theorem
  for i being Instruction of STC N holds i is jump-only
proof
  let i be Instruction of STC N;
  set M = STC N;
  let s be State of M, o be Object of M, I be Instruction of M such that
  InsCode I = InsCode i and
A1: o in Data-Locations M;
A2: the ZeroF of M = NAT by Def11;
  Data-Locations M = (NAT \/ {NAT}) \ ({NAT} \/ NAT) by A2,Def11
       .= {} by XBOOLE_1:37;
   hence thesis by A1;
end;

registration let N;
 cluster -> ins-loc-free Instruction of STC N;
 coherence
  proof let I be Instruction of STC N;
    I in the Instructions of STC N;
    then I in {[0,0,0],[1,0,0]} by Def11;
    then I = [0,0,0] or I = [1,0,0] by TARSKI:def 2;
   hence JumpPart I is empty by RECDEF_2:def 2;
  end;
end;

Lm5: for l being Element of NAT, i being Element of the
Instructions of STC N st l = z & InsCode i = 1 holds NIC(i, l) = {z+1}

proof

  let l be Element of NAT, i be Element of the Instructions of
  STC N;

  assume that
A1: l = z and
A2: InsCode i = 1;
  set M = STC N;
  set F = { IC Exec(i,ss)
   where ss is Element of product the Object-Kind of STC N: IC ss = l};
  now
    set f = (NAT) --> i;
    set w =the  State of M;
    reconsider l9 = l as Element of ObjectKind IC M by COMPOS_1:def 6;
    set u = (IC M).-->l9;
A3: dom u = {IC M} by FUNCOP_1:19;
    reconsider s = w +* f as State of M;
    let y be set;
A4: dom f = NAT by FUNCOP_1:19;
    reconsider t = s+*u as Element of product the Object-Kind of STC N
     by PBOOLE:155;
    l <> IC M by COMPOS_1:3;
    then
A5:    not l in dom u by A3,TARSKI:def 1;
A6: (ProgramPart t)/.l = t.l by COMPOS_1:38
      .= s.l by A5,FUNCT_4:12
      .= f.l by A4,FUNCT_4:14
      .= i by FUNCOP_1:13;
    hereby
      assume y in F;

      then ex s being Element of product the Object-Kind of STC N
      st y = IC Exec(i,s) & IC s = l;

      then y = succ z by A1,A2,Lm4
        .= z+1;
      hence y in {z+1} by TARSKI:def 1;
    end;
    assume y in {z+1};
    then
A7: y = succ z by TARSKI:def 1;
    IC M in dom u by A3,TARSKI:def 1;
    then
A8: IC t = u.IC M by FUNCT_4:14
      .= z by A1,FUNCOP_1:87;
    then IC Following(ProgramPart t,t) = succ z by A1,A2,A6,Lm4;
    hence y in F by A1,A7,A8,A6;
  end;
  hence thesis by TARSKI:2;
end;

Lm6: for i being Element of the Instructions of STC N holds JUMP i is empty
proof
  let i be Element of the Instructions of STC N;
  per cases by Th22;
  suppose
A1: InsCode i = 1;
    reconsider l1 = 0, l2 = 1 as Element of NAT;

    set X = { NIC(i,l) where l is Element of NAT : not
    contradiction };

    assume not thesis;
    then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
    NIC(i, l1) in X;
    then {0+1} in X by A1,Lm5;
    then x in {1} by A2,SETFAM_1:def 1;
    then
A3: x = 1 by TARSKI:def 1;
    NIC(i, l2) in X;
    then {1+1} in X by A1,Lm5;
    then x in {2} by A2,SETFAM_1:def 1;
    hence contradiction by A3,TARSKI:def 1;
  end;
  suppose
A4: InsCode i = 0;
    reconsider i as Instruction of STC N;

    for l being Element of NAT holds NIC(i,l)={l} by A4,Th15,Th20;

    hence thesis by Th14;
  end;
end;

theorem Th24:
  for l being Element of NAT st l = z holds SUCC(l,STC N)
  = {z, z+1}
proof
  let l be Element of NAT such that
A1: l = z;
  set M = STC N;
  set K = { NIC(i,l) \ JUMP i where i is Element of the Instructions of STC N
  : not contradiction };
  now
    let y be set;
    hereby
      assume y in K;
      then consider ii being Element of the Instructions of STC N such that
A2:   y = NIC(ii,l) \ JUMP ii and
      not contradiction;
      reconsider ii as Instruction of STC N;
      now
        per cases by Th22;
        suppose
A3:       InsCode ii = 1;
          JUMP ii = {} by Lm6;
          then y = {z+1} by A1,A2,A3,Lm5;
          hence y in {{z},{z+1}} by TARSKI:def 2;
        end;
        suppose
A4:       InsCode ii = 0;
          JUMP ii = {} by Lm6;
          then y = {z} by A1,A2,A4,Th15,Th20;
          hence y in {{z},{z+1}} by TARSKI:def 2;
        end;
      end;
      hence y in {{z},{z+1}};
    end;
    assume
A5: y in {{z},{z+1}};
    per cases by A5,TARSKI:def 2;
    suppose
A6:   y = {z};
      reconsider i = [0,0,0] as Instruction of M by Def11;
      JUMP i = {} & InsCode i = 0 by Lm6,RECDEF_2:def 1;
      then NIC(i,l) \ JUMP i = y by A1,A6,Th15,Th20;
      hence y in K;
    end;
    suppose
A7:   y = {z+1};
      set i = [1,0,0];
      i in III by TARSKI:def 2;
      then reconsider i as Instruction of M by Def11;
      JUMP i = {} & InsCode i = 1 by Lm6,RECDEF_2:def 1;
      then NIC(i,l) \ JUMP i = y by A1,A7,Lm5;
      hence y in K;
    end;
  end;
  then K = {{z},{z+1}} by TARSKI:2;
  hence thesis by ZFMISC_1:32;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> standard;
  coherence
  proof
    set M = STC N;
    now
      let k be Element of NAT;
A1:   SUCC(k,STC N) = {k,k+1} by Th24;
      thus k+1 in SUCC(k,STC N) by A1,TARSKI:def 2;
      let j be Element of NAT;
      assume j in SUCC(k,STC N);
      then j = k or j = k+1 by A1,TARSKI:def 2;
      hence k <= j by NAT_1:11;
    end;
    hence thesis by Th19;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> halting;
  coherence
  proof
    set I = the haltF of STC N;
    I = [0,0,0] by Def11;
    then InsCode I = 0 by RECDEF_2:def 1;
    hence I is halting by Th20;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard halting realistic
standard-ins (IC-Ins-separated definite (non empty stored-program AMI-Struct
    over N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

reserve T for standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));

canceled 13;

theorem
  for i being Instruction of STC N, s being State of STC N st InsCode i
  = 1 holds Exec(i,s).IC STC N = succ IC s by Lm4;

theorem
  for l being Element of NAT, i being Element of the
  Instructions of STC N st InsCode i = 1 holds NIC(i, l) = {succ l} by Lm5;

theorem
  for l being Element of NAT holds SUCC(l,STC N) = {l, succ l} by Th24;

definition
 canceled 4;
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N),
  i be Instruction of S;
  attr i is sequential means
  for s being State of S holds Exec(i, s).IC S = succ IC s;
end;

theorem Th41:
  for S being realistic (IC-Ins-separated definite
   (non
empty stored-program AMI-Struct over N)), il being Element of NAT,
  i being Instruction of S st i is sequential holds NIC(i,il)
   = {succ il}
proof
  let S be realistic (IC-Ins-separated definite
   (non empty
  stored-program AMI-Struct over N)), il be Element of NAT, i be
  Instruction of S such that
A1: for s being State of S holds Exec(i, s).IC S = succ IC s;
  now
    let x be set;
A2: now
      reconsider il1 = il as Element of ObjectKind IC S by COMPOS_1:def 6;
      reconsider I = i as Element of (the Object-Kind of S).il by
COMPOS_1:def 8;
      set t =the  State of S;
      assume
A3:   x = succ il;
      reconsider f = (IC S,il) --> (il1,I) as PartState of S by COMPOS_1:37;
      reconsider u = t+*f as
       Element of product the Object-Kind of S by PBOOLE:155;
A4:   dom ((IC S, il)-->(il1, I)) = {IC S, il} by FUNCT_4:65;
      then
A5:     il in dom ((IC S, il)-->(il1, I)) by TARSKI:def 2;
A6:   (ProgramPart u)/.il = u.il by COMPOS_1:38
        .= ((IC S, il)-->(il1, I)).il by A5,FUNCT_4:14
        .= i by FUNCT_4:66;
      IC S in dom ((IC S, il)-->(il1, I)) by A4,TARSKI:def 2;
      then
A7:   IC u = ((IC S, il)-->(il1, I)).IC S by FUNCT_4:14
        .= il by COMPOS_1:3,FUNCT_4:66;
      then IC Following(ProgramPart u,u) = succ il by A1,A6;
      hence x in {IC Exec(i,ss)
       where ss is Element of product the Object-Kind of S
        : IC ss = il} by A3,A7,A6;
    end;
    now
      assume x in {IC Exec(i,ss)
       where ss is Element of product the Object-Kind of S : IC ss = il};
      then ex s being Element of product the Object-Kind of S
       st x = IC Exec(i,s) & IC s = il;
      hence x = succ il by A1;
    end;
    hence
    x in {succ il} iff x in {IC Exec(i,ss)
       where ss is Element of product the Object-Kind of S
     : IC ss = il } by A2,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let N;
  let S be realistic IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
  cluster sequential -> non halting Instruction of S;
  coherence
proof
  let i be Instruction of S such that
A1: i is sequential;
  set s =the  State of S;
  NIC(i,IC s) = {succ IC s} by A1,Th41;
  then NIC(i,IC s) <> {IC s} by ORDINAL1:14,ZFMISC_1:6;
  hence thesis by Th15;
end;
  cluster halting -> non sequential Instruction of S;
  coherence;
end;

canceled;

theorem
 for T being IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N)
  for i being Instruction of T st JUMP i is non empty holds i is non
  sequential
proof
 let T be IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let i be Instruction of T;
  set X = { NIC(i,l1) where l1 is Element of NAT: not contradiction
  };
  assume JUMP i is non empty;
  then consider l being set such that
A1: l in JUMP i by XBOOLE_0:def 1;
  reconsider l as Element of NAT by A1;
  NIC(i,l) in X;
  then l in NIC(i,l) by A1,SETFAM_1:def 1;
  then consider s being Element of product the Object-Kind of T
  such that
A2: l = IC Exec(i,s) & IC s = l;
  take s;
  thus thesis by A2;
end;

begin :: Closedness of finite partial states

definition

  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let F be NAT-defined (the Instructions of S)-valued FinPartState of S;
  attr F is closed means
  :Def17:
  for l being Element of NAT st l in dom F holds NIC (F/.l, l) c= dom F;
  attr F is really-closed means
  for s being State of S st IC s in dom F
   for k being Element of NAT holds IC Comput(F,s,k) in dom F;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));
  let F be NAT-defined (the Instructions of S)-valued Function;
  attr F is para-closed means
  for s being State of S st IC s = 0
   for k being Element of NAT holds IC Comput(F,s,k) in dom F;
end;

theorem Th44:
  for S being standard (IC-Ins-separated
definite (non empty stored-program AMI-Struct over N)),
   F being NAT-defined (the Instructions of S)-valued
  FinPartState of S st F is really-closed & 0 in dom F holds F is
  para-closed
proof
  let S be standard (IC-Ins-separated definite (non empty
stored-program AMI-Struct over N)),
      F be NAT-defined (the Instructions of S)-valued
FinPartState of S such
  that
A1: ( for s being State of S st IC s in dom F for k being
  Element of NAT holds IC Comput(F,s,k) in dom F)& 0 in dom F;
  let s be State of S;
  assume IC s = 0;
  hence thesis by A1;
end;

theorem Th45:
  for S being IC-Ins-separated definite
  (non
empty stored-program AMI-Struct over N),
  F being NAT-defined (the Instructions of S)-valued FinPartState of
  S st F is closed holds F is really-closed
proof
  let S be IC-Ins-separated definite
   (non empty
  stored-program AMI-Struct over N),
  F be NAT-defined (the Instructions of S)-valued FinPartState of S such
  that
A1: F is closed;
  let s be State of S such that
A2: IC s in dom F;
  defpred P[Element of NAT] means IC Comput(F,s,$1) in dom F;
A3: now
    let k be Element of NAT such that
A4: P[k];
    reconsider t = Comput(F,s,k)
     as Element of product the Object-Kind of S by PBOOLE:155;
    set l = IC Comput(F,s,k);
A5: IC Following(F,t) in NIC(F/.l,l);
A6: Comput(F,s,k+1) = Following(F,t) by EXTPRO_1:4;
    NIC(F/.l, l) c= dom F by A1,A4,Def17;
    hence P[k+1] by A5,A6;
  end;
A7: P[0] by A2,EXTPRO_1:3;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A7,A3);
end;

registration

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  cluster closed -> really-closed
   (NAT-defined (the Instructions of S)-valued FinPartState of S);
  coherence by Th45;
end;

theorem Th46:
  for S being standard realistic halting (IC-Ins-separated
definite
 (non empty stored-program AMI-Struct over N)) holds 0 .-->
  halt S qua NAT-defined (the Instructions of S)-valued
   FinPartState of S is closed
proof
  let S be standard realistic halting (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
  reconsider F = 0 .--> halt S as
   NAT-defined (the Instructions of S)-valued FinPartState of S;
  let l be Element of NAT;
  assume
A1: l in dom(0 .--> halt S);
A2: dom F = {0} by FUNCOP_1:19;
  then
A3: l = 0 by A1,TARSKI:def 1;
  F/.l = F.l by A1,PARTFUN1:def 8
    .= halt S by A3,FUNCOP_1:87;
  hence thesis by A2,A3,Th15;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard
  (IC-Ins-separated definite (non empty stored-program AMI-Struct over N));
  cluster really-closed initial non empty -> para-closed (NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  coherence
  proof
    let F be NAT-defined (the Instructions of S)-valued FinPartState of S;
    assume
A1: F is really-closed;
    assume F is initial non empty;
    then 0 in dom F by AFINSQ_1:69;
    hence thesis by A1,Th44;
  end;
end;

Lm7: now
  let N;
  let S be standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N));
  set F = <%halt S%>;
A1: dom F = {0} by FUNCOP_1:19;
  then
A2: card dom F = 1 by CARD_1:50;
A3: LastLoc F = card F -' 1 by AFINSQ_1:74
    .= card dom F -' 1
    .= 0 by A2,XREAL_1:234;
  hence F.(LastLoc F) = halt S by FUNCOP_1:87;
  let l be Element of NAT such that
  F.l = halt S;
  assume l in dom F;
  hence l = LastLoc F by A1,A3,TARSKI:def 1;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting realistic (IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N));
  cluster trivial closed initial non empty
  (NAT-defined (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus thesis by Th46;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting realistic (IC-Ins-separated definite
    (non empty
  stored-program AMI-Struct over N));
  cluster halt-ending unique-halt trivial closed (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis by Th46;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard realistic halting (IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N));
  cluster closed pre-Macro of S;
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    FinPartState of S;
    F.(LastLoc F) = halt S & for l being Element of NAT st F.l
    = halt S & l in dom F holds l = LastLoc F by Lm7;
    then reconsider F as pre-Macro of S by COMPOS_1:def 25;
    take F;
    thus thesis by Th46;
  end;
end;

canceled 9;

theorem
  for i being Instruction of Trivial-AMI(N) holds i is halting
proof
  let i be Instruction of Trivial-AMI(N);
  set M = Trivial-AMI(N);
A1: the Instructions of M = {[0,{},{}]} by EXTPRO_1:def 1;
  let s be State of M;
  reconsider s as Element of product the Object-Kind of M by PBOOLE:155;
  the Object-Kind of M = (NAT --> {[0,{},{}]}) +* (NAT .--> NAT)
   by EXTPRO_1:def 1;
  then
  (the Execution of M).i = ([0,{},{}] .--> id product the Object-Kind of M).i
  by EXTPRO_1:def 1
    .= id product the Object-Kind of M by A1,FUNCOP_1:13;
  then (the Execution of M).i.s = s by FUNCT_1:35;
  hence thesis;
end;

theorem
  for i being Element of the Instructions of Trivial-AMI(N) holds
  InsCode i = 0
proof
  let i be Element of the Instructions of Trivial-AMI(N);
  the Instructions of Trivial-AMI(N) = {[0,{},{}]} by EXTPRO_1:def 1;
  then i = [0,{},{}] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 1;
end;

begin :: Addenda

:: from SCMPDS_9, 2008.03.10, A.T.

theorem
  for N being with_non-empty_elements non empty set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over N),
 i being Instruction of S, l being Element of NAT
 holds JUMP(i) c= NIC(i,l)
proof
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N), i be Instruction of S, l be
  Element of NAT;
  set X = { NIC(i,k) where k is Element of NAT: not contradiction };
  let x be set;
A1: NIC(i,l) in X;
  assume x in JUMP(i);
  hence thesis by A1,SETFAM_1:def 1;
end;

theorem
 for i being Instruction of STC N, s being State of STC N st InsCode i = 1
  holds Exec(i,s) = IncIC(s,1)
proof
  let i be Instruction of STC N, s be State of STC N;
  set M = STC N;
  assume
A1: InsCode i = 1;
A2: now
    assume i in {[0,0,0]};
    then i = [0,0,0] by TARSKI:def 1;
    hence contradiction by A1,RECDEF_2:def 1;
  end;
  the Instructions of M = III by Def11;
  then i = [1,0,0] or i = [0,0,0] by TARSKI:def 2;
  then
A3: i in {[1,0,0]} by A1,RECDEF_2:def 1,TARSKI:def 1;
  consider f be Function of product the Object-Kind of M, product the
  Object-Kind of M such that
A4: for s being Element of product the Object-Kind of M
   holds f.s = s+*(NAT .-->succ(s.NAT)) and
A5: the Execution of M = ([1,0,0] .--> f) +* ([0,0,0] .--> id product the
  Object-Kind of M) by Def11;
A6: for s being State of M holds f.s = s+*(NAT .-->succ(s.NAT))
 proof let s be State of M;
  reconsider s as Element of product the Object-Kind of M by PBOOLE:155;
  f.s = s+*(NAT .-->succ(s.NAT)) by A4;
  hence thesis;
 end;
A7: the ZeroF of M = NAT by Def11;
A8: Start-At(IC s+1,M) = NAT .--> (IC s + 1) by Def11
      .= NAT .-->succ(s.NAT) by A7,NAT_1:39;
  dom ([0,0,0] .--> id product the Object-Kind of M) = {[0,0,0]}
   by FUNCOP_1:19;
  then (the Execution of M).i = ([1,0,0] .--> f).i by A5,A2,FUNCT_4:12
    .= f by A3,FUNCOP_1:13;
  hence Exec(i,s) = s +* (NAT .-->succ(s.NAT)) by A6
    .= s +* Start-At(IC s+1,M) by A8
    .= IncIC(s,1);
end;

registration let N; let p be PartState of STC N;
 cluster DataPart p -> empty;
 coherence
  proof
   Data-Locations STC N = (the carrier of STC N) \ ({IC STC N} \/ NAT)
     .= (the carrier of STC N) \ ({NAT} \/ NAT) by Def11
     .= ({NAT} \/ NAT) \ ({NAT} \/ NAT) by Def11
     .= {} by XBOOLE_1:37;
  hence thesis;
  end;
end;
