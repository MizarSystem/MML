:: On the compositions of macro instructions, Part II
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies FUNCT_1, RELAT_1, FUNCT_4, BOOLE, AMI_1, SCMFSA_2, SCMFSA6A,
      AMI_3, CAT_1, SCM_1, INT_1, FUNCT_7, SF_MASTR, AMI_5, FINSEQ_1, RELOC,
      CARD_1, SCMFSA6B, CARD_3, ARYTM, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, FUNCT_7, INT_1, RELAT_1, FUNCT_1, FINSEQ_1, FUNCOP_1,
      FUNCT_4, VALUED_1,
      STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5,
      SCMFSA6A, SF_MASTR;
 constructors DOMAIN_1, XXREAL_0, NAT_1, PARTFUN1, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMNORM, SCMFSA_4, RELSET_1, SCMFSA_1;
 registrations SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2, SCMFSA6A, SF_MASTR,
      XBOOLE_0, SCMNORM, FINSET_1, VALUED_1, AMI_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, SCMFSA_2, SCMFSA6A, SCMNORM, AMI_1;
 theorems RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, SCMFSA_3, INT_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_4, AMI_1, SCMFSA_2, FSM_1, LATTICE2, SCMFSA_5,
      GRFUNC_1, CARD_3, SCMFSA6A, SF_MASTR, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, XXREAL_0, VALUED_1, SCMNORM;
 schemes NAT_1, SCMFSA6A;

begin

reserve m, n for Element of NAT,
  x for set,
  i for Instruction of SCM+FSA,
  I
  for Program of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location,
  l, l1 for
  Instruction-Location of SCM+FSA,
  s,s1,s2 for State of SCM+FSA;

canceled 3;

theorem
  Start-At insloc 0 c= Initialized I by FUNCT_4:26;

theorem Th5:
  I +* Start-At insloc n c= s implies I c= s
proof
  dom I misses dom Start-At insloc n by SF_MASTR:64;
  then
A1: I +* Start-At insloc n = I \/ Start-At insloc n by FUNCT_4:32;
  assume
  I +* Start-At insloc n c= s;
  hence thesis by A1,XBOOLE_1:11;
end;

Lm1: now
  assume
  IC SCM+FSA in NAT;

  then reconsider l = IC SCM+FSA as Instruction-Location of SCM+FSA by
  AMI_1:def
  4;

  l = IC SCM+FSA;
  hence contradiction by AMI_1:48;
end;

theorem Th6:
  (I +* Start-At insloc n)|NAT = I
proof
  NAT misses dom Start-At insloc n
  proof
    assume
    not thesis;
    then
A1: ex x being set st x in NAT & x in dom Start-At insloc n by
    XBOOLE_0:
    3;
    dom Start-At insloc n = {IC SCM+FSA} by FUNCOP_1:19;
    hence contradiction by A1,Lm1,TARSKI:def 1;
  end;
  then dom I c= NAT & (I +* Start-At insloc n)|NAT = I | NAT by
  FUNCT_4:76 ,
  RELAT_1:def 18;
  hence thesis by RELAT_1:97;
end;

theorem Th7:
  x in dom I implies I.x = (I +* Start-At insloc n).x
proof
A1: dom I c= NAT by RELAT_1:def 18;
  assume
  x in dom I;
  then dom Start-At insloc n = {IC SCM+FSA} & x <> IC SCM+FSA by A1,Lm1,
  FUNCOP_1:19;
  then not x in dom Start-At insloc n by TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem Th8:
  Initialized I c= s implies I +* Start-At insloc 0 c= s
proof
  assume
A1: Initialized I c= s;
  I c= Initialized I by SCMFSA6A:26;
  then
A2: I c= s by A1,XBOOLE_1:1;
  dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then
A3: I +* Start-At insloc 0 = I \/ Start-At insloc 0 by FUNCT_4:32;
  Start-At(insloc 0) c= Initialized I by FUNCT_4:26;
  then Start-At(insloc 0) c= s by A1,XBOOLE_1:1;
  hence thesis by A2,A3,XBOOLE_1:8;
end;

theorem Th9:
  not a in dom Start-At l
proof
A1: dom Start-At l = {IC SCM+FSA} by FUNCOP_1:19;
  assume
  a in dom Start-At l;
  then a = IC SCM+FSA by A1,TARSKI:def 1;
  hence contradiction by SCMFSA_2:81;
end;

theorem Th10:
  not f in dom Start-At l
proof
A1: dom Start-At l = {IC SCM+FSA} by FUNCOP_1:19;
  assume
  f in dom Start-At l;
  then f = IC SCM+FSA by A1,TARSKI:def 1;
  hence contradiction by SCMFSA_2:82;
end;

canceled;

theorem Th12:
  not a in dom (I+*Start-At l)
proof
  assume
  a in dom (I+*Start-At l);
  then a in dom I \/ dom Start-At l by FUNCT_4:def 1;
  then
A1: a in dom I or a in dom Start-At l by XBOOLE_0:def 3;
  dom I c= NAT & a in Int-Locations by RELAT_1:def 18,SCMFSA_2:9;
  hence contradiction by A1,Th9,SCMFSA_2:13,XBOOLE_0:3;
end;

theorem Th13:
  not f in dom (I+*Start-At l)
proof
  assume
  f in dom (I+*Start-At l);
  then f in dom I \/ dom Start-At l by FUNCT_4:def 1;
  then
A1: f in dom I or f in dom Start-At l by XBOOLE_0:def 3;
  dom I c= NAT & f in FinSeq-Locations by RELAT_1:def 18,SCMFSA_2:10;
  hence contradiction by A1,Th10,SCMFSA_2:14,XBOOLE_0:3;
end;

theorem Th14:
  s+*I+*Start-At insloc 0 = s+*Start-At insloc 0+*I
proof
A1: dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then I+*Start-At insloc 0 = I \/ Start-At insloc 0 by FUNCT_4:32
    .= Start-At insloc 0 +* I by A1,FUNCT_4:32;
  hence s+*I+*Start-At insloc 0 = s+*(Start-At insloc 0+*I) by FUNCT_4:15
    .= s+*Start-At insloc 0+*I by FUNCT_4:15;
end;

begin ::  General theory

reserve N for with_non-empty_elements set;

definition
  let s be State of SCM+FSA, li be Int-Location, k be Integer;
  redefine func s+*(li,k) -> State of SCM+FSA;
  coherence
  proof
A1: dom s = dom the Object-Kind of SCM+FSA by CARD_3:18;
A2: now
      let x be set;
      assume
A3:   x in dom the Object-Kind of SCM+FSA;
      per cases;
      suppose
A4:     x = li;
        then
A5:     (the Object-Kind of SCM+FSA).x = ObjectKind li
          .= INT by SCMFSA_2:26;
        (s+*(li,k)).x = k by A1,A3,A4,FUNCT_7:33;
        hence (s+*(li,k)).x in (the Object-Kind of SCM+FSA).x by A5,INT_1:
        def 2;
      end;
      suppose
        x <> li;
        then (s+*(li,k)).x = s.x by FUNCT_7:34;
        hence (s+*(li,k)).x in (the Object-Kind of SCM+FSA).x by A3, CARD_3:
        18;
      end;
    end;
    dom(s+*(li,k)) = dom s by FUNCT_7:32;
    hence thesis by A1,A2,CARD_3:18;
  end;
end;

begin

definition
  let I be Program of SCM+FSA, s be State of SCM+FSA;
  func IExec(I,s) -> State of SCM+FSA equals
  Result(s+*Initialized I) +* s|NAT;
  coherence by CARD_3:96;
end;

definition
  let I be Program of SCM+FSA;
  attr I is paraclosed means
  :Def2:
  for s being State of SCM+FSA, n being
Element of NAT st I +* Start-At insloc 0 c= s holds IC Computation(s,n) in dom
  I;
  attr I is parahalting means
  :Def3:
  I +* Start-At insloc 0 is halting;
  attr I is keeping_0 means
  :Def4:
  for s being State of SCM+FSA st I +*
Start-At insloc 0 c= s for k being Element of NAT holds Computation(s,k).intloc
  0 = s.intloc 0;
end;

Lm2: Macro halt SCM+FSA is parahalting
proof
  let s;
  set m = Macro halt SCM+FSA;
  set m1 = m +* Start-At insloc 0;
  assume
A1: m1 c= s;
A2: dom(Start-At insloc 0) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A3: IC SCM+FSA in dom (Start-At insloc 0) by TARSKI:def 1;
  then
A4: IC SCM+FSA in dom m1 by FUNCT_4:13;
  then
A5: IC m1 = m1.IC SCM+FSA by AMI_1:def 43
    .= (Start-At insloc 0).IC SCM+FSA by A3,FUNCT_4:14
    .= insloc 0 by FUNCOP_1:87;
A6: dom m = {insloc 0,insloc 1} by FUNCT_4:65;
  now
    assume
    dom m /\ dom (Start-At insloc 0) is non empty;
    then consider x being set such that
A7: x in dom m /\ dom (Start-At insloc 0) by XBOOLE_0:def 1;
    x in dom (Start-At insloc 0) by A7,XBOOLE_0:def 4;
    then
A8: x=IC SCM+FSA by A2,TARSKI:def 1;
    x in dom m by A7,XBOOLE_0:def 4;
    then x=insloc 0 or x=insloc 1 by A6,TARSKI:def 2;
    hence contradiction by A8,AMI_1:48;
  end;
  then dom m misses dom (Start-At insloc 0) by XBOOLE_0:def 7;
  then
A9: m.insloc 0 = halt SCM+FSA & m c= m1 by FUNCT_4:33,66;
  take 0;
  dom m = {insloc 0,insloc 1} by FUNCT_4:65;
  then
A10: insloc 0 in dom m by TARSKI:def 2;
  then
A11: insloc 0 in dom m1 by FUNCT_4:13;
  IC Computation(s,0) in NAT by AMI_1:def 4;
 hence IC Computation(s,0) in dom ProgramPart s by AMI_1:143;
  CurInstr Computation(s,0) = CurInstr s by AMI_1:13
    .= s.IC m1 by A1,A4,AMI_1:97
    .= m1.insloc 0 by A1,A11,A5,GRFUNC_1:8
    .= halt SCM+FSA by A9,A10,GRFUNC_1:8;
 hence (ProgramPart s).IC Computation(s,0) = halt SCM+FSA by AMI_1:145;
end;

registration
  cluster parahalting Program of SCM+FSA;
  existence by Lm2;
end;

canceled 3;

theorem Th18:
  for I being parahalting Program of SCM+FSA st I +* Start-At
  insloc 0 c= s holds ProgramPart s halts_on s
proof
  let I be parahalting Program of SCM+FSA;
  assume
A1: I +* Start-At insloc 0 c= s;
  I +* Start-At insloc 0 is halting by Def3;
  hence thesis by A1,AMI_1:def 26;
end;

theorem Th19:
  for I being parahalting Program of SCM+FSA st Initialized I c= s
  holds ProgramPart s halts_on s
proof
  let I be parahalting Program of SCM+FSA;
A1: I +* Start-At insloc 0 is halting by Def3;
  Start-At insloc 0 c= Initialized I & I c= Initialized I by FUNCT_4:26 ,
  SCMFSA6A:26;
  then
  I +* Start-At insloc 0 c= I \/ Start-At insloc 0 & I \/ Start-At insloc
  0 c= Initialized I by FUNCT_4:30,XBOOLE_1:8;
  then
A2: I +* Start-At insloc 0 c= Initialized I by XBOOLE_1:1;
  assume
  Initialized I c= s;
  then I +* Start-At insloc 0 c= s by A2,XBOOLE_1:1;
  hence thesis by A1,AMI_1:def 26;
end;

registration
  let I be parahalting Program of SCM+FSA;
  cluster Initialized I -> halting;
  coherence
  proof
    let s be State of SCM+FSA;
    assume
    Initialized I c= s;
    hence thesis by Th19;
  end;
end;

theorem Th20:
  not ProgramPart(s2 +*(IC s2, goto IC s2)) halts_on s2 +*(IC s2, goto IC s2)
proof
  set s1 = s2 +*(IC s2, goto IC s2);
  defpred X[Element of NAT] means IC Computation(s1,$1) = IC s1;
  IC SCM+FSA <> IC s2 by AMI_1:48;
  then
A1: IC s1 = IC s2 by FUNCT_7:34;
A2: IC s2 in dom s2 by AMI_1:115;
A3: now
    let n;
    assume
    X[n];
    then
A4: CurInstr Computation(s1,n) = s1.IC s1 by AMI_1:54
      .= goto IC s2 by A2,A1,FUNCT_7:33;
    IC Computation(s1,n+1) = IC Following Computation(s1,n) by AMI_1:14
      .= IC s1 by A1,A4,SCMFSA_2:95;
    hence X[n+1];
  end;
  let n;
A5: X[0] by AMI_1:13;
 assume IC Computation(s1,n) in dom ProgramPart s1;
  for n holds X[n] from NAT_1:sch 1(A5,A3);
  then CurInstr Computation(s1,n) = Computation(s1,n).IC s1
    .= s1.IC s1 by AMI_1:54
    .= goto IC s2 by A2,A1,FUNCT_7:33;
  then CurInstr Computation(s1,n) <> halt SCM+FSA by SCMFSA_2:47,124;
  hence thesis by SCMFSA_2:47,124,AMI_1:145;
end;

theorem Th21:
  s1,s2 equal_outside NAT & I c= s1 & I c= s2 & (for m st m < n
holds IC Computation(s2,m) in dom I) implies for m st m <= n holds Computation(
  s1,m), Computation(s2,m) equal_outside NAT
proof
  assume that
A1: s1,s2 equal_outside NAT and
A2: I c= s1 and
A3: I c= s2 and
A4: for m st m < n holds IC Computation(s2,m) in dom I;
  defpred X[Element of NAT] means $1 <= n implies Computation(s1,$1),
  Computation(s2,$1) equal_outside NAT;
A5: for m st X[m] holds X[m+1]
  proof
    let m such that
A6: X[m];
A7: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m), Computation(s2,m));
A8: Computation(s1,m+1) = Following( Computation(s1,m)) by AMI_1:14
      .= Exec(CurInstr( Computation(s1,m)), Computation(s1,m));
    assume
A9: m+1 <= n;
    then
A10: IC ( Computation(s1,m)) = IC Computation(s2,m) by A6,AMI_1:121 ,
    NAT_1:13;
    m < n by A9,NAT_1:13;
    then
A11: IC Computation(s2,m) in dom I by A4;
    CurInstr( Computation(s1,m)) = s1.IC( Computation(s1,m)) by AMI_1:54
      .= I.IC( Computation(s1,m)) by A2,A11,A10,GRFUNC_1:8
      .= s2.IC Computation(s2,m) by A3,A11,A10,GRFUNC_1:8
      .= CurInstr Computation(s2,m) by AMI_1:54;
    hence thesis by A6,A8,A7,A9,NAT_1:13,SCMFSA6A:32;
  end;
  Computation(s1,0) = s1 by AMI_1:13;
  then
A12: X[0] by A1,AMI_1:13;
  thus for m holds X[m] from NAT_1:sch 1(A12,A5);
end;

registration
  cluster parahalting -> paraclosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    set IAt = I +* Start-At insloc 0;
    dom I misses dom Start-At insloc 0 by SF_MASTR:64;
    then
A1: I c= IAt by FUNCT_4:33;
    assume
    I is parahalting;
    then
A2: IAt is halting by Def3;
    let s be State of SCM+FSA, n be Element of NAT;
    defpred X[Nat] means not IC Computation(s,$1) in dom I;
    assume
A3: I +* Start-At insloc 0 c= s;
    then
A4: I c= s by A1,XBOOLE_1:1;
    assume
    not IC Computation(s,n) in dom I;
    then
A5: ex n be Nat st X[n];
    consider n be Nat such that
A6: X[n] and
A7: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A5);
    reconsider n as Element of NAT by ORDINAL1:def 13;
A8: for m st m < n holds IC Computation(s,m) in dom I by A7;
    set s2 = Computation(s,n), s0 = s +*(IC s2, goto IC s2), s1 = s2 +*(IC s2,
    goto IC s2);
A9: s|NAT = s2|NAT by AMI_1:123;
A10: Computation(s0,n)|NAT = s0|NAT by AMI_1:123
      .= s1|NAT by A9,FUNCT_7:95;
A11: IC s2 in NAT by AMI_1:def 4;
    then
A12: s0,s equal_outside NAT by FUNCT_7:28,93;
A13: s2,s1 equal_outside NAT by A11,FUNCT_7:93;
    (IAt)|NAT = I by Th6;
    then dom I = dom(IAt)/\NAT by RELAT_1:90;
    then not IC s2 in dom IAt by A6,A11,XBOOLE_0:def 4;
    then
A14: IAt c= s0 by A3,FUNCT_7:91;
    then I c= s0 by A1,XBOOLE_1:1;
    then Computation(s0,n),s2 equal_outside NAT by A12,A4,A8,Th21;
    then
A15: Computation(s0,n) = s1 by A13,A10,FUNCT_7:29,92;
A16: not ProgramPart s1 halts_on s1 by Th20;
    ProgramPart s0 halts_on s0 by A2,A14,AMI_1:def 26;
    then ProgramPart s0 halts_on Computation(s0,n) by A15,A16,AMI_1:93;
    hence contradiction by A15,A16,AMI_1:93,144;
  end;
  cluster keeping_0 -> paraclosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A17: I is keeping_0;
    set FI = FirstNotUsed(I);
    let s be State of SCM+FSA, n be Element of NAT;
    assume
A18: I +* Start-At insloc 0 c= s;
    defpred X[Nat] means not IC Computation(s,$1) in dom I;
    assume
    not IC Computation(s,n) in dom I;
    then
A19: ex n be Nat st X[n];
    consider n be Nat such that
A20: X[n] and
A21: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A19);
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set s2 = Computation(s,n);
    reconsider s00 = s +*(IC s2, intloc 0 := FI) as State of SCM+FSA;
    reconsider s0 = s00+* (FI, (s.intloc 0)+1) as State of SCM+FSA;
A22: dom I c= NAT by RELAT_1:def 18;
    not I is keeping_0
    proof
A23:  not IC s2 in UsedInt*Loc I
      proof
        assume
        not thesis;
        then IC s2 is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:85;
      end;
      not FI in UsedInt*Loc I
      proof
        assume
        not thesis;
        then FI is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:83;
      end;
      then
A24:  s0 | UsedInt*Loc I = s00 | UsedInt*Loc I by FUNCT_7:94
        .= s | UsedInt*Loc I by A23,FUNCT_7:94;
A25:  now
        assume
A26:    FI in dom I;
        then reconsider FI as Instruction-Location of SCM+FSA by A22,AMI_1:def
        4;
        FI in dom I by A26;
        hence contradiction by SCMFSA_2:84;
      end;
A27:  (s.intloc 0) < (s.intloc 0)+1 by XREAL_1:31;
A28:  IC s2 in dom s by AMI_1:116;
      IC s2 <> FI by SCMFSA_2:84;
      then
A29:  s0.IC s2 = s00.IC s2 by FUNCT_7:34
        .= intloc 0 := FI by A28,FUNCT_7:33;
A30:  s0.intloc 0 = s00.intloc 0 by FUNCT_7:34
        .= s.intloc 0 by FUNCT_7:34,SCMFSA_2:84;
      FI in dom s00 by SCMFSA_2:66;
      then
A31:  s0.FI = (s.intloc 0)+1 by FUNCT_7:33;
      set s02 = Computation(s0,n);
      set IS = I +* Start-At insloc 0;
      take s0;
A32:  dom IS = dom I \/ dom Start-At insloc 0 by FUNCT_4:def 1
        .= dom I \/ {IC SCM+FSA} by FUNCOP_1:19;
      IC s2 <> IC SCM+FSA by AMI_1:48;
      then not IC s2 in {IC SCM+FSA} by TARSKI:def 1;
      then not IC s2 in dom IS by A20,A32,XBOOLE_0:def 3;
      then
A33:  IS c= s00 by A18,FUNCT_7:91;
      FI <> IC SCM+FSA by SCMFSA_2:81;
      then not FI in {IC SCM+FSA} by TARSKI:def 1;
      then
A34:  not FI in dom IS by A32,A25,XBOOLE_0:def 3;
      hence
A35:  I +* Start-At insloc 0 c= s0 by A33,FUNCT_7:91;
      take k = n+1;
A36:  not IC s2 in UsedIntLoc I
      proof
        assume
        not thesis;
        then IC s2 is Int-Location by SCMFSA_2:11;
        hence contradiction by SCMFSA_2:84;
      end;
A37:  s0 | UsedIntLoc I = s00 | UsedIntLoc I by FUNCT_7:94,SF_MASTR:54
        .= s | UsedIntLoc I by A36,FUNCT_7:94;
A38:  for m st m < n holds IC Computation(s,m) in dom I by A21;
      then
A39:  IC s02 = IC s2 by A18,A35,A37,A24,SF_MASTR:73;
      ( not FI in UsedIntLoc I)& for m st m < n holds IC Computation(s0,m
      ) in dom I by A18,A35,A38,A37,A24,SF_MASTR:54,73;
      then
A40:  s02.FI = (s.intloc 0)+1 by A33,A34,A31,FUNCT_7:91,SF_MASTR:69;
      Computation(s0,k) = Following s02 by AMI_1:14
        .= Exec(intloc 0 := FI, s02) by A39,A29,AMI_1:54;
      hence thesis by A40,A30,A27,SCMFSA_2:89;
    end;
    hence contradiction by A17;
  end;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a
proof
  let I be parahalting Program of SCM+FSA, a be read-write Int-Location;
  assume
A1: not a in UsedIntLoc I;
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I by Th19,FUNCT_4:26;
  then consider n such that
A2: Result(s+*Initialized I) = Computation(s+*Initialized I,n) and
  CurInstr(Result(s+*Initialized I)) = halt SCM+FSA by AMI_1:def 22;
A3: not a in dom Initialized I by SCMFSA6A:48;
  not a is Instruction-Location of SCM+FSA by SCMFSA_2:84;
  then not a in NAT by AMI_1:def 4;
  then not a in dom (s|NAT) by RELAT_1:86;
  then
A4: (IExec(I, s)).a = (Result(s+*Initialized I)).a by FUNCT_4:12;
A5: I+*Start-At insloc 0 c= s+*Initialized I by Th8,FUNCT_4:26;
  then for m st m < n holds IC Computation(s+*Initialized I,m) in dom I by
  Def2;
  hence (IExec(I, s)).a = (s+*Initialized I).a by A1,A4,A2,A5,SF_MASTR:69
    .= s.a by A3,FUNCT_4:12;
end;

theorem
  for I being parahalting Program of SCM+FSA holds not f in UsedInt*Loc
  I implies (IExec(I, s)).f = s.f
proof
  let I be parahalting Program of SCM+FSA;
  assume
A1: not f in UsedInt*Loc I;
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I by Th19,FUNCT_4:26;
  then consider n such that
A2: Result(s+*Initialized I) = Computation(s+*Initialized I,n) and
  CurInstr(Result(s+*Initialized I)) = halt SCM+FSA by AMI_1:def 22;
A3: not f in dom Initialized I by SCMFSA6A:49;
  not f is Instruction-Location of SCM+FSA by SCMFSA_2:85;
  then not f in NAT by AMI_1:def 4;
  then not f in dom (s|NAT) by RELAT_1:86;
  then
A4: (IExec(I, s)).f = (Result(s+*Initialized I)).f by FUNCT_4:12;
A5: I+*Start-At insloc 0 c= s+*Initialized I by Th8,FUNCT_4:26;
  then for m st m < n holds IC Computation(s+*Initialized I,m) in dom I by
  Def2;
  hence (IExec(I, s)).f = (s+*Initialized I).f by A1,A4,A2,A5,SF_MASTR:71
    .= s.f by A3,FUNCT_4:12;
end;

theorem Th24:
  IC s = l & s.l = goto l implies not ProgramPart s halts_on s
proof
  set S = s;
  assume that
A1: IC S = l and
A2: S.l = goto l;
  defpred X[Element of NAT] means Computation(S,$1) = S;
A3: for m st X[m] holds X[m+1]
  proof
    let m;
A4: ( for f being FinSeq-Location holds Exec(goto l,S).f = S.f)& for i
being Instruction-Location of SCM+FSA holds Exec(goto l,S).i = S.i by AMI_1:def
    13 ,SCMFSA_2:95;
A5: IC Exec(goto l,S) = IC S & for a being Int-Location holds Exec(goto l,
    S).a = S.a by A1,SCMFSA_2:95;
    assume
    Computation(S,m) = S;
    hence Computation(S,m+1) = Following S by AMI_1:14
      .= S by A1,A2,A5,A4,SCMFSA_2:86;
  end;
  let m;
A6: X[0] by AMI_1:13;
A7: for m holds X[m] from NAT_1:sch 1(A6,A3);
 assume IC Computation(s,m) in dom ProgramPart s;
  CurInstr S = goto l by A1,A2;
  then
X:  CurInstr( Computation(S,m)) = goto l by A7;
  InsCode (goto l) = 6 by SCMFSA_2:47;
  then CurInstr( Computation(S,m)) <> halt SCM+FSA by X,SCMFSA_2:124;
  hence (ProgramPart s).IC Computation(s,m) <> halt SCM+FSA
   by SCMFSA_2:47,124,X,AMI_1:145;
end;

registration
  cluster parahalting -> non empty Program of SCM+FSA;
  coherence
  proof
    deffunc W(set) = <*>INT;
    deffunc V(set) = 1;
    deffunc U(set) = goto insloc 0;
    let I be Program of SCM+FSA such that
A1: I is parahalting and
A2: I is empty;
    reconsider I as parahalting Program of SCM+FSA by A1;
    consider S be State of SCM+FSA such that
A3: IC S = insloc 0 and
A4: for i being Element of NAT holds S.insloc i = U(i) & S.intloc i =
    V(i) & S.fsloc i = W(i) from SCMFSA6A:sch 1;
    intloc 0 in dom S & S.intloc 0 = 1 by A4,SCMFSA_2:66;
    then
A5: (intloc 0) .--> 1 c= S by FUNCOP_1:88;
    IC SCM+FSA in dom S by AMI_1:94;
    then
A6: IC SCM+FSA .--> insloc 0 c= S by A3,FUNCOP_1:88;
    I c= S by A2,XBOOLE_1:2;
    then I +* ((intloc 0) .--> 1) c= S by A5,FUNCT_4:92;
    then Initialized I c= S by A6,FUNCT_4:92;
    then
A7: ProgramPart S halts_on S by AMI_1:def 26;
    S.insloc 0 = goto insloc 0 by A4;
    hence contradiction by A3,A7,Th24;
  end;
end;

theorem
  for I being parahalting Program of SCM+FSA holds dom I <> {};

theorem Th26:
  for I being parahalting Program of SCM+FSA holds insloc 0 in dom
  I
proof
  let I be parahalting Program of SCM+FSA;
  consider x being set such that
A1: x in dom I by XBOOLE_0:def 1;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider x as Instruction-Location of SCM+FSA by A1,AMI_1:def 4;
  reconsider n = x as Element of NAT by ORDINAL1:def 13;
  per cases;
  suppose
    n = 0;
    hence thesis by A1;
  end;
  suppose
    0 < n;
    hence thesis by A1,SCMNORM:def 1;
  end;
end;

theorem Th27:
  for J being parahalting Program of SCM+FSA st J +* Start-At
insloc 0 c= s1 for n being Element of NAT st ProgramPart Relocated(J,n) c= s2 &
  IC s2 = insloc n & DataPart s1 = DataPart s2 for i being Element of NAT holds
  IC Computation(s1,i) + n = IC Computation(s2,i) & IncAddr(CurInstr (
Computation(s1,i)),n) = CurInstr ( Computation(s2,i)) & DataPart Computation(s1
  ,i) = DataPart Computation(s2,i)
proof
  let J be parahalting Program of SCM+FSA;
  assume
A1: J +* Start-At insloc 0 c= s1;
  set JAt = J +* Start-At insloc 0;
A2: insloc 0 in dom J by Th26;
  dom J misses dom Start-At insloc 0 by SF_MASTR:64;
  then
A3: J c= JAt by FUNCT_4:33;
  then
A4: dom J c= dom JAt by GRFUNC_1:8;
A5: IC SCM+FSA in dom JAt by SF_MASTR:65;
  then
A6: s1.IC s1 = s1.(JAt.IC SCM+FSA) by A1,GRFUNC_1:8
    .= s1.insloc 0 by SF_MASTR:66
    .= JAt.insloc 0 by A1,A4,A2,GRFUNC_1:8
    .= J.insloc 0 by A3,A2,GRFUNC_1:8;
A7: IC Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
    .= JAt.IC SCM+FSA by A1,A5,GRFUNC_1:8
    .= insloc 0 by SF_MASTR:66;
  ProgramPart J = J by AMI_1:105;
  then
A8: insloc 0 in dom ProgramPart J by Th26;
  let n be Element of NAT;
  assume that
A9: ProgramPart Relocated(J,n) c= s2 and
A10: IC s2 = insloc n and
A11: DataPart s1 = DataPart s2;
A12: DataPart Computation(s1,0) = DataPart s2 by A11,AMI_1:13
    .= DataPart Computation(s2,0) by AMI_1:13;
  defpred P[Element of NAT] means IC Computation(s1,$1) + n = IC Computation(
s2,$1) & IncAddr(CurInstr ( Computation(s1,$1)),n) = CurInstr ( Computation(s2,
  $1)) & DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
A13: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    dom J misses dom Start-At insloc 0 by SF_MASTR:64;
    then
A14: J c= JAt by FUNCT_4:33;
    then
A15: dom J c= dom JAt by GRFUNC_1:8;
    let k be Element of NAT;
A16: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr Computation(s1,k), Computation(s1,k));
    reconsider l = IC Computation(s1,k+1) as Element of NAT by ORDINAL1:def 13;
    reconsider j = CurInstr Computation(s1,k+1) as Instruction of SCM+FSA;
A17: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr Computation(s2,k), Computation(s2,k));
A18: IC Computation(s1,k+1) in dom J by A1,Def2;
    assume
A19: P[k];
    hence
A20: IC Computation(s1,k+1) + n = IC Computation(s2,k+1) by A16,
    A17,SCMFSA6A:41;
    then IC Computation(s2,k+1) in NAT & IC Computation(s2,k+1) in dom
    Relocated(J,n) by A18,AMI_1:def 4,SCMFSA_5:4;
    then IC Computation(s2,k+1) in dom Relocated(J,n) /\ NAT by XBOOLE_0:
    def 4;
    then
A21: IC Computation(s2,k+1) in dom ProgramPart Relocated(J,n) by
    RELAT_1:90;
    dom ProgramPart J = dom J /\ NAT by RELAT_1:90;
    then
A22: l in dom ProgramPart J by A18,XBOOLE_0:def 4;
    j = s1.IC Computation(s1,k+1) by AMI_1:54
      .= JAt.IC Computation(s1,k+1) by A1,A15,A18,GRFUNC_1:8
      .= J.l by A14,A18,GRFUNC_1:8;
    hence IncAddr(CurInstr Computation(s1,k+1),n) = Relocated(J,n).(l + n) by
    A22,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).(IC Computation(s2,k+1)) by A20,
    FUNCT_1:72
      .= s2.IC Computation(s2,k+1) by A9,A21,GRFUNC_1:8
      .= CurInstr Computation(s2,k+1) by AMI_1:54;
    thus thesis by A19,A16,A17,SCMFSA6A:41;
  end;
  let i be Element of NAT;
  insloc 0 in dom J by Th26;
  then insloc 0 + n in dom Relocated(J,n) by SCMFSA_5:4;
  then
A23: insloc (0 + n) in dom ProgramPart Relocated(J,n) by AMI_1:106;
  IncAddr(CurInstr ( Computation(s1,0)),n) = IncAddr(CurInstr s1,n) by
  AMI_1:13
    .= Relocated(J,n).(insloc 0 + n) by A6,A8,SCMFSA_5:7
    .= (ProgramPart Relocated(J,n)).insloc n by FUNCT_1:72
    .= CurInstr s2 by A9,A10,A23,GRFUNC_1:8
    .= CurInstr ( Computation(s2,0)) by AMI_1:13;
  then
A24: P[0] by A10,A7,A12,AMI_1:13;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A24,A13);
  hence thesis;
end;

theorem Th28:
  for I being parahalting Program of SCM+FSA st I +* Start-At
  insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 & s1,s2 equal_outside NAT holds
  for k being Element of NAT holds Computation(s1,k), Computation(s2,k)
  equal_outside NAT & CurInstr Computation(s1,k) = CurInstr Computation(s2,k)
proof
  let I be parahalting Program of SCM+FSA;
  assume that
A1: I +* Start-At insloc 0 c= s1 and
A2: I +* Start-At insloc 0 c= s2 and
A3: s1,s2 equal_outside NAT;
A4: I c= s2 by A2,Th5;
A5: I c= s1 by A1,Th5;
  hereby
    let k be Element of NAT;
A6: IC Computation(s1,k) in dom I by A1,Def2;
A7: IC Computation(s2,k) in dom I by A2,Def2;
    for m being Element of NAT st m < k holds IC Computation(s2,m) in dom
    I by A2,Def2;
    hence Computation(s1,k), Computation(s2,k) equal_outside NAT by A3,A5,
    A4,Th21;
    then
A8: IC Computation(s1,k) = IC Computation(s2,k) by AMI_1:121;
    thus CurInstr Computation(s2,k) = s2.IC Computation(s2,k) by AMI_1:54
      .= I.IC Computation(s2,k) by A4,A7,GRFUNC_1:8
      .= s1.IC Computation(s1,k) by A5,A8,A6,GRFUNC_1:8
      .= CurInstr Computation(s1,k) by AMI_1:54;
  end;
end;

theorem Th29:
  for I being parahalting Program of SCM+FSA st I +* Start-At
  insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 & s1,s2 equal_outside NAT holds
  LifeSpan s1 = LifeSpan s2 & Result s1, Result s2 equal_outside NAT
proof
  let I be parahalting Program of SCM+FSA;
  assume that
A1: I +* Start-At insloc 0 c= s1 and
A2: I +* Start-At insloc 0 c= s2 and
A3: s1,s2 equal_outside NAT;
A4: ProgramPart s2 halts_on s2 by A2,Th18;
A5: ProgramPart s1 halts_on s1 by A1,Th18;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr Computation(s2,l) = halt SCM+FSA;
    CurInstr Computation(s1,l) = CurInstr Computation(s2,l) by A1,A2,A3,
    Th28;
    hence LifeSpan s1 <= l by A5,A7,AMI_1:def 46;
  end;
  CurInstr Computation(s2,LifeSpan s1) = CurInstr Computation(s1,LifeSpan
  s1) by A1,A2,A3,Th28
    .= halt SCM+FSA by A5,AMI_1:def 46;
  hence
K:   LifeSpan s1 = LifeSpan s2 by A6,A4,AMI_1:def 46;
  then ProgramPart s2 halts_on s2 by A2,Th18;
  then
A8: Result s2 = Computation(s2,LifeSpan s1) by A2,Th18,AMI_1:122,K;
  ProgramPart s1 halts_on s1 by A1,Th18;
  then Result s1 = Computation(s1,LifeSpan s1) by A1,Th18,AMI_1:122;
  hence thesis by A1,A2,A3,A8,Th28;
end;

theorem Th30:
  for I being parahalting Program of SCM+FSA holds IC IExec(I,s) =
  IC Result (s +* Initialized I)
proof
  let I be parahalting Program of SCM+FSA;
A1: dom s = Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ NAT by
  AMI_1:79,SCMFSA_2:8;
  dom (s | NAT) = dom s /\ NAT by RELAT_1:90
    .= NAT by A1,XBOOLE_1:21;
  hence thesis by Lm1,FUNCT_4:12;
end;

theorem Th31:
  for I being non empty Program of SCM+FSA holds insloc 0 in dom I
  & insloc 0 in dom Initialized I & insloc 0 in dom (I +* Start-At insloc 0)
proof
  let I be non empty Program of SCM+FSA;
  consider iloc being set such that
A1: iloc in dom I by XBOOLE_0:def 1;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider iloc as Instruction-Location of SCM+FSA by A1,AMI_1:def 4;
  reconsider i = iloc as Element of NAT by ORDINAL1:def 13;
  0 < i or 0 = i;
  hence
A2: insloc 0 in dom I by A1,SCMNORM:def 1;
  I c= Initialized I by SCMFSA6A:26;
  then dom I c= dom Initialized I by RELAT_1:25;
  hence insloc 0 in dom Initialized I by A2;
  dom (I +* Start-At insloc 0) = dom I \/ dom Start-At insloc 0 by FUNCT_4
  :def 1;
  hence thesis by A2,XBOOLE_0:def 3;
end;

theorem Th32:
  x in dom Macro i iff x = insloc 0 or x = insloc 1
proof
  dom Macro i = {insloc 0, insloc 1} by FUNCT_4:65;
  hence thesis by TARSKI:def 2;
end;

theorem Th33:
  (Macro i).(insloc 0) = i & (Macro i).(insloc 1) = halt SCM+FSA &
  (Initialized Macro i).insloc 0 = i & (Initialized Macro i).insloc 1 = halt
  SCM+FSA & ((Macro i) +* Start-At insloc 0).insloc 0 = i
proof
  thus
A1: (Macro i).(insloc 0) = i by FUNCT_4:66;
  thus
A2: (Macro i).(insloc 1) = halt SCM+FSA by FUNCT_4:66;
A3: Macro i c= Initialized Macro i by SCMFSA6A:26;
A4: insloc 0 in dom Macro i by Th32;
  hence (Initialized Macro i).insloc 0 = i by A1,A3,GRFUNC_1:8;
  insloc 1 in dom Macro i by Th32;
  hence (Initialized Macro i).insloc 1 = halt SCM+FSA by A2,A3,GRFUNC_1:8;
  dom (Macro i) misses dom (Start-At insloc 0) by SF_MASTR:64;
  then Macro i c= (Macro i) +* Start-At insloc 0 by FUNCT_4:33;
  hence thesis by A1,A4,GRFUNC_1:8;
end;

theorem
  Initialized I c= s implies IC s = insloc 0
proof
A1: IC Initialized I = insloc 0 & IC SCM+FSA in dom Initialized I by
  SCMFSA6A:24,25;
  assume
  Initialized I c= s;
  hence thesis by A1,AMI_1:97;
end;

Lm3: Macro halt SCM+FSA is keeping_0 parahalting
proof
  set Mi = Macro halt SCM+FSA;
  hereby
A1: insloc 0 in dom (Mi +* Start-At insloc 0) by Th31;
    let s be State of SCM+FSA;
    assume
A2: Mi +* Start-At insloc 0 c= s;
    let k be Element of NAT;
A3: s = Computation(s,0) by AMI_1:13;
    CurInstr Computation(s,0) = CurInstr s by AMI_1:13
      .= s.insloc 0 by A2,SF_MASTR:67
      .= (Mi +* Start-At insloc 0).insloc 0 by A2,A1,GRFUNC_1:8
      .= halt SCM+FSA by Th33;
    hence Computation(s,k).intloc 0 = s.intloc 0 by A3,AMI_1:52;
  end;
  thus thesis by Lm2;
end;

registration
  cluster keeping_0 parahalting Program of SCM+FSA;
  existence by Lm3;
end;

theorem
  for I being keeping_0 parahalting Program of SCM+FSA holds IExec(I, s)
  .intloc 0 = 1
proof
  let I be keeping_0 parahalting Program of SCM+FSA;
A1: intloc 0 in dom (Initialized I) by SCMFSA6A:45;
A2: I +* Start-At insloc 0 c= s+*Initialized I by Th8,FUNCT_4:26;
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I by Th19,FUNCT_4:26;
  then
A3: ex n st Result(s+*Initialized I) = Computation(s+* Initialized I,n) &
  CurInstr(Result(s+*Initialized I)) = halt SCM+FSA by AMI_1:def 22;
  not intloc 0 in NAT
  proof
A4: intloc 0 in Int-Locations by SCMFSA_2:9;
    assume
    intloc 0 in NAT;
    hence contradiction by A4,SCMFSA_2:13,XBOOLE_0:3;
  end;
  then not intloc 0 in dom(s|NAT) by RELAT_1:86;
  hence IExec(I, s).intloc 0 = (Result(s+*Initialized I)).intloc 0 by
  FUNCT_4:12
    .= (s+*Initialized I).intloc 0 by A3,A2,Def4
    .= (Initialized I).intloc 0 by A1,FUNCT_4:14
    .= 1 by SCMFSA6A:46;
end;

begin :: The composition of macroinstructions

theorem Th36:
  for I being paraclosed Program of SCM+FSA, J being Program of
SCM+FSA st I +* Start-At insloc 0 c= s & ProgramPart s halts_on s
 for m st m <= LifeSpan s
  holds Computation(s,m), Computation(s+*(I ';' J),m) equal_outside NAT
proof
  let I be paraclosed Program of SCM+FSA, J be Program of SCM+FSA;
  assume that
A1: I +* Start-At insloc 0 c= s and
A2: ProgramPart s halts_on s;
  defpred X[Element of NAT] means $1 <= LifeSpan s implies Computation(s,$1),
  Computation(s+*(I ';' J),$1) equal_outside NAT;
A3: for m st X[m] holds X[m+1]
  proof
    let m;
    assume
A4: m <= LifeSpan s implies Computation(s,m), Computation(s+*(I ';' J)
    ,m) equal_outside NAT;
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: I ';' J c= Computation(s+*(I ';' J),m) & dom I c= dom(I ';' J) by
    AMI_1:81,FUNCT_4:26,XBOOLE_1:7;
A6: Computation(s,m+1) = Following Computation(s,m) by AMI_1:14
      .= Exec(CurInstr Computation(s,m), Computation(s,m));
A7: Computation(s+*(I ';' J),m+1) = Following Computation(s+*(I ';' J),m)
    by AMI_1:14
      .= Exec(CurInstr Computation(s+*(I ';' J),m), Computation(s+*(I ';' J)
    ,m));
A8: IC Computation(s,m) in dom I by A1,Def2;
    dom I misses dom Start-At insloc 0 by SF_MASTR:64;
    then I c= I +* Start-At insloc 0 by FUNCT_4:33;
    then I c= s by A1,XBOOLE_1:1;
    then I c= Computation(s,m) by AMI_1:81;
    then
A9: CurInstr( Computation(s,m)) = I.IC( Computation(s,m)) by A8,
    GRFUNC_1:8;
    assume
A10: m+1 <= LifeSpan s;
    then
A11: IC( Computation(s,m)) = IC( Computation(s+*(I ';' J),m)) by A4,
    AMI_1:121,NAT_1:13;
    m < LifeSpan s by A10,NAT_1:13;
    then I.IC( Computation(s,m)) <> halt SCM+FSA by A2,A9,AMI_1:def 46;
    then
    CurInstr( Computation(s,m)) = (I ';' J).IC( Computation(s,m)) by A8,
    A9,SCMFSA6A:54
      .= CurInstr( Computation(s+*(I ';' J),m)) by A11,A8,A5,GRFUNC_1:8;
    hence thesis by A4,A10,A6,A7,NAT_1:13,SCMFSA6A:32;
  end;
  Computation(s,0) = s & Computation(s+*(I ';' J),0) = s+*(I ';' J) by
  AMI_1:13;
  then
A12: X[0] by AMI_1:120;
  thus for m holds X[m] from NAT_1:sch 1(A12,A3);
end;

theorem Th37:
  for I being paraclosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
Directed I c= s & Start-At insloc 0 c= s
 holds IC Computation(s,LifeSpan (s +*I
  ) + 1) = insloc card I
proof
  set A = NAT;
  let I be paraclosed Program of SCM+FSA;
  assume that
A1: ProgramPart(s+*I) halts_on s+*I and
A2: Directed I c= s and
A3: Start-At insloc 0 c= s;
  set sISA0 = s +*(I +* Start-At insloc 0);
  set s2 = sISA0 +* Directed I;
  set IAt = I +* Start-At insloc 0;
A4: dom Directed I = dom I by FUNCT_4:105;
  set m = LifeSpan sISA0;
  set l1 = IC Computation(sISA0,m);
A5: I +* Start-At insloc 0 c= sISA0 by FUNCT_4:26;
  then
A6: l1 in dom I by Def2;
A7: sISA0 = s +*I +* Start-At insloc 0 by FUNCT_4:15
    .= s +* Start-At insloc 0 +*I by Th14
    .= s +* I by A3,FUNCT_4:79;
A8: now
    set s1 = sISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Element of NAT] means $1 <= k implies Computation(s1,$1),
    Computation(s2,$1) equal_outside A;
    assume
A9: k <= m;
A10: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
      assume
A11:  n <= k implies Computation(s1,n), Computation(s2,n)
      equal_outside A;
A12:  Computation(s2,n+1) = Following Computation(s2,n) by AMI_1:14
        .= Exec(CurInstr Computation(s2,n), Computation(s2,n));
A13:  Computation(s1,n+1) = Following Computation(s1,n) by AMI_1:14
        .= Exec(CurInstr Computation(s1,n), Computation(s1,n));
A14:  n <= n + 1 by NAT_1:12;
      assume
A15:  n + 1 <= k;
      then
A16:  IC Computation(s1,n) = IC Computation(s2,n) by A11,A14,AMI_1:
      121 ,XXREAL_0:2;
      n <= k by A15,A14,XXREAL_0:2;
      then n <= m by A9,XXREAL_0:2;
      then IC Computation(sISA0,n) = IC Computation(s1,n) by A1,A5,A7,
      Th36,AMI_1:121;
      then
A17:  IC Computation(s1,n) in dom I by A5,Def2;
      then
A18:  IC Computation(s2,n) in dom Directed I by A16,FUNCT_4:105;
A19:  CurInstr Computation(s2,n) = s2.IC Computation(s2,n) by AMI_1:54
        .= (Directed I).IC Computation(s2,n) by A18,FUNCT_4:14;
      dom I c= dom (I ';' I) & CurInstr Computation(s1,n) = s1.IC
      Computation(s1,n ) by AMI_1:54,SCMFSA6A:56;
      then Directed I c= I ';' I & CurInstr Computation(s1,n) = (I ';' I).IC
      Computation(s1,n) by A17,FUNCT_4:14,SCMFSA6A:55;
      then CurInstr Computation(s1,n) = (Directed I).IC Computation(s1,n) by
      A16,A18,GRFUNC_1:8;
      hence thesis by A11,A15,A14,A16,A19,A13,A12,SCMFSA6A:32,XXREAL_0:2;
    end;
    Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
    then Computation(s2,0), Computation(s1,0) equal_outside A by FUNCT_7:
    107,SCMFSA6A:42;
    then
A20: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A20,A10);
    then
A21: Computation(s1,k), Computation(s2,k) equal_outside A;
    Computation(sISA0,k), Computation(s1,k) equal_outside A by A1,A7,A9,
    Th36,FUNCT_4:26;
    hence Computation(sISA0,k), Computation(s2,k) equal_outside A by A21,
    FUNCT_7:29;
  end;
  then
A22: l1 = IC Computation(s2,m) by AMI_1:121;
  dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then I c= I +* Start-At insloc 0 by FUNCT_4:33;
  then dom I c= dom IAt by GRFUNC_1:8;
  then sISA0.l1 = (IAt).l1 by A5,A6,GRFUNC_1:8;
  then
A23: I.l1 = sISA0.l1 by A6,Th7
    .= CurInstr Computation(sISA0,m) by AMI_1:54
    .= halt SCM+FSA by A1,A7,AMI_1:def 46;
  IC Computation(s2,m) in dom I by A8,A6,AMI_1:121;
  then IC Computation(s2,m) in dom Directed I by FUNCT_4:105;
  then
A24: s2.l1 = (Directed I).l1 by A22,FUNCT_4:14
    .= goto insloc card I by A6,A23,FUNCT_4:112;
A25: s2 = s +*I +* Start-At insloc 0 +* Directed I by FUNCT_4:15
    .= s +* Start-At insloc 0 +*I +* Directed I by Th14
    .= s +*I +* Directed I by A3,FUNCT_4:79
    .= s +*(I +* Directed I) by FUNCT_4:15
    .= s +*Directed I by A4,FUNCT_4:20
    .= s by A2,FUNCT_4:79;
  Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
    .= Exec(goto insloc card I, Computation(s2,m)) by A22,A24,AMI_1:54;
  hence thesis by A7,A25,SCMFSA_2:95;
end;

theorem Th38:
  for I being paraclosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
Directed I c= s & Start-At insloc 0 c= s
 holds DataPart Computation(s,LifeSpan(
  s+*I)) = DataPart Computation(s,LifeSpan (s +*I) + 1)
proof
  set A = NAT;
  let I be paraclosed Program of SCM+FSA;
  assume that
A1: ProgramPart(s+*I) halts_on s+*I and
A2: Directed I c= s and
A3: Start-At insloc 0 c= s;
  set sISA0 = s +*(I +* Start-At insloc 0);
  set s2 = sISA0 +* Directed I;
  set IAt = I +* Start-At insloc 0;
A4: dom Directed I = dom I by FUNCT_4:105;
  set m = LifeSpan sISA0;
  set l1 = IC Computation(sISA0,m);
A5: I +* Start-At insloc 0 c= sISA0 by FUNCT_4:26;
  then
A6: l1 in dom I by Def2;
A7: sISA0 = s +*I +* Start-At insloc 0 by FUNCT_4:15
    .= s +* Start-At insloc 0 +*I by Th14
    .= s +* I by A3,FUNCT_4:79;
A8: now
    set s1 = sISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Element of NAT] means $1 <= k implies Computation(s1,$1),
    Computation(s2,$1) equal_outside A;
    assume
A9: k <= m;
A10: for n being Element of NAT st X[n] holds X[n+1]
    proof
A11:  Directed I c= I ';' I by SCMFSA6A:55;
      let n be Element of NAT;
A12:  dom I c= dom (I ';' I) by SCMFSA6A:56;
      assume
A13:  n <= k implies Computation(s1,n), Computation(s2,n)
      equal_outside A;
A14:  Computation(s2,n+1) = Following Computation(s2,n) by AMI_1:14
        .= Exec(CurInstr Computation(s2,n), Computation(s2,n));
A15:  Computation(s1,n+1) = Following Computation(s1,n) by AMI_1:14
        .= Exec(CurInstr Computation(s1,n), Computation(s1,n));
A16:  n <= n + 1 by NAT_1:12;
      assume
A17:  n + 1 <= k;
      then
A18:  IC Computation(s1,n) = IC Computation(s2,n) by A13,A16,AMI_1:
      121 ,XXREAL_0:2;
      n <= k by A17,A16,XXREAL_0:2;
      then n <= m by A9,XXREAL_0:2;
      then IC Computation(sISA0,n) = IC Computation(s1,n) by A1,A5,A7,
      Th36,AMI_1:121;
      then
A19:  IC Computation(s1,n) in dom I by A5,Def2;
      then
A20:  IC Computation(s2,n) in dom Directed I by A18,FUNCT_4:105;
A21:  CurInstr Computation(s2,n) = s2.IC Computation(s2,n) by AMI_1:54
        .= (Directed I).IC Computation(s2,n) by A20,FUNCT_4:14;
      CurInstr Computation(s1,n) = s1.IC Computation(s1,n) by AMI_1:54
        .= (I ';' I).IC Computation(s1,n) by A12,A19,FUNCT_4:14
        .= (Directed I).IC Computation(s1,n) by A11,A18,A20,GRFUNC_1:8;
      hence thesis by A13,A17,A16,A18,A21,A15,A14,SCMFSA6A:32,XXREAL_0:2;
    end;
    Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
    then Computation(s2,0), Computation(s1,0) equal_outside A by FUNCT_7:
    107,SCMFSA6A:42;
    then
A22: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A22,A10);
    then
A23: Computation(s1,k), Computation(s2,k) equal_outside A;
    Computation(sISA0,k), Computation(s1,k) equal_outside A by A1,A7,A9
    ,Th36,FUNCT_4:26;
    hence Computation(sISA0,k), Computation(s2,k) equal_outside A by A23,
    FUNCT_7:29;
  end;
  then
A24: l1 = IC Computation(s2,m) by AMI_1:121;
  dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then I c= I +* Start-At insloc 0 by FUNCT_4:33;
  then dom I c= dom IAt by GRFUNC_1:8;
  then sISA0.l1 = (IAt).l1 by A5,A6,GRFUNC_1:8;
  then
A25: I.l1 = sISA0.l1 by A6,Th7
    .= CurInstr Computation(sISA0,m) by AMI_1:54
    .= halt SCM+FSA by A1,A7,AMI_1:def 46;
  IC Computation(s2,m) in dom I by A8,A6,AMI_1:121;
  then IC Computation(s2,m) in dom Directed I by FUNCT_4:105;
  then
A26: s2.l1 = (Directed I).l1 by A24,FUNCT_4:14
    .= goto insloc card I by A6,A25,FUNCT_4:112;
  s2 = s +*I +* Start-At insloc 0 +* Directed I by FUNCT_4:15
    .= s +* Start-At insloc 0 +*I +* Directed I by Th14
    .= s +*I +* Directed I by A3,FUNCT_4:79
    .= s +*(I +* Directed I) by FUNCT_4:15
    .= s +*Directed I by A4,FUNCT_4:20;
  then
A27: s2 = s by A2,FUNCT_4:79;
  Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
    .= Exec(goto insloc card I, Computation(s2,m)) by A24,A26,AMI_1:54;
  then
  ( for a being Int-Location holds Computation(s2,m+1).a = Computation(s2
, m).a)& for f being FinSeq-Location holds Computation(s2,m+1).f = Computation(
  s2,m). f by SCMFSA_2:95;
  hence thesis by A7,A27,SCMFSA6A:38;
end;

theorem Th39:
  for I being parahalting Program of SCM+FSA st Initialized I c= s
holds for k being Element of NAT st k <= LifeSpan s holds CurInstr Computation(
  s +* Directed I,k) <> halt SCM+FSA
proof
  set A = NAT;
  let I be parahalting Program of SCM+FSA;
  set s2 = s +* Directed I;
  set m = LifeSpan s;
  assume
A1: Initialized I c= s;
  then
A2: I +* Start-At insloc 0 c= s by Th8;
A3: ProgramPart s halts_on s by A1,AMI_1:def 26;
A4: now
    set s1 = s +* (I ';' I);
    let k be Element of NAT;
    defpred X[Element of NAT] means $1 <= k implies Computation(s1,$1),
    Computation(s2,$1) equal_outside A;
    assume
A5: k <= m;
A6: for n being Element of NAT st X[n] holds X[n+1]
    proof
A7:   Directed I c= I ';' I by SCMFSA6A:55;
      let n be Element of NAT;
A8:   dom I c= dom (I ';' I) by SCMFSA6A:56;
      assume
A9:   n <= k implies Computation(s1,n), Computation(s2,n)
      equal_outside A;
A10:  Computation(s2,n+1) = Following Computation(s2,n) by AMI_1:14
        .= Exec(CurInstr Computation(s2,n), Computation(s2,n));
A11:  Computation(s1,n+1) = Following Computation(s1,n) by AMI_1:14
        .= Exec(CurInstr Computation(s1,n), Computation(s1,n));
A12:  n <= n + 1 by NAT_1:12;
      assume
A13:  n + 1 <= k;
      then
A14:  IC Computation(s1,n) = IC Computation(s2,n) by A9,A12,AMI_1:
      121 ,XXREAL_0:2;
      n <= k by A13,A12,XXREAL_0:2;
      then n <= m by A5,XXREAL_0:2;
      then IC Computation(s,n) = IC Computation(s1,n) by A3,A2,
      Th36, AMI_1
      :121;
      then
A15:  IC Computation(s1,n) in dom I by A2,Def2;
      then
A16:  IC Computation(s2,n) in dom Directed I by A14,FUNCT_4:105;
A17:  CurInstr Computation(s2,n) = s2.IC Computation(s2,n) by AMI_1:54
        .= (Directed I).IC Computation(s2,n) by A16,FUNCT_4:14;
      CurInstr Computation(s1,n) = s1.IC Computation(s1,n) by AMI_1:54
        .= (I ';' I).IC Computation(s1,n) by A8,A15,FUNCT_4:14
        .= (Directed I).IC Computation(s1,n) by A7,A14,A16,GRFUNC_1:8;
      hence thesis by A9,A13,A12,A14,A17,A11,A10,SCMFSA6A:32,XXREAL_0:2;
    end;
    Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
    then Computation(s2,0), Computation(s1,0) equal_outside A by
    FUNCT_7:107
    ,SCMFSA6A:42;
    then
A18: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A18,A6);
    then
A19: Computation(s1,k), Computation(s2,k) equal_outside A;
    Computation(s,k), Computation(s1,k) equal_outside A by A3,A2,A5,Th36;
    hence Computation(s,k), Computation(s2,k) equal_outside A by A19,FUNCT_7
    :29;
  end;
  hereby
    let k be Element of NAT;
    set lk = IC Computation(s,k);
A20: IC Computation(s,k) in dom I & dom I = dom Directed I by A2,Def2,
    FUNCT_4:105;
    then
A21: (Directed I).lk in rng Directed I by FUNCT_1:def 5;
    assume
    k <= LifeSpan s;
    then lk = IC Computation(s2,k) by A4,AMI_1:121;
    then
A22: CurInstr Computation(s2,k) = s2.lk by AMI_1:54
      .= (Directed I).lk by A20,FUNCT_4:14;
    assume
    CurInstr Computation(s +* Directed I,k) = halt SCM+FSA;
    hence contradiction by A22,A21,SCMFSA6A:18;
  end;
end;

theorem Th40:
  for I being paraclosed Program of SCM+FSA
   st ProgramPart(s +* (I +* Start-At insloc 0))
    halts_on s +* (I +* Start-At insloc 0)
 for J being Program of SCM+FSA, k being Element of NAT st
  k <= LifeSpan (s +* (I +* Start-At insloc 0)) holds Computation(s +* (I +*
  Start-At insloc 0),k), Computation(s +* ((I ';' J) +* Start-At insloc 0),k)
  equal_outside NAT
proof
  set SA0 = Start-At insloc 0;
  let I be paraclosed Program of SCM+FSA;
  assume
A1: ProgramPart(s +* (I +* Start-At insloc 0))
    halts_on s +* (I +* Start-At insloc 0)
;
  set s1 = s +* (I +* Start-At insloc 0);
  let J be Program of SCM+FSA;
A2: I +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  set s2 = s +* ((I ';' J) +* Start-At insloc 0);
  defpred X[Element of NAT] means $1 <= LifeSpan s1 implies Computation(s1,$1)
  , Computation(s2,$1) equal_outside NAT;
A3: (I ';' J) +* Start-At insloc 0 c= s2 by FUNCT_4:26;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    let m;
    assume
A6: m <= LifeSpan s1 implies Computation(s1,m), Computation(s2,m)
    equal_outside NAT;
    dom (I ';' J) misses dom SA0 by SF_MASTR:64;
    then (I ';' J) c= (I ';' J)+*SA0 by FUNCT_4:33;
    then (I ';' J) c= s2 by A3,XBOOLE_1:1;
    then
A7: I ';' J c= Computation(s2,m) by AMI_1:81;
A8: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m), Computation(s1,m));
A9: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m), Computation(s2,m));
A10: IC Computation(s1,m) in dom I by A2,Def2;
    dom I misses dom Start-At insloc 0 by SF_MASTR:64;
    then I c= I +* Start-At insloc 0 by FUNCT_4:33;
    then I c= s1 by A2,XBOOLE_1:1;
    then I c= Computation(s1,m) by AMI_1:81;
    then
A11: CurInstr( Computation(s1,m)) = I.IC( Computation(s1,m)) by A10,
    GRFUNC_1:8;
    assume
A12: m+1 <= LifeSpan s1;
    then
A13: IC( Computation(s1,m)) = IC( Computation(s2,m)) by A6,
    AMI_1:121,
    NAT_1:13;
    m < LifeSpan s1 by A12,NAT_1:13;
    then I.IC( Computation(s1,m)) <> halt SCM+FSA by A1,A11,AMI_1:def 46;
    then CurInstr( Computation(s1,m)) = (I ';' J).IC( Computation(s1,m)) by
    A10,A11,SCMFSA6A:54
      .= CurInstr( Computation(s2,m)) by A13,A10,A7,A5,GRFUNC_1:8;
    hence thesis by A6,A12,A8,A9,NAT_1:13,SCMFSA6A:32;
  end;
A14: Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
A15: s+*SA0+*I, s+*SA0 equal_outside NAT & s+*SA0, s+*SA0+*(I ';' J)
  equal_outside NAT by AMI_1:120,FUNCT_7:28;
A16: s2 = s +* (I ';' J) +* SA0 by FUNCT_4:15
    .= s+*SA0+*(I ';' J) by Th14;
  s1 = s +* I +* SA0 by FUNCT_4:15
    .= s+*SA0+*I by Th14;
  then
A17: X[0] by A16,A15,A14,FUNCT_7:29;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A17, A4 );
end;

Lm4: for I being keeping_0 parahalting Program of SCM+FSA, J being parahalting
Program of SCM+FSA, s being State of SCM+FSA st Initialized (I ';' J) c= s
holds IC Computation(s,LifeSpan (s +* I) + 1) = insloc card I & DataPart
Computation(s,LifeSpan (s +* I) + 1) = DataPart (Computation (s +* I,(LifeSpan
(s +* I))) +* Initialized J) & ProgramPart Relocated(J,card I) c= Computation(s
,LifeSpan (s +* I) + 1) & Computation(s,LifeSpan (s +* I) + 1).intloc 0 = 1
 & ProgramPart s halts_on s &
LifeSpan s = LifeSpan (s +* I) + 1 + LifeSpan (Result (s +* I) +*
Initialized J) & (J is keeping_0 implies (Result s).intloc 0 = 1)

proof
  set D = Int-Locations \/ FinSeq-Locations;
  let I be keeping_0 parahalting Program of SCM+FSA;
  set SA0 = Start-At insloc 0;
  let J be parahalting Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* I;
  set s3 = Computation(s1,LifeSpan s1) +* Initialized J;
  set m1 = LifeSpan s1;
  set m3 = LifeSpan s3;
A1: dom Directed I = dom I by FUNCT_4:105;

A2: Directed I c= I ';' J & I ';' J c= Initialized (I ';' J) by SCMFSA6A:26
  ,55;

  assume
A3: Initialized (I ';' J) c= s;
  then SA0 c= (I ';' J) +* SA0 & (I ';' J) +* SA0 c= s by Th8,FUNCT_4:26;
  then
A4: Start-At insloc 0 c= s by XBOOLE_1:1;
A5: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
    .= s +* Directed I by A1,FUNCT_4:20
    .= s +* Initialized (I ';' J) +* Directed I by A3,LATTICE2:8
    .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
    .= s +* Initialized (I ';' J) by A2,LATTICE2:8,XBOOLE_1:1
    .= s by A3,LATTICE2:8;
  then
A6: Directed I c= s by FUNCT_4:26;
  (I ';' J) +* SA0 c= s by A3,Th8;
  then
A7: s = s +*((I ';' J) +* SA0) by FUNCT_4:79;
A8: Initialized I c= s +* I by A3,SCMFSA6A:52;
  then
A9: I +* Start-At insloc 0 c= s +* I by Th8;
  then
A10: ProgramPart(s+*I) halts_on s+*I by Th18;

  hence
A11: IC Computation(s,LifeSpan (s +* I) + 1) = insloc card I by A4,
  A5,Th37,FUNCT_4:26;

A12: intloc 0 in dom Initialized I by SCMFSA6A:45;
A13: now
    let x be set;
    assume
    x in dom DataPart Initialized J;
    then
A14: x in dom (Initialized J) /\ D by RELAT_1:90,SCMFSA_2:127;
    then
A15: x in dom Initialized J by XBOOLE_0:def 4;
A16: x in D by A14,XBOOLE_0:def 4;
    per cases by A15,SCMFSA6A:44;
    suppose
A17:  x in dom J;
      dom J c= NAT by RELAT_1:def 18;

      then reconsider l=x as Instruction-Location of SCM+FSA by A17,
      AMI_1:def 4;

      (DataPart Initialized J).l = (DataPart Computation(s1,m1)).l by A16
      ,SCMFSA6A:37;

      hence (DataPart Initialized J).x = (DataPart Computation(s1,m1)).x;

    end;
    suppose
A18:  x = intloc 0;

      thus (DataPart Initialized J).x = (Initialized J).x by A16,FUNCT_1:72,
      SCMFSA_2:127

        .= 1 by A18,SCMFSA6A:46
        .= (Initialized I).x by A18,SCMFSA6A:46
        .= s1.x by A8,A12,A18,GRFUNC_1:8
        .= ( Computation(s1,m1)).x by A9,A18,Def4
        .= (DataPart Computation(s1,m1)).x by A16,FUNCT_1:72,SCMFSA_2:127;
    end;
    suppose
      x = IC SCM+FSA;

      hence
      (DataPart Initialized J).x = (DataPart Computation(s1,m1)).x by A14
      ,SCMFSA6A:37,XBOOLE_0:def 4;

    end;
  end;
  set s4 = Computation(s,m1+1);
  reconsider m = m1 + 1 + m3 as Element of NAT;
A19: ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
A20: Initialized J c= s3 by FUNCT_4:26;
  Initialized J c= s3 by FUNCT_4:26;
  then dom Initialized J c= dom s3 by GRFUNC_1:8;
  then
A21: dom Initialized J c= the carrier of SCM+FSA by AMI_1:79;
A22: ProgramPart s3 halts_on s3 by Th19,FUNCT_4:26;

  dom DataPart Initialized J = dom Initialized J /\ D by RELAT_1:90,
  SCMFSA_2:127;

  then dom DataPart Initialized J c= (the carrier of SCM+FSA) /\ D by A21,
  XBOOLE_1:26;

  then dom DataPart Initialized J c= dom ( Computation(s1,m1)) /\ D by
  AMI_1:79;

  then dom DataPart Initialized J c= dom DataPart Computation(s1,m1) by
  RELAT_1:90,SCMFSA_2:127;

  then DataPart s3 = DataPart Computation(s1,m1) +* DataPart Initialized J &
  DataPart Initialized J c= DataPart Computation(s1,m1) by A13,FUNCT_4:75 ,
  GRFUNC_1:8;

  then
A23: DataPart Computation(s1,m1) = DataPart s3 by LATTICE2:8;
  s +* I = s +*Start-At insloc 0 +* I by A4,FUNCT_4:79
    .= s +*I+*Start-At insloc 0 by Th14
    .= s +*(I+*Start-At insloc 0) by FUNCT_4:15;

  then DataPart Computation(s,m1) = DataPart s3 by A7,
  A10,A23,Th40, SCMFSA6A
  :39;

  hence
A24: DataPart Computation(s,m1+1) = DataPart s3 by A9,A4,A6,Th18,A10,
  Th38;

  I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
  then I ';' J c= s by A3,XBOOLE_1:1;
  then ProgramPart Relocated(J,card I) c= s by A19,XBOOLE_1:1;
  then
A25: [ProgramPart Relocated(J,card I)] c= s4 by AMI_1:81;
  hence ProgramPart Relocated(J,card I) c= s4;
A26: intloc 0 in dom Initialized J by SCMFSA6A:45;
  intloc 0 in Int-Locations by SCMFSA_2:9;
  then
A27: intloc 0 in D by XBOOLE_0:def 3;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A24,FUNCT_1:72,SCMFSA_2:127
    .= s3.intloc 0 by A27,FUNCT_1:72,SCMFSA_2:127
    .= (Initialized J).intloc 0 by A26,FUNCT_4:14
    .= 1 by SCMFSA6A:46;
A28: J +* Start-At insloc 0 c= s3 by Th8,FUNCT_4:26;

  then IncAddr(CurInstr Computation(s3,m3),card I) = CurInstr Computation(s4,
  m3) by A11,A24,A25,Th27;

  then
  IncAddr(CurInstr Computation(s3,m3),card I) = CurInstr Computation(s,m1
  +1+m3) by AMI_1:51;

  then
A29: CurInstr Computation(s,m) = IncAddr (halt SCM+FSA,card I) by A22,
  AMI_1:def 46

    .= halt SCM+FSA by SCMFSA_4:8;
  hence
A30: ProgramPart s halts_on s by AMI_1:146;
A31: now
    let k be Element of NAT;
    assume
    m1 + 1 + k < m;
    then
A32: k < m3 by XREAL_1:8;
    assume
A33: CurInstr Computation(s,m1+1+k) = halt SCM+FSA;

    IncAddr(CurInstr Computation(s3,k),card I) = CurInstr Computation(s4,
    k) by A11,A24,A28,A25,Th27

      .= halt SCM+FSA by A33,AMI_1:51;

    then InsCode CurInstr Computation(s3,k) = 0 by
    SCMFSA_2:124 ,SCMFSA_4:
    22;

    then CurInstr Computation(s3,k) = halt SCM+FSA by SCMFSA_2:122;
    hence contradiction by A22,A32,AMI_1:def 46;
  end;
  now
    let k be Element of NAT;
    assume
A34: k < m;
    per cases;
    suppose
      k <= m1;
      hence CurInstr Computation(s,k) <> halt SCM+FSA by A8,A5,Th39;
    end;
    suppose
      m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A35:  m1 + 1 + kk = k by NAT_1:10;
      kk in NAT by ORDINAL1:def 13;
      hence CurInstr Computation(s,k) <> halt SCM+FSA by A31,A34,A35;
    end;
  end;

  then for k being Element of NAT st CurInstr Computation(s,k) = halt SCM+FSA
  holds m <= k;

  then
A36: LifeSpan s = m by A29,A30,AMI_1:def 46;
  s1 = s +* Initialized I by A3,SCMFSA6A:51;
  then Initialized I c= s1 by FUNCT_4:26;
  then ProgramPart s1 halts_on s1 by Th19;
  hence LifeSpan s = LifeSpan (s +* I) + 1 + LifeSpan (Result (s +* I) +*
  Initialized J) by A36,Th19,AMI_1:122;

A37: J +* Start-At insloc 0 c= s3 by Th8,FUNCT_4:26;
  hereby

A38: DataPart Computation(s3,m3) = DataPart Computation(s4,m3) by A11,A24,
    A28,A25,Th27;

    assume
A39: J is keeping_0;
    thus (Result s).intloc 0 = Computation(s,m).intloc 0 by A30,A36,AMI_1:122
      .= Computation(s4,m3).intloc 0 by AMI_1:51
      .= Computation(s3,m3).intloc 0 by A38,SCMFSA6A:38
      .= s3.intloc 0 by A37,A39,Def4
      .= (Initialized J).intloc 0 by A26,A20,GRFUNC_1:8
      .= 1 by SCMFSA6A:46;
  end;
end;

registration
  let I, J be parahalting Program of SCM+FSA;
  cluster I ';' J -> parahalting;
  coherence
  proof
    set D = Int-Locations \/ FinSeq-Locations;
    set SAt = Start-At insloc 0;
    let s be State of SCM+FSA;
    set SA0 = Start-At insloc 0;
    set JAt = J +* SAt;
    set s1 = s +* I;
    set s3 = Computation(s1,LifeSpan s1) +* JAt;
    set m1 = LifeSpan s1;
    set m3 = LifeSpan s3;
    reconsider kk = DataPart JAt as Function;
A1: now
      let x be set;
      assume
      x in dom DataPart JAt;
      then
A2:   x in dom JAt /\ D by RELAT_1:90,SCMFSA_2:127;
      then
A3:   x in D by XBOOLE_0:def 4;
      x in dom JAt by A2,XBOOLE_0:def 4;
      then x in dom J \/ dom SAt by FUNCT_4:def 1;
      then x in dom J \/ {IC SCM+FSA} by FUNCOP_1:19;
      then
A4:   x in dom J or x in {IC SCM+FSA} by XBOOLE_0:def 3;
      per cases by A4,TARSKI:def 1;
      suppose
A5:     x in dom J;
        dom J c= NAT by RELAT_1:def 18;
        then reconsider l=x as Instruction-Location of SCM+FSA by A5,
        AMI_1:def
        4;
        kk.l = (DataPart Computation(s1,m1)).l by A3,SCMFSA6A:37;
        hence kk.x = (DataPart Computation(s1,m1)).x;
      end;
      suppose
        x = IC SCM+FSA;
        hence kk.x = (DataPart Computation(s1,m1)).x by A2,SCMFSA6A:37 ,
        XBOOLE_0:def 4;
      end;
    end;
    JAt c= s3 by FUNCT_4:26;
    then dom JAt c= dom s3 by GRFUNC_1:8;
    then
A6: dom JAt c= the carrier of SCM+FSA by AMI_1:79;
    dom DataPart JAt = dom JAt /\ D by RELAT_1:90,SCMFSA_2:127;
    then dom DataPart JAt c= (the carrier of SCM+FSA) /\ D by A6,
    XBOOLE_1:26;
    then dom DataPart JAt c= dom ( Computation(s1,m1)) /\ D by AMI_1:79;
    then dom DataPart JAt c= dom DataPart Computation(s1,m1) by
    RELAT_1:90
    ,SCMFSA_2:127;
    then s3 | D = (DataPart Computation(s1,m1)) +* kk & DataPart JAt c=
    DataPart Computation(s1,m1) by A1,FUNCT_4:75,GRFUNC_1:8,SCMFSA_2:127;
    then
A7: DataPart Computation(s1,m1) = DataPart s3 by
    LATTICE2:8,SCMFSA_2:
    127;
    assume
A8: (I ';' J) +* Start-At insloc 0 c= s;
    then
A9: s = s +*((I ';' J) +* SA0) by FUNCT_4:79;
    reconsider m = m1 + 1 + m3 as Element of NAT;
A10: dom Directed I = dom I by FUNCT_4:105;
A11: ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
    take m;
    set s4 = Computation(s,m1+1);
A12: Directed I c= I ';' J by SCMFSA6A:55;
    dom (I ';' J) misses dom Start-At insloc 0 by SF_MASTR:64;
    then
A13: I ';' J c= (I ';' J) +* SAt by FUNCT_4:33;
    then I ';' J c= s by A8,XBOOLE_1:1;
    then ProgramPart Relocated(J,card I) c= s by A11,XBOOLE_1:1;
    then
A14: JAt c= s3 & [ProgramPart Relocated(J,card I)] c= s4 by
    AMI_1:81 ,
    FUNCT_4:26;
A15: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
      .= s +* Directed I by A10,FUNCT_4:20
      .= s +* ((I ';' J) +* SAt) +* Directed I by A8,LATTICE2:8
      .= s +* (((I ';' J) +* SAt) +* Directed I) by FUNCT_4:15
      .= s +* ((I ';' J) +* SAt) by A12,A13,LATTICE2:8,XBOOLE_1:1
      .= s by A8,LATTICE2:8;
    then
A16: Directed I c= s by FUNCT_4:26;
    SAt c= (I ';' J) +* SAt by FUNCT_4:26;
    then
A17: SAt c= s by A8,XBOOLE_1:1;
    then s +*SAt = s by FUNCT_4:79;
    then dom I misses dom SAt & s +*(SAt +* I) = s +* I by FUNCT_4:15,
    SF_MASTR:64;
    then
A18: s +* (I +* SAt) = s +* I by FUNCT_4:36;
    then
A19: ProgramPart(s+*I) halts_on s+*I by Th18,FUNCT_4:26;
    then
A20: IC Computation(s,LifeSpan (s +* I) + 1) = insloc card I by A17,
    A15
    ,Th37,FUNCT_4:26;
    s +* I = s +*Start-At insloc 0 +* I by A17,FUNCT_4:79
      .= s +*I+*Start-At insloc 0 by Th14
      .= s +*(I+*Start-At insloc 0) by FUNCT_4:15;
    then
A21: DataPart Computation(s,m1) = DataPart s3 by A9,A19,A7,Th40,
    SCMFSA6A:39;
    I +* SAt c= s +* I by A18,FUNCT_4:26;
    then ProgramPart(s+*I) halts_on s+*I by Th18;
    then DataPart Computation(s,m1+1) = DataPart s3 by A17,
    A21,A16,Th18,Th38;
    then
    IncAddr(CurInstr Computation(s3,m3),card I) = CurInstr Computation(s4
    ,m3) by A20,A14,Th27;
    then
A22: IncAddr(CurInstr Computation(s3,m3),card I) = CurInstr Computation(s,
    m1+1+m3) by AMI_1:51;
    IC Computation(s,m) in NAT by AMI_1:def 4;
   hence IC Computation(s,m) in dom ProgramPart s by AMI_1:143;
    JAt c= s3 & JAt is halting by Def3,FUNCT_4:26;
    then ProgramPart s3 halts_on s3 by AMI_1:def 26;
    then CurInstr Computation(s,m) = IncAddr (halt SCM+FSA,card I) by A22,
    AMI_1:def 46
      .= halt SCM+FSA by SCMFSA_4:8;
   hence (ProgramPart s).IC Computation(s,m) = halt SCM+FSA by AMI_1:145;
  end;
end;

theorem Th41:
  for I being keeping_0 Program of SCM+FSA
   st not ProgramPart(s +* (I +* Start-At insloc 0))
    halts_on s +* (I +* Start-At insloc 0)
   for J being Program of SCM+FSA, k being Element
of NAT holds Computation(s +* (I +* Start-At insloc 0),k), Computation(s +* ((I
  ';' J) +* Start-At insloc 0),k) equal_outside NAT
proof
  set SA0 = Start-At insloc 0;
  let I be keeping_0 Program of SCM+FSA;
  assume
A1: not ProgramPart(s +* (I +* Start-At insloc 0))
    halts_on s +* (I +* Start-At insloc 0);
  set s1 = s +* (I +* Start-At insloc 0);
  let J be Program of SCM+FSA;
A2: I +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  set s2 = s +* ((I ';' J) +* Start-At insloc 0);
  defpred X[Element of NAT] means Computation(s1,$1), Computation(s2,$1)
  equal_outside NAT;
A3: (I ';' J) +* Start-At insloc 0 c= s2 by FUNCT_4:26;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    let m;
A6: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m), Computation(s1,m));
A7: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m),Computation(s2,m));
    dom (I ';' J) misses dom SA0 by SF_MASTR:64;
    then (I ';' J) c= (I ';' J)+*SA0 by FUNCT_4:33;
    then (I ';' J) c= s2 by A3,XBOOLE_1:1;
    then
A8: I ';' J c= Computation(s2,m) by AMI_1:81;
A9: IC Computation(s1,m) in dom I by A2,Def2;
    assume
A10: Computation(s1,m), Computation(s2,m) equal_outside NAT;
    then
A11: IC( Computation(s1,m)) = IC( Computation(s2,m)) by AMI_1:121;
    dom I misses dom Start-At insloc 0 by SF_MASTR:64;
    then I c= I +* Start-At insloc 0 by FUNCT_4:33;
    then I c= s1 by A2,XBOOLE_1:1;
    then I c= Computation(s1,m) by AMI_1:81;
    then
A12: CurInstr( Computation(s1,m)) = I.IC( Computation(s1,m)) by A9,
    GRFUNC_1:8;
    then I.IC( Computation(s1,m)) <> halt SCM+FSA by A1,AMI_1:146;
    then CurInstr( Computation(s1,m)) = (I ';' J).IC( Computation(s1,m)) by
    A9,A12,SCMFSA6A:54
      .= CurInstr( Computation(s2,m)) by A11,A9,A8,A5,GRFUNC_1:8;
    hence thesis by A10,A6,A7,SCMFSA6A:32;
  end;
A13: Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
A14: s+*SA0+*I, s+*SA0 equal_outside NAT & s+*SA0, s+*SA0+*(I ';' J)
  equal_outside NAT by AMI_1:120,FUNCT_7:28;
A15: s2 = s +* (I ';' J) +* SA0 by FUNCT_4:15
    .= s+*SA0+*(I ';' J) by Th14;
  s1 = s +* I +* SA0 by FUNCT_4:15
    .= s+*SA0+*I by Th14;
  then
A16: X[0] by A15,A14,A13,FUNCT_7:29;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A16, A4 );
end;

theorem Th42:
  for I being keeping_0 Program of SCM+FSA st ProgramPart(s+*I) halts_on s+*I
for J being paraclosed Program of SCM+FSA st (I ';' J) +* Start-At insloc 0 c=
s for k being Element of NAT holds Computation (Result(s +*I) +* (J +* Start-At
  insloc 0),k) +* Start-At (IC (Computation ((Result(s +*I)) +* (J +* Start-At
insloc 0),k)) + card I), Computation (s +* (I ';' J), (LifeSpan (s +* I)+1+k))
  equal_outside NAT
proof
  set SA0 = Start-At insloc 0;
  let I be keeping_0 Program of SCM+FSA;
  assume
A1: ProgramPart(s+*I) halts_on s+*I;
  set ISA0 = I +* Start-At insloc 0;
  let J be paraclosed Program of SCM+FSA;
  set sISA0 = s +* ISA0;
  set RI = Result(s +* ISA0);
  set JSA0 = (J +* Start-At insloc 0);
  set RIJ = RI +* JSA0;
  set sIJSA0 = s +* ((I ';' J) +* Start-At insloc 0);
  defpred X[Element of NAT] means Computation(RIJ,$1) +* Start-At (IC
  Computation(RIJ,$1) + card I), Computation(sIJSA0,LifeSpan sISA0+1+$1)
  equal_outside NAT;
  assume
  (I ';' J) +* SA0 c= s;
  then
A2: s = sIJSA0 by FUNCT_4:79;
A3: sIJSA0 = s +*(I ';' J) +* Start-At insloc 0 by FUNCT_4:15;
  then
A4: SA0 c= s by A2,FUNCT_4:26;
  sIJSA0 = s +*Start-At insloc 0 +*(I ';' J) by A3,Th14;
  then
A5: (I ';' J) c= s by A2,FUNCT_4:26;
A6: for n being Element of NAT st X[n] holds X[n+1]
  proof
    let k be Element of NAT;
    set k1 = k+1;
    set CRk = Computation(RIJ,k);
    set CRSk = CRk +* Start-At (IC CRk + card I);
    set CIJk = Computation(sIJSA0,LifeSpan sISA0+1+k);
    set CRk1 = Computation(RIJ,k1);
    set CRSk1 = CRk1 +* Start-At (IC CRk1 + card I);
    set CIJk1 = Computation(sIJSA0,LifeSpan sISA0+1+k1);
    assume
A7: Computation(RIJ,k) +* Start-At (IC Computation(RIJ,k) + card I),
    Computation(sIJSA0,LifeSpan sISA0+1+k) equal_outside NAT;
A8: IncAddr(CurInstr CRk, card I) = CurInstr CIJk
    proof
      RIJ = RI +* J +* Start-At insloc 0 by FUNCT_4:15
        .= RI +* Start-At insloc 0 +* J by Th14;
      then
A9:   J c= CRk by AMI_1:81,FUNCT_4:26;
      ProgramPart Relocated(J, card I) c= I ';' J by FUNCT_4:26;
      then
A10:  ProgramPart Relocated(J, card I) c= sIJSA0 by A2,A5,
      XBOOLE_1:1;
A11:  CurInstr CIJk = CIJk.IC CRSk by A7,AMI_1:121
        .= CIJk.(IC CRk + card I) by AMI_1:111;
      reconsider ii = IC CRk as Element of NAT by ORDINAL1:def 13;
A12:  ProgramPart Relocated(J, card I) = IncAddr([Shift(ProgramPart(J),
      card I)], card I) by SCMFSA_5:2
        .= IncAddr(Shift(J, card I), card I) by AMI_1:105
        .= Shift(IncAddr(J, card I), card I) by SCMFSA_4:35;
      JSA0 c= RIJ by FUNCT_4:26;
      then
A13:  IC CRk in dom J by Def2;
      then
A14:  IC CRk in dom IncAddr(J, card I) by SCMFSA_4:def 6;
      then
A15:  Shift(IncAddr(J, card I), card I).(IC CRk + card I) = IncAddr(J,
      card I).ii by VALUED_1:def 12
        .= IncAddr(pi(J, ii), card I) by A13,SCMFSA_4:24;
      dom Shift(IncAddr(J, card I), card I) = { il+card I where il is
      Element of NAT: il in dom IncAddr(J, card I)} by VALUED_1:def 12;
      then
A16:  ii + card I in dom Shift(IncAddr(J, card I), card I) by A14;
      pi(J, ii) = J.ii by A13,AMI_1:def 47
        .= CRk.IC CRk by A13,A9,GRFUNC_1:8;
      hence
      IncAddr(CurInstr CRk, card I) = sIJSA0.(IC CRk + card I) by A15,A10
      ,A12,A16,GRFUNC_1:8
        .= CurInstr CIJk by A11,AMI_1:54;
    end;
    CIJk, CRSk equal_outside NAT by A7,FUNCT_7:28;
    then Exec(CurInstr CIJk, CIJk), Exec(IncAddr(CurInstr CRk,card I), CRSk)
    equal_outside NAT by A8,SCMFSA6A:32;
    then
A17: Exec(CurInstr CIJk, CIJk), Following(CRk) +* Start-At (IC Following(
    CRk) + card I) equal_outside NAT by SCMFSA_4:28;
    CIJk1 =Computation(sIJSA0,LifeSpan sISA0+1+k+1);
    then
A18: CIJk1 = Following CIJk by AMI_1:14;
A19: now
      let a be Int-Location;
      thus CRSk1.a = CRk1.a by SCMFSA_3:11
        .= (Following CRk).a by AMI_1:14
        .= (Following(CRk) +* Start-At (IC Following(CRk) + card I)).a by
      SCMFSA_3:11
        .= CIJk1.a by A18,A17,SCMFSA6A:30;
    end;
A20: now
      let f be FinSeq-Location;
      thus CRSk1.f = CRk1.f by SCMFSA_3:12
        .= (Following CRk).f by AMI_1:14
        .= (Following(CRk) +* Start-At (IC Following(CRk) + card I)).f by
      SCMFSA_3:12
        .= CIJk1.f by A18,A17,SCMFSA6A:31;
    end;
    IC CRSk1 = IC CRk1 + card I by AMI_1:111
      .= IC Following CRk + card I by AMI_1:14;
    then
    IC CRSk1 = IC (Following(CRk) +* Start-At (IC Following(CRk) + card I
    )) by AMI_1:111
      .= IC CIJk1 by A18,A17,AMI_1:121;
    hence thesis by A19,A20,SCMFSA6A:28;
  end;
A21: sISA0 = s +*I +* Start-At insloc 0 by FUNCT_4:15
    .= s +* Start-At insloc 0 +*I by Th14
    .= s +* I by A4,FUNCT_4:79;
  Directed I c= I ';' J by SCMFSA6A:55;
  then
A22: Directed I c= s by A5,XBOOLE_1:1;
A23: now
    set s2 = Computation(sIJSA0,LifeSpan sISA0+1+0);
    set s1 = RIJ +* Start-At (IC RIJ + card I);
    thus IC s1 = IC RIJ + card I by AMI_1:111
      .= IC (RI +* J +* SA0) + card I by FUNCT_4:15
      .= insloc (0+card I) by AMI_1:111
      .= IC s2 by A1,A2,A3,A22,A21,Th37,FUNCT_4:26;
A24: DataPart Computation(s,LifeSpan sISA0) = DataPart Computation(s,
    LifeSpan sISA0+1) by A1,A2,A3,A22,A21,Th38,FUNCT_4:26;
    hereby
      let a be Int-Location;
A25:  not a in dom JSA0 by Th12;
      not a in dom Start-At (IC RIJ + card I) by Th9;
      hence s1.a = RIJ.a by FUNCT_4:12
        .= RI.a by A25,FUNCT_4:12
        .= Computation(sISA0,LifeSpan sISA0).a by A1,A21,AMI_1:122
        .= Computation(sIJSA0,LifeSpan sISA0).a by A1,A21,Th40,SCMFSA6A:30
        .= s2.a by A2,A24,SCMFSA6A:38;
    end;
    let f be FinSeq-Location;
A26: not f in dom JSA0 by Th13;
    not f in dom Start-At (IC RIJ + card I) by Th10;
    hence s1.f = RIJ.f by FUNCT_4:12
      .= RI.f by A26,FUNCT_4:12
      .= Computation(sISA0,LifeSpan sISA0).f by A1,A21,AMI_1:122
      .= Computation(sIJSA0,LifeSpan sISA0).f by A1,A21,Th40,SCMFSA6A:31
      .= s2.f by A2,A24,SCMFSA6A:38;
  end;
A27: sIJSA0 = s +*(I ';' J) +* Start-At insloc 0 by FUNCT_4:15
    .= s +* Start-At insloc 0 +*(I ';' J) by Th14
    .= s +* (I ';' J) by A4,FUNCT_4:79;
  Computation(RIJ,0) = RIJ by AMI_1:13;
  then
A28: X[0] by A23,SCMFSA6A:28;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A28, A6);
  hence thesis by A21,A27;
end;

registration
  let I, J be keeping_0 Program of SCM+FSA;
  cluster I ';' J -> keeping_0;
  coherence
  proof
    let s be State of SCM+FSA;
    set SA0 = Start-At insloc 0;
A1: I +* SA0 c= s +* (I +* SA0) by FUNCT_4:26;
    assume
A2: (I ';' J) +* SA0 c= s;
    then
A3: s +* ((I ';' J) +* SA0) = s by FUNCT_4:79;
    dom SA0 = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:19,
    SCMFSA_2:81;
    then ( not intloc 0 in dom I)& not intloc 0 in dom SA0 by
    SCMFSA6A:47 ,
    TARSKI:def 1;
    then not intloc 0 in dom I \/ dom SA0 by XBOOLE_0:def 3;
    then
A4: not intloc 0 in dom (I +* SA0) by FUNCT_4:def 1;
    SA0 c= (I ';' J) +* SA0 by FUNCT_4:26;
    then
A5: SA0 c= s by A2,XBOOLE_1:1;
A6: s +*((I ';' J) +* Start-At insloc 0) = s +*(I ';' J) +* Start-At
    insloc 0 by FUNCT_4:15
      .= s +* Start-At insloc 0 +*(I ';' J) by Th14
      .= s +* (I ';' J) by A5,FUNCT_4:79;
    per cases;
    suppose
A7:   ProgramPart(s +* (I +* SA0)) halts_on s +* (I +* SA0);
      let k be Element of NAT;
A8:   s +* (I +* SA0) = s +*I +* SA0 by FUNCT_4:15
        .= s +* SA0 +* I by Th14
        .= s +* I by A5,FUNCT_4:79;
      hereby
        per cases;
        suppose
A9:       k <= LifeSpan(s +* (I +* SA0));
          Computation (s +* (I +* SA0),k).intloc 0 = (s +* (I +* SA0)).
          intloc 0 by A1,Def4
            .= s.intloc 0 by A4,FUNCT_4:12;
          hence thesis by A3,A7,A9,Th40,SCMFSA6A:30;
        end;
        suppose
A10:      k > LifeSpan(s +* (I +* SA0));
          set LS = LifeSpan(s +* (I +* SA0));
          consider p being Element of NAT such that
A11:      k = LS + p and
A12:      1 <= p by A10,FSM_1:1;
          consider r being Nat such that
A13:      p = 1 + r by A12,NAT_1:10;
          dom SA0 = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:19,
          SCMFSA_2:81;
          then ( not intloc 0 in dom J)& not intloc 0 in dom SA0 by
          SCMFSA6A:47 ,TARSKI:def 1;
          then not intloc 0 in dom J \/ dom SA0 by XBOOLE_0:def 3;
          then
A14:      not intloc 0 in dom (J +* SA0) by FUNCT_4:def 1;
          reconsider r as Element of NAT by ORDINAL1:def 13;
          dom Start-At (IC ((Computation (Result(s +*(I+*SA0)) +* (J +*
SA0),r))) + card I) = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:19,
          SCMFSA_2:81;
          then
          not intloc 0 in dom Start-At (IC ((Computation (Result(s +*(I+*
          SA0)) +* (J +* SA0),r))) + card I) by TARSKI:def 1;
          then
A15:      ((Computation (Result(s +*(I+*SA0)) +* (J +* SA0),r)) +*
Start-At (IC ((Computation (Result(s +*(I+*SA0)) +* (J +* SA0),r))) + card I)).
intloc 0 = (Computation (Result(s +*(I+*SA0)) +* (J +* SA0),r)).intloc 0 by
          FUNCT_4:12;
A16:      (Computation (Result(s +*(I+*SA0)) +* (J +* SA0),r)) +*
Start-At (IC ((Computation (Result(s +*(I+*SA0)) +* (J +* SA0),r))) + card I),
Computation (s +* ((I ';' J) +* Start-At insloc 0),(LS+1+r)) equal_outside NAT
          by A2,A6,A7,A8,Th42;
          J +* SA0 c= Result(s +*(I+*SA0)) +* (J +* SA0) by FUNCT_4:26;
          then Computation (Result(s +*(I+*SA0)) +* (J +* SA0),r). intloc 0 =
          (Result(s +*(I+*SA0)) +* (J +* SA0)).intloc 0 by Def4
            .= (Result(s +*(I+*SA0))).intloc 0 by A14,FUNCT_4:12
            .= Computation(s +*(I+*SA0),(LifeSpan (s +*(I+*SA0)))) .intloc 0
          by A7,AMI_1:122
            .= (s +*(I+*SA0)).intloc 0 by A1,Def4
            .= s.intloc 0 by A4,FUNCT_4:12;
          hence thesis by A3,A11,A13,A15,A16,SCMFSA6A:30;
        end;
      end;
    end;
    suppose
A17:  not ProgramPart(s +* (I +* SA0)) halts_on s +* (I +* SA0);
      let k be Element of NAT;
      I +* SA0 c= s +* (I +* SA0) by FUNCT_4:26;
      then
      Computation (s +* (I +* SA0),k).intloc 0 = (s +* (I +* SA0)).intloc
      0 by Def4
        .= s.intloc 0 by A4,FUNCT_4:12;
      hence thesis by A3,A17,Th41,SCMFSA6A:30;
    end;
  end;
end;

theorem Th43:
  for I being keeping_0 parahalting Program of SCM+FSA, J being
  parahalting Program of SCM+FSA holds LifeSpan (s +* Initialized (I ';' J)) =
  LifeSpan (s +* Initialized I) + 1 + LifeSpan (Result (s +* Initialized I) +*
  Initialized J)
proof
  set SA0 = Start-At insloc 0;
  let I be keeping_0 parahalting Program of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  s +* Initialized (I ';' J), s +* Initialized (I ';' J) +* I
  equal_outside NAT & s +* Initialized I, s +* Initialized (I ';' J)
  equal_outside NAT by AMI_1:120,SCMFSA6A:53;
  then
A1: s +* Initialized I, s +* Initialized (I ';' J) +* I equal_outside NAT by
  FUNCT_7:29;
  Initialized (I ';' J) c= s +* Initialized (I ';' J) by FUNCT_4:26;
  then
A2: LifeSpan (s +* Initialized (I ';' J)) = LifeSpan (s +* Initialized (I
  ';' J) +* I) + 1 + LifeSpan (Result (s +* Initialized (I ';' J) +* I) +*
  Initialized J) by Lm4;
A3: J +* SA0 c= Result (s +* Initialized (I ';' J) +* I) +* Initialized J &
  J +* SA0 c= Result (s +* Initialized I) +* Initialized J by Th8,FUNCT_4:26;
  Initialized I c= s +* Initialized (I ';' J) +* I by FUNCT_4:26,SCMFSA6A:
  52;
  then
A4: I +* SA0 c= s +* Initialized (I ';' J) +* I by Th8;
A5: I +* SA0 c= s +* Initialized I by Th8,FUNCT_4:26;
  then Result (s +* Initialized I), Result (s +* Initialized (I ';' J) +* I)
  equal_outside NAT by A4,A1,Th29;
  then Result (s +* Initialized (I ';' J) +* I), Result (s +* Initialized I )
  equal_outside NAT by FUNCT_7:28;
  then
A6: Result (s +* Initialized (I ';' J) +* I) +* Initialized J, Result (s +*
  Initialized I) +* Initialized J equal_outside NAT by FUNCT_7:106;
  LifeSpan (s +* Initialized I) = LifeSpan (s +* Initialized (I ';' J) +*
  I) by A5,A4,A1,Th29;
  hence thesis by A2,A3,A6,Th29;
end;

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA holds IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I)
proof
  set D = (Int-Locations \/ FinSeq-Locations);
  set A = NAT;
  set SA0 = Start-At insloc 0;
  let I be keeping_0 parahalting Program of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  set ps = s | NAT;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (I ';' J);
  set s3 = Computation(s1,LifeSpan s1) +* Initialized J;
  set m1 = LifeSpan s1;
  set m3 = LifeSpan s3;
A1: Initialized (I ';' J) c= s2 by FUNCT_4:26;
  I +* SA0 c= s2 +*(I +* SA0) by FUNCT_4:26;
  then I +* SA0 c= s2 +*I +* SA0 by FUNCT_4:15;
  then
A2: I +* SA0 c= s2 +* SA0 +*I by Th14;
A3: s1 +* (I ';' J) = s +* (Initialized I +* (I ';' J)) by FUNCT_4:15
    .= s2 by SCMFSA6A:58;
A4: ProgramPart s1 halts_on s1 by Th19,FUNCT_4:26;
A5: J +* Start-At insloc 0 c= s3 by Th8,FUNCT_4:26;
A6: Computation(s1,m1) +* Initialized J, Computation(s1,m1) +* ps +*
  Initialized J equal_outside dom ps by FUNCT_7:31,106;
  then
A7: Computation(s1,m1) +* ps +* Initialized J, Computation(s1,m1) +*
  Initialized J equal_outside dom ps by FUNCT_7:28;
A8: dom ps = dom s /\ A by RELAT_1:90
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ A) /\ A by
  AMI_1:79,SCMFSA_2:8
    .= A by XBOOLE_1:21;
  then
A9: dom ps misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
  then
A10: I +* Start-At insloc 0 c= s2 +* I by Th8;
A11: I +* Start-At insloc 0 c= s1 by Th8,FUNCT_4:26;
  s1,s2 equal_outside A & s2,s2 +* I equal_outside A by AMI_1:120,
  SCMFSA6A:53;
  then s1,s2 +* I equal_outside A by FUNCT_7:29;
  then
A12: LifeSpan (s2 +* I) = m1 by A11,A10,Th29;
  then
A13: ProgramPart Relocated(J,card I) c= Computation(s2,m1+1) by A1,Lm4;
A14: Initialized I c= s1 by FUNCT_4:26;
  then
B14: ProgramPart s1 halts_on s1 by Th19;
  then
A15: s3 = Result s1 +* Initialized J by Th19,AMI_1:122;
  SA0 c= Initialized (I ';' J) & Initialized (I ';' J) c= s2 by FUNCT_4:26;
  then SA0 c= s2 by XBOOLE_1:1;
  then I +* SA0 c= s2 +*I by A2,FUNCT_4:79;
  then ProgramPart(s2+*I) halts_on s2+*I by Th18;
  then DataPart Computation(s2+*I,m1) = DataPart Computation ((s2 +* I) +* (I
  ';' J),m1) by A10,A12,Th36, SCMFSA6A:39
    .= DataPart Computation ((s2 +* (I +* (I ';' J))),m1) by FUNCT_4:15
    .= DataPart Computation (s2 +* (I ';' J),m1) by SCMFSA6A:57
    .= DataPart Computation (s +* (Initialized (I ';' J) +* (I ';' J)),m1)
  by FUNCT_4:15
    .= DataPart Computation(s2,m1) by LATTICE2:8,SCMFSA6A:26
    .= DataPart Computation(s1,m1) by A4,A11,A3,Th36,SCMFSA6A:39;
  then
A16: DataPart( Computation(s2+*I,m1)+* Initialized J) = DataPart Computation
  (s1,m1) +* DataPart Initialized J by FUNCT_4:75
    .= DataPart( Computation(s1,m1) +* Initialized J) by FUNCT_4:75;
A17: IC Computation(s2,m1+1) = insloc card I & DataPart Computation(s2,m1+1)
  = DataPart( Computation(s2+*I,m1)+* Initialized J) by A1,A12,Lm4;
  then
A18: DataPart Computation(Computation(s2,m1+1),m3) = DataPart Computation(s3
  ,m3 ) by A13,A5,A16,Th27;
A19: IC Computation(Computation(s2,m1+1),m3) = IC Computation(s3,m3) + card
  I by A17,A13,A5,A16,Th27;
A20: J +* SA0 c= Result s1 +* Initialized J & J +* SA0 c= IExec(I,s) +*
  Initialized J by Th8,FUNCT_4:26;
A21: J +* SA0 c= IExec(I,s) +* Initialized J & J +* SA0 c= s3 by Th8,FUNCT_4
  :26;
A22: Initialized J c= s3 by FUNCT_4:26;
  then
B22: ProgramPart s3 halts_on s3 by Th19;
  Result s1 = Computation(s1,m1) by A14,Th19,AMI_1:122,B14;
  then
A23: IC Result (Result s1 +* Initialized J) = IC Result (IExec(I,s) +*
  Initialized J) by A8,A6,A20,Th29,AMI_1:121;
A24: IExec(I,s) | A = ps by CARD_3:99;
  IExec(I,s) = Computation(s1,m1) +* ps by A14,Th19,AMI_1:122,B14;
  then
  Result (IExec(I,s) +* Initialized J), Result s3 equal_outside A by A8,
  A7,A21,Th29;
  then Result (IExec(I,s) +* Initialized J) +* ps = Result s3 +* ps by A8,
  FUNCT_7:108;
  then
A25: IExec(J,IExec(I,s)) = Computation(s3,m3) +* ps by A22,A24,Th19,B22,
  AMI_1:122;
B1: ProgramPart s2 halts_on s2 by A1,Th19;
  then
  IExec(I ';' J,s) = Computation(s2,LifeSpan s2) +* ps by A1,Th19,AMI_1:
  122
    .= Computation(s2,m1+1+m3) +* ps by A15,Th43;
  then
A26: DataPart IExec(I ';' J,s) = DataPart Computation(s2,m1+1+m3) by
  A9
  ,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Computation(s3,m3) by A18,AMI_1:51
    .= DataPart IExec(J,IExec(I,s)) by A25,A9,FUNCT_4:76,SCMFSA_2:127;
A27: IC IExec(I ';' J,s) = IC Result (s +* Initialized (I ';' J)) by Th30
    .= IC Computation(s2,LifeSpan s2) by A1,Th19,AMI_1:122,B1
    .= IC Computation(s2,m1+1+m3) by A15,Th43
    .= IC Computation(s3,m3) + card I by A19,AMI_1:51
    .= IC Result s3 + card I by A22,Th19,AMI_1:122,B22
    .= IC Result (Result s1 +* Initialized J) + card I
     by A14,Th19,AMI_1:122,B14
    .= IC IExec(J,IExec(I,s)) + card I by A23,Th30;
  hereby
    reconsider l = IC IExec(J,IExec(I,s)) + card I as Instruction-Location of
    SCM+FSA;
A28: dom Start-At l = {IC SCM+FSA} by FUNCOP_1:19;
A29: now
      let x be set;
      assume
A30:  x in dom IExec(I ';' J,s);
      per cases by A30,SCMFSA6A:35;
      suppose
A31:    x is Int-Location;
        then x <> IC SCM+FSA by SCMFSA_2:81;
        then
A32:    not x in dom Start-At l by A28,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A26,A31, SCMFSA6A:
        38;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I)).x by A32,FUNCT_4:12;
      end;
      suppose
A33:    x is FinSeq-Location;
        then x <> IC SCM+FSA by SCMFSA_2:82;
        then
A34:    not x in dom Start-At l by A28,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A26,A33, SCMFSA6A:
        38;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I)).x by A34,FUNCT_4:12;
      end;
      suppose
A35:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A36:    x in dom Start-At l by FUNCOP_1:19;
        thus IExec(I ';' J,s).x = (Start-At l).IC SCM+FSA by A27,A35,FUNCOP_1:
        87
          .= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
        I)).x by A35,A36,FUNCT_4:14;
      end;
      suppose
A37:    x is Instruction-Location of SCM+FSA;
        then x <> IC SCM+FSA by AMI_1:48;
        then
A38:    not x in dom Start-At l by A28,TARSKI:def 1;
        IExec(I ';' J,s) | A = ps by CARD_3:99
          .= IExec(J,IExec(I,s)) | A by A24,CARD_3:99;
        then IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A37, SCMFSA6A:
        36;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I)).x by A38,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,s) = the carrier of SCM+FSA by AMI_1:79
      .= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
    I)) by AMI_1:79;
    hence thesis by A29,FUNCT_1:9;
  end;
end;

