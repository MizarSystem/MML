:: The SCMPDS Computer and the Basic Semantics of Its Instructions
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies AMI_1, INT_1, AMI_2, GR_CY_1, SCMPDS_1, RELAT_1, FUNCT_1, BOOLE,
      CAT_1, FINSET_1, AMI_3, AMI_5, FINSEQ_1, MCART_1, ABSVALUE,
      CARD_3, ARYTM_1, NAT_1, CQC_LANG, FUNCT_4, SCMPDS_2, FUNCT_7,
      ARYTM, ORDINAL1, SCMNORM, FUNCT_5;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, ORDINAL1, XCMPLX_0, FUNCT_1,
      FUNCT_2, INT_1, NAT_1, MCART_1, FUNCOP_1, CARD_1, CARD_3, ZFMISC_1,
      STRUCT_0, RELAT_1, FUNCT_4, FINSET_1, FINSEQ_1, FINSEQ_4, FUNCT_7, AMI_1,
      SCMNORM, AMI_2, SCMPDS_1, AMI_3, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, INT_2, FINSEQ_4, CAT_2, AMI_5,
      SCMPDS_1, SCMNORM, RELSET_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, ORDINAL1, FUNCOP_1, NUMBERS,
      XREAL_0, INT_1, FINSEQ_1, CARD_3, AMI_1, AMI_2, SCMPDS_1, SCMNORM,
      XXREAL_0, FUNCT_1, GR_CY_1, FINSEQ_4;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, AMI_1, FUNCOP_1, AMI_2, CARD_1, SCMPDS_1, NAT_1, SCMNORM,
      FINSEQ_1;
 theorems NAT_1, FUNCT_1, TARSKI, ZFMISC_1, ENUMSET1, AMI_2, FUNCOP_1, FUNCT_4,
      AMI_1, CARD_3, FUNCT_2, MCART_1, INT_1, GR_CY_1, SCMPDS_1, AMI_3,
      ABSVALUE, STRUCT_0, XBOOLE_0, XBOOLE_1, RELAT_1, XREAL_1, SYSREL,
      FUNCT_7, ARYTM_3, NUMBERS, XXREAL_0, FINSEQ_1;
 schemes FUNCT_2;

begin :: The SCMPDS Computer

reserve x for set,
  k for Element of NAT;

definition
  func SCMPDS -> strict AMI-Struct over { INT } equals
  AMI-Struct(#
    SCM-Memory,In(NAT,SCM-Memory),SCMPDS-Instr, SCMPDS-OK,SCMPDS-Exec#);
  correctness;
end;

registration
 cluster proj2 SCMPDS-Instr -> FinSequence-membered;
 coherence
  proof let f be set;
   assume f in proj2 SCMPDS-Instr;
    then consider y being set such that
Z:   [y,f] in SCMPDS-Instr by RELAT_1:def 5;
    set x = [y,f];
    per cases by Z,XBOOLE_0:def 3;
    suppose
S:    x in { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction} \/
  { [I,<*v,c*>] where I is Element of Segm 14,v is Element of SCM-Data-Loc,
  c is Element of INT: I in {2,3} } \/
  { [I,<*v,c1,c2*>] where I is Element of Segm 14,
  v is Element of SCM-Data-Loc, c1,c2 is Element of INT: I in {4,5,6,7,8} };
    per cases by S,XBOOLE_0:def 3;
    suppose
S:   x in { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction} \/
  { [I,<*v,c*>] where I is Element of Segm 14,v is Element of SCM-Data-Loc,
  c is Element of INT: I in {2,3} };
    per cases by S,XBOOLE_0:def 3;
    suppose
S:   x in { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction};
    per cases by S,XBOOLE_0:def 3;
    suppose x in { [0,<*l*>] where l is Element of INT: not contradiction};
     then consider l being Element of INT such that
W:    x = [0,<*l*>];
     f = <*l*> by W,ZFMISC_1:33;
    hence f is FinSequence by W,ZFMISC_1:106;
    end;
    suppose x in { [1,<*sp*>] where
     sp is Element of SCM-Data-Loc:not contradiction};
     then consider sp being Element of SCM-Data-Loc such that
W:   x = [1,<*sp*>];
     f = <*sp*> by W,ZFMISC_1:33;
    hence f is FinSequence by W,ZFMISC_1:106;
    end;
    end;
    suppose x in { [I,<*v,c*>] where I is Element of Segm 14,
    v is Element of SCM-Data-Loc,
  c is Element of INT: I in {2,3} };
     then consider I being Element of Segm 14,v being Element of SCM-Data-Loc,
  c being Element of INT such that
W:   x = [I,<*v,c*>] & I in {2,3};
     f = <*v,c*> by W,ZFMISC_1:33;
    hence f is FinSequence by W,ZFMISC_1:106;
    end;
    end;
    suppose x in { [I,<*v,c1,c2*>] where I is Element of Segm 14,
  v is Element of SCM-Data-Loc, c1,c2 is Element of INT: I in {4,5,6,7,8}};
     then consider I being Element of Segm 14,
  v being Element of SCM-Data-Loc, c1,c2 being Element of INT such that
W:   x = [I,<*v,c1,c2*>] & I in {4,5,6,7,8};
     f = <*v,c1,c2*> by W,ZFMISC_1:33;
    hence f is FinSequence by W,ZFMISC_1:106;
    end;
    end;
    suppose x in  { [I,<*v1,v2,c1,c2*>] where I is Element of Segm 14,
  v1,v2 is Element of SCM-Data-Loc,
  c1,c2 is Element of INT: I in {9,10,11,12,13} };
     then consider I being Element of Segm 14,
  v1,v2 being Element of SCM-Data-Loc,
  c1,c2 being Element of INT such that
W:  x = [I,<*v1,v2,c1,c2*>] & I in {9,10,11,12,13};
     f = <*v1,v2,c1,c2*> by W,ZFMISC_1:33;
    hence f is FinSequence by W,ZFMISC_1:106;
    end;
  end;
end;


registration
  cluster SCMPDS -> non empty stored-program standard-ins;
  coherence
  proof
    thus SCMPDS is non empty stored-program by AMI_1:def 3,STRUCT_0:def 1;
    consider X being non empty set such that
WW:   proj2 SCMPDS-Instr c= X* by FINSEQ_1:106;
    take X;
    let x;
    assume
Z:   x in  the Instructions of SCMPDS;
    per cases by Z,XBOOLE_0:def 3;
    suppose
S:    x in { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction} \/
  { [I,<*v,c*>] where I is Element of Segm 14,v is Element of SCM-Data-Loc,
  c is Element of INT: I in {2,3} } \/
  { [I,<*v,c1,c2*>] where I is Element of Segm 14,
  v is Element of SCM-Data-Loc, c1,c2 is Element of INT: I in {4,5,6,7,8} };
    per cases by S,XBOOLE_0:def 3;
    suppose
S:   x in { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction} \/
  { [I,<*v,c*>] where I is Element of Segm 14,v is Element of SCM-Data-Loc,
  c is Element of INT: I in {2,3} };
    per cases by S,XBOOLE_0:def 3;
    suppose
S:   x in { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction};
    per cases by S,XBOOLE_0:def 3;
    suppose x in { [0,<*l*>] where l is Element of INT: not contradiction};
     then consider l being Element of INT such that
W:    x = [0,<*l*>];
     <*l*> in proj2 SCMPDS-Instr by Z,W,RELAT_1:def 5;
     then <*l*> in X* by WW;
    hence x in [: NAT, X*:] by W,ZFMISC_1:106;
    end;
    suppose x in { [1,<*sp*>] where
     sp is Element of SCM-Data-Loc:not contradiction};
     then consider sp being Element of SCM-Data-Loc such that
W:   x = [1,<*sp*>];
     <*sp*> in proj2 SCMPDS-Instr by Z,W,RELAT_1:def 5;
     then <*sp*> in X* by WW;
    hence x in [: NAT, X*:] by W,ZFMISC_1:106;
    end;
    end;
    suppose x in { [I,<*v,c*>] where I is Element of Segm 14,
    v is Element of SCM-Data-Loc,
  c is Element of INT: I in {2,3} };
     then consider I being Element of Segm 14,v being Element of SCM-Data-Loc,
  c being Element of INT such that
W:   x = [I,<*v,c*>] & I in {2,3};
     <*v,c*> in proj2 SCMPDS-Instr by Z,W,RELAT_1:def 5;
     then <*v,c*> in X* by WW;
    hence x in [: NAT, X*:] by W,ZFMISC_1:106;
    end;
    end;
    suppose x in { [I,<*v,c1,c2*>] where I is Element of Segm 14,
  v is Element of SCM-Data-Loc, c1,c2 is Element of INT: I in {4,5,6,7,8}};
     then consider I being Element of Segm 14,
  v being Element of SCM-Data-Loc, c1,c2 being Element of INT such that
W:   x = [I,<*v,c1,c2*>] & I in {4,5,6,7,8};
     <*v,c1,c2*> in proj2 SCMPDS-Instr by Z,W,RELAT_1:def 5;
     then <*v,c1,c2*> in X* by WW;
    hence x in [: NAT, X*:] by W,ZFMISC_1:106;
    end;
    end;
    suppose x in  { [I,<*v1,v2,c1,c2*>] where I is Element of Segm 14,
  v1,v2 is Element of SCM-Data-Loc,
  c1,c2 is Element of INT: I in {9,10,11,12,13} };
     then consider I being Element of Segm 14,
  v1,v2 being Element of SCM-Data-Loc,
  c1,c2 being Element of INT such that
W:  x = [I,<*v1,v2,c1,c2*>] & I in {9,10,11,12,13};
   <*v1,v2,c1,c2*> in proj2 SCMPDS-Instr by Z,W,RELAT_1:def 5;
     then <*v1,v2,c1,c2*> in X* by WW;
    hence x in [: NAT, X*:] by W,ZFMISC_1:106;
    end;
  end;
end;

canceled 2;

theorem Th3:
  SCMPDS is definite
proof
  let l be Instruction-Location of SCMPDS;
  l is Element of NAT by AMI_1:def 4;
  hence thesis by SCMPDS_1:22;
end;

registration
  cluster SCMPDS -> IC-Ins-separated definite;
  coherence
  proof
    IC SCMPDS = NAT by AMI_2:30,FUNCT_7:def 1;
    then ObjectKind IC SCMPDS = NAT by SCMPDS_1:def 4;
    hence thesis by Th3,AMI_1:def 11;
  end;
end;

theorem
  the Instructions of SCMPDS <> INT & NAT <> the Instructions of SCMPDS
  by SCMPDS_1:17;

canceled;

reserve s for State of SCMPDS;

theorem Th6:
  IC SCMPDS = NAT by AMI_2:30,FUNCT_7:def 1;

begin :: The Memory Structure

definition
  mode Int_position -> Object of SCMPDS means
    :Def2:
    it in SCM-Data-Loc;
  existence
  proof
    consider x being Element of SCM-Data-Loc;
    reconsider x as Object of SCMPDS;
    take x;
    thus thesis;
  end;
end;

canceled 2;

theorem
  x in SCM-Data-Loc implies x is Int_position by Def2;

canceled;

theorem
  NAT is infinite;

theorem
  for I being Int_position holds I is Data-Location
proof
  let I be Int_position;
  I in SCM-Data-Loc by Def2;
  hence thesis by AMI_3:def 1,def 2;
end;

theorem Th13:
  for l being Int_position holds ObjectKind l = INT
proof
  let l be Int_position;
  l in SCM-Data-Loc by Def2;
  hence thesis by SCMPDS_1:21;
end;

begin :: The Instruction Structure

reserve d1,d2,d3,d4,d5 for Element of SCM-Data-Loc,
  k1,k2,k3,k4,k5,k6 for
  Integer;

reserve I for Instruction of SCMPDS;

set S1={ [0,<*k1*>] where k1 is Element of INT: not contradiction}, S2={ [1,<*
d1*>] : not contradiction}, S3={ [I1,<*d2,k2*>] where I1 is Element of Segm 14,
d2 is Element of SCM-Data-Loc, k2 is Element of INT : I1 in {2,3}}, S4={ [I2,<*
d3,k3,k4*>] where I2 is Element of Segm 14, d3 is Element of SCM-Data-Loc, k3,
k4 is Element of INT: I2 in {4,5,6,7,8} }, S5={ [I3,<*d4,d5,k5,k6*>] where I3
is Element of Segm 14, d4,d5 is Element of SCM-Data-Loc, k5,k6 is Element of
INT: I3 in {9,10,11,12,13} };

Lm1: I in S1 or I in S2 or I in S3 or I in S4 or I in S5
proof
  I in S1 \/ S2 \/ S3 \/ S4 or I in S5 by XBOOLE_0:def 3;
  then I in S1 \/ S2 \/ S3 or I in S4 or I in S5 by XBOOLE_0:def 3;
  then I in S1 \/ S2 or I in S3 or I in S4 or I in S5 by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

canceled;

theorem
  for I being Instruction of SCMPDS holds InsCode I <= 13
proof
  let I be Instruction of SCMPDS;
  per cases by Lm1;
  suppose
    I in S1;
    then ex k1 being Element of INT st I=[0,<*k1*>];
    hence thesis by MCART_1:7;
  end;
  suppose
    I in S2;
    then ex d1 st I=[1,<*d1*>];
    then I`1=1 by MCART_1:7;
    hence thesis;
  end;
  suppose
    I in S3;
    then consider
    I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1
    being Element of INT such that
A1: I = [I1,<*d1,k1*>] and
A2: I1 in {2,3};
A3: I`1 = I1 by A1,MCART_1:7;
    I1 = 2 or I1 = 3 by A2,TARSKI:def 2;
    hence thesis by A3;
  end;
  suppose
    I in S4;
    then consider
    I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1
    ,k2 being Element of INT such that
A4: I = [I1,<*d1,k1,k2*>] and
A5: I1 in {4,5,6,7,8};
A6: I`1 = I1 by A4,MCART_1:7;
    I1 = 4 or I1 = 5 or I1=6 or I1=7 or I1=8 by A5,ENUMSET1:def 3;
    hence thesis by A6;
  end;
  suppose
    I in S5;
    then consider
    I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
    k1,k2 being Element of INT such that
A7: I = [I1,<*d1,d2,k1,k2*>] and
A8: I1 in {9,10,11,12,13};
A9: I`1 = I1 by A7,MCART_1:7;
    I1 = 9 or I1 = 10 or I1=11 or I1=12 or I1=13 by A8,ENUMSET1:def 3;
    hence thesis by A9;
  end;
end;

definition
  let s be State of SCMPDS, d be Int_position;
  redefine func s.d -> Integer;
  coherence
  proof
    reconsider D = d as Element of SCM-Data-Loc by Def2;
    reconsider S = s as SCMPDS-State;
    S.D = s.d;
    hence thesis;
  end;
end;

definition
  let m,n be Integer;
  canceled;
  func DataLoc(m,n) -> Int_position equals
  [1,abs(m+n)];
  coherence
  proof
    [1,abs(m+n)] in SCM-Data-Loc by AMI_2:33;
    hence thesis by Def2;
  end;
end;

theorem Th16:
  [0,<*k1*>] in SCMPDS-Instr
proof
  k1 is Element of INT by INT_1:def 2;
  then [0,<*k1*>] in S1;
  then [0,<*k1*>] in S1 \/ S2 by XBOOLE_0:def 3;
  then [0,<*k1*>] in S1 \/ S2 \/ S3 by XBOOLE_0:def 3;
  then [0,<*k1*>] in S1 \/ S2 \/ S3 \/ S4 by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th17:
  [1,<*d1*>] in SCMPDS-Instr
proof
  [1,<*d1*>] in S2;
  then [1,<*d1*>] in S1 \/ S2 by XBOOLE_0:def 3;
  then [1,<*d1*>] in S1 \/ S2 \/ S3 by XBOOLE_0:def 3;
  then [1,<*d1*>] in S1 \/ S2 \/ S3 \/ S4 by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th18:
  x in { 2,3 } implies [x,<*d2,k2*>] in SCMPDS-Instr
proof
  assume
A1: x in { 2,3 };
  then x = 2 or x = 3 by TARSKI:def 2;
  then reconsider x as Element of Segm 14 by NAT_1:45;
  k2 is Element of INT by INT_1:def 2;
  then [x,<*d2,k2*>] in S3 by A1;
  then [x,<*d2,k2*>] in S1 \/ S2 \/ S3 by XBOOLE_0:def 3;
  then [x,<*d2,k2*>] in S1 \/ S2 \/ S3 \/ S4 by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th19:
  x in { 4,5,6,7,8 } implies [x,<*d3,k3,k4*>] in SCMPDS-Instr
proof
  assume
A1: x in { 4,5,6,7,8 };
  then x = 4 or x = 5 or x=6 or x=7 or x=8 by ENUMSET1:def 3;
  then reconsider x as Element of Segm 14 by NAT_1:45;
  k3 is Element of INT & k4 is Element of INT by INT_1:def 2;
  then [x,<*d3,k3,k4*>] in S4 by A1;
  then [x,<*d3,k3,k4*>] in S1 \/ S2 \/ S3 \/ S4 by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th20:
  x in { 9,10,11,12,13 } implies [x,<*d4,d5,k5,k6*>] in
  SCMPDS-Instr
proof
  assume
A1: x in { 9,10,11,12,13 };
  then x = 9 or x=10 or x=11 or x=12 or x=13 by ENUMSET1:def 3;
  then reconsider x as Element of Segm 14 by NAT_1:45;
  k5 is Element of INT & k6 is Element of INT by INT_1:def 2;
  then [x,<*d4,d5,k5,k6*>] in S5 by A1;
  hence thesis by XBOOLE_0:def 3;
end;

reserve a,b,c for Int_position;

definition
  let k1;
  func goto k1 -> Instruction of SCMPDS equals
  [ 0, <*k1*>];
  correctness by Th16;
end;

definition
  let a;
  func return a -> Instruction of SCMPDS equals
  [ 1, <*a*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    [ 1, <*v*>] in SCMPDS-Instr by Th17;
    hence thesis;
  end;
end;

definition
  let a,k1;
  func a := k1 -> Instruction of SCMPDS equals
  [ 2, <*a,k1*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    2 in {2,3} by TARSKI:def 2;
    then [ 2, <*v,k1*>] in SCMPDS-Instr by Th18;
    hence thesis;
  end;
  func saveIC(a,k1) -> Instruction of SCMPDS equals
  [ 3, <*a,k1*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    3 in {2,3} by TARSKI:def 2;
    then [ 3, <*v,k1*>] in SCMPDS-Instr by Th18;
    hence thesis;
  end;
end;

definition
  let a,k1,k2;
  func (a,k1)<>0_goto k2 -> Instruction of SCMPDS equals
  [ 4, <*a,k1,k2*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    4 in { 4,5,6,7,8 } by ENUMSET1:def 3;
    then [ 4, <*v,k1,k2*>] in SCMPDS-Instr by Th19;
    hence thesis;
  end;
  func (a,k1)<=0_goto k2 -> Instruction of SCMPDS equals
  [ 5, <*a,k1,k2*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    5 in { 4,5,6,7,8 } by ENUMSET1:def 3;
    then [ 5, <*v,k1,k2*>] in SCMPDS-Instr by Th19;
    hence thesis;
  end;
  func (a,k1)>=0_goto k2 -> Instruction of SCMPDS equals
  [ 6, <*a,k1,k2*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    6 in { 4,5,6,7,8 } by ENUMSET1:def 3;
    then [ 6, <*v,k1,k2*>] in SCMPDS-Instr by Th19;
    hence thesis;
  end;
  func (a,k1) := k2 -> Instruction of SCMPDS equals
  [ 7, <*a,k1,k2*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    7 in { 4,5,6,7,8 } by ENUMSET1:def 3;
    then [ 7, <*v,k1,k2*>] in SCMPDS-Instr by Th19;
    hence thesis;
  end;
  func AddTo(a,k1,k2) -> Instruction of SCMPDS equals
  [ 8, <*a,k1,k2*>];
  correctness
  proof
    reconsider v = a as Element of SCM-Data-Loc by Def2;
    8 in { 4,5,6,7,8 } by ENUMSET1:def 3;
    then [ 8, <*v,k1,k2*>] in SCMPDS-Instr by Th19;
    hence thesis;
  end;
end;

definition
  let a,b,k1,k2;
  func AddTo(a,k1,b,k2) -> Instruction of SCMPDS equals
  [ 9, <*a,b,k1,k2*>];
  correctness
  proof
    reconsider v1 = a, v2 = b as Element of SCM-Data-Loc by Def2;
    9 in { 9,10,11,12,13 } by ENUMSET1:def 3;
    then [ 9, <*v1,v2,k1,k2*>] in SCMPDS-Instr by Th20;
    hence thesis;
  end;
  func SubFrom(a,k1,b,k2) -> Instruction of SCMPDS equals
  [ 10, <*a,b,k1,k2*>];
  correctness
  proof
    reconsider v1 = a, v2 = b as Element of SCM-Data-Loc by Def2;
    10 in { 9,10,11,12,13 } by ENUMSET1:def 3;
    then [ 10, <*v1,v2,k1,k2*>] in SCMPDS-Instr by Th20;
    hence thesis;
  end;
  func MultBy(a,k1,b,k2) -> Instruction of SCMPDS equals
  [ 11, <*a,b,k1,k2*>];
  correctness
  proof
    reconsider v1 = a, v2 = b as Element of SCM-Data-Loc by Def2;
    11 in { 9,10,11,12,13 } by ENUMSET1:def 3;
    then [ 11, <*v1,v2,k1,k2*>] in SCMPDS-Instr by Th20;
    hence thesis;
  end;
  func Divide(a,k1,b,k2) -> Instruction of SCMPDS equals
  [ 12, <*a,b,k1,k2*>];
  correctness
  proof
    reconsider v1 = a, v2 = b as Element of SCM-Data-Loc by Def2;
    12 in { 9,10,11,12,13 } by ENUMSET1:def 3;
    then [ 12, <*v1,v2,k1,k2*>] in SCMPDS-Instr by Th20;
    hence thesis;
  end;
  func (a,k1) := (b,k2) -> Instruction of SCMPDS equals
  [ 13, <*a,b,k1,k2*>];
  correctness
  proof
    reconsider v1 = a, v2 = b as Element of SCM-Data-Loc by Def2;
    13 in { 9,10,11,12,13 } by ENUMSET1:def 3;
    then [ 13, <*v1,v2,k1,k2*>] in SCMPDS-Instr by Th20;
    hence thesis;
  end;
end;

theorem
  InsCode (goto k1) = 0 by MCART_1:7;

theorem
  InsCode (return a) = 1 by MCART_1:7;

theorem
  InsCode (a := k1) = 2 by MCART_1:7;

theorem
  InsCode (saveIC(a,k1)) = 3 by MCART_1:7;

theorem
  InsCode ((a,k1)<>0_goto k2) = 4 by MCART_1:7;

theorem
  InsCode ((a,k1)<=0_goto k2) = 5 by MCART_1:7;

theorem
  InsCode ((a,k1)>=0_goto k2) = 6 by MCART_1:7;

theorem
  InsCode ((a,k1) := k2) = 7 by MCART_1:7;

theorem
  InsCode (AddTo(a,k1,k2)) = 8 by MCART_1:7;

theorem
  InsCode (AddTo(a,k1,b,k2)) = 9 by MCART_1:7;

theorem
  InsCode (SubFrom(a,k1,b,k2)) = 10 by MCART_1:7;

theorem
  InsCode (MultBy(a,k1,b,k2)) = 11 by MCART_1:7;

theorem
  InsCode (Divide(a,k1,b,k2)) = 12 by MCART_1:7;

theorem
  InsCode ((a,k1) := (b,k2)) = 13 by MCART_1:7;

Lm2: I in { [0,<*k1*>] where k1 is Element of INT: not contradiction } implies
InsCode I =0

proof
  assume
  I in { [0,<*k1*>]where k1 is Element of INT:not contradiction };
  then ex k1 being Element of INT st I=[0,<*k1*>];
  hence thesis by MCART_1:7;
end;

Lm3: I in { [1,<*d1*>] : not contradiction } implies InsCode I =1
proof
  assume
  I in { [1,<*d1*>]:not contradiction };
  then ex d1 st I=[1,<*d1*>];
  hence thesis by MCART_1:7;
end;

Lm4: I in { [I1,<*d1,k1*>] where I1 is Element of Segm 14, d1 is Element of
SCM-Data-Loc, k1 is Element of INT : I1 in { 2, 3} } implies InsCode I =2 or
InsCode I=3

proof
  assume

  I in { [I1,<*d1,k1*>] where I1 is Element of Segm 14, d1 is Element
  of SCM-Data-Loc, k1 is Element of INT :I1 in { 2, 3}};

  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1
  being Element of INT such that

A1: I=[I1,<*d1,k1*>] and
A2: I1 in { 2, 3};
  I1 = 2 or I1 = 3 by A2,TARSKI:def 2;
  hence thesis by A1,MCART_1:7;
end;

Lm5: I in { [I1,<*d1,k1,k2*>] where I1 is Element of Segm 14, d1 is Element of
SCM-Data-Loc, k1,k2 is Element of INT: I1 in { 4,5,6,7,8} } implies InsCode I =
4 or InsCode I=5 or InsCode I =6 or InsCode I=7 or InsCode I =8

proof
  assume

  I in { [I1,<*d1,k1,k2*>] where I1 is Element of Segm 14, d1 is
  Element of SCM-Data-Loc, k1,k2 is Element of INT:I1 in { 4,5,6,7,8}};

  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1,
  k2 being Element of INT such that

A1: I=[I1,<*d1,k1,k2*>] and
A2: I1 in { 4,5,6,7,8};
  I1 = 4 or I1 = 5 or I1=6 or I1=7 or I1=8 by A2,ENUMSET1:def 3;
  hence thesis by A1,MCART_1:7;
end;

Lm6: I in { [I1,<*d1,d2,k1,k2*>] where I1 is Element of Segm 14, d1,d2 is
Element of SCM-Data-Loc, k1,k2 is Element of INT: I1 in {9,10,11,12,13} }
implies InsCode I =9 or InsCode I=10 or InsCode I =11 or InsCode I=12 or
InsCode I =13

proof
  assume

  I in { [I1,<*d1,d2,k1,k2*>]where I1 is Element of Segm 14, d1,d2 is
  Element of SCM-Data-Loc, k1,k2 is Element of INT:I1 in {9,10,11,12,13}};

  then consider
  I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
  k1,k2 being Element of INT such that

A1: I=[I1,<*d1,d2,k1,k2*>] and
A2: I1 in {9,10,11,12,13};
  I1 = 9 or I1 = 10 or I1=11 or I1=12 or I1=13 by A2,ENUMSET1:def 3;
  hence thesis by A1,MCART_1:7;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 0 holds ex k1 st
  ins = goto k1
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 0;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider k1 being Element of INT such that
A2: I=[0,<*k1*>] by A1,Lm3,Lm4,Lm5,Lm6;
  take k1;
  thus thesis by A2;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 1 holds ex a st
  ins = return a
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 1;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider d1 such that
A2: I=[1,<*d1*>] by A1,Lm2,Lm4,Lm5,Lm6;
  reconsider a=d1 as Int_position by Def2;
  take a;
  thus thesis by A2;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 2 holds ex a,k1
  st ins = a := k1
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 2;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1
  being Element of INT such that
A2: I=[I1,<*d1,k1*>] and
A3: I1 in {2,3} by A1,Lm2,Lm3,Lm5,Lm6;
  I1=2 or I1=3 by A3,TARSKI:def 2;
  then consider d1,k1 such that
A4: I=[ 2, <*d1,k1*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 3 holds ex a,k1
  st ins = saveIC(a,k1)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 3;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1
  being Element of INT such that
A2: I=[I1,<*d1,k1*>] and
A3: I1 in {2,3} by A1,Lm2,Lm3,Lm5,Lm6;
  I1=2 or I1=3 by A3,TARSKI:def 2;
  then consider d1,k1 such that
A4: I=[ 3, <*d1,k1*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1;
  thus thesis by A4;
end;

Lm7: I in S1 or I in S2 or I in S3 or I in S5 implies InsCode I=0 or InsCode I
=1 or InsCode I=2 or InsCode I=3 or InsCode I=9 or InsCode I=10 or InsCode I=11
or InsCode I=12 or InsCode I=13

proof
  assume
A1: I in S1 or I in S2 or I in S3 or I in S5;
  per cases by A1;
  suppose
    I in S1;
    hence thesis by Lm2;
  end;
  suppose
    I in S2;
    hence thesis by Lm3;
  end;
  suppose
    I in S3;
    hence thesis by Lm4;
  end;
  suppose
    I in S5;
    hence thesis by Lm6;
  end;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 4 holds ex a,k1,
  k2 st ins = (a,k1)<>0_goto k2
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 4;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1,
  k2 being Element of INT such that
A2: I=[I1,<*d1,k1,k2*>] and
A3: I1 in {4,5,6,7,8} by A1,Lm7;
  I1=4 or I1=5 or I1=6 or I1=7 or I1=8 by A3,ENUMSET1:def 3;
  then consider d1,k1,k2 such that
A4: I=[ 4, <*d1,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 5 holds ex a,k1,
  k2 st ins = (a,k1)<=0_goto k2
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 5;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1,
  k2 being Element of INT such that
A2: I=[I1,<*d1,k1,k2*>] and
A3: I1 in {4,5,6,7,8} by A1,Lm7;
  I1=4 or I1=5 or I1=6 or I1=7 or I1=8 by A3,ENUMSET1:def 3;
  then consider d1,k1,k2 such that
A4: I=[ 5, <*d1,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 6 holds ex a,k1,
  k2 st ins = (a,k1)>=0_goto k2
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 6;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1,
  k2 being Element of INT such that
A2: I=[I1,<*d1,k1,k2*>] and
A3: I1 in {4,5,6,7,8} by A1,Lm7;
  I1=4 or I1=5 or I1=6 or I1=7 or I1=8 by A3,ENUMSET1:def 3;
  then consider d1,k1,k2 such that
A4: I=[ 6, <*d1,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 7 holds ex a,k1,
  k2 st ins = (a,k1) := k2
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 7;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1,
  k2 being Element of INT such that
A2: I=[I1,<*d1,k1,k2*>] and
A3: I1 in {4,5,6,7,8} by A1,Lm7;
  I1=4 or I1=5 or I1=6 or I1=7 or I1=8 by A3,ENUMSET1:def 3;
  then consider d1,k1,k2 such that
A4: I=[ 7, <*d1,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 8 holds ex a,k1,
  k2 st ins = AddTo(a,k1,k2)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 8;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc, k1,
  k2 being Element of INT such that
A2: I=[I1,<*d1,k1,k2*>] and
A3: I1 in {4,5,6,7,8} by A1,Lm7;
  I1=4 or I1=5 or I1=6 or I1=7 or I1=8 by A3,ENUMSET1:def 3;
  then consider d1,k1,k2 such that
A4: I=[ 8, <*d1,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1 as Int_position by Def2;
  take a,k1,k2;
  thus thesis by A4;
end;

Lm8: I in S1 or I in S2 or I in S3 or I in S4 implies InsCode I=0 or InsCode I
=1 or InsCode I=2 or InsCode I=3 or InsCode I=4 or InsCode I=5 or InsCode I=6
or InsCode I=7 or InsCode I=8

proof
  assume
A1: I in S1 or I in S2 or I in S3 or I in S4;
  per cases by A1;
  suppose
    I in S1;
    hence thesis by Lm2;
  end;
  suppose
    I in S2;
    hence thesis by Lm3;
  end;
  suppose
    I in S3;
    hence thesis by Lm4;
  end;
  suppose
    I in S4;
    hence thesis by Lm5;
  end;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 9 holds ex a,b,k1
  ,k2 st ins = AddTo(a,k1,b,k2)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 9;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
  k1,k2 being Element of INT such that
A2: I=[I1,<*d1,d2,k1,k2*>] and
A3: I1 in {9,10,11,12,13} by A1,Lm8;
  I1=9 or I1=10 or I1=11 or I1=12 or I1=13 by A3,ENUMSET1:def 3;
  then consider d1,d2,k1,k2 such that
A4: I=[ 9, <*d1,d2,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1,b=d2 as Int_position by Def2;
  take a,b,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 10 holds ex a,b,
  k1,k2 st ins = SubFrom(a,k1,b,k2)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 10;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
  k1,k2 being Element of INT such that
A2: I=[I1,<*d1,d2,k1,k2*>] and
A3: I1 in {9,10,11,12,13} by A1,Lm8;
  I1=9 or I1=10 or I1=11 or I1=12 or I1=13 by A3,ENUMSET1:def 3;
  then consider d1,d2,k1,k2 such that
A4: I=[ 10, <*d1,d2,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1,b=d2 as Int_position by Def2;
  take a,b,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 11 holds ex a,b,
  k1,k2 st ins = MultBy(a,k1,b,k2)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 11;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
  k1,k2 being Element of INT such that
A2: I=[I1,<*d1,d2,k1,k2*>] and
A3: I1 in {9,10,11,12,13} by A1,Lm8;
  I1=9 or I1=10 or I1=11 or I1=12 or I1=13 by A3,ENUMSET1:def 3;
  then consider d1,d2,k1,k2 such that
A4: I=[ 11, <*d1,d2,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1,b=d2 as Int_position by Def2;
  take a,b,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 12 holds ex a,b,
  k1,k2 st ins = Divide(a,k1,b,k2)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 12;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
  k1,k2 being Element of INT such that
A2: I=[I1,<*d1,d2,k1,k2*>] and
A3: I1 in {9,10,11,12,13} by A1,Lm8;
  I1=9 or I1=10 or I1=11 or I1=12 or I1=13 by A3,ENUMSET1:def 3;
  then consider d1,d2,k1,k2 such that
A4: I=[ 12, <*d1,d2,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1,b=d2 as Int_position by Def2;
  take a,b,k1,k2;
  thus thesis by A4;
end;

theorem
  for ins being Instruction of SCMPDS st InsCode ins = 13 holds ex a,b,
  k1,k2 st ins = (a,k1) := (b,k2)
proof
  let I be Instruction of SCMPDS such that
A1: InsCode I = 13;
  I in S1 or I in S2 or I in S3 or I in S4 or I in S5 by Lm1;
  then consider
  I1 being Element of Segm 14, d1,d2 being Element of SCM-Data-Loc,
  k1,k2 being Element of INT such that
A2: I=[I1,<*d1,d2,k1,k2*>] and
A3: I1 in {9,10,11,12,13} by A1,Lm8;
  I1=9 or I1=10 or I1=11 or I1=12 or I1=13 by A3,ENUMSET1:def 3;
  then consider d1,d2,k1,k2 such that
A4: I=[ 13, <*d1,d2,k1,k2*>] by A1,A2,MCART_1:7;
  reconsider a=d1,b=d2 as Int_position by Def2;
  take a,b,k1,k2;
  thus thesis by A4;
end;

theorem
  for s being State of SCMPDS, d being Int_position holds d in dom s
proof
  let s be State of SCMPDS, d be Int_position;
  dom s = the carrier of SCMPDS by AMI_1:79;
  hence thesis;
end;

theorem Th50:
  for s being State of SCMPDS holds SCM-Data-Loc c= dom s
proof
  let s be State of SCMPDS;
  dom s = the carrier of SCMPDS by AMI_1:79;
  hence thesis;
end;

Lm9: Data-Locations SCMPDS = SCM-Data-Loc
proof
  SCM-Data-Loc misses {NAT} by AMI_2:27,ZFMISC_1:56;
  then
A1: SCM-Data-Loc misses {NAT} \/ NAT by AMI_2:29,XBOOLE_1:70;

  thus Data-Locations SCMPDS = {NAT} \/ SCM-Data-Loc \/ NAT \ ({NAT} \/ NAT)
  by AMI_2:30,FUNCT_7:def 1

    .= SCM-Data-Loc \/ ({NAT} \/ NAT) \ ({NAT} \/ NAT) by XBOOLE_1:4
    .= SCM-Data-Loc \ ({NAT} \/ NAT) by XBOOLE_1:40
    .= SCM-Data-Loc by A1,XBOOLE_1:83;
end;

theorem
  for s being State of SCMPDS holds dom DataPart s = SCM-Data-Loc
proof
  let s be State of SCMPDS;
  SCM-Data-Loc c= dom s by Th50;
  hence thesis by Lm9,RELAT_1:91;
end;

theorem
  for dl being Int_position holds dl <> IC SCMPDS
proof
  let dl be Int_position;
  ObjectKind dl = INT by Th13;
  hence thesis by AMI_1:def 11,NUMBERS:27;
end;

theorem
  for il being Instruction-Location of SCMPDS,dl being Int_position
  holds il <> dl
proof
  let il be Instruction-Location of SCMPDS, dl be Int_position;
  ObjectKind dl = INT by Th13;
  hence thesis by AMI_1:def 14,SCMPDS_1:17;
end;

theorem
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & (for a being
  Int_position holds s1.a = s2.a) & for i being Instruction-Location of SCMPDS
  holds s1.i = s2.i holds s1 = s2
proof
  let s1,s2 be State of SCMPDS such that
A1: IC(s1) = IC(s2) and
A2: for a being Int_position holds s1.a = s2.a and
A3: for i being Instruction-Location of SCMPDS holds s1.i = s2.i;
  consider g1 being Function such that
A4: s1 = g1 and
A5: dom g1 = dom SCMPDS-OK and
  for x being set st x in dom SCMPDS-OK holds g1.x in SCMPDS-OK.x by
CARD_3:def 5;
  consider g2 being Function such that
A6: s2 = g2 and
A7: dom g2 = dom SCMPDS-OK and
  for x being set st x in dom SCMPDS-OK holds g2.x in SCMPDS-OK.x by
CARD_3:def 5;
A8: now
    let x be set;
    assume
    x in SCM-Memory;
    then
A9: x in {IC SCMPDS} \/ SCM-Data-Loc or x in NAT by Th6,XBOOLE_0:def 3;
    per cases by A9,XBOOLE_0:def 3;
    suppose
      x in {IC SCMPDS};
      then x = IC SCMPDS by TARSKI:def 1;
      hence g1.x = g2.x by A1,A4,A6;
    end;
    suppose
      x in SCM-Data-Loc;
      then x is Int_position by Def2;
      hence g1.x = g2.x by A2,A4,A6;
    end;
    suppose
      x in NAT;
      then reconsider l = x as Instruction-Location of SCMPDS by AMI_1:def 4;
      g1.l = g2.l by A3,A4,A6;
      hence g1.x = g2.x;
    end;
  end;
  SCM-Memory = dom g1 by A5,FUNCT_2:def 1;
  hence thesis by A4,A5,A6,A7,A8,FUNCT_1:9;
end;

begin :: Execution semantics of the SCMPDS instructions

canceled 2;

theorem Th57:
  Exec( a:=k1, s).IC SCMPDS = Next IC s & Exec( a:=k1, s).a = k1 &
  for b st b <> a holds Exec( a:=k1, s).b = s.b
proof
  reconsider S = s as SCMPDS-State;
  reconsider mk = a as Element of SCM-Data-Loc by Def2;
  reconsider I = a:=k1 as Element of SCMPDS-Instr;
  set S1 = SCM-Chg(S, I P21address, I P22const);
  reconsider i = 2 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*mk,k1*>];
  then
A2: I P21address = mk by SCMPDS_1:35;
A3: I P22const = k1 by A1,SCMPDS_1:35;
A4: Exec(a:=k1, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec(a:=k1, s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
  thus Exec(a:=k1, s).a = S1.mk by A4,SCMPDS_1:27
    .= k1 by A2,A3,SCMPDS_1:30;
  let b;
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  assume
A5: b <> a;
  thus Exec(a:=k1, s).b = S1.mn by A4,SCMPDS_1:27
    .= s.b by A2,A5,SCMPDS_1:31;
end;

theorem Th58:
  Exec((a,k1):=k2, s).IC SCMPDS = Next IC s & Exec((a,k1):=k2, s).
DataLoc(s.a,k1) = k2 & for b st b <> DataLoc(s.a,k1) holds Exec((a,k1):=k2, s).
  b = s.b
proof
  reconsider S = s as SCMPDS-State;
  reconsider mk = a as Element of SCM-Data-Loc by Def2;
  reconsider I = (a,k1):=k2 as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P31address,I P32const), S1 = SCM-Chg(S, A2, I
  P33const);
  reconsider i = 7 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*mk,k1,k2*>];
  then
A2: I P33const = k2 by SCMPDS_1:36;
A3: Exec((a,k1):=k2, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec((a,k1):=k2, s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P31address = mk & I P32const = k1 by A1,SCMPDS_1:36;
  hence Exec((a,k1):=k2, s).DataLoc(s.a,k1) = S1.A2 by A3,SCMPDS_1:27
    .= k2 by A2,SCMPDS_1:30;
  let b;
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  assume
A5: b <> DataLoc(s.a,k1);
  thus Exec((a,k1):=k2, s).b = S1.mn by A3,SCMPDS_1:27
    .= s.b by A4,A5,SCMPDS_1:31;
end;

theorem Th59:
  Exec((a,k1):=(b,k2), s).IC SCMPDS = Next IC s & Exec((a,k1):=(b,
  k2), s).DataLoc(s.a,k1) = s.DataLoc(s.b,k2) & for c st c <> DataLoc(s.a,k1)
  holds Exec((a,k1):=(b,k2),s).c = s.c
proof
  reconsider S = s as SCMPDS-State;
  reconsider da = a,db=b as Element of SCM-Data-Loc by Def2;
  reconsider I = (a,k1):=(b,k2) as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P41address,I P43const), A4=Address_Add(S,I P42address
  ,I P44const), S1 = SCM-Chg(S, A2, S.A4);
  reconsider i = 13 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*da,db,k1,k2*>];
  then
A2: I P42address = db & I P44const = k2 by SCMPDS_1:37;
A3: Exec((a,k1):=(b,k2), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec((a,k1):=(b,k2), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P41address = da & I P43const = k1 by A1,SCMPDS_1:37;
  hence Exec((a,k1):=(b,k2), s).DataLoc(s.a,k1) = S1.A2 by A3,SCMPDS_1:27
    .= s.DataLoc(s.b,k2) by A2,SCMPDS_1:30;
  let c;
  reconsider mn = c as Element of SCM-Data-Loc by Def2;
  assume
A5: c <> DataLoc(s.a,k1);
  thus Exec((a,k1):=(b,k2), s).c = S1.mn by A3,SCMPDS_1:27
    .= s.c by A4,A5,SCMPDS_1:31;
end;

theorem Th60:
  Exec(AddTo(a,k1,k2), s).IC SCMPDS = Next IC s & Exec(AddTo(a,k1,
  k2), s).DataLoc(s.a,k1)=s.DataLoc(s.a,k1)+k2 & for b st b <>DataLoc(s.a,k1)
  holds Exec(AddTo(a,k1,k2), s).b = s.b
proof
  reconsider S = s as SCMPDS-State;
  reconsider mk = a as Element of SCM-Data-Loc by Def2;
  reconsider I = AddTo(a,k1,k2) as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P31address,I P32const), S1 = SCM-Chg(S, A2, S.A2+I
  P33const);
  reconsider i = 8 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*mk,k1,k2*>];
  then
A2: I P33const = k2 by SCMPDS_1:36;
A3: Exec(AddTo(a,k1,k2), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec(AddTo(a,k1,k2), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P31address = mk & I P32const = k1 by A1,SCMPDS_1:36;
  hence Exec(AddTo(a,k1,k2), s).DataLoc(s.a,k1) = S1.A2 by A3,SCMPDS_1:27
    .= s.DataLoc(s.a,k1)+k2 by A4,A2,SCMPDS_1:30;
  let c;
  reconsider mn = c as Element of SCM-Data-Loc by Def2;
  assume
A5: c <> DataLoc(s.a,k1);
  thus Exec(AddTo(a,k1,k2), s).c = S1.mn by A3,SCMPDS_1:27
    .= s.c by A4,A5,SCMPDS_1:31;
end;

theorem Th61:
  Exec(AddTo(a,k1,b,k2), s).IC SCMPDS = Next IC s & Exec(AddTo(a,
k1,b,k2), s).DataLoc(s.a,k1) = s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) & for c st
  c <> DataLoc(s.a,k1) holds Exec(AddTo(a,k1,b,k2),s).c = s.c
proof
  reconsider S = s as SCMPDS-State;
  reconsider da = a,db=b as Element of SCM-Data-Loc by Def2;
  reconsider I = AddTo(a,k1,b,k2) as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P41address,I P43const), A4=Address_Add(S,I P42address
  ,I P44const), S1 = SCM-Chg(S, A2, S.A2+S.A4);
  reconsider i = 9 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*da,db,k1,k2*>];
  then
A2: I P42address = db & I P44const = k2 by SCMPDS_1:37;
A3: Exec(AddTo(a,k1,b,k2), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec(AddTo(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P41address = da & I P43const = k1 by A1,SCMPDS_1:37;
  hence Exec(AddTo(a,k1,b,k2), s).DataLoc(s.a,k1) = S1.A2 by A3,SCMPDS_1:27
    .= s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) by A4,A2,SCMPDS_1:30;
  let c;
  reconsider mn = c as Element of SCM-Data-Loc by Def2;
  assume
A5: c <> DataLoc(s.a,k1);
  thus Exec(AddTo(a,k1,b,k2), s).c = S1.mn by A3,SCMPDS_1:27
    .= s.c by A4,A5,SCMPDS_1:31;
end;

theorem Th62:
  Exec(SubFrom(a,k1,b,k2), s).IC SCMPDS = Next IC s & Exec(SubFrom
(a,k1,b,k2), s).DataLoc(s.a,k1) = s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) & for c
  st c <> DataLoc(s.a,k1) holds Exec(SubFrom(a,k1,b,k2),s).c = s.c
proof
  reconsider S = s as SCMPDS-State;
  reconsider da = a,db=b as Element of SCM-Data-Loc by Def2;
  reconsider I = SubFrom(a,k1,b,k2) as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P41address,I P43const), A4=Address_Add(S,I P42address
  ,I P44const), S1 = SCM-Chg(S, A2, S.A2-S.A4);
  reconsider i = 10 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*da,db,k1,k2*>];
  then
A2: I P42address = db & I P44const = k2 by SCMPDS_1:37;
A3: Exec(SubFrom(a,k1,b,k2), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec(SubFrom(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P41address = da & I P43const = k1 by A1,SCMPDS_1:37;
  hence Exec(SubFrom(a,k1,b,k2), s).DataLoc(s.a,k1) = S1.A2 by A3,SCMPDS_1:27
    .= s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) by A4,A2,SCMPDS_1:30;
  let c;
  reconsider mn = c as Element of SCM-Data-Loc by Def2;
  assume
A5: c <> DataLoc(s.a,k1);
  thus Exec(SubFrom(a,k1,b,k2), s).c = S1.mn by A3,SCMPDS_1:27
    .= s.c by A4,A5,SCMPDS_1:31;
end;

theorem Th63:
  Exec(MultBy(a,k1,b,k2), s).IC SCMPDS = Next IC s & Exec(MultBy(a
  ,k1,b,k2), s).DataLoc(s.a,k1) = s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) & for c
  st c <> DataLoc(s.a,k1) holds Exec(MultBy(a,k1,b,k2),s).c = s.c
proof
  reconsider S = s as SCMPDS-State;
  reconsider da = a,db=b as Element of SCM-Data-Loc by Def2;
  reconsider I = MultBy(a,k1,b,k2) as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P41address,I P43const), A4=Address_Add(S,I P42address
  ,I P44const), S1 = SCM-Chg(S, A2, S.A2*S.A4);
  reconsider i = 11 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*da,db,k1,k2*>];
  then
A2: I P42address = db & I P44const = k2 by SCMPDS_1:37;
A3: Exec(MultBy(a,k1,b,k2), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= (SCM-Chg(S1, succ IC S)) by A1,SCMPDS_1:def 24;
  hence Exec(MultBy(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P41address = da & I P43const = k1 by A1,SCMPDS_1:37;
  hence Exec(MultBy(a,k1,b,k2), s).DataLoc(s.a,k1) = S1.A2 by A3,SCMPDS_1:27
    .= s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) by A4,A2,SCMPDS_1:30;
  let c;
  reconsider mn = c as Element of SCM-Data-Loc by Def2;
  assume
A5: c <> DataLoc(s.a,k1);
  thus Exec(MultBy(a,k1,b,k2), s).c = S1.mn by A3,SCMPDS_1:27
    .= s.c by A4,A5,SCMPDS_1:31;
end;

theorem Th64:
  Exec(Divide(a,k1,b,k2), s).IC SCMPDS = Next IC s & (DataLoc(s.a,
k1) <> DataLoc(s.b,k2) implies Exec(Divide(a,k1,b,k2), s).DataLoc(s.a,k1) = s.
DataLoc(s.a,k1) div s.DataLoc(s.b,k2)) & Exec(Divide(a,k1,b,k2), s).DataLoc(s.b
,k2) = s.DataLoc(s.a,k1) mod s.DataLoc(s.b,k2) & for c st c <> DataLoc(s.a,k1)
  & c <> DataLoc(s.b,k2) holds Exec(Divide(a,k1,b,k2),s).c = s.c
proof
  reconsider S = s as SCMPDS-State;
  reconsider da = a,db=b as Element of SCM-Data-Loc by Def2;
  reconsider I = Divide(a,k1,b,k2) as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P41address,I P43const), A4=Address_Add(S,I P42address
,I P44const), S1 = SCM-Chg(S, A2,S.A2 div S.A4), S2 = SCM-Chg(S1,A4,S.A2 mod S.
  A4);
  reconsider i = 12 as Element of Segm 14 by NAT_1:45;
  set Da=DataLoc(s.a,k1), Db=DataLoc(s.b,k2);
A1: I = [ i, <*da,db,k1,k2*>];
  then
A2: I P41address = da & I P43const = k1 by SCMPDS_1:37;
A3: Exec(Divide(a,k1,b,k2), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= SCM-Chg(S2, succ IC S) by A1,SCMPDS_1:def 24;
  hence Exec(Divide(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
A4: I P42address = db & I P44const = k2 by A1,SCMPDS_1:37;
  hereby
    reconsider mn = Da as Element of SCM-Data-Loc by Def2;
    assume
A5: Da <> DataLoc(s.b,k2);
    thus Exec(Divide(a,k1,b,k2), s).Da = S2.mn by A3,SCMPDS_1:27
      .= S1.A2 by A2,A4,A5,SCMPDS_1:31
      .= s.Da div s.Db by A2,A4,SCMPDS_1:30;
  end;
  thus Exec(Divide(a,k1,b,k2), s).DataLoc(s.b,k2) = S2.A4 by A3,A4,SCMPDS_1:27
    .= s.Da mod s.Db by A2,A4,SCMPDS_1:30;
  let c;
  reconsider mn = c as Element of SCM-Data-Loc by Def2;
  assume that
A6: c <> Da and
A7: c <> Db;
  thus Exec(Divide(a,k1,b,k2), s).c = S2.mn by A3,SCMPDS_1:27
    .= S1.mn by A4,A7,SCMPDS_1:31
    .= s.c by A2,A6,SCMPDS_1:31;
end;

theorem
  Exec(Divide(a,k1,a,k1), s).IC SCMPDS = Next IC s & Exec(Divide(a,k1,a,
k1), s).DataLoc(s.a,k1) = s.DataLoc(s.a,k1) mod s.DataLoc(s.a,k1) & for c st c
  <> DataLoc(s.a,k1) holds Exec(Divide(a,k1,a,k1),s).c = s.c by Th64;

definition
  canceled;
  let s be State of SCMPDS,c be Integer;
  func ICplusConst(s,c) -> Instruction-Location of SCMPDS means
  :Def20:
  ex m
  be Element of NAT st m = IC s & it = abs(m+c);
  existence
  proof
    reconsider m1=IC s as Element of NAT by AMI_1:def 4;
    consider k being Element of NAT such that
A1: m1 = k;
    reconsider m=abs(k+c) as Nat;
    reconsider l = m as Instruction-Location of SCMPDS by AMI_1:def 4;
    take l;
    thus thesis by A1;
  end;
  correctness;
end;

theorem Th66:
  Exec(goto k1, s).IC SCMPDS = ICplusConst(s,k1) & for a holds
  Exec(goto k1, s).a = s.a
proof
  reconsider i = 0 as Element of Segm 14 by NAT_1:45;
  reconsider I = goto k1 as Element of SCMPDS-Instr;
  reconsider S = s as SCMPDS-State;
A1: Exec(goto k1, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .=SCM-Chg(S,jump_address(S,I const_INT)) by SCMPDS_1:def 24;
  I = [ i, <*k1*>];
  then
A2: I const_INT = k1 by SCMPDS_1:34;
  ex n be Element of NAT st n=IC s & ICplusConst(s,k1)=abs (n+k1) by Def20;
  hence Exec(goto k1, s).IC SCMPDS =ICplusConst(s,k1) by A1,A2,Th6,SCMPDS_1:26;
  let a;
  reconsider mn = a as Element of SCM-Data-Loc by Def2;
  thus Exec(goto k1, s).a = S.mn by A1,SCMPDS_1:27
    .= s.a;
end;

theorem Th67:
  ( s.DataLoc(s.a,k1) <> 0 implies Exec((a,k1)<>0_goto k2, s).IC
  SCMPDS = ICplusConst(s,k2)) & ( s.DataLoc(s.a,k1) = 0 implies Exec((a,k1)
  <>0_goto k2, s).IC SCMPDS = Next IC s ) & Exec((a,k1)<>0_goto k2, s).b = s.b
proof
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  reconsider S = s as SCMPDS-State;
A1: ex n be Element of NAT st n=IC s & ICplusConst(s,k2)=abs (n+k2) by Def20;
  reconsider da = a as Element of SCM-Data-Loc by Def2;
  reconsider I = (a,k1)<>0_goto k2 as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P31address,I P32const), JP=jump_address(S,I P33const)
  , IF=IFEQ(S.A2, 0, succ IC S,JP), Da=DataLoc(s.a,k1);
  reconsider i = 4 as Element of Segm 14 by NAT_1:45;
A2: I = [ i, <*da,k1,k2*>];
  then
A3: I P31address = da & I P32const = k1 by SCMPDS_1:36;
A4: Exec((a,k1)<>0_goto k2, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .=SCM-Chg(S,IF) by A2,SCMPDS_1:def 24;
A5: I P33const = k2 by A2,SCMPDS_1:36;
  thus s.Da <> 0 implies Exec((a,k1)<>0_goto k2,s).IC SCMPDS = ICplusConst(s,
  k2)
  proof
    assume
A6: s.Da <> 0;
    thus Exec((a,k1)<>0_goto k2, s).IC SCMPDS = IF by A4,Th6,SCMPDS_1:26
      .=ICplusConst(s,k2) by A3,A5,A1,A6,Th6,FUNCOP_1:def 8;
  end;
  thus s.Da = 0 implies Exec((a,k1)<>0_goto k2,s).IC SCMPDS = Next IC s
  proof
    assume
A7: s.Da = 0;
    thus Exec((a,k1)<>0_goto k2, s).IC SCMPDS = IF by A4,Th6,SCMPDS_1:26
      .= succ IC S by A3,A7,FUNCOP_1:def 8
      .= Next IC s by AMI_2:30,FUNCT_7:def 1;
  end;
  thus Exec((a,k1)<>0_goto k2, s).b = S.mn by A4,SCMPDS_1:27
    .= s.b;
end;

theorem Th68:
  ( s.DataLoc(s.a,k1) <= 0 implies Exec((a,k1)<=0_goto k2, s).IC
  SCMPDS = ICplusConst(s,k2)) & ( s.DataLoc(s.a,k1) > 0 implies Exec((a,k1)
  <=0_goto k2, s).IC SCMPDS = Next IC s ) & Exec((a,k1)<=0_goto k2, s).b = s.b
proof
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  reconsider S = s as SCMPDS-State;
A1: ex n be Element of NAT st n=IC s & ICplusConst(s,k2)=abs (n+k2) by Def20;
  reconsider da = a as Element of SCM-Data-Loc by Def2;
  reconsider I = (a,k1)<=0_goto k2 as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P31address,I P32const), JP=jump_address(S,I P33const)
  , IF=IFGT(S.A2, 0, succ IC S,JP), Da=DataLoc(s.a,k1);
  reconsider i = 5 as Element of Segm 14 by NAT_1:45;
A2: I = [ i, <*da,k1,k2*>];
  then
A3: I P31address = da & I P32const = k1 by SCMPDS_1:36;
A4: Exec((a,k1)<=0_goto k2, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .=SCM-Chg(S,IF) by A2,SCMPDS_1:def 24;
A5: I P33const = k2 by A2,SCMPDS_1:36;
  thus s.Da <= 0 implies Exec((a,k1)<=0_goto k2,s).IC SCMPDS = ICplusConst(s,
  k2)
  proof
    assume
A6: s.Da <= 0;
    thus Exec((a,k1)<=0_goto k2, s).IC SCMPDS = IF by A4,Th6,SCMPDS_1:26
      .=ICplusConst(s,k2) by A3,A5,A1,A6,Th6,XXREAL_0:def 11;
  end;
  thus s.Da > 0 implies Exec((a,k1)<=0_goto k2,s).IC SCMPDS = Next IC s
  proof
    assume
A7: s.Da > 0;
    thus Exec((a,k1)<=0_goto k2, s).IC SCMPDS = IF by A4,Th6,SCMPDS_1:26
      .= succ IC S by A3,A7,XXREAL_0:def 11
      .= Next IC s by AMI_2:30,FUNCT_7:def 1;
  end;
  thus Exec((a,k1)<=0_goto k2, s).b = S.mn by A4,SCMPDS_1:27
    .= s.b;
end;

theorem Th69:
  ( s.DataLoc(s.a,k1) >= 0 implies Exec((a,k1)>=0_goto k2, s).IC
  SCMPDS = ICplusConst(s,k2)) & ( s.DataLoc(s.a,k1) < 0 implies Exec((a,k1)
  >=0_goto k2, s).IC SCMPDS = Next IC s ) & Exec((a,k1)>=0_goto k2, s).b = s.b
proof
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  reconsider S = s as SCMPDS-State;
A1: ex n be Element of NAT st n=IC s & ICplusConst(s,k2)=abs (n+k2) by Def20;
  reconsider da = a as Element of SCM-Data-Loc by Def2;
  reconsider I = (a,k1)>=0_goto k2 as Element of SCMPDS-Instr;
  set A2=Address_Add(S,I P31address,I P32const), JP=jump_address(S,I P33const)
  , IF=IFGT(0, S.A2, succ IC S,JP), Da=DataLoc(s.a,k1);
  reconsider i = 6 as Element of Segm 14 by NAT_1:45;
A2: I = [ i, <*da,k1,k2*>];
  then
A3: I P31address = da & I P32const = k1 by SCMPDS_1:36;
A4: Exec((a,k1)>=0_goto k2, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .=SCM-Chg(S,IF) by A2,SCMPDS_1:def 24;
A5: I P33const = k2 by A2,SCMPDS_1:36;
  thus s.Da >= 0 implies Exec((a,k1)>=0_goto k2,s).IC SCMPDS = ICplusConst(s,
  k2)
  proof
    assume
A6: s.Da >= 0;
    thus Exec((a,k1)>=0_goto k2, s).IC SCMPDS = IF by A4,Th6,SCMPDS_1:26
      .=ICplusConst(s,k2) by A3,A5,A1,A6,Th6,XXREAL_0:def 11;
  end;
  thus s.Da < 0 implies Exec((a,k1)>=0_goto k2,s).IC SCMPDS = Next IC s
  proof
    assume
A7: s.Da < 0;
    thus Exec((a,k1)>=0_goto k2, s).IC SCMPDS = IF by A4,Th6,SCMPDS_1:26
      .= succ IC S by A3,A7,XXREAL_0:def 11
      .= Next IC s by AMI_2:30,FUNCT_7:def 1;
  end;
  thus Exec((a,k1)>=0_goto k2, s).b = S.mn by A4,SCMPDS_1:27
    .= s.b;
end;

theorem Th70:
  Exec(return a, s).IC SCMPDS = (abs(s.DataLoc(s.a,RetIC)))+2 &
Exec(return a, s).a = s.DataLoc(s.a,RetSP) & for b st a <> b holds Exec(return
  a, s).b = s.b
proof
  reconsider S = s as SCMPDS-State;
  reconsider da = a as Element of SCM-Data-Loc by Def2;
  reconsider I = return a as Element of SCMPDS-Instr;
  set A1 =Address_Add(S,I address_1,RetSP), S1 =SCM-Chg(S,I address_1,S.A1),
  A2=Address_Add(S,I address_1,RetIC), lc=PopInstrLoc(S,A2);
  reconsider i = 1 as Element of Segm 14 by NAT_1:45;
A1: I = [ i, <*da*>];
  then
A2: I address_1 = da by SCMPDS_1:33;
A3: Exec(return a, s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= SCM-Chg(S1,lc) by A1,SCMPDS_1:def 24;
  hence Exec(return a, s).IC SCMPDS =(abs(s.DataLoc(s.a,RetIC)))+2 by A2,Th6,
SCMPDS_1:26;
  thus Exec(return a, s).a = S1.da by A3,SCMPDS_1:27
    .= s.DataLoc(s.a,RetSP) by A2,SCMPDS_1:30;
  let b;
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  assume
A4: b <> a;
  thus Exec(return a, s).b = S1.mn by A3,SCMPDS_1:27
    .= s.b by A2,A4,SCMPDS_1:31;
end;

theorem Th71:
  Exec(saveIC(a,k1),s).IC SCMPDS = Next IC s & Exec(saveIC(a,k1),
s).DataLoc(s.a,k1) = IC s & for b st DataLoc(s.a,k1) <> b holds Exec(saveIC(a,
  k1), s).b = s.b
proof
  reconsider S = s as SCMPDS-State;
  reconsider m = IC S as Element of NAT;
  reconsider da = a as Element of SCM-Data-Loc by Def2;
  reconsider I = saveIC(a,k1) as Element of SCMPDS-Instr;
  set A1=Address_Add(S,I P21address,I P22const), S1=SCM-Chg(S, A1,m);
  reconsider i = 3 as Element of Segm 14 by NAT_1:45;
  set DL=DataLoc(s.a,k1);
A1: I = [ i, <*da,k1*>];
  then
A2: I P21address = da & I P22const = k1 by SCMPDS_1:35;
A3: Exec(saveIC(a,k1), s) = SCM-Exec-Res(I,S) by SCMPDS_1:def 25
    .= SCM-Chg(S1,succ IC S) by A1,SCMPDS_1:def 24;
  hence Exec(saveIC(a,k1), s).IC SCMPDS = Next IC s by Th6,SCMPDS_1:26;
  thus Exec(saveIC(a,k1), s).DL =S1.A1 by A3,A2,SCMPDS_1:27
    .=IC s by Th6,SCMPDS_1:30;
  let b;
  reconsider mn = b as Element of SCM-Data-Loc by Def2;
  assume
A4: DL <> b;
  thus Exec(saveIC(a,k1),s).b = S1.mn by A3,SCMPDS_1:27
    .= s.b by A2,A4,SCMPDS_1:31;
end;

theorem Th72:
  for k be Integer holds ex f being Function of SCM-Data-Loc,INT
  st for x being Element of SCM-Data-Loc holds f.x = k
proof
  let k be Integer;
  defpred X[set,set] means $2 = k;
A1: now
    reconsider y=k as Element of INT by INT_1:def 2;
    let x be Element of SCM-Data-Loc;
    take y;
    thus X[x,y];
  end;
  thus ex f being Function of SCM-Data-Loc,INT st for x being Element of
  SCM-Data-Loc holds X[x,f.x] from FUNCT_2:sch 3(A1);
end;

theorem Th73:
  for k be Integer holds ex s be State of SCMPDS st for d being
  Int_position holds s.d = k
proof
  set f = the Object-Kind of SCMPDS;
  consider S being SCMPDS-State;
  let k be Integer;
A1: dom S = dom SCMPDS-OK by CARD_3:18;
A2: dom f = SCM-Memory by FUNCT_2:def 1;
  consider g be Function of SCM-Data-Loc,INT such that
A3: for x be Element of SCM-Data-Loc holds g.x = k by Th72;
  set t = S +* g;
A4: for x being set st x in dom f holds t.x in f.x
  proof
    let x be set such that
A5: x in dom f;
    per cases;
    suppose
A6:   x in dom g;
      then
A7:   x in SCM-Data-Loc by FUNCT_2:def 1;
      then
A8:   f.x = INT by SCMPDS_1:21;
      t.x = g.x by A6,FUNCT_4:14
        .= k by A3,A7;
      hence thesis by A8,INT_1:def 2;
    end;
    suppose
      not x in dom g;
      then t.x = S.x by FUNCT_4:12;
      hence thesis by A5,CARD_3:18;
    end;
  end;
  dom t = dom S \/ dom g by FUNCT_4:def 1
    .= SCM-Memory \/ dom g by A1,FUNCT_2:def 1
    .= SCM-Memory \/ SCM-Data-Loc by FUNCT_2:def 1
    .= SCM-Memory by XBOOLE_1:12;
  then reconsider s=t as State of SCMPDS by A2,A4,CARD_3:18;
  take s;
  let d be Int_position;
  reconsider D = d as Element of SCM-Data-Loc by Def2;
  D in SCM-Data-Loc;
  then D in dom g by FUNCT_2:def 1;
  hence s.d =g.D by FUNCT_4:14
    .=k by A3;
end;

theorem Th74:
  for k be Integer,loc be Instruction-Location of SCMPDS holds ex
  s be State of SCMPDS st s.NAT=loc & for d being Int_position holds s.d = k
proof
  set f = the Object-Kind of SCMPDS;
  let k be Integer,loc be Instruction-Location of SCMPDS;
A1: {NAT} c= SCM-Memory by AMI_2:30,ZFMISC_1:37;
A2: dom f = SCM-Memory by FUNCT_2:def 1;
  consider s1 be State of SCMPDS such that
A3: for d being Int_position holds s1.d = k by Th73;
  reconsider S = s1 as SCMPDS-State;
  set t = S +* (NAT.--> loc);
A4: dom S = dom SCMPDS-OK by CARD_3:18;
A5: dom(NAT .--> loc) = {NAT} by FUNCOP_1:19;
  then NAT in dom (NAT.--> loc) by TARSKI:def 1;
  then
A6: t.NAT = (NAT.--> loc).NAT by FUNCT_4:14
    .= loc by FUNCOP_1:87;
  then
A7: t.NAT in NAT by AMI_1:def 4;
A8: for x being set st x in dom f holds t.x in f.x
  proof
    let x be set such that
A9: x in dom f;
    per cases;
    suppose
      x = NAT;
      hence thesis by A7,AMI_2:30,SCMPDS_1:18;
    end;
    suppose
      x <> NAT;
      then not x in dom (NAT.--> loc) by A5,TARSKI:def 1;
      then t.x = S.x by FUNCT_4:12;
      hence thesis by A9,CARD_3:18;
    end;
  end;
  dom t = dom S \/ dom (NAT.--> loc) by FUNCT_4:def 1
    .= SCM-Memory \/ dom (NAT.--> loc) by A4,FUNCT_2:def 1
    .= SCM-Memory \/ {NAT} by FUNCOP_1:19
    .= SCM-Memory by A1,XBOOLE_1:12;
  then reconsider s=t as State of SCMPDS by A2,A8,CARD_3:18;
  take s;
  thus s.NAT=loc by A6;
  hereby
    let d be Int_position;
    d in SCM-Data-Loc by Def2;
    then
A10: ex j be Element of NAT st d=[1,j] by AMI_2:32;
    now
      assume
      d in dom (NAT.--> loc);
      then d = NAT by A5,TARSKI:def 1;
      hence contradiction by A10,ARYTM_3:36;
    end;
    hence s.d=s1.d by FUNCT_4:12
      .=k by A3;
  end;
end;

theorem Th75:
  goto 0 is halting
proof
  set I=goto 0;
  let s be State of SCMPDS;
  reconsider S = s as SCMPDS-State;
  reconsider Es = Exec(I, s) as SCMPDS-State;
A1: dom Es = dom SCMPDS-OK by CARD_3:18
    .= SCM-Memory by FUNCT_2:def 1;
A2: now
    let x be set;
A3: dom SCMPDS-OK = SCM-Memory by FUNCT_2:def 1;
    assume
    x in dom s;
    then reconsider m=x as Element of SCM-Memory by A3,CARD_3:18;
    per cases by SCMPDS_1:14;
    suppose
A4:   m=NAT;
      reconsider n=IC s as Element of NAT by AMI_1:def 4;
      consider k being Element of NAT such that
A5:   n=k;
A6:   n >= 0 by NAT_1:2;
      ex m be Element of NAT st m=IC s & ICplusConst(s,0)=abs( m+2*0) by Def20;
      hence Es.x=abs(0+k) by A4,A5,Th6,Th66
        .= k by A5,A6,ABSVALUE:def 1
        .=S.x by A4,A5,FUNCT_7:def 1;
    end;
    suppose
      m in SCM-Data-Loc;
      then reconsider d=x as Int_position by Def2;
      thus Es.x=s.d by Th66
        .=S.x;
    end;
    suppose
      m in NAT;
      then reconsider v=x as Element of NAT;
      reconsider I0=I as Element of SCMPDS-Instr;
      Exec(I, s) = SCM-Exec-Res(I0,S) by SCMPDS_1:def 25
        .=SCM-Chg(S,jump_address(S,I0 const_INT)) by SCMPDS_1:def 24;
      hence Es.x= S.v by SCMPDS_1:28
        .=S.x;
    end;
  end;
  dom S = dom SCMPDS-OK by CARD_3:18
    .= SCM-Memory by FUNCT_2:def 1;
  hence thesis by A2,A1,FUNCT_1:9;
end;

theorem Th76:
  for I being Instruction of SCMPDS st ex s st Exec(I,s).IC SCMPDS
  = Next IC s holds I is non halting
proof
  let I be Instruction of SCMPDS;
  given s such that
A1: Exec(I, s).IC SCMPDS = Next IC s;
  assume
  I is halting;
  then Exec(I,s).IC SCMPDS = s.NAT by Th6,AMI_1:def 8;
  hence contradiction by A1,Th6;
  IC s = s.NAT by AMI_2:30,FUNCT_7:def 1;
  then reconsider w = s.NAT as Instruction-Location of SCMPDS;
end;

theorem Th77:
  a:=k1 is non halting
proof
  consider s being State of SCMPDS;
  Exec(a:=k1, s).IC SCMPDS = Next IC s by Th57;
  hence thesis by Th76;
end;

theorem Th78:
  (a,k1):=k2 is non halting
proof
  consider s being State of SCMPDS;
  Exec((a,k1):=k2, s).IC SCMPDS = Next IC s by Th58;
  hence thesis by Th76;
end;

theorem Th79:
  (a,k1):=(b,k2) is non halting
proof
  consider s being State of SCMPDS;
  Exec((a,k1):=(b,k2), s).IC SCMPDS = Next IC s by Th59;
  hence thesis by Th76;
end;

theorem Th80:
  AddTo(a,k1,k2) is non halting
proof
  consider s being State of SCMPDS;
  Exec(AddTo(a,k1,k2), s).IC SCMPDS = Next IC s by Th60;
  hence thesis by Th76;
end;

theorem Th81:
  AddTo(a,k1,b,k2) is non halting
proof
  consider s being State of SCMPDS;
  Exec(AddTo(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th61;
  hence thesis by Th76;
end;

theorem Th82:
  SubFrom(a,k1,b,k2) is non halting
proof
  consider s being State of SCMPDS;
  Exec(SubFrom(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th62;
  hence thesis by Th76;
end;

theorem Th83:
  MultBy(a,k1,b,k2) is non halting
proof
  consider s being State of SCMPDS;
  Exec(MultBy(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th63;
  hence thesis by Th76;
end;

theorem Th84:
  Divide(a,k1,b,k2) is non halting
proof
  consider s being State of SCMPDS;
  Exec(Divide(a,k1,b,k2), s).IC SCMPDS = Next IC s by Th64;
  hence thesis by Th76;
end;

theorem Th85:
  k1 <> 0 implies goto k1 is non halting
proof
  assume
A1: k1<>0;
  set n=abs(k1);
  reconsider loc=n+1 as Instruction-Location of SCMPDS by AMI_1:def 4;
  consider s be State of SCMPDS such that
A2: s.NAT=loc and
  for d being Int_position holds s.d = 0 by Th74;
  -n<=k1 by ABSVALUE:11;
  then 0-n<=k1;
  then
A3: (n+k1)*1>=0 by XREAL_1:22;
  ex m be Element of NAT st m=IC s & ICplusConst(s,k1)=abs (m+k1) by Def20;
  then
A4: Exec(goto k1, s).IC SCMPDS = abs(n+k1+1) by A2,Th6,Th66
    .= (abs(n+k1)+abs(1)) by A3,ABSVALUE:24
    .=abs((n+k1))+1 by ABSVALUE:def 1
    .=(n+k1)+1 by A3,ABSVALUE:def 1
    .=n+1+k1;
  assume
  goto k1 is halting;
  then Exec(goto k1,s).IC SCMPDS = n+1 by A2,Th6,AMI_1:def 8;
  hence contradiction by A1,A4;
end;

theorem Th86:
  (a,k1)<>0_goto k2 is non halting
proof
  consider s being State of SCMPDS such that
A1: for d being Int_position holds s.d = 0 by Th73;
  s.DataLoc(s.a,k1) = 0 by A1;
  then Exec((a,k1)<>0_goto k2, s).IC SCMPDS = Next IC s by Th67;
  hence thesis by Th76;
end;

theorem Th87:
  (a,k1)<=0_goto k2 is non halting
proof
  consider s being State of SCMPDS such that
A1: for d being Int_position holds s.d = 1 by Th73;
  s.DataLoc(s.a,k1) = 1 by A1;
  then Exec((a,k1)<=0_goto k2, s).IC SCMPDS = Next IC s by Th68;
  hence thesis by Th76;
end;

theorem Th88:
  (a,k1)>=0_goto k2 is non halting
proof
  consider s being State of SCMPDS such that
A1: for d being Int_position holds s.d = -1 by Th73;
  s.DataLoc(s.a,k1) = -1 by A1;
  then Exec((a,k1)>=0_goto k2, s).IC SCMPDS = Next IC s by Th69;
  hence thesis by Th76;
end;

theorem Th89:
  return a is non halting
proof
  reconsider loc=1 as Instruction-Location of SCMPDS by AMI_1:def 4;
A1: In(NAT,SCM-Memory) = NAT by AMI_2:30,FUNCT_7:def 1;
  consider s be State of SCMPDS such that
A2: s.NAT=loc and
A3: for d being Int_position holds s.d = 0 by Th74;
  Exec(return a, s).IC SCMPDS = (abs(s.DataLoc(s.a,RetIC)))+2 by Th70
    .=(abs(0))+2 by A3
    .=0+2 by ABSVALUE:def 1
    .=Next IC s by A2,A1;
  hence thesis by Th76;
end;

theorem Th90:
  saveIC(a,k1) is non halting
proof
  consider s being State of SCMPDS;
  Exec(saveIC(a,k1), s).IC SCMPDS = Next IC s by Th71;
  hence thesis by Th76;
end;

theorem Th91:
  for I being set holds I is Instruction of SCMPDS iff (ex k1 st I
= goto k1) or (ex a st I = return a) or (ex a,k1 st I = saveIC(a,k1)) or (ex a,
k1 st I = a:=k1) or (ex a,k1,k2 st I = (a,k1):=k2) or (ex a,k1,k2 st I = (a,k1)
<>0_goto k2) or (ex a,k1,k2 st I = (a,k1)<=0_goto k2) or (ex a,k1,k2 st I = (a,
k1)>=0_goto k2) or (ex a,b,k1,k2 st I = AddTo(a,k1,k2)) or (ex a,b,k1,k2 st I =
AddTo(a,k1,b,k2)) or (ex a,b,k1,k2 st I = SubFrom(a,k1,b,k2)) or (ex a,b,k1,k2
st I = MultBy(a,k1,b,k2)) or (ex a,b,k1,k2 st I = Divide(a,k1,b,k2)) or ex a,b,
  k1,k2 st I = (a,k1):=(b,k2)
proof
  let I be set;
  thus I is Instruction of SCMPDS implies (ex k1 st I = goto k1) or (ex a st I
= return a) or (ex a,k1 st I = saveIC(a,k1)) or (ex a,k1 st I = a:=k1) or (ex a
,k1,k2 st I = (a,k1):=k2) or (ex a,k1,k2 st I = (a,k1)<>0_goto k2) or (ex a,k1,
k2 st I = (a,k1)<=0_goto k2) or (ex a,k1,k2 st I = (a,k1)>=0_goto k2) or (ex a,
b,k1,k2 st I = AddTo(a,k1,k2)) or (ex a,b,k1,k2 st I = AddTo(a,k1,b,k2)) or (ex
a,b,k1,k2 st I = SubFrom(a,k1,b,k2)) or (ex a,b,k1,k2 st I = MultBy(a,k1,b,k2))
or (ex a,b,k1,k2 st I = Divide(a,k1,b,k2)) or ex a,b,k1,k2 st I = (a,k1):=(b,k2
  )
  proof
    assume
    I is Instruction of SCMPDS;
    then reconsider I as Instruction of SCMPDS;
    per cases by Lm1;
    suppose
      I in S1;
      then consider k1 being Element of INT such that
A1:   I = [0,<*k1*>];
      I = goto k1 by A1;
      hence thesis;
    end;
    suppose
      I in S2;
      then consider d1 such that
A2:   I = [1,<*d1*>];
      reconsider a=d1 as Int_position by Def2;
      I = return a by A2;
      hence thesis;
    end;
    suppose
      I in S3;
      then consider
      I2 being Element of Segm 14, d2 being Element of SCM-Data-Loc,
      k2 being Element of INT such that
A3:   I = [I2,<*d2,k2*>] & I2 in {2,3};
      reconsider a=d2 as Int_position by Def2;
      I = saveIC(a,k2) or I = a:=k2 by A3,TARSKI:def 2;
      hence thesis;
    end;
    suppose
      I in S4;
      then consider
      I3 being Element of Segm 14, d3 being Element of SCM-Data-Loc,
      k1,k2 being Element of INT such that
A4:   I=[I3,<*d3,k1,k2*>] & I3 in {4,5,6,7,8};
      reconsider a=d3 as Int_position by Def2;
      I = (a,k1)<>0_goto k2 or I=(a,k1)<=0_goto k2 or I= (a,k1) >=0_goto
      k2 or I= (a,k1) := k2 or I=AddTo(a,k1,k2) by A4,ENUMSET1:def 3;
      hence thesis;
    end;
    suppose
      I in S5;
      then consider I3 being Element of Segm 14, d4,d5 being Element of
      SCM-Data-Loc, k1,k2 being Element of INT such that
A5:   I=[I3,<*d4,d5,k1,k2*>] & I3 in {9,10,11,12,13};
      reconsider a=d4,b=d5 as Int_position by Def2;
      I=AddTo(a,k1,b,k2) or I=SubFrom(a,k1,b,k2) or I=MultBy(a,k1,b,k2)
      or I=Divide(a,k1,b,k2) or I=(a,k1) := (b,k2) by A5,ENUMSET1:def 3;
      hence thesis;
    end;
  end;
  thus thesis;
end;

Lm10: for W being Instruction of SCMPDS st W is halting holds W = goto 0
proof
  set I = goto 0;
  let W be Instruction of SCMPDS such that
A1: W is halting;
  assume
A2: I <> W;
  per cases by Th91;
  suppose
    ex k1 st W=goto k1;
    hence thesis by A1,A2,Th85;
  end;
  suppose
    ex a st W = return a;
    hence thesis by A1,Th89;
  end;
  suppose
    ex a,k1 st W = saveIC(a,k1);
    hence thesis by A1,Th90;
  end;
  suppose
    ex a,k1 st W = a:=k1;
    hence thesis by A1,Th77;
  end;
  suppose
    ex a,k1,k2 st W=(a,k1):=k2;
    hence thesis by A1,Th78;
  end;
  suppose
    ex a,k1,k2 st W = (a,k1)<>0_goto k2;
    hence thesis by A1,Th86;
  end;
  suppose
    ex a,k1,k2 st W = (a,k1)<=0_goto k2;
    hence thesis by A1,Th87;
  end;
  suppose
    ex a,k1,k2 st W = (a,k1)>=0_goto k2;
    hence thesis by A1,Th88;
  end;
  suppose
    ex a,b,k1,k2 st W = AddTo(a,k1,k2);
    hence thesis by A1,Th80;
  end;
  suppose
    ex a,b,k1,k2 st W = AddTo(a,k1,b,k2);
    hence thesis by A1,Th81;
  end;
  suppose
    ex a,b,k1,k2 st W = SubFrom(a,k1,b,k2);
    hence thesis by A1,Th82;
  end;
  suppose
    ex a,b,k1,k2 st W = MultBy(a,k1,b,k2);
    hence thesis by A1,Th83;
  end;
  suppose
    ex a,b,k1,k2 st W = Divide(a,k1,b,k2);
    hence thesis by A1,Th84;
  end;
  suppose
    ex a,b,k1,k2 st W = (a,k1):=(b,k2);
    hence thesis by A1,Th79;
  end;
end;

registration
  cluster SCMPDS -> halting;
  coherence
  proof
    take H=goto 0;
    thus thesis by Th75;
  end;
end;

theorem Th92:
  for I being Instruction of SCMPDS st I is halting holds I = halt
  SCMPDS
proof
  let I be Instruction of SCMPDS;
  assume
  I is halting;
  then I = goto 0 by Lm10;
  hence thesis by Lm10;
end;

theorem
  halt SCMPDS = goto 0 by Th75,Th92;

canceled 2;

theorem Th96:
  for s being State of SCMPDS, i being Instruction of SCMPDS, l
  being Instruction-Location of SCMPDS holds Exec(i,s).l = s.l
proof
  let s be State of SCMPDS, i be Instruction of SCMPDS, l be
  Instruction-Location of SCMPDS;
  reconsider c = i as Element of SCMPDS-Instr;
  reconsider S = s as Element of product SCMPDS-OK;
  reconsider l' = l as Element of NAT by AMI_1:def 4;
  now
    per cases by Lm1;
    case
      c in S1;
      then ex k1 being Element of INT st c = [0,<*k1*>];
      hence SCM-Exec-Res(c,S).l' = SCM-Chg(S,jump_address(S,c const_INT )).l'
      by SCMPDS_1:def 24
        .= S.l' by SCMPDS_1:28;
    end;
    case
A1:   c in S2;
      set SS=SCM-Chg(S,c address_1, S.Address_Add(S,c address_1,RetSP));
      ex d1 st c = [1,<*d1*>] by A1;
      hence SCM-Exec-Res(c,S).l' = SCM-Chg(SS,PopInstrLoc(S,Address_Add(S,c
      address_1,RetIC))).l' by SCMPDS_1:def 24
        .= SS.l' by SCMPDS_1:28
        .= S.l' by SCMPDS_1:32;
    end;
    case
A2:   c in S3;
      set SS=SCM-Chg(S, c P21address, c P22const);
      consider I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc,
      k1 being Element of INT such that
A3:   c = [I1,<*d1,k1*>] and
A4:   I1 in { 2,3 } by A2;
      now
        per cases by A4,TARSKI:def 2;
        case
          I1=2;
          hence SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A3,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
        case
A5:       I1=3;
          set SS = SCM-Chg(S,Address_Add(S,c P21address,c P22const),IC S);
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A3,A5,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
      end;
      hence SCM-Exec-Res(c,S).l' = S.l';
    end;
    case
      c in S4;
      then consider
      I1 being Element of Segm 14, d1 being Element of SCM-Data-Loc,
      k1,k2 being Element of INT such that
A6:   c = [I1,<*d1,k1,k2*>] and
A7:   I1 in { 4,5,6,7,8};
      now
        per cases by A7,ENUMSET1:def 3;
        case
          I1 = 4;
          hence SCM-Exec-Res(c,S).l' = SCM-Chg(S, IFEQ(S.Address_Add(S,c
P31address,c P32const), 0, succ IC S,jump_address(S,c P33const ))).l' by A6,
SCMPDS_1:def 24
            .= S.l' by SCMPDS_1:28;
        end;
        case
          I1 = 5;
          hence SCM-Exec-Res(c,S).l' = SCM-Chg(S, IFGT(S.Address_Add(S,c
P31address,c P32const), 0, succ IC S,jump_address(S,c P33const ))).l' by A6,
SCMPDS_1:def 24
            .= S.l' by SCMPDS_1:28;
        end;
        case
          I1 = 6;
          hence SCM-Exec-Res(c,S).l' = SCM-Chg(S,IFGT(0, S.Address_Add(S,c
P31address,c P32const), succ IC S,jump_address(S,c P33const ))).l' by A6,
SCMPDS_1:def 24
            .= S.l' by SCMPDS_1:28;
        end;
        case
A8:       I1 = 7;
          set SS=SCM-Chg(S,Address_Add(S,c P31address,c P32const),c P33const);
          thus SCM-Exec-Res(c,S).l' =SCM-Chg(SS,succ IC S).l' by A6,A8,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
        case
A9:       I1 = 8;
          set SS=SCM-Chg(S,Address_Add(S,c P31address,c P32const), S.
          Address_Add(S,c P31address,c P32const)+ (c P33const));
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A6,A9,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
      end;
      hence SCM-Exec-Res(c,S).l' = S.l';
    end;
    case
      c in S5;
      then consider I1 being Element of Segm 14, d1,d2 being Element of
      SCM-Data-Loc, k1,k2 being Element of INT such that
A10:  c = [I1,<*d1,d2,k1,k2*>] and
A11:  I1 in { 9,10,11,12,13 };
      now
        per cases by A11,ENUMSET1:def 3;
        case
A12:      I1 = 9;
          set SS=SCM-Chg(S, Address_Add(S,c P41address,c P43const), S.
Address_Add(S,c P41address,c P43const)+ S.Address_Add(S,c P42address,c P44const
          ));
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A10,A12,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
        case
A13:      I1 = 10;
          set SS=SCM-Chg(S, Address_Add(S,c P41address,c P43const), S.
Address_Add(S,c P41address,c P43const)- S.Address_Add(S,c P42address,c P44const
          ));
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A10,A13,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
        case
A14:      I1 = 11;
          set SS=SCM-Chg(S, Address_Add(S,c P41address,c P43const), S.
Address_Add(S,c P41address,c P43const)* S.Address_Add(S,c P42address,c P44const
          ));
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A10,A14,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
        case
A15:      I1 = 12;
          set SA= SCM-Chg(S,Address_Add(S,c P41address,c P43const), S.
Address_Add(S,c P41address,c P43const) div S.Address_Add(S,c P42address,c
          P44const)), SB=SCM-Chg(SA, Address_Add(S,c P42address,c P44const), S.
Address_Add(S,c P41address,c P43const) mod S.Address_Add(S,c P42address,c
          P44const));
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SB,succ IC S).l' by A10,A15,
SCMPDS_1:def 24
            .= SB.l' by SCMPDS_1:28
            .= SA.l' by SCMPDS_1:32
            .= S.l' by SCMPDS_1:32;
        end;
        case
A16:      I1 = 13;
          set SS=SCM-Chg(S, Address_Add(S,c P41address,c P43const), S.
          Address_Add(S,c P42address,c P44const));
          thus SCM-Exec-Res(c,S).l' = SCM-Chg(SS,succ IC S).l' by A10,A16,
SCMPDS_1:def 24
            .= SS.l' by SCMPDS_1:28
            .= S.l' by SCMPDS_1:32;
        end;
      end;
      hence SCM-Exec-Res(c,S).l' = S.l';
    end;
  end;
  hence thesis by SCMPDS_1:def 25;
end;

theorem Th97:
  SCMPDS is realistic
proof
  assume
  the Instruction-Counter of SCMPDS in NAT;
  hence contradiction by Th6;
end;

registration
  cluster SCMPDS -> steady-programmed realistic;
  coherence
  proof
    thus SCMPDS is steady-programmed
    proof
      let s be State of SCMPDS, i be Instruction of SCMPDS, l be
      Instruction-Location of SCMPDS;
      thus Exec(i,s).l = s.l by Th96;
    end;
    thus thesis by Th97;
  end;
end;

theorem
  for i being Element of NAT holds IC SCMPDS <> dl.i & IC SCMPDS <> il.i
proof
  let i be Element of NAT;
  hereby
    assume
    IC SCMPDS = dl.i;
    then NAT = [1,i] by Th6,AMI_3:def 19;
    hence contradiction by ARYTM_3:36;
  end;
  assume
  IC SCMPDS = il.i;
  then NAT = i by Th6,AMI_3:def 20;
  then NAT in NAT;
  hence contradiction;
end;

theorem
  for I being Instruction of SCMPDS st I = goto 0 holds I is halting by Th75;

theorem
  Data-Locations SCMPDS = SCM-Data-Loc by Lm9;

